/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/@noble/hashes/_md.js":
/*!*******************************************!*\
  !*** ./node_modules/@noble/hashes/_md.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;\nexports.setBigUint64 = setBigUint64;\nexports.Chi = Chi;\nexports.Maj = Maj;\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/utils.js\");\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nfunction Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nfunction Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends utils_ts_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_ts_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, utils_ts_1.aexists)(this);\n        data = (0, utils_ts_1.toBytes)(data);\n        (0, utils_ts_1.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_ts_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        (0, utils_ts_1.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_ts_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.HashMD = HashMD;\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexports.SHA256_IV = Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexports.SHA224_IV = Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexports.SHA384_IV = Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexports.SHA512_IV = Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fbWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsY0FBYztBQUM5RixvQkFBb0I7QUFDcEIsV0FBVztBQUNYLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLHlEQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX21kLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TSEE1MTJfSVYgPSBleHBvcnRzLlNIQTM4NF9JViA9IGV4cG9ydHMuU0hBMjI0X0lWID0gZXhwb3J0cy5TSEEyNTZfSVYgPSBleHBvcnRzLkhhc2hNRCA9IHZvaWQgMDtcbmV4cG9ydHMuc2V0QmlnVWludDY0ID0gc2V0QmlnVWludDY0O1xuZXhwb3J0cy5DaGkgPSBDaGk7XG5leHBvcnRzLk1haiA9IE1hajtcbi8qKlxuICogSW50ZXJuYWwgTWVya2xlLURhbWdhcmQgaGFzaCB1dGlscy5cbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLyoqIFBvbHlmaWxsIGZvciBTYWZhcmkgMTQuIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfZGF0YXZpZXdfc2V0YmlndWludDY0ICovXG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLyoqIENob2ljZTogYSA/IGIgOiBjICovXG5mdW5jdGlvbiBDaGkoYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAmIGIpIF4gKH5hICYgYyk7XG59XG4vKiogTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1dHMgaXMgdHJ1ZS4gKi9cbmZ1bmN0aW9uIE1haihhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbn1cbi8qKlxuICogTWVya2xlLURhbWdhcmQgaGFzaCBjb25zdHJ1Y3Rpb24gYmFzZSBjbGFzcy5cbiAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuICovXG5jbGFzcyBIYXNoTUQgZXh0ZW5kcyB1dGlsc190c18xLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9ICgwLCB1dGlsc190c18xLmNyZWF0ZVZpZXcpKHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWV4aXN0cykodGhpcyk7XG4gICAgICAgIGRhdGEgPSAoMCwgdXRpbHNfdHNfMS50b0J5dGVzKShkYXRhKTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShkYXRhKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlVmlldykoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWV4aXN0cykodGhpcyk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFvdXRwdXQpKG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykpO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgICAgIC8vIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVWaWV3KShvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzaE1EID0gSGFzaE1EO1xuLyoqXG4gKiBJbml0aWFsIFNIQS0yIHN0YXRlOiBmcmFjdGlvbmFsIHBhcnRzIG9mIHNxdWFyZSByb290cyBvZiBmaXJzdCAxNiBwcmltZXMgMi4uNTMuXG4gKiBDaGVjayBvdXQgYHRlc3QvbWlzYy9zaGEyLWdlbi1pdi5qc2AgZm9yIHJlY29tcHV0YXRpb24gZ3VpZGUuXG4gKi9cbi8qKiBJbml0aWFsIFNIQTI1NiBzdGF0ZS4gQml0cyAwLi4zMiBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMi4uMTkgKi9cbmV4cG9ydHMuU0hBMjU2X0lWID0gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOSxcbl0pO1xuLyoqIEluaXRpYWwgU0hBMjI0IHN0YXRlLiBCaXRzIDMyLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMjMuLjUzICovXG5leHBvcnRzLlNIQTIyNF9JViA9IFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4YzEwNTllZDgsIDB4MzY3Y2Q1MDcsIDB4MzA3MGRkMTcsIDB4ZjcwZTU5MzksIDB4ZmZjMDBiMzEsIDB4Njg1ODE1MTEsIDB4NjRmOThmYTcsIDB4YmVmYTRmYTQsXG5dKTtcbi8qKiBJbml0aWFsIFNIQTM4NCBzdGF0ZS4gQml0cyAwLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMjMuLjUzICovXG5leHBvcnRzLlNIQTM4NF9JViA9IFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4Y2JiYjlkNWQsIDB4YzEwNTllZDgsIDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcsIDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcsIDB4MTUyZmVjZDgsIDB4ZjcwZTU5MzksXG4gICAgMHg2NzMzMjY2NywgMHhmZmMwMGIzMSwgMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSwgMHhkYjBjMmUwZCwgMHg2NGY5OGZhNywgMHg0N2I1NDgxZCwgMHhiZWZhNGZhNCxcbl0pO1xuLyoqIEluaXRpYWwgU0hBNTEyIHN0YXRlLiBCaXRzIDAuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyLi4xOSAqL1xuZXhwb3J0cy5TSEE1MTJfSVYgPSBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDZhMDllNjY3LCAweGYzYmNjOTA4LCAweGJiNjdhZTg1LCAweDg0Y2FhNzNiLCAweDNjNmVmMzcyLCAweGZlOTRmODJiLCAweGE1NGZmNTNhLCAweDVmMWQzNmYxLFxuICAgIDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEsIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsIDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIsIDB4NWJlMGNkMTksIDB4MTM3ZTIxNzksXG5dKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9tZC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/_md.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/_u64.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/_u64.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;\nexports.add = add;\nexports.fromBig = fromBig;\nexports.split = split;\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l) => h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexports[\"default\"] = u64;\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fdTY0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxlQUFlLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWE7QUFDelQsV0FBVztBQUNYLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL191NjQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvQmlnID0gZXhwb3J0cy5zaHJTTCA9IGV4cG9ydHMuc2hyU0ggPSBleHBvcnRzLnJvdHJTTCA9IGV4cG9ydHMucm90clNIID0gZXhwb3J0cy5yb3RyQkwgPSBleHBvcnRzLnJvdHJCSCA9IGV4cG9ydHMucm90cjMyTCA9IGV4cG9ydHMucm90cjMySCA9IGV4cG9ydHMucm90bFNMID0gZXhwb3J0cy5yb3RsU0ggPSBleHBvcnRzLnJvdGxCTCA9IGV4cG9ydHMucm90bEJIID0gZXhwb3J0cy5hZGQ1TCA9IGV4cG9ydHMuYWRkNUggPSBleHBvcnRzLmFkZDRMID0gZXhwb3J0cy5hZGQ0SCA9IGV4cG9ydHMuYWRkM0wgPSBleHBvcnRzLmFkZDNIID0gdm9pZCAwO1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5leHBvcnRzLmZyb21CaWcgPSBmcm9tQmlnO1xuZXhwb3J0cy5zcGxpdCA9IHNwbGl0O1xuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXJzIGZvciB1NjQuIEJpZ1VpbnQ2NEFycmF5IGlzIHRvbyBzbG93IGFzIHBlciAyMDI1LCBzbyB3ZSBpbXBsZW1lbnQgaXQgdXNpbmcgVWludDMyQXJyYXkuXG4gKiBAdG9kbyByZS1jaGVjayBodHRwczovL2lzc3Vlcy5jaHJvbWl1bS5vcmcvaXNzdWVzLzQyMjEyNTg4XG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IFUzMl9NQVNLNjQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBsc3QubGVuZ3RoO1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsZW4pO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbmV4cG9ydHMudG9CaWcgPSB0b0JpZztcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmV4cG9ydHMuc2hyU0ggPSBzaHJTSDtcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbmV4cG9ydHMuc2hyU0wgPSBzaHJTTDtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90clNIID0gcm90clNIO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbmV4cG9ydHMucm90clNMID0gcm90clNMO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5leHBvcnRzLnJvdHJCSCA9IHJvdHJCSDtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuZXhwb3J0cy5yb3RyQkwgPSByb3RyQkw7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmV4cG9ydHMucm90cjMySCA9IHJvdHIzMkg7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuZXhwb3J0cy5yb3RyMzJMID0gcm90cjMyTDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuZXhwb3J0cy5yb3RsU0ggPSByb3RsU0g7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuZXhwb3J0cy5yb3RsU0wgPSByb3RsU0w7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuZXhwb3J0cy5yb3RsQkggPSByb3RsQkg7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcbmV4cG9ydHMucm90bEJMID0gcm90bEJMO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuZXhwb3J0cy5hZGQzTCA9IGFkZDNMO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5leHBvcnRzLmFkZDNIID0gYWRkM0g7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmV4cG9ydHMuYWRkNEwgPSBhZGQ0TDtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQ0SCA9IGFkZDRIO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmV4cG9ydHMuYWRkNUwgPSBhZGQ1TDtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQ1SCA9IGFkZDVIO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/_u64.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/crypto.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/crypto.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.crypto = void 0;\nexports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG8uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2NyeXB0by5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3J5cHRvID0gdm9pZCAwO1xuZXhwb3J0cy5jcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/crypto.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/legacy.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/legacy.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;\n/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nconst _md_ts_1 = __webpack_require__(/*! ./_md.js */ \"./node_modules/@noble/hashes/_md.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/utils.js\");\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */\nclass SHA1 extends _md_ts_1.HashMD {\n    constructor() {\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = (0, _md_ts_1.Chi)(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = (0, _md_ts_1.Maj)(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = ((0, utils_ts_1.rotl)(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = (0, utils_ts_1.rotl)(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA1 = SHA1;\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexports.sha1 = (0, utils_ts_1.createHasher)(() => new SHA1());\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nclass MD5 extends _md_ts_1.HashMD {\n    constructor() {\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [A, B, C, D];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for (let i = 0; i < 64; i++) {\n            let F, g, s;\n            if (i < 16) {\n                F = (0, _md_ts_1.Chi)(B, C, D);\n                g = i;\n                s = [7, 12, 17, 22];\n            }\n            else if (i < 32) {\n                F = (0, _md_ts_1.Chi)(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [5, 9, 14, 20];\n            }\n            else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [4, 11, 16, 23];\n            }\n            else {\n                F = C ^ (B | ~D);\n                g = (7 * i) % 16;\n                s = [6, 10, 15, 21];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.MD5 = MD5;\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexports.md5 = (0, utils_ts_1.createHasher)(() => new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n    const L = [Id160];\n    const R = [Pi160];\n    const res = [L, R];\n    for (let i = 0; i < 4; i++)\n        for (let j of res)\n            j.push(j[i].map((k) => Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    if (group === 1)\n        return (x & y) | (~x & z);\n    if (group === 2)\n        return (x | ~y) ^ z;\n    if (group === 3)\n        return (x & z) | (y & ~z);\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _md_ts_1.HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = ((0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = ((0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\nexports.RIPEMD160 = RIPEMD160;\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexports.ripemd160 = (0, utils_ts_1.createHasher)(() => new RIPEMD160());\n//# sourceMappingURL=legacy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9sZWdhY3kuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsV0FBVyxHQUFHLFdBQVcsR0FBRyxZQUFZLEdBQUcsWUFBWTtBQUMvRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxxREFBVTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyx5REFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQix3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQSwwREFBMEQ7QUFDMUQsc0RBQXNEO0FBQ3RELGtFQUFrRTtBQUNsRSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvbGVnYWN5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLlJJUEVNRDE2MCA9IGV4cG9ydHMubWQ1ID0gZXhwb3J0cy5NRDUgPSBleHBvcnRzLnNoYTEgPSBleHBvcnRzLlNIQTEgPSB2b2lkIDA7XG4vKipcblxuU0hBMSAoUkZDIDMxNzQpLCBNRDUgKFJGQyAxMzIxKSBhbmQgUklQRU1EMTYwIChSRkMgMjI4NikgbGVnYWN5LCB3ZWFrIGhhc2ggZnVuY3Rpb25zLlxuRG9uJ3QgdXNlIHRoZW0gaW4gYSBuZXcgcHJvdG9jb2wuIFdoYXQgXCJ3ZWFrXCIgbWVhbnM6XG5cbi0gQ29sbGlzaW9ucyBjYW4gYmUgbWFkZSB3aXRoIDJeMTggZWZmb3J0IGluIE1ENSwgMl42MCBpbiBTSEExLCAyXjgwIGluIFJJUEVNRDE2MC5cbi0gTm8gcHJhY3RpY2FsIHByZS1pbWFnZSBhdHRhY2tzIChvbmx5IHRoZW9yZXRpY2FsLCAyXjEyMy40KVxuLSBITUFDIHNlZW1zIGtpbmRhIG9rOiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzYxNTFcbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgX21kX3RzXzEgPSByZXF1aXJlKFwiLi9fbWQuanNcIik7XG5jb25zdCB1dGlsc190c18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vKiogSW5pdGlhbCBTSEExIHN0YXRlICovXG5jb25zdCBTSEExX0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjAsXG5dKTtcbi8vIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXJcbmNvbnN0IFNIQTFfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuLyoqIFNIQTEgbGVnYWN5IGhhc2ggY2xhc3MuICovXG5jbGFzcyBTSEExIGV4dGVuZHMgX21kX3RzXzEuSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDIwLCA4LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuQSA9IFNIQTFfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBTSEExX0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMV9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IFNIQTFfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBTSEExX0lWWzRdIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRV07XG4gICAgfVxuICAgIHNldChBLCBCLCBDLCBELCBFKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTFfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKVxuICAgICAgICAgICAgU0hBMV9XW2ldID0gKDAsIHV0aWxzX3RzXzEucm90bCkoU0hBMV9XW2kgLSAzXSBeIFNIQTFfV1tpIC0gOF0gXiBTSEExX1dbaSAtIDE0XSBeIFNIQTFfV1tpIC0gMTZdLCAxKTtcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgRiwgSztcbiAgICAgICAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgICAgICAgICBGID0gKDAsIF9tZF90c18xLkNoaSkoQiwgQywgRCk7XG4gICAgICAgICAgICAgICAgSyA9IDB4NWE4Mjc5OTk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpIDwgNDApIHtcbiAgICAgICAgICAgICAgICBGID0gQiBeIEMgXiBEO1xuICAgICAgICAgICAgICAgIEsgPSAweDZlZDllYmExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IDYwKSB7XG4gICAgICAgICAgICAgICAgRiA9ICgwLCBfbWRfdHNfMS5NYWopKEIsIEMsIEQpO1xuICAgICAgICAgICAgICAgIEsgPSAweDhmMWJiY2RjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRiA9IEIgXiBDIF4gRDtcbiAgICAgICAgICAgICAgICBLID0gMHhjYTYyYzFkNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFQgPSAoKDAsIHV0aWxzX3RzXzEucm90bCkoQSwgNSkgKyBGICsgRSArIEsgKyBTSEExX1dbaV0pIHwgMDtcbiAgICAgICAgICAgIEUgPSBEO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gKDAsIHV0aWxzX3RzXzEucm90bCkoQiwgMzApO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gVDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikoU0hBMV9XKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuZXhwb3J0cy5TSEExID0gU0hBMTtcbi8qKiBTSEExIChSRkMgMzE3NCkgbGVnYWN5IGhhc2ggZnVuY3Rpb24uIEl0IHdhcyBjcnlwdG9ncmFwaGljYWxseSBicm9rZW4uICovXG5leHBvcnRzLnNoYTEgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBTSEExKCkpO1xuLyoqIFBlci1yb3VuZCBjb25zdGFudHMgKi9cbmNvbnN0IHAzMiA9IC8qIEBfX1BVUkVfXyAqLyBNYXRoLnBvdygyLCAzMik7XG5jb25zdCBLID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDY0IH0sIChfLCBpKSA9PiBNYXRoLmZsb29yKHAzMiAqIE1hdGguYWJzKE1hdGguc2luKGkgKyAxKSkpKTtcbi8qKiBtZDUgaW5pdGlhbCBzdGF0ZTogc2FtZSBhcyBzaGExLCBidXQgNCB1MzIgaW5zdGVhZCBvZiA1LiAqL1xuY29uc3QgTUQ1X0lWID0gLyogQF9fUFVSRV9fICovIFNIQTFfSVYuc2xpY2UoMCwgNCk7XG4vLyBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyXG5jb25zdCBNRDVfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoMTYpO1xuLyoqIE1ENSBsZWdhY3kgaGFzaCBjbGFzcy4gKi9cbmNsYXNzIE1ENSBleHRlbmRzIF9tZF90c18xLkhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAxNiwgOCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuQSA9IE1ENV9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IE1ENV9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IE1ENV9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IE1ENV9JVlszXSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBEIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIERdO1xuICAgIH1cbiAgICBzZXQoQSwgQiwgQywgRCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIE1ENV9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgRiwgZywgcztcbiAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcbiAgICAgICAgICAgICAgICBGID0gKDAsIF9tZF90c18xLkNoaSkoQiwgQywgRCk7XG4gICAgICAgICAgICAgICAgZyA9IGk7XG4gICAgICAgICAgICAgICAgcyA9IFs3LCAxMiwgMTcsIDIyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgICAgICAgICAgIEYgPSAoMCwgX21kX3RzXzEuQ2hpKShELCBCLCBDKTtcbiAgICAgICAgICAgICAgICBnID0gKDUgKiBpICsgMSkgJSAxNjtcbiAgICAgICAgICAgICAgICBzID0gWzUsIDksIDE0LCAyMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgICAgICAgICAgICBGID0gQiBeIEMgXiBEO1xuICAgICAgICAgICAgICAgIGcgPSAoMyAqIGkgKyA1KSAlIDE2O1xuICAgICAgICAgICAgICAgIHMgPSBbNCwgMTEsIDE2LCAyM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBGID0gQyBeIChCIHwgfkQpO1xuICAgICAgICAgICAgICAgIGcgPSAoNyAqIGkpICUgMTY7XG4gICAgICAgICAgICAgICAgcyA9IFs2LCAxMCwgMTUsIDIxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEYgPSBGICsgQSArIEtbaV0gKyBNRDVfV1tnXTtcbiAgICAgICAgICAgIEEgPSBEO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBCICsgKDAsIHV0aWxzX3RzXzEucm90bCkoRiwgc1tpICUgNF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBEKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKE1ENV9XKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuZXhwb3J0cy5NRDUgPSBNRDU7XG4vKipcbiAqIE1ENSAoUkZDIDEzMjEpIGxlZ2FjeSBoYXNoIGZ1bmN0aW9uLiBJdCB3YXMgY3J5cHRvZ3JhcGhpY2FsbHkgYnJva2VuLlxuICogTUQ1IGFyY2hpdGVjdHVyZSBpcyBzaW1pbGFyIHRvIFNIQTEsIHdpdGggc29tZSBkaWZmZXJlbmNlczpcbiAqIC0gUmVkdWNlZCBvdXRwdXQgbGVuZ3RoOiAxNiBieXRlcyAoMTI4IGJpdCkgaW5zdGVhZCBvZiAyMFxuICogLSA2NCByb3VuZHMsIGluc3RlYWQgb2YgODBcbiAqIC0gTGl0dGxlLWVuZGlhbjogY291bGQgYmUgZmFzdGVyLCBidXQgd2lsbCByZXF1aXJlIG1vcmUgY29kZVxuICogLSBOb24tbGluZWFyIGluZGV4IHNlbGVjdGlvbjogaHVnZSBzcGVlZC11cCBmb3IgdW5yb2xsXG4gKiAtIFBlciByb3VuZCBjb25zdGFudHM6IG1vcmUgbWVtb3J5IGFjY2Vzc2VzLCBhZGRpdGlvbmFsIHNwZWVkLXVwIGZvciB1bnJvbGxcbiAqL1xuZXhwb3J0cy5tZDUgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBNRDUoKSk7XG4vLyBSSVBFTUQtMTYwXG5jb25zdCBSaG8xNjAgPSAvKiBAX19QVVJFX18gKi8gVWludDhBcnJheS5mcm9tKFtcbiAgICA3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4LFxuXSk7XG5jb25zdCBJZDE2MCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gVWludDhBcnJheS5mcm9tKG5ldyBBcnJheSgxNikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGkpKSkoKTtcbmNvbnN0IFBpMTYwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBJZDE2MC5tYXAoKGkpID0+ICg5ICogaSArIDUpICUgMTYpKSgpO1xuY29uc3QgaWR4TFIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICBjb25zdCBMID0gW0lkMTYwXTtcbiAgICBjb25zdCBSID0gW1BpMTYwXTtcbiAgICBjb25zdCByZXMgPSBbTCwgUl07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICAgIGZvciAobGV0IGogb2YgcmVzKVxuICAgICAgICAgICAgai5wdXNoKGpbaV0ubWFwKChrKSA9PiBSaG8xNjBba10pKTtcbiAgICByZXR1cm4gcmVzO1xufSkoKTtcbmNvbnN0IGlkeEwgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlkeExSWzBdKSgpO1xuY29uc3QgaWR4UiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaWR4TFJbMV0pKCk7XG4vLyBjb25zdCBbaWR4TCwgaWR4Ul0gPSBpZHhMUjtcbmNvbnN0IHNoaWZ0czE2MCA9IC8qIEBfX1BVUkVfXyAqLyBbXG4gICAgWzExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOF0sXG4gICAgWzEyLCAxMywgMTEsIDE1LCA2LCA5LCA5LCA3LCAxMiwgMTUsIDExLCAxMywgNywgOCwgNywgN10sXG4gICAgWzEzLCAxNSwgMTQsIDExLCA3LCA3LCA2LCA4LCAxMywgMTQsIDEzLCAxMiwgNSwgNSwgNiwgOV0sXG4gICAgWzE0LCAxMSwgMTIsIDE0LCA4LCA2LCA1LCA1LCAxNSwgMTIsIDE1LCAxNCwgOSwgOSwgOCwgNl0sXG4gICAgWzE1LCAxMiwgMTMsIDEzLCA5LCA1LCA4LCA2LCAxNCwgMTEsIDEyLCAxMSwgOCwgNiwgNSwgNV0sXG5dLm1hcCgoaSkgPT4gVWludDhBcnJheS5mcm9tKGkpKTtcbmNvbnN0IHNoaWZ0c0wxNjAgPSAvKiBAX19QVVJFX18gKi8gaWR4TC5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzMTYwW2ldW2pdKSk7XG5jb25zdCBzaGlmdHNSMTYwID0gLyogQF9fUFVSRV9fICovIGlkeFIubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0czE2MFtpXVtqXSkpO1xuY29uc3QgS2wxNjAgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHgwMDAwMDAwMCwgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhhOTUzZmQ0ZSxcbl0pO1xuY29uc3QgS3IxNjAgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg1MGEyOGJlNiwgMHg1YzRkZDEyNCwgMHg2ZDcwM2VmMywgMHg3YTZkNzZlOSwgMHgwMDAwMDAwMCxcbl0pO1xuLy8gSXQncyBjYWxsZWQgZigpIGluIHNwZWMuXG5mdW5jdGlvbiByaXBlbWRfZihncm91cCwgeCwgeSwgeikge1xuICAgIGlmIChncm91cCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgICBpZiAoZ3JvdXAgPT09IDEpXG4gICAgICAgIHJldHVybiAoeCAmIHkpIHwgKH54ICYgeik7XG4gICAgaWYgKGdyb3VwID09PSAyKVxuICAgICAgICByZXR1cm4gKHggfCB+eSkgXiB6O1xuICAgIGlmIChncm91cCA9PT0gMylcbiAgICAgICAgcmV0dXJuICh4ICYgeikgfCAoeSAmIH56KTtcbiAgICByZXR1cm4geCBeICh5IHwgfnopO1xufVxuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlclxuY29uc3QgQlVGXzE2MCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoMTYpO1xuY2xhc3MgUklQRU1EMTYwIGV4dGVuZHMgX21kX3RzXzEuSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDIwLCA4LCB0cnVlKTtcbiAgICAgICAgdGhpcy5oMCA9IDB4Njc0NTIzMDEgfCAwO1xuICAgICAgICB0aGlzLmgxID0gMHhlZmNkYWI4OSB8IDA7XG4gICAgICAgIHRoaXMuaDIgPSAweDk4YmFkY2ZlIHwgMDtcbiAgICAgICAgdGhpcy5oMyA9IDB4MTAzMjU0NzYgfCAwO1xuICAgICAgICB0aGlzLmg0ID0gMHhjM2QyZTFmMCB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBoMCwgaDEsIGgyLCBoMywgaDQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbaDAsIGgxLCBoMiwgaDMsIGg0XTtcbiAgICB9XG4gICAgc2V0KGgwLCBoMSwgaDIsIGgzLCBoNCkge1xuICAgICAgICB0aGlzLmgwID0gaDAgfCAwO1xuICAgICAgICB0aGlzLmgxID0gaDEgfCAwO1xuICAgICAgICB0aGlzLmgyID0gaDIgfCAwO1xuICAgICAgICB0aGlzLmgzID0gaDMgfCAwO1xuICAgICAgICB0aGlzLmg0ID0gaDQgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgQlVGXzE2MFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgYWwgPSB0aGlzLmgwIHwgMCwgYXIgPSBhbCwgYmwgPSB0aGlzLmgxIHwgMCwgYnIgPSBibCwgY2wgPSB0aGlzLmgyIHwgMCwgY3IgPSBjbCwgZGwgPSB0aGlzLmgzIHwgMCwgZHIgPSBkbCwgZWwgPSB0aGlzLmg0IHwgMCwgZXIgPSBlbDtcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBpdGVyYXRpbmcgMCB0byA4MCwgd2Ugc3BsaXQgaXQgaW50byA1IGdyb3Vwc1xuICAgICAgICAvLyBBbmQgdXNlIHRoZSBncm91cHMgaW4gY29uc3RhbnRzLCBmdW5jdGlvbnMsIGV0Yy4gTXVjaCBzaW1wbGVyXG4gICAgICAgIGZvciAobGV0IGdyb3VwID0gMDsgZ3JvdXAgPCA1OyBncm91cCsrKSB7XG4gICAgICAgICAgICBjb25zdCByR3JvdXAgPSA0IC0gZ3JvdXA7XG4gICAgICAgICAgICBjb25zdCBoYmwgPSBLbDE2MFtncm91cF0sIGhiciA9IEtyMTYwW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBybCA9IGlkeExbZ3JvdXBdLCByciA9IGlkeFJbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHNsID0gc2hpZnRzTDE2MFtncm91cF0sIHNyID0gc2hpZnRzUjE2MFtncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGwgPSAoKDAsIHV0aWxzX3RzXzEucm90bCkoYWwgKyByaXBlbWRfZihncm91cCwgYmwsIGNsLCBkbCkgKyBCVUZfMTYwW3JsW2ldXSArIGhibCwgc2xbaV0pICsgZWwpIHwgMDtcbiAgICAgICAgICAgICAgICBhbCA9IGVsLCBlbCA9IGRsLCBkbCA9ICgwLCB1dGlsc190c18xLnJvdGwpKGNsLCAxMCkgfCAwLCBjbCA9IGJsLCBibCA9IHRsOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDIgbG9vcHMgYXJlIDEwJSBmYXN0ZXJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gKCgwLCB1dGlsc190c18xLnJvdGwpKGFyICsgcmlwZW1kX2Yockdyb3VwLCBiciwgY3IsIGRyKSArIEJVRl8xNjBbcnJbaV1dICsgaGJyLCBzcltpXSkgKyBlcikgfCAwO1xuICAgICAgICAgICAgICAgIGFyID0gZXIsIGVyID0gZHIsIGRyID0gKDAsIHV0aWxzX3RzXzEucm90bCkoY3IsIDEwKSB8IDAsIGNyID0gYnIsIGJyID0gdHI7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIHRoaXMuc2V0KCh0aGlzLmgxICsgY2wgKyBkcikgfCAwLCAodGhpcy5oMiArIGRsICsgZXIpIHwgMCwgKHRoaXMuaDMgKyBlbCArIGFyKSB8IDAsICh0aGlzLmg0ICsgYWwgKyBicikgfCAwLCAodGhpcy5oMCArIGJsICsgY3IpIHwgMCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKShCVUZfMTYwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikodGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLlJJUEVNRDE2MCA9IFJJUEVNRDE2MDtcbi8qKlxuICogUklQRU1ELTE2MCAtIGEgbGVnYWN5IGhhc2ggZnVuY3Rpb24gZnJvbSAxOTkwcy5cbiAqICogaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAuaHRtbFxuICogKiBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuICovXG5leHBvcnRzLnJpcGVtZDE2MCA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhhc2hlcikoKCkgPT4gbmV3IFJJUEVNRDE2MCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlZ2FjeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/legacy.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/ripemd160.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/ripemd160.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ripemd160 = exports.RIPEMD160 = void 0;\n/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n * @deprecated\n */\nconst legacy_ts_1 = __webpack_require__(/*! ./legacy.js */ \"./node_modules/@noble/hashes/legacy.js\");\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexports.RIPEMD160 = legacy_ts_1.RIPEMD160;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexports.ripemd160 = legacy_ts_1.ripemd160;\n//# sourceMappingURL=ripemd160.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsMkRBQWE7QUFDekM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJpcGVtZDE2MCA9IGV4cG9ydHMuUklQRU1EMTYwID0gdm9pZCAwO1xuLyoqXG4gKiBSSVBFTUQtMTYwIGxlZ2FjeSBoYXNoIGZ1bmN0aW9uLlxuICogaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAuaHRtbFxuICogaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAvcGRmL0FCLTk2MDEvQUItOTYwMS5wZGZcbiAqIEBtb2R1bGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmNvbnN0IGxlZ2FjeV90c18xID0gcmVxdWlyZShcIi4vbGVnYWN5LmpzXCIpO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL2xlZ2FjeWAgbW9kdWxlICovXG5leHBvcnRzLlJJUEVNRDE2MCA9IGxlZ2FjeV90c18xLlJJUEVNRDE2MDtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9sZWdhY3lgIG1vZHVsZSAqL1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBsZWdhY3lfdHNfMS5yaXBlbWQxNjA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yaXBlbWQxNjAuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/ripemd160.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/sha1.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/sha1.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha1 = exports.SHA1 = void 0;\n/**\n * SHA1 (RFC 3174) legacy hash function.\n * @module\n * @deprecated\n */\nconst legacy_ts_1 = __webpack_require__(/*! ./legacy.js */ \"./node_modules/@noble/hashes/legacy.js\");\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexports.SHA1 = legacy_ts_1.SHA1;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexports.sha1 = legacy_ts_1.sha1;\n//# sourceMappingURL=sha1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGExLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVksR0FBRyxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQywyREFBYTtBQUN6QztBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWiIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYTEgPSBleHBvcnRzLlNIQTEgPSB2b2lkIDA7XG4vKipcbiAqIFNIQTEgKFJGQyAzMTc0KSBsZWdhY3kgaGFzaCBmdW5jdGlvbi5cbiAqIEBtb2R1bGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmNvbnN0IGxlZ2FjeV90c18xID0gcmVxdWlyZShcIi4vbGVnYWN5LmpzXCIpO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL2xlZ2FjeWAgbW9kdWxlICovXG5leHBvcnRzLlNIQTEgPSBsZWdhY3lfdHNfMS5TSEExO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL2xlZ2FjeWAgbW9kdWxlICovXG5leHBvcnRzLnNoYTEgPSBsZWdhY3lfdHNfMS5zaGExO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/sha1.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/sha2.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/sha2.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nconst _md_ts_1 = __webpack_require__(/*! ./_md.js */ \"./node_modules/@noble/hashes/_md.js\");\nconst u64 = __webpack_require__(/*! ./_u64.js */ \"./node_modules/@noble/hashes/_u64.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/utils.js\");\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_ts_1.HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_ts_1.SHA256_IV[0] | 0;\n        this.B = _md_ts_1.SHA256_IV[1] | 0;\n        this.C = _md_ts_1.SHA256_IV[2] | 0;\n        this.D = _md_ts_1.SHA256_IV[3] | 0;\n        this.E = _md_ts_1.SHA256_IV[4] | 0;\n        this.F = _md_ts_1.SHA256_IV[5] | 0;\n        this.G = _md_ts_1.SHA256_IV[6] | 0;\n        this.H = _md_ts_1.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);\n            const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA256 = SHA256;\nclass SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = _md_ts_1.SHA224_IV[0] | 0;\n        this.B = _md_ts_1.SHA224_IV[1] | 0;\n        this.C = _md_ts_1.SHA224_IV[2] | 0;\n        this.D = _md_ts_1.SHA224_IV[3] | 0;\n        this.E = _md_ts_1.SHA224_IV[4] | 0;\n        this.F = _md_ts_1.SHA224_IV[5] | 0;\n        this.G = _md_ts_1.SHA224_IV[6] | 0;\n        this.H = _md_ts_1.SHA224_IV[7] | 0;\n    }\n}\nexports.SHA224 = SHA224;\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_ts_1.HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_ts_1.SHA512_IV[0] | 0;\n        this.Al = _md_ts_1.SHA512_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA512_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA512_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA512_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA512_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA512_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA512_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA512_IV[8] | 0;\n        this.El = _md_ts_1.SHA512_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA512_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA512_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA512_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA512_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA512_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexports.SHA512 = SHA512;\nclass SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = _md_ts_1.SHA384_IV[0] | 0;\n        this.Al = _md_ts_1.SHA384_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA384_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA384_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA384_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA384_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA384_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA384_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA384_IV[8] | 0;\n        this.El = _md_ts_1.SHA384_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA384_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA384_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA384_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA384_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA384_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA384_IV[15] | 0;\n    }\n}\nexports.SHA384 = SHA384;\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexports.SHA512_224 = SHA512_224;\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\nexports.SHA512_256 = SHA512_256;\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nexports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQ3pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMscURBQVU7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLHVEQUFXO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLHlEQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQWlFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUVBQWlFO0FBQy9FO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYTUxMl8yMjQgPSBleHBvcnRzLnNoYTUxMl8yNTYgPSBleHBvcnRzLnNoYTM4NCA9IGV4cG9ydHMuc2hhNTEyID0gZXhwb3J0cy5zaGEyMjQgPSBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHMuU0hBNTEyXzI1NiA9IGV4cG9ydHMuU0hBNTEyXzIyNCA9IGV4cG9ydHMuU0hBMzg0ID0gZXhwb3J0cy5TSEE1MTIgPSBleHBvcnRzLlNIQTIyNCA9IGV4cG9ydHMuU0hBMjU2ID0gdm9pZCAwO1xuLyoqXG4gKiBTSEEyIGhhc2ggZnVuY3Rpb24uIEEuay5hLiBzaGEyNTYsIHNoYTM4NCwgc2hhNTEyLCBzaGE1MTJfMjI0LCBzaGE1MTJfMjU2LlxuICogU0hBMjU2IGlzIHRoZSBmYXN0ZXN0IGhhc2ggaW1wbGVtZW50YWJsZSBpbiBKUywgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKiBDaGVjayBvdXQgW1JGQyA0NjM0XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzQ2MzQpIGFuZFxuICogW0ZJUFMgMTgwLTRdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGYpLlxuICogQG1vZHVsZVxuICovXG5jb25zdCBfbWRfdHNfMSA9IHJlcXVpcmUoXCIuL19tZC5qc1wiKTtcbmNvbnN0IHU2NCA9IHJlcXVpcmUoXCIuL191NjQuanNcIik7XG5jb25zdCB1dGlsc190c18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vKipcbiAqIFJvdW5kIGNvbnN0YW50czpcbiAqIEZpcnN0IDMyIGJpdHMgb2YgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLyoqIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXIuIFwiV1wiIGNvbWVzIHN0cmFpZ2h0IGZyb20gc3BlYy4gKi9cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBfbWRfdHNfMS5IYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKG91dHB1dExlbiA9IDMyKSB7XG4gICAgICAgIHN1cGVyKDY0LCBvdXRwdXRMZW4sIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IF9tZF90c18xLlNIQTI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IF9tZF90c18xLlNIQTI1Nl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IF9tZF90c18xLlNIQTI1Nl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IF9tZF90c18xLlNIQTI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IF9tZF90c18xLlNIQTI1Nl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IF9tZF90c18xLlNIQTI1Nl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IF9tZF90c18xLlNIQTI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IF9tZF90c18xLlNIQTI1Nl9JVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSAoMCwgdXRpbHNfdHNfMS5yb3RyKShXMTUsIDcpIF4gKDAsIHV0aWxzX3RzXzEucm90cikoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gKDAsIHV0aWxzX3RzXzEucm90cikoVzIsIDE3KSBeICgwLCB1dGlsc190c18xLnJvdHIpKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSAoMCwgdXRpbHNfdHNfMS5yb3RyKShFLCA2KSBeICgwLCB1dGlsc190c18xLnJvdHIpKEUsIDExKSBeICgwLCB1dGlsc190c18xLnJvdHIpKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyAoMCwgX21kX3RzXzEuQ2hpKShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9ICgwLCB1dGlsc190c18xLnJvdHIpKEEsIDIpIF4gKDAsIHV0aWxzX3RzXzEucm90cikoQSwgMTMpIF4gKDAsIHV0aWxzX3RzXzEucm90cikoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgKDAsIF9tZF90c18xLk1haikoQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikoU0hBMjU2X1cpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKHRoaXMuYnVmZmVyKTtcbiAgICB9XG59XG5leHBvcnRzLlNIQTI1NiA9IFNIQTI1NjtcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDI4KTtcbiAgICAgICAgdGhpcy5BID0gX21kX3RzXzEuU0hBMjI0X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gX21kX3RzXzEuU0hBMjI0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gX21kX3RzXzEuU0hBMjI0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gX21kX3RzXzEuU0hBMjI0X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gX21kX3RzXzEuU0hBMjI0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gX21kX3RzXzEuU0hBMjI0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gX21kX3RzXzEuU0hBMjI0X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gX21kX3RzXzEuU0hBMjI0X0lWWzddIHwgMDtcbiAgICB9XG59XG5leHBvcnRzLlNIQTIyNCA9IFNIQTIyNDtcbi8vIFNIQTItNTEyIGlzIHNsb3dlciB0aGFuIHNoYTI1NiBpbiBqcyBiZWNhdXNlIHU2NCBvcGVyYXRpb25zIGFyZSBzbG93LlxuLy8gUm91bmQgY29udGFudHNcbi8vIEZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSzUxMiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbmNvbnN0IFNIQTUxMl9LaCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSzUxMlswXSkoKTtcbmNvbnN0IFNIQTUxMl9LbCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSzUxMlsxXSkoKTtcbi8vIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXJzXG5jb25zdCBTSEE1MTJfV19IID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5jb25zdCBTSEE1MTJfV19MID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5jbGFzcyBTSEE1MTIgZXh0ZW5kcyBfbWRfdHNfMS5IYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKG91dHB1dExlbiA9IDY0KSB7XG4gICAgICAgIHN1cGVyKDEyOCwgb3V0cHV0TGVuLCAxNiwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IF9tZF90c18xLlNIQTUxMl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBfbWRfdHNfMS5TSEE1MTJfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkJoID0gX21kX3RzXzEuU0hBNTEyX0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IF9tZF90c18xLlNIQTUxMl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBfbWRfdHNfMS5TSEE1MTJfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkNsID0gX21kX3RzXzEuU0hBNTEyX0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IF9tZF90c18xLlNIQTUxMl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBfbWRfdHNfMS5TSEE1MTJfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLkVoID0gX21kX3RzXzEuU0hBNTEyX0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IF9tZF90c18xLlNIQTUxMl9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBfbWRfdHNfMS5TSEE1MTJfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IF9tZF90c18xLlNIQTUxMl9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gX21kX3RzXzEuU0hBNTEyX0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBfbWRfdHNfMS5TSEE1MTJfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IF9tZF90c18xLlNIQTUxMl9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gX21kX3RzXzEuU0hBNTEyX0lWWzE1XSB8IDA7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSB1NjQucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSB1NjQucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gdTY0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCTChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gdTY0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSB1NjQuYWRkNEgoU1VNbCwgczBoLCBzMWgsIFNIQTUxMl9XX0hbaSAtIDddLCBTSEE1MTJfV19IW2kgLSAxNl0pO1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IFNVTWggfCAwO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFMxIDo9IChlIHJpZ2h0cm90YXRlIDE0KSB4b3IgKGUgcmlnaHRyb3RhdGUgMTgpIHhvciAoZSByaWdodHJvdGF0ZSA0MSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWggPSB1NjQucm90clNIKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkgoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTFsID0gdTY0LnJvdHJTTChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQucm90ckJMKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgLy9jb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XG4gICAgICAgICAgICBjb25zdCBDSElsID0gKEVsICYgRmwpIF4gKH5FbCAmIEdsKTtcbiAgICAgICAgICAgIC8vIFQxID0gSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTUxMl9LW2ldICsgU0hBNTEyX1dbaV1cbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVDFsbCA9IHU2NC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IHU2NC5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwaCA9IHU2NC5yb3RyU0goQWgsIEFsLCAyOCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQucm90clNMKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICAgICAgICBHaCA9IEZoIHwgMDtcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgICAgICAgRmggPSBFaCB8IDA7XG4gICAgICAgICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xuICAgICAgICAgICAgRGggPSBDaCB8IDA7XG4gICAgICAgICAgICBEbCA9IENsIHwgMDtcbiAgICAgICAgICAgIENoID0gQmggfCAwO1xuICAgICAgICAgICAgQ2wgPSBCbCB8IDA7XG4gICAgICAgICAgICBCaCA9IEFoIHwgMDtcbiAgICAgICAgICAgIEJsID0gQWwgfCAwO1xuICAgICAgICAgICAgY29uc3QgQWxsID0gdTY0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IHU2NC5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcbiAgICAgICAgKHsgaDogQmgsIGw6IEJsIH0gPSB1NjQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcbiAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSB1NjQuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcbiAgICAgICAgKHsgaDogSGgsIGw6IEhsIH0gPSB1NjQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikoU0hBNTEyX1dfSCwgU0hBNTEyX1dfTCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKSh0aGlzLmJ1ZmZlcik7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBNTEyID0gU0hBNTEyO1xuY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNDgpO1xuICAgICAgICB0aGlzLkFoID0gX21kX3RzXzEuU0hBMzg0X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IF9tZF90c18xLlNIQTM4NF9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBfbWRfdHNfMS5TSEEzODRfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gX21kX3RzXzEuU0hBMzg0X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IF9tZF90c18xLlNIQTM4NF9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBfbWRfdHNfMS5TSEEzODRfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gX21kX3RzXzEuU0hBMzg0X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IF9tZF90c18xLlNIQTM4NF9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBfbWRfdHNfMS5TSEEzODRfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gX21kX3RzXzEuU0hBMzg0X0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IF9tZF90c18xLlNIQTM4NF9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gX21kX3RzXzEuU0hBMzg0X0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBfbWRfdHNfMS5TSEEzODRfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IF9tZF90c18xLlNIQTM4NF9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gX21kX3RzXzEuU0hBMzg0X0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBfbWRfdHNfMS5TSEEzODRfSVZbMTVdIHwgMDtcbiAgICB9XG59XG5leHBvcnRzLlNIQTM4NCA9IFNIQTM4NDtcbi8qKlxuICogVHJ1bmNhdGVkIFNIQTUxMi8yNTYgYW5kIFNIQTUxMi8yMjQuXG4gKiBTSEE1MTJfSVYgaXMgWE9SZWQgd2l0aCAweGE1YTVhNWE1YTVhNWE1YTUsIHRoZW4gdXNlZCBhcyBcImludGVybWVkaWFyeVwiIElWIG9mIFNIQTUxMi90LlxuICogVGhlbiB0IGhhc2hlcyBzdHJpbmcgdG8gcHJvZHVjZSByZXN1bHQgSVYuXG4gKiBTZWUgYHRlc3QvbWlzYy9zaGEyLWdlbi1pdi5qc2AuXG4gKi9cbi8qKiBTSEE1MTIvMjI0IElWICovXG5jb25zdCBUMjI0X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4OGMzZDM3YzgsIDB4MTk1NDRkYTIsIDB4NzNlMTk5NjYsIDB4ODlkY2Q0ZDYsIDB4MWRmYWI3YWUsIDB4MzJmZjljODIsIDB4Njc5ZGQ1MTQsIDB4NTgyZjlmY2YsXG4gICAgMHgwZjZkMmI2OSwgMHg3YmQ0NGRhOCwgMHg3N2UzNmY3MywgMHgwNGM0ODk0MiwgMHgzZjlkODVhOCwgMHg2YTFkMzZjOCwgMHgxMTEyZTZhZCwgMHg5MWQ2OTJhMSxcbl0pO1xuLyoqIFNIQTUxMi8yNTYgSVYgKi9cbmNvbnN0IFQyNTZfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHgyMjMxMjE5NCwgMHhmYzJiZjcyYywgMHg5ZjU1NWZhMywgMHhjODRjNjRjMiwgMHgyMzkzYjg2YiwgMHg2ZjUzYjE1MSwgMHg5NjM4NzcxOSwgMHg1OTQwZWFiZCxcbiAgICAweDk2MjgzZWUyLCAweGE4OGVmZmUzLCAweGJlNWUxZTI1LCAweDUzODYzOTkyLCAweDJiMDE5OWZjLCAweDJjODViOGFhLCAweDBlYjcyZGRjLCAweDgxYzUyY2EyLFxuXSk7XG5jbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMjgpO1xuICAgICAgICB0aGlzLkFoID0gVDIyNF9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBUMjI0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IFQyMjRfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gVDIyNF9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBUMjI0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IFQyMjRfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gVDIyNF9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBUMjI0X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IFQyMjRfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gVDIyNF9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBUMjI0X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBUMjI0X0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBUMjI0X0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBUMjI0X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBUMjI0X0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBUMjI0X0lWWzE1XSB8IDA7XG4gICAgfVxufVxuZXhwb3J0cy5TSEE1MTJfMjI0ID0gU0hBNTEyXzIyNDtcbmNsYXNzIFNIQTUxMl8yNTYgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigzMik7XG4gICAgICAgIHRoaXMuQWggPSBUMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IFQyNTZfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkJoID0gVDI1Nl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBUMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IFQyNTZfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkNsID0gVDI1Nl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBUMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IFQyNTZfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLkVoID0gVDI1Nl9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBUMjU2X0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IFQyNTZfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IFQyNTZfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IFQyNTZfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IFQyNTZfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IFQyNTZfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IFQyNTZfSVZbMTVdIHwgMDtcbiAgICB9XG59XG5leHBvcnRzLlNIQTUxMl8yNTYgPSBTSEE1MTJfMjU2O1xuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuXG4gKlxuICogSXQgaXMgdGhlIGZhc3Rlc3QgSlMgaGFzaCwgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKiBUbyBicmVhayBzaGEyNTYgdXNpbmcgYmlydGhkYXkgYXR0YWNrLCBhdHRhY2tlcnMgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzLlxuICogQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl43MCBoYXNoZXMvc2VjICgyXjk1IGhhc2hlcy95ZWFyKSBhcyBwZXIgMjAyNS5cbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBTSEEyNTYoKSk7XG4vKiogU0hBMi0yMjQgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0ICovXG5leHBvcnRzLnNoYTIyNCA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhhc2hlcikoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8qKiBTSEEyLTUxMiBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuICovXG5leHBvcnRzLnNoYTUxMiA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhhc2hlcikoKCkgPT4gbmV3IFNIQTUxMigpKTtcbi8qKiBTSEEyLTM4NCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuICovXG5leHBvcnRzLnNoYTM4NCA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhhc2hlcikoKCkgPT4gbmV3IFNIQTM4NCgpKTtcbi8qKlxuICogU0hBMi01MTIvMjU2IFwidHJ1bmNhdGVkXCIgaGFzaCBmdW5jdGlvbiwgd2l0aCBpbXByb3ZlZCByZXNpc3RhbmNlIHRvIGxlbmd0aCBleHRlbnNpb24gYXR0YWNrcy5cbiAqIFNlZSB0aGUgcGFwZXIgb24gW3RydW5jYXRlZCBTSEE1MTJdKGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvNTQ4LnBkZikuXG4gKi9cbmV4cG9ydHMuc2hhNTEyXzI1NiA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhhc2hlcikoKCkgPT4gbmV3IFNIQTUxMl8yNTYoKSk7XG4vKipcbiAqIFNIQTItNTEyLzIyNCBcInRydW5jYXRlZFwiIGhhc2ggZnVuY3Rpb24sIHdpdGggaW1wcm92ZWQgcmVzaXN0YW5jZSB0byBsZW5ndGggZXh0ZW5zaW9uIGF0dGFja3MuXG4gKiBTZWUgdGhlIHBhcGVyIG9uIFt0cnVuY2F0ZWQgU0hBNTEyXShodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEwLzU0OC5wZGYpLlxuICovXG5leHBvcnRzLnNoYTUxMl8yMjQgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/sha2.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/sha256.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/sha256.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nconst sha2_ts_1 = __webpack_require__(/*! ./sha2.js */ \"./node_modules/@noble/hashes/sha2.js\");\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA256 = sha2_ts_1.SHA256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha256 = sha2_ts_1.sha256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA224 = sha2_ts_1.SHA224;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha224 = sha2_ts_1.sha224;\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyNTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHVEQUFXO0FBQ3JDO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMjU2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGEyMjQgPSBleHBvcnRzLlNIQTIyNCA9IGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5TSEEyNTYgPSB2b2lkIDA7XG4vKipcbiAqIFNIQTItMjU2IGEuay5hLiBzaGEyNTYuIEluIEpTLCBpdCBpcyB0aGUgZmFzdGVzdCBoYXNoLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqXG4gKiBUbyBicmVhayBzaGEyNTYgdXNpbmcgYmlydGhkYXkgYXR0YWNrLCBhdHRhY2tlcnMgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzLlxuICogQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl43MCBoYXNoZXMvc2VjICgyXjk1IGhhc2hlcy95ZWFyKSBhcyBwZXIgMjAyNS5cbiAqXG4gKiBDaGVjayBvdXQgW0ZJUFMgMTgwLTRdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGYpLlxuICogQG1vZHVsZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuY29uc3Qgc2hhMl90c18xID0gcmVxdWlyZShcIi4vc2hhMi5qc1wiKTtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydHMuU0hBMjU2ID0gc2hhMl90c18xLlNIQTI1Njtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydHMuc2hhMjU2ID0gc2hhMl90c18xLnNoYTI1Njtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydHMuU0hBMjI0ID0gc2hhMl90c18xLlNIQTIyNDtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydHMuc2hhMjI0ID0gc2hhMl90c18xLnNoYTIyNDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/sha256.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/@noble/hashes/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;\nexports.isBytes = isBytes;\nexports.anumber = anumber;\nexports.abytes = abytes;\nexports.ahash = ahash;\nexports.aexists = aexists;\nexports.aoutput = aoutput;\nexports.u8 = u8;\nexports.u32 = u32;\nexports.clean = clean;\nexports.createView = createView;\nexports.rotr = rotr;\nexports.rotl = rotl;\nexports.byteSwap = byteSwap;\nexports.byteSwap32 = byteSwap32;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.asyncLoop = asyncLoop;\nexports.utf8ToBytes = utf8ToBytes;\nexports.bytesToUtf8 = bytesToUtf8;\nexports.toBytes = toBytes;\nexports.kdfInputToBytes = kdfInputToBytes;\nexports.concatBytes = concatBytes;\nexports.checkOpts = checkOpts;\nexports.createHasher = createHasher;\nexports.createOptHasher = createOptHasher;\nexports.createXOFer = createXOFer;\nexports.randomBytes = randomBytes;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"./node_modules/@noble/hashes/crypto.js\");\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexports.swap8IfBE = exports.isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexports.byteSwapIfBE = exports.swap8IfBE;\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexports.swap32IfBE = exports.isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nfunction kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nclass Hash {\n}\nexports.Hash = Hash;\n/** Wraps hash function, creating an interface on top of it */\nfunction createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructor = createHasher;\nexports.wrapConstructorWithOpts = createOptHasher;\nexports.wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLCtCQUErQjtBQUMvQixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFV0aWxpdGllcyBmb3IgaGV4LCBieXRlcywgQ1NQUk5HLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gZXhwb3J0cy5IYXNoID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuc3dhcDMySWZCRSA9IGV4cG9ydHMuYnl0ZVN3YXBJZkJFID0gZXhwb3J0cy5zd2FwOElmQkUgPSBleHBvcnRzLmlzTEUgPSB2b2lkIDA7XG5leHBvcnRzLmlzQnl0ZXMgPSBpc0J5dGVzO1xuZXhwb3J0cy5hbnVtYmVyID0gYW51bWJlcjtcbmV4cG9ydHMuYWJ5dGVzID0gYWJ5dGVzO1xuZXhwb3J0cy5haGFzaCA9IGFoYXNoO1xuZXhwb3J0cy5hZXhpc3RzID0gYWV4aXN0cztcbmV4cG9ydHMuYW91dHB1dCA9IGFvdXRwdXQ7XG5leHBvcnRzLnU4ID0gdTg7XG5leHBvcnRzLnUzMiA9IHUzMjtcbmV4cG9ydHMuY2xlYW4gPSBjbGVhbjtcbmV4cG9ydHMuY3JlYXRlVmlldyA9IGNyZWF0ZVZpZXc7XG5leHBvcnRzLnJvdHIgPSByb3RyO1xuZXhwb3J0cy5yb3RsID0gcm90bDtcbmV4cG9ydHMuYnl0ZVN3YXAgPSBieXRlU3dhcDtcbmV4cG9ydHMuYnl0ZVN3YXAzMiA9IGJ5dGVTd2FwMzI7XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbmV4cG9ydHMuYXN5bmNMb29wID0gYXN5bmNMb29wO1xuZXhwb3J0cy51dGY4VG9CeXRlcyA9IHV0ZjhUb0J5dGVzO1xuZXhwb3J0cy5ieXRlc1RvVXRmOCA9IGJ5dGVzVG9VdGY4O1xuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbmV4cG9ydHMua2RmSW5wdXRUb0J5dGVzID0ga2RmSW5wdXRUb0J5dGVzO1xuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuZXhwb3J0cy5jaGVja09wdHMgPSBjaGVja09wdHM7XG5leHBvcnRzLmNyZWF0ZUhhc2hlciA9IGNyZWF0ZUhhc2hlcjtcbmV4cG9ydHMuY3JlYXRlT3B0SGFzaGVyID0gY3JlYXRlT3B0SGFzaGVyO1xuZXhwb3J0cy5jcmVhdGVYT0ZlciA9IGNyZWF0ZVhPRmVyO1xuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkICgyMDI1LTA0LTMwKSwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9jcnlwdG9cIik7XG4vKiogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiBCZSBjYXJlZnVsOiBub2RlanMgQnVmZmVyIHdpbGwgcmV0dXJuIHRydWUuICovXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgcG9zaXRpdmUgaW50ZWdlci4gKi9cbmZ1bmN0aW9uIGFudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncG9zaXRpdmUgaW50ZWdlciBleHBlY3RlZCwgZ290ICcgKyBuKTtcbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiAqL1xuZnVuY3Rpb24gYWJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICcgKyBsZW5ndGhzICsgJywgZ290IGxlbmd0aD0nICsgYi5sZW5ndGgpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIGhhc2ggKi9cbmZ1bmN0aW9uIGFoYXNoKGgpIHtcbiAgICBpZiAodHlwZW9mIGggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGguY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMuY3JlYXRlSGFzaGVyJyk7XG4gICAgYW51bWJlcihoLm91dHB1dExlbik7XG4gICAgYW51bWJlcihoLmJsb2NrTGVuKTtcbn1cbi8qKiBBc3NlcnRzIGEgaGFzaCBpbnN0YW5jZSBoYXMgbm90IGJlZW4gZGVzdHJveWVkIC8gZmluaXNoZWQgKi9cbmZ1bmN0aW9uIGFleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbi8qKiBBc3NlcnRzIG91dHB1dCBpcyBwcm9wZXJseS1zaXplZCBieXRlIGFycmF5ICovXG5mdW5jdGlvbiBhb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBhYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAnICsgbWluKTtcbiAgICB9XG59XG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1OC4gKi9cbmZ1bmN0aW9uIHU4KGFycikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIENhc3QgdTggLyB1MTYgLyB1MzIgdG8gdTMyLiAqL1xuZnVuY3Rpb24gdTMyKGFycikge1xuICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG59XG4vKiogWmVyb2l6ZSBhIGJ5dGUgYXJyYXkuIFdhcm5pbmc6IEpTIHByb3ZpZGVzIG5vIGd1YXJhbnRlZXMuICovXG5mdW5jdGlvbiBjbGVhbiguLi5hcnJheXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheXNbaV0uZmlsbCgwKTtcbiAgICB9XG59XG4vKiogQ3JlYXRlIERhdGFWaWV3IG9mIGFuIGFycmF5IGZvciBlYXN5IGJ5dGUtbGV2ZWwgbWFuaXB1bGF0aW9uLiAqL1xuZnVuY3Rpb24gY3JlYXRlVmlldyhhcnIpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG59XG4vKiogVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5mdW5jdGlvbiByb3RyKHdvcmQsIHNoaWZ0KSB7XG4gICAgcmV0dXJuICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xufVxuLyoqIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmZ1bmN0aW9uIHJvdGwod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbn1cbi8qKiBJcyBjdXJyZW50IHBsYXRmb3JtIGxpdHRsZS1lbmRpYW4/IE1vc3QgYXJlLiBCaWctRW5kaWFuIHBsYXRmb3JtOiBJQk0gKi9cbmV4cG9ydHMuaXNMRSA9ICgoKSA9PiBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0KSgpO1xuLyoqIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmZ1bmN0aW9uIGJ5dGVTd2FwKHdvcmQpIHtcbiAgICByZXR1cm4gKCgod29yZCA8PCAyNCkgJiAweGZmMDAwMDAwKSB8XG4gICAgICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAgICAgKCh3b3JkID4+PiAyNCkgJiAweGZmKSk7XG59XG4vKiogQ29uZGl0aW9uYWxseSBieXRlIHN3YXAgaWYgb24gYSBiaWctZW5kaWFuIHBsYXRmb3JtICovXG5leHBvcnRzLnN3YXA4SWZCRSA9IGV4cG9ydHMuaXNMRVxuICAgID8gKG4pID0+IG5cbiAgICA6IChuKSA9PiBieXRlU3dhcChuKTtcbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0cy5ieXRlU3dhcElmQkUgPSBleHBvcnRzLnN3YXA4SWZCRTtcbi8qKiBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5ICovXG5mdW5jdGlvbiBieXRlU3dhcDMyKGFycikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGJ5dGVTd2FwKGFycltpXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnRzLnN3YXAzMklmQkUgPSBleHBvcnRzLmlzTEVcbiAgICA/ICh1KSA9PiB1XG4gICAgOiBieXRlU3dhcDMyO1xuLy8gQnVpbHQtaW4gaGV4IGNvbnZlcnNpb24gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc191aW50OGFycmF5X2Zyb21oZXhcbmNvbnN0IGhhc0hleEJ1aWx0aW4gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IFxuLy8gQHRzLWlnbm9yZVxudHlwZW9mIFVpbnQ4QXJyYXkuZnJvbShbXSkudG9IZXggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbUhleCA9PT0gJ2Z1bmN0aW9uJykoKTtcbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gaGV4IHN0cmluZy4gVXNlcyBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvSGV4KCk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2gpIHtcbiAgICBpZiAoY2ggPj0gYXNjaWlzLl8wICYmIGNoIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoIC0gYXNjaWlzLl8wOyAvLyAnMicgPT4gNTAtNDhcbiAgICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuQSAtIDEwKTsgLy8gJ0InID0+IDY2LSg2NS0xMClcbiAgICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgICByZXR1cm47XG59XG4vKipcbiAqIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5LiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGhhc0hleEJ1aWx0aW4pXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb21IZXgoaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yOyAvLyBtdWx0aXBseSBmaXJzdCBvY3RldCwgZS5nLiAnYTMnID0+IDEwKjE2KzMgPT4gMTYwICsgMyA9PiAxNjNcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLyoqXG4gKiBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuICogQ2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4gKiBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG4gKi9cbmNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuZXhwb3J0cy5uZXh0VGljayA9IG5leHRUaWNrO1xuLyoqIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmcuICovXG5hc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgKDAsIGV4cG9ydHMubmV4dFRpY2spKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8gYnl0ZXMgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBVaW50OEFycmF5LmZyb20oWzk3LCA5OCwgOTldKVxuICovXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBDb252ZXJ0cyBieXRlcyB0byBzdHJpbmcgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlIGJ5dGVzVG9VdGY4KFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pKSAvLyAnYWJjJ1xuICovXG5mdW5jdGlvbiBieXRlc1RvVXRmOChieXRlcykge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBhYnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIEhlbHBlciBmb3IgS0RGczogY29uc3VtZXMgdWludDhhcnJheSBvciBzdHJpbmcuXG4gKiBXaGVuIHN0cmluZyBpcyBwYXNzZWQsIGRvZXMgdXRmOCBkZWNvZGluZywgdXNpbmcgVGV4dERlY29kZXIuXG4gKi9cbmZ1bmN0aW9uIGtkZklucHV0VG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB7fS50b1N0cmluZy5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbi8qKiBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZSAqL1xuY2xhc3MgSGFzaCB7XG59XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuLyoqIFdyYXBzIGhhc2ggZnVuY3Rpb24sIGNyZWF0aW5nIGFuIGludGVyZmFjZSBvbiB0b3Agb2YgaXQgKi9cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5mdW5jdGlvbiBjcmVhdGVPcHRIYXNoZXIoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5mdW5jdGlvbiBjcmVhdGVYT0ZlcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gY3JlYXRlSGFzaGVyO1xuZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGNyZWF0ZU9wdEhhc2hlcjtcbmV4cG9ydHMud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMgPSBjcmVhdGVYT0Zlcjtcbi8qKiBDcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgUFJORy4gVXNlcyBpbnRlcm5hbCBPUy1sZXZlbCBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AuICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICAvLyBMZWdhY3kgTm9kZS5qcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY3J5cHRvXzEuY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/utils.js\n"));

/***/ }),

/***/ "./node_modules/bech32/dist/index.js":
/*!*******************************************!*\
  !*** ./node_modules/bech32/dist/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bech32m = exports.bech32 = void 0;\nconst ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst ALPHABET_MAP = {};\nfor (let z = 0; z < ALPHABET.length; z++) {\n    const x = ALPHABET.charAt(z);\n    ALPHABET_MAP[x] = z;\n}\nfunction polymodStep(pre) {\n    const b = pre >> 25;\n    return (((pre & 0x1ffffff) << 5) ^\n        (-((b >> 0) & 1) & 0x3b6a57b2) ^\n        (-((b >> 1) & 1) & 0x26508e6d) ^\n        (-((b >> 2) & 1) & 0x1ea119fa) ^\n        (-((b >> 3) & 1) & 0x3d4233dd) ^\n        (-((b >> 4) & 1) & 0x2a1462b3));\n}\nfunction prefixChk(prefix) {\n    let chk = 1;\n    for (let i = 0; i < prefix.length; ++i) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            return 'Invalid prefix (' + prefix + ')';\n        chk = polymodStep(chk) ^ (c >> 5);\n    }\n    chk = polymodStep(chk);\n    for (let i = 0; i < prefix.length; ++i) {\n        const v = prefix.charCodeAt(i);\n        chk = polymodStep(chk) ^ (v & 0x1f);\n    }\n    return chk;\n}\nfunction convert(data, inBits, outBits, pad) {\n    let value = 0;\n    let bits = 0;\n    const maxV = (1 << outBits) - 1;\n    const result = [];\n    for (let i = 0; i < data.length; ++i) {\n        value = (value << inBits) | data[i];\n        bits += inBits;\n        while (bits >= outBits) {\n            bits -= outBits;\n            result.push((value >> bits) & maxV);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            result.push((value << (outBits - bits)) & maxV);\n        }\n    }\n    else {\n        if (bits >= inBits)\n            return 'Excess padding';\n        if ((value << (outBits - bits)) & maxV)\n            return 'Non-zero padding';\n    }\n    return result;\n}\nfunction toWords(bytes) {\n    return convert(bytes, 8, 5, true);\n}\nfunction fromWordsUnsafe(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n}\nfunction fromWords(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n    throw new Error(res);\n}\nfunction getLibraryFromEncoding(encoding) {\n    let ENCODING_CONST;\n    if (encoding === 'bech32') {\n        ENCODING_CONST = 1;\n    }\n    else {\n        ENCODING_CONST = 0x2bc830a3;\n    }\n    function encode(prefix, words, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (prefix.length + 7 + words.length > LIMIT)\n            throw new TypeError('Exceeds length limit');\n        prefix = prefix.toLowerCase();\n        // determine chk mod\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            throw new Error(chk);\n        let result = prefix + '1';\n        for (let i = 0; i < words.length; ++i) {\n            const x = words[i];\n            if (x >> 5 !== 0)\n                throw new Error('Non 5-bit word');\n            chk = polymodStep(chk) ^ x;\n            result += ALPHABET.charAt(x);\n        }\n        for (let i = 0; i < 6; ++i) {\n            chk = polymodStep(chk);\n        }\n        chk ^= ENCODING_CONST;\n        for (let i = 0; i < 6; ++i) {\n            const v = (chk >> ((5 - i) * 5)) & 0x1f;\n            result += ALPHABET.charAt(v);\n        }\n        return result;\n    }\n    function __decode(str, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (str.length < 8)\n            return str + ' too short';\n        if (str.length > LIMIT)\n            return 'Exceeds length limit';\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        const uppered = str.toUpperCase();\n        if (str !== lowered && str !== uppered)\n            return 'Mixed-case string ' + str;\n        str = lowered;\n        const split = str.lastIndexOf('1');\n        if (split === -1)\n            return 'No separator character for ' + str;\n        if (split === 0)\n            return 'Missing prefix for ' + str;\n        const prefix = str.slice(0, split);\n        const wordChars = str.slice(split + 1);\n        if (wordChars.length < 6)\n            return 'Data too short';\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            return chk;\n        const words = [];\n        for (let i = 0; i < wordChars.length; ++i) {\n            const c = wordChars.charAt(i);\n            const v = ALPHABET_MAP[c];\n            if (v === undefined)\n                return 'Unknown character ' + c;\n            chk = polymodStep(chk) ^ v;\n            // not in the checksum?\n            if (i + 6 >= wordChars.length)\n                continue;\n            words.push(v);\n        }\n        if (chk !== ENCODING_CONST)\n            return 'Invalid checksum for ' + str;\n        return { prefix, words };\n    }\n    function decodeUnsafe(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n    }\n    function decode(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n        throw new Error(res);\n    }\n    return {\n        decodeUnsafe,\n        decode,\n        encode,\n        toWords,\n        fromWordsUnsafe,\n        fromWords,\n    };\n}\nexports.bech32 = getLibraryFromEncoding('bech32');\nexports.bech32m = getLibraryFromEncoding('bech32m');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmVjaDMyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLGNBQWM7QUFDaEM7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxlQUFlIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL2JlY2gzMi9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmVjaDMybSA9IGV4cG9ydHMuYmVjaDMyID0gdm9pZCAwO1xuY29uc3QgQUxQSEFCRVQgPSAncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnO1xuY29uc3QgQUxQSEFCRVRfTUFQID0ge307XG5mb3IgKGxldCB6ID0gMDsgeiA8IEFMUEhBQkVULmxlbmd0aDsgeisrKSB7XG4gICAgY29uc3QgeCA9IEFMUEhBQkVULmNoYXJBdCh6KTtcbiAgICBBTFBIQUJFVF9NQVBbeF0gPSB6O1xufVxuZnVuY3Rpb24gcG9seW1vZFN0ZXAocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICByZXR1cm4gKCgocHJlICYgMHgxZmZmZmZmKSA8PCA1KSBeXG4gICAgICAgICgtKChiID4+IDApICYgMSkgJiAweDNiNmE1N2IyKSBeXG4gICAgICAgICgtKChiID4+IDEpICYgMSkgJiAweDI2NTA4ZTZkKSBeXG4gICAgICAgICgtKChiID4+IDIpICYgMSkgJiAweDFlYTExOWZhKSBeXG4gICAgICAgICgtKChiID4+IDMpICYgMSkgJiAweDNkNDIzM2RkKSBeXG4gICAgICAgICgtKChiID4+IDQpICYgMSkgJiAweDJhMTQ2MmIzKSk7XG59XG5mdW5jdGlvbiBwcmVmaXhDaGsocHJlZml4KSB7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDMzIHx8IGMgPiAxMjYpXG4gICAgICAgICAgICByZXR1cm4gJ0ludmFsaWQgcHJlZml4ICgnICsgcHJlZml4ICsgJyknO1xuICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IHBvbHltb2RTdGVwKGNoayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdiA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gKHYgJiAweDFmKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbmZ1bmN0aW9uIGNvbnZlcnQoZGF0YSwgaW5CaXRzLCBvdXRCaXRzLCBwYWQpIHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIGxldCBiaXRzID0gMDtcbiAgICBjb25zdCBtYXhWID0gKDEgPDwgb3V0Qml0cykgLSAxO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBpbkJpdHMpIHwgZGF0YVtpXTtcbiAgICAgICAgYml0cyArPSBpbkJpdHM7XG4gICAgICAgIHdoaWxlIChiaXRzID49IG91dEJpdHMpIHtcbiAgICAgICAgICAgIGJpdHMgLT0gb3V0Qml0cztcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCh2YWx1ZSA+PiBiaXRzKSAmIG1heFYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYWQpIHtcbiAgICAgICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgodmFsdWUgPDwgKG91dEJpdHMgLSBiaXRzKSkgJiBtYXhWKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGJpdHMgPj0gaW5CaXRzKVxuICAgICAgICAgICAgcmV0dXJuICdFeGNlc3MgcGFkZGluZyc7XG4gICAgICAgIGlmICgodmFsdWUgPDwgKG91dEJpdHMgLSBiaXRzKSkgJiBtYXhWKVxuICAgICAgICAgICAgcmV0dXJuICdOb24temVybyBwYWRkaW5nJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvV29yZHMoYnl0ZXMpIHtcbiAgICByZXR1cm4gY29udmVydChieXRlcywgOCwgNSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBmcm9tV29yZHNVbnNhZmUod29yZHMpIHtcbiAgICBjb25zdCByZXMgPSBjb252ZXJ0KHdvcmRzLCA1LCA4LCBmYWxzZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSlcbiAgICAgICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGZyb21Xb3Jkcyh3b3Jkcykge1xuICAgIGNvbnN0IHJlcyA9IGNvbnZlcnQod29yZHMsIDUsIDgsIGZhbHNlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBFcnJvcihyZXMpO1xufVxuZnVuY3Rpb24gZ2V0TGlicmFyeUZyb21FbmNvZGluZyhlbmNvZGluZykge1xuICAgIGxldCBFTkNPRElOR19DT05TVDtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiZWNoMzInKSB7XG4gICAgICAgIEVOQ09ESU5HX0NPTlNUID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIEVOQ09ESU5HX0NPTlNUID0gMHgyYmM4MzBhMztcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIExJTUlUKSB7XG4gICAgICAgIExJTUlUID0gTElNSVQgfHwgOTA7XG4gICAgICAgIGlmIChwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aCA+IExJTUlUKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhjZWVkcyBsZW5ndGggbGltaXQnKTtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIGRldGVybWluZSBjaGsgbW9kXG4gICAgICAgIGxldCBjaGsgPSBwcmVmaXhDaGsocHJlZml4KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGsgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNoayk7XG4gICAgICAgIGxldCByZXN1bHQgPSBwcmVmaXggKyAnMSc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB3b3Jkc1tpXTtcbiAgICAgICAgICAgIGlmICh4ID4+IDUgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24gNS1iaXQgd29yZCcpO1xuICAgICAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeIHg7XG4gICAgICAgICAgICByZXN1bHQgKz0gQUxQSEFCRVQuY2hhckF0KHgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspO1xuICAgICAgICB9XG4gICAgICAgIGNoayBePSBFTkNPRElOR19DT05TVDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoY2hrID4+ICgoNSAtIGkpICogNSkpICYgMHgxZjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBBTFBIQUJFVC5jaGFyQXQodik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gX19kZWNvZGUoc3RyLCBMSU1JVCkge1xuICAgICAgICBMSU1JVCA9IExJTUlUIHx8IDkwO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDgpXG4gICAgICAgICAgICByZXR1cm4gc3RyICsgJyB0b28gc2hvcnQnO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IExJTUlUKVxuICAgICAgICAgICAgcmV0dXJuICdFeGNlZWRzIGxlbmd0aCBsaW1pdCc7XG4gICAgICAgIC8vIGRvbid0IGFsbG93IG1peGVkIGNhc2VcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB1cHBlcmVkID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSB1cHBlcmVkKVxuICAgICAgICAgICAgcmV0dXJuICdNaXhlZC1jYXNlIHN0cmluZyAnICsgc3RyO1xuICAgICAgICBzdHIgPSBsb3dlcmVkO1xuICAgICAgICBjb25zdCBzcGxpdCA9IHN0ci5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc3BsaXQgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuICdObyBzZXBhcmF0b3IgY2hhcmFjdGVyIGZvciAnICsgc3RyO1xuICAgICAgICBpZiAoc3BsaXQgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gJ01pc3NpbmcgcHJlZml4IGZvciAnICsgc3RyO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBzdHIuc2xpY2UoMCwgc3BsaXQpO1xuICAgICAgICBjb25zdCB3b3JkQ2hhcnMgPSBzdHIuc2xpY2Uoc3BsaXQgKyAxKTtcbiAgICAgICAgaWYgKHdvcmRDaGFycy5sZW5ndGggPCA2KVxuICAgICAgICAgICAgcmV0dXJuICdEYXRhIHRvbyBzaG9ydCc7XG4gICAgICAgIGxldCBjaGsgPSBwcmVmaXhDaGsocHJlZml4KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGsgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGNoaztcbiAgICAgICAgY29uc3Qgd29yZHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQ2hhcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB3b3JkQ2hhcnMuY2hhckF0KGkpO1xuICAgICAgICAgICAgY29uc3QgdiA9IEFMUEhBQkVUX01BUFtjXTtcbiAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdVbmtub3duIGNoYXJhY3RlciAnICsgYztcbiAgICAgICAgICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiB2O1xuICAgICAgICAgICAgLy8gbm90IGluIHRoZSBjaGVja3N1bT9cbiAgICAgICAgICAgIGlmIChpICsgNiA+PSB3b3JkQ2hhcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgd29yZHMucHVzaCh2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hrICE9PSBFTkNPRElOR19DT05TVClcbiAgICAgICAgICAgIHJldHVybiAnSW52YWxpZCBjaGVja3N1bSBmb3IgJyArIHN0cjtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUoc3RyLCBMSU1JVCkge1xuICAgICAgICBjb25zdCByZXMgPSBfX2RlY29kZShzdHIsIExJTUlUKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXMgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgTElNSVQpIHtcbiAgICAgICAgY29uc3QgcmVzID0gX19kZWNvZGUoc3RyLCBMSU1JVCk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWNvZGVVbnNhZmUsXG4gICAgICAgIGRlY29kZSxcbiAgICAgICAgZW5jb2RlLFxuICAgICAgICB0b1dvcmRzLFxuICAgICAgICBmcm9tV29yZHNVbnNhZmUsXG4gICAgICAgIGZyb21Xb3JkcyxcbiAgICB9O1xufVxuZXhwb3J0cy5iZWNoMzIgPSBnZXRMaWJyYXJ5RnJvbUVuY29kaW5nKCdiZWNoMzInKTtcbmV4cG9ydHMuYmVjaDMybSA9IGdldExpYnJhcnlGcm9tRW5jb2RpbmcoJ2JlY2gzMm0nKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bech32/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/big.js/big.js":
/*!************************************!*\
  !*** ./node_modules/big.js/big.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("var __WEBPACK_AMD_DEFINE_RESULT__;/* big.js v3.1.3 https://github.com/MikeMcl/big.js/LICENCE */\r\n;(function (global) {\r\n    'use strict';\r\n\r\n/*\r\n  big.js v3.1.3\r\n  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.\r\n  https://github.com/MikeMcl/big.js/\r\n  Copyright (c) 2014 Michael Mclaughlin <M8ch88l@gmail.com>\r\n  MIT Expat Licence\r\n*/\r\n\r\n/***************************** EDITABLE DEFAULTS ******************************/\r\n\r\n    // The default values below must be integers within the stated ranges.\r\n\r\n    /*\r\n     * The maximum number of decimal places of the results of operations\r\n     * involving division: div and sqrt, and pow with negative exponents.\r\n     */\r\n    var DP = 20,                           // 0 to MAX_DP\r\n\r\n        /*\r\n         * The rounding mode used when rounding to the above decimal places.\r\n         *\r\n         * 0 Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)\r\n         * 1 To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)\r\n         * 2 To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)\r\n         * 3 Away from zero.                                  (ROUND_UP)\r\n         */\r\n        RM = 1,                            // 0, 1, 2 or 3\r\n\r\n        // The maximum value of DP and Big.DP.\r\n        MAX_DP = 1E6,                      // 0 to 1000000\r\n\r\n        // The maximum magnitude of the exponent argument to the pow method.\r\n        MAX_POWER = 1E6,                   // 1 to 1000000\r\n\r\n        /*\r\n         * The exponent value at and beneath which toString returns exponential\r\n         * notation.\r\n         * JavaScript's Number type: -7\r\n         * -1000000 is the minimum recommended exponent value of a Big.\r\n         */\r\n        E_NEG = -7,                   // 0 to -1000000\r\n\r\n        /*\r\n         * The exponent value at and above which toString returns exponential\r\n         * notation.\r\n         * JavaScript's Number type: 21\r\n         * 1000000 is the maximum recommended exponent value of a Big.\r\n         * (This limit is not enforced or checked.)\r\n         */\r\n        E_POS = 21,                   // 0 to 1000000\r\n\r\n/******************************************************************************/\r\n\r\n        // The shared prototype object.\r\n        P = {},\r\n        isValid = /^-?(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\r\n        Big;\r\n\r\n\r\n    /*\r\n     * Create and return a Big constructor.\r\n     *\r\n     */\r\n    function bigFactory() {\r\n\r\n        /*\r\n         * The Big constructor and exported function.\r\n         * Create and return a new instance of a Big number object.\r\n         *\r\n         * n {number|string|Big} A numeric value.\r\n         */\r\n        function Big(n) {\r\n            var x = this;\r\n\r\n            // Enable constructor usage without new.\r\n            if (!(x instanceof Big)) {\r\n                return n === void 0 ? bigFactory() : new Big(n);\r\n            }\r\n\r\n            // Duplicate.\r\n            if (n instanceof Big) {\r\n                x.s = n.s;\r\n                x.e = n.e;\r\n                x.c = n.c.slice();\r\n            } else {\r\n                parse(x, n);\r\n            }\r\n\r\n            /*\r\n             * Retain a reference to this Big constructor, and shadow\r\n             * Big.prototype.constructor which points to Object.\r\n             */\r\n            x.constructor = Big;\r\n        }\r\n\r\n        Big.prototype = P;\r\n        Big.DP = DP;\r\n        Big.RM = RM;\r\n        Big.E_NEG = E_NEG;\r\n        Big.E_POS = E_POS;\r\n\r\n        return Big;\r\n    }\r\n\r\n\r\n    // Private functions\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of Big x in normal or exponential\r\n     * notation to dp fixed decimal places or significant digits.\r\n     *\r\n     * x {Big} The Big to format.\r\n     * dp {number} Integer, 0 to MAX_DP inclusive.\r\n     * toE {number} 1 (toExponential), 2 (toPrecision) or undefined (toFixed).\r\n     */\r\n    function format(x, dp, toE) {\r\n        var Big = x.constructor,\r\n\r\n            // The index (normal notation) of the digit that may be rounded up.\r\n            i = dp - (x = new Big(x)).e,\r\n            c = x.c;\r\n\r\n        // Round?\r\n        if (c.length > ++dp) {\r\n            rnd(x, i, Big.RM);\r\n        }\r\n\r\n        if (!c[0]) {\r\n            ++i;\r\n        } else if (toE) {\r\n            i = dp;\r\n\r\n        // toFixed\r\n        } else {\r\n            c = x.c;\r\n\r\n            // Recalculate i as x.e may have changed if value rounded up.\r\n            i = x.e + i + 1;\r\n        }\r\n\r\n        // Append zeros?\r\n        for (; c.length < i; c.push(0)) {\r\n        }\r\n        i = x.e;\r\n\r\n        /*\r\n         * toPrecision returns exponential notation if the number of\r\n         * significant digits specified is less than the number of digits\r\n         * necessary to represent the integer part of the value in normal\r\n         * notation.\r\n         */\r\n        return toE === 1 || toE && (dp <= i || i <= Big.E_NEG) ?\r\n\r\n          // Exponential notation.\r\n          (x.s < 0 && c[0] ? '-' : '') +\r\n            (c.length > 1 ? c[0] + '.' + c.join('').slice(1) : c[0]) +\r\n              (i < 0 ? 'e' : 'e+') + i\r\n\r\n          // Normal notation.\r\n          : x.toString();\r\n    }\r\n\r\n\r\n    /*\r\n     * Parse the number or string value passed to a Big constructor.\r\n     *\r\n     * x {Big} A Big number instance.\r\n     * n {number|string} A numeric value.\r\n     */\r\n    function parse(x, n) {\r\n        var e, i, nL;\r\n\r\n        // Minus zero?\r\n        if (n === 0 && 1 / n < 0) {\r\n            n = '-0';\r\n\r\n        // Ensure n is string and check validity.\r\n        } else if (!isValid.test(n += '')) {\r\n            throwErr(NaN);\r\n        }\r\n\r\n        // Determine sign.\r\n        x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;\r\n\r\n        // Decimal point?\r\n        if ((e = n.indexOf('.')) > -1) {\r\n            n = n.replace('.', '');\r\n        }\r\n\r\n        // Exponential form?\r\n        if ((i = n.search(/e/i)) > 0) {\r\n\r\n            // Determine exponent.\r\n            if (e < 0) {\r\n                e = i;\r\n            }\r\n            e += +n.slice(i + 1);\r\n            n = n.substring(0, i);\r\n\r\n        } else if (e < 0) {\r\n\r\n            // Integer.\r\n            e = n.length;\r\n        }\r\n\r\n        nL = n.length;\r\n\r\n        // Determine leading zeros.\r\n        for (i = 0; i < nL && n.charAt(i) == '0'; i++) {\r\n        }\r\n\r\n        if (i == nL) {\r\n\r\n            // Zero.\r\n            x.c = [ x.e = 0 ];\r\n        } else {\r\n\r\n            // Determine trailing zeros.\r\n            for (; nL > 0 && n.charAt(--nL) == '0';) {\r\n            }\r\n\r\n            x.e = e - i - 1;\r\n            x.c = [];\r\n\r\n            // Convert string to array of digits without leading/trailing zeros.\r\n            //for (e = 0; i <= nL; x.c[e++] = +n.charAt(i++)) {\r\n            for (; i <= nL; x.c.push(+n.charAt(i++))) {\r\n            }\r\n        }\r\n\r\n        return x;\r\n    }\r\n\r\n\r\n    /*\r\n     * Round Big x to a maximum of dp decimal places using rounding mode rm.\r\n     * Called by div, sqrt and round.\r\n     *\r\n     * x {Big} The Big to round.\r\n     * dp {number} Integer, 0 to MAX_DP inclusive.\r\n     * rm {number} 0, 1, 2 or 3 (DOWN, HALF_UP, HALF_EVEN, UP)\r\n     * [more] {boolean} Whether the result of division was truncated.\r\n     */\r\n    function rnd(x, dp, rm, more) {\r\n        var u,\r\n            xc = x.c,\r\n            i = x.e + dp + 1;\r\n\r\n        if (rm === 1) {\r\n\r\n            // xc[i] is the digit after the digit that may be rounded up.\r\n            more = xc[i] >= 5;\r\n        } else if (rm === 2) {\r\n            more = xc[i] > 5 || xc[i] == 5 &&\r\n              (more || i < 0 || xc[i + 1] !== u || xc[i - 1] & 1);\r\n        } else if (rm === 3) {\r\n            more = more || xc[i] !== u || i < 0;\r\n        } else {\r\n            more = false;\r\n\r\n            if (rm !== 0) {\r\n                throwErr('!Big.RM!');\r\n            }\r\n        }\r\n\r\n        if (i < 1 || !xc[0]) {\r\n\r\n            if (more) {\r\n\r\n                // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n                x.e = -dp;\r\n                x.c = [1];\r\n            } else {\r\n\r\n                // Zero.\r\n                x.c = [x.e = 0];\r\n            }\r\n        } else {\r\n\r\n            // Remove any digits after the required decimal places.\r\n            xc.length = i--;\r\n\r\n            // Round up?\r\n            if (more) {\r\n\r\n                // Rounding up may mean the previous digit has to be rounded up.\r\n                for (; ++xc[i] > 9;) {\r\n                    xc[i] = 0;\r\n\r\n                    if (!i--) {\r\n                        ++x.e;\r\n                        xc.unshift(1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Remove trailing zeros.\r\n            for (i = xc.length; !xc[--i]; xc.pop()) {\r\n            }\r\n        }\r\n\r\n        return x;\r\n    }\r\n\r\n\r\n    /*\r\n     * Throw a BigError.\r\n     *\r\n     * message {string} The error message.\r\n     */\r\n    function throwErr(message) {\r\n        var err = new Error(message);\r\n        err.name = 'BigError';\r\n\r\n        throw err;\r\n    }\r\n\r\n\r\n    // Prototype/instance methods\r\n\r\n\r\n    /*\r\n     * Return a new Big whose value is the absolute value of this Big.\r\n     */\r\n    P.abs = function () {\r\n        var x = new this.constructor(this);\r\n        x.s = 1;\r\n\r\n        return x;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return\r\n     * 1 if the value of this Big is greater than the value of Big y,\r\n     * -1 if the value of this Big is less than the value of Big y, or\r\n     * 0 if they have the same value.\r\n    */\r\n    P.cmp = function (y) {\r\n        var xNeg,\r\n            x = this,\r\n            xc = x.c,\r\n            yc = (y = new x.constructor(y)).c,\r\n            i = x.s,\r\n            j = y.s,\r\n            k = x.e,\r\n            l = y.e;\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n            return !xc[0] ? !yc[0] ? 0 : -j : i;\r\n        }\r\n\r\n        // Signs differ?\r\n        if (i != j) {\r\n            return i;\r\n        }\r\n        xNeg = i < 0;\r\n\r\n        // Compare exponents.\r\n        if (k != l) {\r\n            return k > l ^ xNeg ? 1 : -1;\r\n        }\r\n\r\n        i = -1;\r\n        j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n        // Compare digit by digit.\r\n        for (; ++i < j;) {\r\n\r\n            if (xc[i] != yc[i]) {\r\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\r\n            }\r\n        }\r\n\r\n        // Compare lengths.\r\n        return k == l ? 0 : k > l ^ xNeg ? 1 : -1;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new Big whose value is the value of this Big divided by the\r\n     * value of Big y, rounded, if necessary, to a maximum of Big.DP decimal\r\n     * places using rounding mode Big.RM.\r\n     */\r\n    P.div = function (y) {\r\n        var x = this,\r\n            Big = x.constructor,\r\n            // dividend\r\n            dvd = x.c,\r\n            //divisor\r\n            dvs = (y = new Big(y)).c,\r\n            s = x.s == y.s ? 1 : -1,\r\n            dp = Big.DP;\r\n\r\n        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n            throwErr('!Big.DP!');\r\n        }\r\n\r\n        // Either 0?\r\n        if (!dvd[0] || !dvs[0]) {\r\n\r\n            // If both are 0, throw NaN\r\n            if (dvd[0] == dvs[0]) {\r\n                throwErr(NaN);\r\n            }\r\n\r\n            // If dvs is 0, throw +-Infinity.\r\n            if (!dvs[0]) {\r\n                throwErr(s / 0);\r\n            }\r\n\r\n            // dvd is 0, return +-0.\r\n            return new Big(s * 0);\r\n        }\r\n\r\n        var dvsL, dvsT, next, cmp, remI, u,\r\n            dvsZ = dvs.slice(),\r\n            dvdI = dvsL = dvs.length,\r\n            dvdL = dvd.length,\r\n            // remainder\r\n            rem = dvd.slice(0, dvsL),\r\n            remL = rem.length,\r\n            // quotient\r\n            q = y,\r\n            qc = q.c = [],\r\n            qi = 0,\r\n            digits = dp + (q.e = x.e - y.e) + 1;\r\n\r\n        q.s = s;\r\n        s = digits < 0 ? 0 : digits;\r\n\r\n        // Create version of divisor with leading zero.\r\n        dvsZ.unshift(0);\r\n\r\n        // Add zeros to make remainder as long as divisor.\r\n        for (; remL++ < dvsL; rem.push(0)) {\r\n        }\r\n\r\n        do {\r\n\r\n            // 'next' is how many times the divisor goes into current remainder.\r\n            for (next = 0; next < 10; next++) {\r\n\r\n                // Compare divisor and remainder.\r\n                if (dvsL != (remL = rem.length)) {\r\n                    cmp = dvsL > remL ? 1 : -1;\r\n                } else {\r\n\r\n                    for (remI = -1, cmp = 0; ++remI < dvsL;) {\r\n\r\n                        if (dvs[remI] != rem[remI]) {\r\n                            cmp = dvs[remI] > rem[remI] ? 1 : -1;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // If divisor < remainder, subtract divisor from remainder.\r\n                if (cmp < 0) {\r\n\r\n                    // Remainder can't be more than 1 digit longer than divisor.\r\n                    // Equalise lengths using divisor with extra leading zero?\r\n                    for (dvsT = remL == dvsL ? dvs : dvsZ; remL;) {\r\n\r\n                        if (rem[--remL] < dvsT[remL]) {\r\n                            remI = remL;\r\n\r\n                            for (; remI && !rem[--remI]; rem[remI] = 9) {\r\n                            }\r\n                            --rem[remI];\r\n                            rem[remL] += 10;\r\n                        }\r\n                        rem[remL] -= dvsT[remL];\r\n                    }\r\n                    for (; !rem[0]; rem.shift()) {\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Add the 'next' digit to the result array.\r\n            qc[qi++] = cmp ? next : ++next;\r\n\r\n            // Update the remainder.\r\n            if (rem[0] && cmp) {\r\n                rem[remL] = dvd[dvdI] || 0;\r\n            } else {\r\n                rem = [ dvd[dvdI] ];\r\n            }\r\n\r\n        } while ((dvdI++ < dvdL || rem[0] !== u) && s--);\r\n\r\n        // Leading zero? Do not remove if result is simply zero (qi == 1).\r\n        if (!qc[0] && qi != 1) {\r\n\r\n            // There can't be more than one zero.\r\n            qc.shift();\r\n            q.e--;\r\n        }\r\n\r\n        // Round?\r\n        if (qi > digits) {\r\n            rnd(q, dp, Big.RM, rem[0] !== u);\r\n        }\r\n\r\n        return q;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this Big is equal to the value of Big y,\r\n     * otherwise returns false.\r\n     */\r\n    P.eq = function (y) {\r\n        return !this.cmp(y);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this Big is greater than the value of Big y,\r\n     * otherwise returns false.\r\n     */\r\n    P.gt = function (y) {\r\n        return this.cmp(y) > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this Big is greater than or equal to the\r\n     * value of Big y, otherwise returns false.\r\n     */\r\n    P.gte = function (y) {\r\n        return this.cmp(y) > -1;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this Big is less than the value of Big y,\r\n     * otherwise returns false.\r\n     */\r\n    P.lt = function (y) {\r\n        return this.cmp(y) < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this Big is less than or equal to the value\r\n     * of Big y, otherwise returns false.\r\n     */\r\n    P.lte = function (y) {\r\n         return this.cmp(y) < 1;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new Big whose value is the value of this Big minus the value\r\n     * of Big y.\r\n     */\r\n    P.sub = P.minus = function (y) {\r\n        var i, j, t, xLTy,\r\n            x = this,\r\n            Big = x.constructor,\r\n            a = x.s,\r\n            b = (y = new Big(y)).s;\r\n\r\n        // Signs differ?\r\n        if (a != b) {\r\n            y.s = -b;\r\n            return x.plus(y);\r\n        }\r\n\r\n        var xc = x.c.slice(),\r\n            xe = x.e,\r\n            yc = y.c,\r\n            ye = y.e;\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n\r\n            // y is non-zero? x is non-zero? Or both are zero.\r\n            return yc[0] ? (y.s = -b, y) : new Big(xc[0] ? x : 0);\r\n        }\r\n\r\n        // Determine which is the bigger number.\r\n        // Prepend zeros to equalise exponents.\r\n        if (a = xe - ye) {\r\n\r\n            if (xLTy = a < 0) {\r\n                a = -a;\r\n                t = xc;\r\n            } else {\r\n                ye = xe;\r\n                t = yc;\r\n            }\r\n\r\n            t.reverse();\r\n            for (b = a; b--; t.push(0)) {\r\n            }\r\n            t.reverse();\r\n        } else {\r\n\r\n            // Exponents equal. Check digit by digit.\r\n            j = ((xLTy = xc.length < yc.length) ? xc : yc).length;\r\n\r\n            for (a = b = 0; b < j; b++) {\r\n\r\n                if (xc[b] != yc[b]) {\r\n                    xLTy = xc[b] < yc[b];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // x < y? Point xc to the array of the bigger number.\r\n        if (xLTy) {\r\n            t = xc;\r\n            xc = yc;\r\n            yc = t;\r\n            y.s = -y.s;\r\n        }\r\n\r\n        /*\r\n         * Append zeros to xc if shorter. No need to add zeros to yc if shorter\r\n         * as subtraction only needs to start at yc.length.\r\n         */\r\n        if (( b = (j = yc.length) - (i = xc.length) ) > 0) {\r\n\r\n            for (; b--; xc[i++] = 0) {\r\n            }\r\n        }\r\n\r\n        // Subtract yc from xc.\r\n        for (b = i; j > a;){\r\n\r\n            if (xc[--j] < yc[j]) {\r\n\r\n                for (i = j; i && !xc[--i]; xc[i] = 9) {\r\n                }\r\n                --xc[i];\r\n                xc[j] += 10;\r\n            }\r\n            xc[j] -= yc[j];\r\n        }\r\n\r\n        // Remove trailing zeros.\r\n        for (; xc[--b] === 0; xc.pop()) {\r\n        }\r\n\r\n        // Remove leading zeros and adjust exponent accordingly.\r\n        for (; xc[0] === 0;) {\r\n            xc.shift();\r\n            --ye;\r\n        }\r\n\r\n        if (!xc[0]) {\r\n\r\n            // n - n = +0\r\n            y.s = 1;\r\n\r\n            // Result must be zero.\r\n            xc = [ye = 0];\r\n        }\r\n\r\n        y.c = xc;\r\n        y.e = ye;\r\n\r\n        return y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new Big whose value is the value of this Big modulo the\r\n     * value of Big y.\r\n     */\r\n    P.mod = function (y) {\r\n        var yGTx,\r\n            x = this,\r\n            Big = x.constructor,\r\n            a = x.s,\r\n            b = (y = new Big(y)).s;\r\n\r\n        if (!y.c[0]) {\r\n            throwErr(NaN);\r\n        }\r\n\r\n        x.s = y.s = 1;\r\n        yGTx = y.cmp(x) == 1;\r\n        x.s = a;\r\n        y.s = b;\r\n\r\n        if (yGTx) {\r\n            return new Big(x);\r\n        }\r\n\r\n        a = Big.DP;\r\n        b = Big.RM;\r\n        Big.DP = Big.RM = 0;\r\n        x = x.div(y);\r\n        Big.DP = a;\r\n        Big.RM = b;\r\n\r\n        return this.minus( x.times(y) );\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new Big whose value is the value of this Big plus the value\r\n     * of Big y.\r\n     */\r\n    P.add = P.plus = function (y) {\r\n        var t,\r\n            x = this,\r\n            Big = x.constructor,\r\n            a = x.s,\r\n            b = (y = new Big(y)).s;\r\n\r\n        // Signs differ?\r\n        if (a != b) {\r\n            y.s = -b;\r\n            return x.minus(y);\r\n        }\r\n\r\n        var xe = x.e,\r\n            xc = x.c,\r\n            ye = y.e,\r\n            yc = y.c;\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n\r\n            // y is non-zero? x is non-zero? Or both are zero.\r\n            return yc[0] ? y : new Big(xc[0] ? x : a * 0);\r\n        }\r\n        xc = xc.slice();\r\n\r\n        // Prepend zeros to equalise exponents.\r\n        // Note: Faster to use reverse then do unshifts.\r\n        if (a = xe - ye) {\r\n\r\n            if (a > 0) {\r\n                ye = xe;\r\n                t = yc;\r\n            } else {\r\n                a = -a;\r\n                t = xc;\r\n            }\r\n\r\n            t.reverse();\r\n            for (; a--; t.push(0)) {\r\n            }\r\n            t.reverse();\r\n        }\r\n\r\n        // Point xc to the longer array.\r\n        if (xc.length - yc.length < 0) {\r\n            t = yc;\r\n            yc = xc;\r\n            xc = t;\r\n        }\r\n        a = yc.length;\r\n\r\n        /*\r\n         * Only start adding at yc.length - 1 as the further digits of xc can be\r\n         * left as they are.\r\n         */\r\n        for (b = 0; a;) {\r\n            b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;\r\n            xc[a] %= 10;\r\n        }\r\n\r\n        // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n\r\n        if (b) {\r\n            xc.unshift(b);\r\n            ++ye;\r\n        }\r\n\r\n         // Remove trailing zeros.\r\n        for (a = xc.length; xc[--a] === 0; xc.pop()) {\r\n        }\r\n\r\n        y.c = xc;\r\n        y.e = ye;\r\n\r\n        return y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a Big whose value is the value of this Big raised to the power n.\r\n     * If n is negative, round, if necessary, to a maximum of Big.DP decimal\r\n     * places using rounding mode Big.RM.\r\n     *\r\n     * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.\r\n     */\r\n    P.pow = function (n) {\r\n        var x = this,\r\n            one = new x.constructor(1),\r\n            y = one,\r\n            isNeg = n < 0;\r\n\r\n        if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {\r\n            throwErr('!pow!');\r\n        }\r\n\r\n        n = isNeg ? -n : n;\r\n\r\n        for (;;) {\r\n\r\n            if (n & 1) {\r\n                y = y.times(x);\r\n            }\r\n            n >>= 1;\r\n\r\n            if (!n) {\r\n                break;\r\n            }\r\n            x = x.times(x);\r\n        }\r\n\r\n        return isNeg ? one.div(y) : y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new Big whose value is the value of this Big rounded to a\r\n     * maximum of dp decimal places using rounding mode rm.\r\n     * If dp is not specified, round to 0 decimal places.\r\n     * If rm is not specified, use Big.RM.\r\n     *\r\n     * [dp] {number} Integer, 0 to MAX_DP inclusive.\r\n     * [rm] 0, 1, 2 or 3 (ROUND_DOWN, ROUND_HALF_UP, ROUND_HALF_EVEN, ROUND_UP)\r\n     */\r\n    P.round = function (dp, rm) {\r\n        var x = this,\r\n            Big = x.constructor;\r\n\r\n        if (dp == null) {\r\n            dp = 0;\r\n        } else if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n            throwErr('!round!');\r\n        }\r\n        rnd(x = new Big(x), dp, rm == null ? Big.RM : rm);\r\n\r\n        return x;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new Big whose value is the square root of the value of this Big,\r\n     * rounded, if necessary, to a maximum of Big.DP decimal places using\r\n     * rounding mode Big.RM.\r\n     */\r\n    P.sqrt = function () {\r\n        var estimate, r, approx,\r\n            x = this,\r\n            Big = x.constructor,\r\n            xc = x.c,\r\n            i = x.s,\r\n            e = x.e,\r\n            half = new Big('0.5');\r\n\r\n        // Zero?\r\n        if (!xc[0]) {\r\n            return new Big(x);\r\n        }\r\n\r\n        // If negative, throw NaN.\r\n        if (i < 0) {\r\n            throwErr(NaN);\r\n        }\r\n\r\n        // Estimate.\r\n        i = Math.sqrt(x.toString());\r\n\r\n        // Math.sqrt underflow/overflow?\r\n        // Pass x to Math.sqrt as integer, then adjust the result exponent.\r\n        if (i === 0 || i === 1 / 0) {\r\n            estimate = xc.join('');\r\n\r\n            if (!(estimate.length + e & 1)) {\r\n                estimate += '0';\r\n            }\r\n\r\n            r = new Big( Math.sqrt(estimate).toString() );\r\n            r.e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);\r\n        } else {\r\n            r = new Big(i.toString());\r\n        }\r\n\r\n        i = r.e + (Big.DP += 4);\r\n\r\n        // Newton-Raphson iteration.\r\n        do {\r\n            approx = r;\r\n            r = half.times( approx.plus( x.div(approx) ) );\r\n        } while ( approx.c.slice(0, i).join('') !==\r\n                       r.c.slice(0, i).join('') );\r\n\r\n        rnd(r, Big.DP -= 4, Big.RM);\r\n\r\n        return r;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new Big whose value is the value of this Big times the value of\r\n     * Big y.\r\n     */\r\n    P.mul = P.times = function (y) {\r\n        var c,\r\n            x = this,\r\n            Big = x.constructor,\r\n            xc = x.c,\r\n            yc = (y = new Big(y)).c,\r\n            a = xc.length,\r\n            b = yc.length,\r\n            i = x.e,\r\n            j = y.e;\r\n\r\n        // Determine sign of result.\r\n        y.s = x.s == y.s ? 1 : -1;\r\n\r\n        // Return signed 0 if either 0.\r\n        if (!xc[0] || !yc[0]) {\r\n            return new Big(y.s * 0);\r\n        }\r\n\r\n        // Initialise exponent of result as x.e + y.e.\r\n        y.e = i + j;\r\n\r\n        // If array xc has fewer digits than yc, swap xc and yc, and lengths.\r\n        if (a < b) {\r\n            c = xc;\r\n            xc = yc;\r\n            yc = c;\r\n            j = a;\r\n            a = b;\r\n            b = j;\r\n        }\r\n\r\n        // Initialise coefficient array of result with zeros.\r\n        for (c = new Array(j = a + b); j--; c[j] = 0) {\r\n        }\r\n\r\n        // Multiply.\r\n\r\n        // i is initially xc.length.\r\n        for (i = b; i--;) {\r\n            b = 0;\r\n\r\n            // a is yc.length.\r\n            for (j = a + i; j > i;) {\r\n\r\n                // Current sum of products at this digit position, plus carry.\r\n                b = c[j] + yc[i] * xc[j - i - 1] + b;\r\n                c[j--] = b % 10;\r\n\r\n                // carry\r\n                b = b / 10 | 0;\r\n            }\r\n            c[j] = (c[j] + b) % 10;\r\n        }\r\n\r\n        // Increment result exponent if there is a final carry.\r\n        if (b) {\r\n            ++y.e;\r\n        }\r\n\r\n        // Remove any leading zero.\r\n        if (!c[0]) {\r\n            c.shift();\r\n        }\r\n\r\n        // Remove trailing zeros.\r\n        for (i = c.length; !c[--i]; c.pop()) {\r\n        }\r\n        y.c = c;\r\n\r\n        return y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this Big.\r\n     * Return exponential notation if this Big has a positive exponent equal to\r\n     * or greater than Big.E_POS, or a negative exponent equal to or less than\r\n     * Big.E_NEG.\r\n     */\r\n    P.toString = P.valueOf = P.toJSON = function () {\r\n        var x = this,\r\n            Big = x.constructor,\r\n            e = x.e,\r\n            str = x.c.join(''),\r\n            strL = str.length;\r\n\r\n        // Exponential notation?\r\n        if (e <= Big.E_NEG || e >= Big.E_POS) {\r\n            str = str.charAt(0) + (strL > 1 ? '.' + str.slice(1) : '') +\r\n              (e < 0 ? 'e' : 'e+') + e;\r\n\r\n        // Negative exponent?\r\n        } else if (e < 0) {\r\n\r\n            // Prepend zeros.\r\n            for (; ++e; str = '0' + str) {\r\n            }\r\n            str = '0.' + str;\r\n\r\n        // Positive exponent?\r\n        } else if (e > 0) {\r\n\r\n            if (++e > strL) {\r\n\r\n                // Append zeros.\r\n                for (e -= strL; e-- ; str += '0') {\r\n                }\r\n            } else if (e < strL) {\r\n                str = str.slice(0, e) + '.' + str.slice(e);\r\n            }\r\n\r\n        // Exponent zero.\r\n        } else if (strL > 1) {\r\n            str = str.charAt(0) + '.' + str.slice(1);\r\n        }\r\n\r\n        // Avoid '-0'\r\n        return x.s < 0 && x.c[0] ? '-' + str : str;\r\n    };\r\n\r\n\r\n    /*\r\n     ***************************************************************************\r\n     * If toExponential, toFixed, toPrecision and format are not required they\r\n     * can safely be commented-out or deleted. No redundant code will be left.\r\n     * format is used only by toExponential, toFixed and toPrecision.\r\n     ***************************************************************************\r\n     */\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this Big in exponential\r\n     * notation to dp fixed decimal places and rounded, if necessary, using\r\n     * Big.RM.\r\n     *\r\n     * [dp] {number} Integer, 0 to MAX_DP inclusive.\r\n     */\r\n    P.toExponential = function (dp) {\r\n\r\n        if (dp == null) {\r\n            dp = this.c.length - 1;\r\n        } else if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {\r\n            throwErr('!toExp!');\r\n        }\r\n\r\n        return format(this, dp, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this Big in normal notation\r\n     * to dp fixed decimal places and rounded, if necessary, using Big.RM.\r\n     *\r\n     * [dp] {number} Integer, 0 to MAX_DP inclusive.\r\n     */\r\n    P.toFixed = function (dp) {\r\n        var str,\r\n            x = this,\r\n            Big = x.constructor,\r\n            neg = Big.E_NEG,\r\n            pos = Big.E_POS;\r\n\r\n        // Prevent the possibility of exponential notation.\r\n        Big.E_NEG = -(Big.E_POS = 1 / 0);\r\n\r\n        if (dp == null) {\r\n            str = x.toString();\r\n        } else if (dp === ~~dp && dp >= 0 && dp <= MAX_DP) {\r\n            str = format(x, x.e + dp);\r\n\r\n            // (-0).toFixed() is '0', but (-0.1).toFixed() is '-0'.\r\n            // (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n            if (x.s < 0 && x.c[0] && str.indexOf('-') < 0) {\r\n        //E.g. -0.5 if rounded to -0 will cause toString to omit the minus sign.\r\n                str = '-' + str;\r\n            }\r\n        }\r\n        Big.E_NEG = neg;\r\n        Big.E_POS = pos;\r\n\r\n        if (!str) {\r\n            throwErr('!toFix!');\r\n        }\r\n\r\n        return str;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this Big rounded to sd\r\n     * significant digits using Big.RM. Use exponential notation if sd is less\r\n     * than the number of digits necessary to represent the integer part of the\r\n     * value in normal notation.\r\n     *\r\n     * sd {number} Integer, 1 to MAX_DP inclusive.\r\n     */\r\n    P.toPrecision = function (sd) {\r\n\r\n        if (sd == null) {\r\n            return this.toString();\r\n        } else if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {\r\n            throwErr('!toPre!');\r\n        }\r\n\r\n        return format(this, sd - 1, 2);\r\n    };\r\n\r\n\r\n    // Export\r\n\r\n\r\n    Big = bigFactory();\r\n\r\n    //AMD.\r\n    if (true) {\r\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\r\n            return Big;\r\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n    // Node and other CommonJS-like environments that support module.exports.\r\n    } else {}\r\n})(this);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsS0FBSztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRCxRQUFRLG1DQUFPO0FBQ2Y7QUFDQSxTQUFTO0FBQUEsa0dBQUM7QUFDVjtBQUNBO0FBQ0EsTUFBTSxLQUFLLEVBT047QUFDTCxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL2JpZy5qcy9iaWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogYmlnLmpzIHYzLjEuMyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvTElDRU5DRSAqL1xyXG47KGZ1bmN0aW9uIChnbG9iYWwpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbi8qXHJcbiAgYmlnLmpzIHYzLjEuM1xyXG4gIEEgc21hbGwsIGZhc3QsIGVhc3ktdG8tdXNlIGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gZGVjaW1hbCBhcml0aG1ldGljLlxyXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy9cclxuICBDb3B5cmlnaHQgKGMpIDIwMTQgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICBNSVQgRXhwYXQgTGljZW5jZVxyXG4qL1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqIEVESVRBQkxFIERFRkFVTFRTICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbiAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIHN0YXRlZCByYW5nZXMuXHJcblxyXG4gICAgLypcclxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGUgcmVzdWx0cyBvZiBvcGVyYXRpb25zXHJcbiAgICAgKiBpbnZvbHZpbmcgZGl2aXNpb246IGRpdiBhbmQgc3FydCwgYW5kIHBvdyB3aXRoIG5lZ2F0aXZlIGV4cG9uZW50cy5cclxuICAgICAqL1xyXG4gICAgdmFyIERQID0gMjAsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfRFBcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogMCBUb3dhcmRzIHplcm8gKGkuZS4gdHJ1bmNhdGUsIG5vIHJvdW5kaW5nKS4gICAgICAgKFJPVU5EX0RPV04pXHJcbiAgICAgICAgICogMSBUbyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHJvdW5kIHVwLiAgKFJPVU5EX0hBTEZfVVApXHJcbiAgICAgICAgICogMiBUbyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvIGV2ZW4uICAgKFJPVU5EX0hBTEZfRVZFTilcclxuICAgICAgICAgKiAzIEF3YXkgZnJvbSB6ZXJvLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoUk9VTkRfVVApXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUk0gPSAxLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwLCAxLCAyIG9yIDNcclxuXHJcbiAgICAgICAgLy8gVGhlIG1heGltdW0gdmFsdWUgb2YgRFAgYW5kIEJpZy5EUC5cclxuICAgICAgICBNQVhfRFAgPSAxRTYsICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gMTAwMDAwMFxyXG5cclxuICAgICAgICAvLyBUaGUgbWF4aW11bSBtYWduaXR1ZGUgb2YgdGhlIGV4cG9uZW50IGFyZ3VtZW50IHRvIHRoZSBwb3cgbWV0aG9kLlxyXG4gICAgICAgIE1BWF9QT1dFUiA9IDFFNiwgICAgICAgICAgICAgICAgICAgLy8gMSB0byAxMDAwMDAwXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWxcclxuICAgICAgICAgKiBub3RhdGlvbi5cclxuICAgICAgICAgKiBKYXZhU2NyaXB0J3MgTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgICAgICogLTEwMDAwMDAgaXMgdGhlIG1pbmltdW0gcmVjb21tZW5kZWQgZXhwb25lbnQgdmFsdWUgb2YgYSBCaWcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRV9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtMTAwMDAwMFxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbFxyXG4gICAgICAgICAqIG5vdGF0aW9uLlxyXG4gICAgICAgICAqIEphdmFTY3JpcHQncyBOdW1iZXIgdHlwZTogMjFcclxuICAgICAgICAgKiAxMDAwMDAwIGlzIHRoZSBtYXhpbXVtIHJlY29tbWVuZGVkIGV4cG9uZW50IHZhbHVlIG9mIGEgQmlnLlxyXG4gICAgICAgICAqIChUaGlzIGxpbWl0IGlzIG5vdCBlbmZvcmNlZCBvciBjaGVja2VkLilcclxuICAgICAgICAgKi9cclxuICAgICAgICBFX1BPUyA9IDIxLCAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDEwMDAwMDBcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4gICAgICAgIC8vIFRoZSBzaGFyZWQgcHJvdG90eXBlIG9iamVjdC5cclxuICAgICAgICBQID0ge30sXHJcbiAgICAgICAgaXNWYWxpZCA9IC9eLT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgICAgIEJpZztcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgQmlnIGNvbnN0cnVjdG9yLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYmlnRmFjdG9yeSgpIHtcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBUaGUgQmlnIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAgICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJpZyBudW1iZXIgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWd9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBCaWcobikge1xyXG4gICAgICAgICAgICB2YXIgeCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvLyBFbmFibGUgY29uc3RydWN0b3IgdXNhZ2Ugd2l0aG91dCBuZXcuXHJcbiAgICAgICAgICAgIGlmICghKHggaW5zdGFuY2VvZiBCaWcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbiA9PT0gdm9pZCAwID8gYmlnRmFjdG9yeSgpIDogbmV3IEJpZyhuKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gRHVwbGljYXRlLlxyXG4gICAgICAgICAgICBpZiAobiBpbnN0YW5jZW9mIEJpZykge1xyXG4gICAgICAgICAgICAgICAgeC5zID0gbi5zO1xyXG4gICAgICAgICAgICAgICAgeC5lID0gbi5lO1xyXG4gICAgICAgICAgICAgICAgeC5jID0gbi5jLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXJzZSh4LCBuKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogUmV0YWluIGEgcmVmZXJlbmNlIHRvIHRoaXMgQmlnIGNvbnN0cnVjdG9yLCBhbmQgc2hhZG93XHJcbiAgICAgICAgICAgICAqIEJpZy5wcm90b3R5cGUuY29uc3RydWN0b3Igd2hpY2ggcG9pbnRzIHRvIE9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHguY29uc3RydWN0b3IgPSBCaWc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBCaWcucHJvdG90eXBlID0gUDtcclxuICAgICAgICBCaWcuRFAgPSBEUDtcclxuICAgICAgICBCaWcuUk0gPSBSTTtcclxuICAgICAgICBCaWcuRV9ORUcgPSBFX05FRztcclxuICAgICAgICBCaWcuRV9QT1MgPSBFX1BPUztcclxuXHJcbiAgICAgICAgcmV0dXJuIEJpZztcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUHJpdmF0ZSBmdW5jdGlvbnNcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIEJpZyB4IGluIG5vcm1hbCBvciBleHBvbmVudGlhbFxyXG4gICAgICogbm90YXRpb24gdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICpcclxuICAgICAqIHgge0JpZ30gVGhlIEJpZyB0byBmb3JtYXQuXHJcbiAgICAgKiBkcCB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWF9EUCBpbmNsdXNpdmUuXHJcbiAgICAgKiB0b0Uge251bWJlcn0gMSAodG9FeHBvbmVudGlhbCksIDIgKHRvUHJlY2lzaW9uKSBvciB1bmRlZmluZWQgKHRvRml4ZWQpLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmb3JtYXQoeCwgZHAsIHRvRSkge1xyXG4gICAgICAgIHZhciBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGluZGV4IChub3JtYWwgbm90YXRpb24pIG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgICAgICBpID0gZHAgLSAoeCA9IG5ldyBCaWcoeCkpLmUsXHJcbiAgICAgICAgICAgIGMgPSB4LmM7XHJcblxyXG4gICAgICAgIC8vIFJvdW5kP1xyXG4gICAgICAgIGlmIChjLmxlbmd0aCA+ICsrZHApIHtcclxuICAgICAgICAgICAgcm5kKHgsIGksIEJpZy5STSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWNbMF0pIHtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodG9FKSB7XHJcbiAgICAgICAgICAgIGkgPSBkcDtcclxuXHJcbiAgICAgICAgLy8gdG9GaXhlZFxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGMgPSB4LmM7XHJcblxyXG4gICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSBpIGFzIHguZSBtYXkgaGF2ZSBjaGFuZ2VkIGlmIHZhbHVlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgICAgIGkgPSB4LmUgKyBpICsgMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICBmb3IgKDsgYy5sZW5ndGggPCBpOyBjLnB1c2goMCkpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSA9IHguZTtcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2ZcclxuICAgICAgICAgKiBzaWduaWZpY2FudCBkaWdpdHMgc3BlY2lmaWVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAgICAgICAqIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gbm9ybWFsXHJcbiAgICAgICAgICogbm90YXRpb24uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmV0dXJuIHRvRSA9PT0gMSB8fCB0b0UgJiYgKGRwIDw9IGkgfHwgaSA8PSBCaWcuRV9ORUcpID9cclxuXHJcbiAgICAgICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICAgICh4LnMgPCAwICYmIGNbMF0gPyAnLScgOiAnJykgK1xyXG4gICAgICAgICAgICAoYy5sZW5ndGggPiAxID8gY1swXSArICcuJyArIGMuam9pbignJykuc2xpY2UoMSkgOiBjWzBdKSArXHJcbiAgICAgICAgICAgICAgKGkgPCAwID8gJ2UnIDogJ2UrJykgKyBpXHJcblxyXG4gICAgICAgICAgLy8gTm9ybWFsIG5vdGF0aW9uLlxyXG4gICAgICAgICAgOiB4LnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBQYXJzZSB0aGUgbnVtYmVyIG9yIHN0cmluZyB2YWx1ZSBwYXNzZWQgdG8gYSBCaWcgY29uc3RydWN0b3IuXHJcbiAgICAgKlxyXG4gICAgICogeCB7QmlnfSBBIEJpZyBudW1iZXIgaW5zdGFuY2UuXHJcbiAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHBhcnNlKHgsIG4pIHtcclxuICAgICAgICB2YXIgZSwgaSwgbkw7XHJcblxyXG4gICAgICAgIC8vIE1pbnVzIHplcm8/XHJcbiAgICAgICAgaWYgKG4gPT09IDAgJiYgMSAvIG4gPCAwKSB7XHJcbiAgICAgICAgICAgIG4gPSAnLTAnO1xyXG5cclxuICAgICAgICAvLyBFbnN1cmUgbiBpcyBzdHJpbmcgYW5kIGNoZWNrIHZhbGlkaXR5LlxyXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzVmFsaWQudGVzdChuICs9ICcnKSkge1xyXG4gICAgICAgICAgICB0aHJvd0VycihOYU4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHNpZ24uXHJcbiAgICAgICAgeC5zID0gbi5jaGFyQXQoMCkgPT0gJy0nID8gKG4gPSBuLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IG4uaW5kZXhPZignLicpKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IG4uc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgICAgaWYgKGUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBlID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlICs9ICtuLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICAgICAgbiA9IG4uc3Vic3RyaW5nKDAsIGkpO1xyXG5cclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnRlZ2VyLlxyXG4gICAgICAgICAgICBlID0gbi5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBuTCA9IG4ubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbkwgJiYgbi5jaGFyQXQoaSkgPT0gJzAnOyBpKyspIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpID09IG5MKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICB4LmMgPSBbIHguZSA9IDAgXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgICBmb3IgKDsgbkwgPiAwICYmIG4uY2hhckF0KC0tbkwpID09ICcwJzspIHtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeC5lID0gZSAtIGkgLSAxO1xyXG4gICAgICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIGFycmF5IG9mIGRpZ2l0cyB3aXRob3V0IGxlYWRpbmcvdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICAgIC8vZm9yIChlID0gMDsgaSA8PSBuTDsgeC5jW2UrK10gPSArbi5jaGFyQXQoaSsrKSkge1xyXG4gICAgICAgICAgICBmb3IgKDsgaSA8PSBuTDsgeC5jLnB1c2goK24uY2hhckF0KGkrKykpKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUm91bmQgQmlnIHggdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uXHJcbiAgICAgKiBDYWxsZWQgYnkgZGl2LCBzcXJ0IGFuZCByb3VuZC5cclxuICAgICAqXHJcbiAgICAgKiB4IHtCaWd9IFRoZSBCaWcgdG8gcm91bmQuXHJcbiAgICAgKiBkcCB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWF9EUCBpbmNsdXNpdmUuXHJcbiAgICAgKiBybSB7bnVtYmVyfSAwLCAxLCAyIG9yIDMgKERPV04sIEhBTEZfVVAsIEhBTEZfRVZFTiwgVVApXHJcbiAgICAgKiBbbW9yZV0ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbiB3YXMgdHJ1bmNhdGVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBybmQoeCwgZHAsIHJtLCBtb3JlKSB7XHJcbiAgICAgICAgdmFyIHUsXHJcbiAgICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgICBpID0geC5lICsgZHAgKyAxO1xyXG5cclxuICAgICAgICBpZiAocm0gPT09IDEpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIHhjW2ldIGlzIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAgICAgbW9yZSA9IHhjW2ldID49IDU7XHJcbiAgICAgICAgfSBlbHNlIGlmIChybSA9PT0gMikge1xyXG4gICAgICAgICAgICBtb3JlID0geGNbaV0gPiA1IHx8IHhjW2ldID09IDUgJiZcclxuICAgICAgICAgICAgICAobW9yZSB8fCBpIDwgMCB8fCB4Y1tpICsgMV0gIT09IHUgfHwgeGNbaSAtIDFdICYgMSk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChybSA9PT0gMykge1xyXG4gICAgICAgICAgICBtb3JlID0gbW9yZSB8fCB4Y1tpXSAhPT0gdSB8fCBpIDwgMDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtb3JlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBpZiAocm0gIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyKCchQmlnLlJNIScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaSA8IDEgfHwgIXhjWzBdKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAobW9yZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICAgICAgICB4LmUgPSAtZHA7XHJcbiAgICAgICAgICAgICAgICB4LmMgPSBbMV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgYW55IGRpZ2l0cyBhZnRlciB0aGUgcmVxdWlyZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IGktLTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgICBpZiAobW9yZSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAgICAgICAgIGZvciAoOyArK3hjW2ldID4gOTspIHtcclxuICAgICAgICAgICAgICAgICAgICB4Y1tpXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICsreC5lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Yy51bnNoaWZ0KDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgICBmb3IgKGkgPSB4Yy5sZW5ndGg7ICF4Y1stLWldOyB4Yy5wb3AoKSkge1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFRocm93IGEgQmlnRXJyb3IuXHJcbiAgICAgKlxyXG4gICAgICogbWVzc2FnZSB7c3RyaW5nfSBUaGUgZXJyb3IgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdGhyb3dFcnIobWVzc2FnZSkge1xyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgZXJyLm5hbWUgPSAnQmlnRXJyb3InO1xyXG5cclxuICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFByb3RvdHlwZS9pbnN0YW5jZSBtZXRob2RzXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZy5cclxuICAgICAqL1xyXG4gICAgUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHggPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcclxuICAgICAgICB4LnMgPSAxO1xyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm5cclxuICAgICAqIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnIHksXHJcbiAgICAgKiAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWcgeSwgb3JcclxuICAgICAqIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLlxyXG4gICAgKi9cclxuICAgIFAuY21wID0gZnVuY3Rpb24gKHkpIHtcclxuICAgICAgICB2YXIgeE5lZyxcclxuICAgICAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgICB5YyA9ICh5ID0gbmV3IHguY29uc3RydWN0b3IoeSkpLmMsXHJcbiAgICAgICAgICAgIGkgPSB4LnMsXHJcbiAgICAgICAgICAgIGogPSB5LnMsXHJcbiAgICAgICAgICAgIGsgPSB4LmUsXHJcbiAgICAgICAgICAgIGwgPSB5LmU7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAheGNbMF0gPyAheWNbMF0gPyAwIDogLWogOiBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgIGlmIChpICE9IGopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHhOZWcgPSBpIDwgMDtcclxuXHJcbiAgICAgICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICAgICAgaWYgKGsgIT0gbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gayA+IGwgXiB4TmVnID8gMSA6IC0xO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaSA9IC0xO1xyXG4gICAgICAgIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgICAgICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgICBmb3IgKDsgKytpIDwgajspIHtcclxuXHJcbiAgICAgICAgICAgIGlmICh4Y1tpXSAhPSB5Y1tpXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHhjW2ldID4geWNbaV0gXiB4TmVnID8gMSA6IC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgICAgICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIHhOZWcgPyAxIDogLTE7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgZGl2aWRlZCBieSB0aGVcclxuICAgICAqIHZhbHVlIG9mIEJpZyB5LCByb3VuZGVkLCBpZiBuZWNlc3NhcnksIHRvIGEgbWF4aW11bSBvZiBCaWcuRFAgZGVjaW1hbFxyXG4gICAgICogcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgQmlnLlJNLlxyXG4gICAgICovXHJcbiAgICBQLmRpdiA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICAgICAgdmFyIHggPSB0aGlzLFxyXG4gICAgICAgICAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICAgICAgICAvLyBkaXZpZGVuZFxyXG4gICAgICAgICAgICBkdmQgPSB4LmMsXHJcbiAgICAgICAgICAgIC8vZGl2aXNvclxyXG4gICAgICAgICAgICBkdnMgPSAoeSA9IG5ldyBCaWcoeSkpLmMsXHJcbiAgICAgICAgICAgIHMgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICAgICAgICBkcCA9IEJpZy5EUDtcclxuXHJcbiAgICAgICAgaWYgKGRwICE9PSB+fmRwIHx8IGRwIDwgMCB8fCBkcCA+IE1BWF9EUCkge1xyXG4gICAgICAgICAgICB0aHJvd0VycignIUJpZy5EUCEnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciAwP1xyXG4gICAgICAgIGlmICghZHZkWzBdIHx8ICFkdnNbMF0pIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGJvdGggYXJlIDAsIHRocm93IE5hTlxyXG4gICAgICAgICAgICBpZiAoZHZkWzBdID09IGR2c1swXSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3dFcnIoTmFOKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gSWYgZHZzIGlzIDAsIHRocm93ICstSW5maW5pdHkuXHJcbiAgICAgICAgICAgIGlmICghZHZzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0VycihzIC8gMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGR2ZCBpcyAwLCByZXR1cm4gKy0wLlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZyhzICogMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZHZzTCwgZHZzVCwgbmV4dCwgY21wLCByZW1JLCB1LFxyXG4gICAgICAgICAgICBkdnNaID0gZHZzLnNsaWNlKCksXHJcbiAgICAgICAgICAgIGR2ZEkgPSBkdnNMID0gZHZzLmxlbmd0aCxcclxuICAgICAgICAgICAgZHZkTCA9IGR2ZC5sZW5ndGgsXHJcbiAgICAgICAgICAgIC8vIHJlbWFpbmRlclxyXG4gICAgICAgICAgICByZW0gPSBkdmQuc2xpY2UoMCwgZHZzTCksXHJcbiAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoLFxyXG4gICAgICAgICAgICAvLyBxdW90aWVudFxyXG4gICAgICAgICAgICBxID0geSxcclxuICAgICAgICAgICAgcWMgPSBxLmMgPSBbXSxcclxuICAgICAgICAgICAgcWkgPSAwLFxyXG4gICAgICAgICAgICBkaWdpdHMgPSBkcCArIChxLmUgPSB4LmUgLSB5LmUpICsgMTtcclxuXHJcbiAgICAgICAgcS5zID0gcztcclxuICAgICAgICBzID0gZGlnaXRzIDwgMCA/IDAgOiBkaWdpdHM7XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSB2ZXJzaW9uIG9mIGRpdmlzb3Igd2l0aCBsZWFkaW5nIHplcm8uXHJcbiAgICAgICAgZHZzWi51bnNoaWZ0KDApO1xyXG5cclxuICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgIGZvciAoOyByZW1MKysgPCBkdnNMOyByZW0ucHVzaCgwKSkge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZG8ge1xyXG5cclxuICAgICAgICAgICAgLy8gJ25leHQnIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgZm9yIChuZXh0ID0gMDsgbmV4dCA8IDEwOyBuZXh0KyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIGlmIChkdnNMICE9IChyZW1MID0gcmVtLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbXAgPSBkdnNMID4gcmVtTCA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAocmVtSSA9IC0xLCBjbXAgPSAwOyArK3JlbUkgPCBkdnNMOykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR2c1tyZW1JXSAhPSByZW1bcmVtSV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IGR2c1tyZW1JXSA+IHJlbVtyZW1JXSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1haW5kZXIgY2FuJ3QgYmUgbW9yZSB0aGFuIDEgZGlnaXQgbG9uZ2VyIHRoYW4gZGl2aXNvci5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFcXVhbGlzZSBsZW5ndGhzIHVzaW5nIGRpdmlzb3Igd2l0aCBleHRyYSBsZWFkaW5nIHplcm8/XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChkdnNUID0gcmVtTCA9PSBkdnNMID8gZHZzIDogZHZzWjsgcmVtTDspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1bLS1yZW1MXSA8IGR2c1RbcmVtTF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbUkgPSByZW1MO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyByZW1JICYmICFyZW1bLS1yZW1JXTsgcmVtW3JlbUldID0gOSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLS1yZW1bcmVtSV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1bcmVtTF0gKz0gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtW3JlbUxdIC09IGR2c1RbcmVtTF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyAhcmVtWzBdOyByZW0uc2hpZnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgJ25leHQnIGRpZ2l0IHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgIHFjW3FpKytdID0gY21wID8gbmV4dCA6ICsrbmV4dDtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAocmVtWzBdICYmIGNtcCkge1xyXG4gICAgICAgICAgICAgICAgcmVtW3JlbUxdID0gZHZkW2R2ZEldIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZW0gPSBbIGR2ZFtkdmRJXSBdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gd2hpbGUgKChkdmRJKysgPCBkdmRMIHx8IHJlbVswXSAhPT0gdSkgJiYgcy0tKTtcclxuXHJcbiAgICAgICAgLy8gTGVhZGluZyB6ZXJvPyBEbyBub3QgcmVtb3ZlIGlmIHJlc3VsdCBpcyBzaW1wbHkgemVybyAocWkgPT0gMSkuXHJcbiAgICAgICAgaWYgKCFxY1swXSAmJiBxaSAhPSAxKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGVyZSBjYW4ndCBiZSBtb3JlIHRoYW4gb25lIHplcm8uXHJcbiAgICAgICAgICAgIHFjLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIHEuZS0tO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUm91bmQ/XHJcbiAgICAgICAgaWYgKHFpID4gZGlnaXRzKSB7XHJcbiAgICAgICAgICAgIHJuZChxLCBkcCwgQmlnLlJNLCByZW1bMF0gIT09IHUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWcgeSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmVxID0gZnVuY3Rpb24gKHkpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuY21wKHkpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZyB5LFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuZ3QgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNtcCh5KSA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGVcclxuICAgICAqIHZhbHVlIG9mIEJpZyB5LCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5ndGUgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNtcCh5KSA+IC0xO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZyB5LFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAubHQgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNtcCh5KSA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWVcclxuICAgICAqIG9mIEJpZyB5LCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5sdGUgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgICAgICByZXR1cm4gdGhpcy5jbXAoeSkgPCAxO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIG1pbnVzIHRoZSB2YWx1ZVxyXG4gICAgICogb2YgQmlnIHkuXHJcbiAgICAgKi9cclxuICAgIFAuc3ViID0gUC5taW51cyA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICAgICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICAgICAgICBhID0geC5zLFxyXG4gICAgICAgICAgICBiID0gKHkgPSBuZXcgQmlnKHkpKS5zO1xyXG5cclxuICAgICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciB4YyA9IHguYy5zbGljZSgpLFxyXG4gICAgICAgICAgICB4ZSA9IHguZSxcclxuICAgICAgICAgICAgeWMgPSB5LmMsXHJcbiAgICAgICAgICAgIHllID0geS5lO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgICAgLy8geSBpcyBub24temVybz8geCBpcyBub24temVybz8gT3IgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgICAgcmV0dXJuIHljWzBdID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWcoeGNbMF0gPyB4IDogMCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoeExUeSA9IGEgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICAgICAgZm9yIChiID0gYTsgYi0tOyB0LnB1c2goMCkpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgICAgICAgaiA9ICgoeExUeSA9IHhjLmxlbmd0aCA8IHljLmxlbmd0aCkgPyB4YyA6IHljKS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGEgPSBiID0gMDsgYiA8IGo7IGIrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh4Y1tiXSAhPSB5Y1tiXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICAgIGlmICh4TFR5KSB7XHJcbiAgICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICAgICAgeGMgPSB5YztcclxuICAgICAgICAgICAgeWMgPSB0O1xyXG4gICAgICAgICAgICB5LnMgPSAteS5zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci4gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlclxyXG4gICAgICAgICAqIGFzIHN1YnRyYWN0aW9uIG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgeWMubGVuZ3RoLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICgoIGIgPSAoaiA9IHljLmxlbmd0aCkgLSAoaSA9IHhjLmxlbmd0aCkgKSA+IDApIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBiLS07IHhjW2krK10gPSAwKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgICAgZm9yIChiID0gaTsgaiA+IGE7KXtcclxuXHJcbiAgICAgICAgICAgIGlmICh4Y1stLWpdIDwgeWNbal0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBqOyBpICYmICF4Y1stLWldOyB4Y1tpXSA9IDkpIHtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC0teGNbaV07XHJcbiAgICAgICAgICAgICAgICB4Y1tqXSArPSAxMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgeGNbLS1iXSA9PT0gMDsgeGMucG9wKCkpIHtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgZm9yICg7IHhjWzBdID09PSAwOykge1xyXG4gICAgICAgICAgICB4Yy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAtLXllO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgICAgICAgLy8gbiAtIG4gPSArMFxyXG4gICAgICAgICAgICB5LnMgPSAxO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzdWx0IG11c3QgYmUgemVyby5cclxuICAgICAgICAgICAgeGMgPSBbeWUgPSAwXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHkuYyA9IHhjO1xyXG4gICAgICAgIHkuZSA9IHllO1xyXG5cclxuICAgICAgICByZXR1cm4geTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBtb2R1bG8gdGhlXHJcbiAgICAgKiB2YWx1ZSBvZiBCaWcgeS5cclxuICAgICAqL1xyXG4gICAgUC5tb2QgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgICAgIHZhciB5R1R4LFxyXG4gICAgICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICAgICAgQmlnID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgICAgICAgYSA9IHgucyxcclxuICAgICAgICAgICAgYiA9ICh5ID0gbmV3IEJpZyh5KSkucztcclxuXHJcbiAgICAgICAgaWYgKCF5LmNbMF0pIHtcclxuICAgICAgICAgICAgdGhyb3dFcnIoTmFOKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHgucyA9IHkucyA9IDE7XHJcbiAgICAgICAgeUdUeCA9IHkuY21wKHgpID09IDE7XHJcbiAgICAgICAgeC5zID0gYTtcclxuICAgICAgICB5LnMgPSBiO1xyXG5cclxuICAgICAgICBpZiAoeUdUeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZyh4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGEgPSBCaWcuRFA7XHJcbiAgICAgICAgYiA9IEJpZy5STTtcclxuICAgICAgICBCaWcuRFAgPSBCaWcuUk0gPSAwO1xyXG4gICAgICAgIHggPSB4LmRpdih5KTtcclxuICAgICAgICBCaWcuRFAgPSBhO1xyXG4gICAgICAgIEJpZy5STSA9IGI7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLm1pbnVzKCB4LnRpbWVzKHkpICk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgcGx1cyB0aGUgdmFsdWVcclxuICAgICAqIG9mIEJpZyB5LlxyXG4gICAgICovXHJcbiAgICBQLmFkZCA9IFAucGx1cyA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICAgICAgdmFyIHQsXHJcbiAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICAgICAgICBhID0geC5zLFxyXG4gICAgICAgICAgICBiID0gKHkgPSBuZXcgQmlnKHkpKS5zO1xyXG5cclxuICAgICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgeGUgPSB4LmUsXHJcbiAgICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgICB5ZSA9IHkuZSxcclxuICAgICAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgICAvLyB5IGlzIG5vbi16ZXJvPyB4IGlzIG5vbi16ZXJvPyBPciBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgICByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZyh4Y1swXSA/IHggOiBhICogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgICAgLy8gTm90ZTogRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICBmb3IgKDsgYS0tOyB0LnB1c2goMCkpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXkuXHJcbiAgICAgICAgaWYgKHhjLmxlbmd0aCAtIHljLmxlbmd0aCA8IDApIHtcclxuICAgICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgICAgICB5YyA9IHhjO1xyXG4gICAgICAgICAgICB4YyA9IHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGEgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlXHJcbiAgICAgICAgICogbGVmdCBhcyB0aGV5IGFyZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3IgKGIgPSAwOyBhOykge1xyXG4gICAgICAgICAgICBiID0gKHhjWy0tYV0gPSB4Y1thXSArIHljW2FdICsgYikgLyAxMCB8IDA7XHJcbiAgICAgICAgICAgIHhjW2FdICU9IDEwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG5cclxuICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICB4Yy51bnNoaWZ0KGIpO1xyXG4gICAgICAgICAgICArK3llO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGEgPSB4Yy5sZW5ndGg7IHhjWy0tYV0gPT09IDA7IHhjLnBvcCgpKSB7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB5LmMgPSB4YztcclxuICAgICAgICB5LmUgPSB5ZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyByYWlzZWQgdG8gdGhlIHBvd2VyIG4uXHJcbiAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlLCByb3VuZCwgaWYgbmVjZXNzYXJ5LCB0byBhIG1heGltdW0gb2YgQmlnLkRQIGRlY2ltYWxcclxuICAgICAqIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIEJpZy5STS5cclxuICAgICAqXHJcbiAgICAgKiBuIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfUE9XRVIgdG8gTUFYX1BPV0VSIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgUC5wb3cgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcyxcclxuICAgICAgICAgICAgb25lID0gbmV3IHguY29uc3RydWN0b3IoMSksXHJcbiAgICAgICAgICAgIHkgPSBvbmUsXHJcbiAgICAgICAgICAgIGlzTmVnID0gbiA8IDA7XHJcblxyXG4gICAgICAgIGlmIChuICE9PSB+fm4gfHwgbiA8IC1NQVhfUE9XRVIgfHwgbiA+IE1BWF9QT1dFUikge1xyXG4gICAgICAgICAgICB0aHJvd0VycignIXBvdyEnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG4gPSBpc05lZyA/IC1uIDogbjtcclxuXHJcbiAgICAgICAgZm9yICg7Oykge1xyXG5cclxuICAgICAgICAgICAgaWYgKG4gJiAxKSB7XHJcbiAgICAgICAgICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID4+PSAxO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFuKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4ID0geC50aW1lcyh4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpc05lZyA/IG9uZS5kaXYoeSkgOiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWcgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnIHJvdW5kZWQgdG8gYVxyXG4gICAgICogbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLlxyXG4gICAgICogSWYgZHAgaXMgbm90IHNwZWNpZmllZCwgcm91bmQgdG8gMCBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAqIElmIHJtIGlzIG5vdCBzcGVjaWZpZWQsIHVzZSBCaWcuUk0uXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWF9EUCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIDAsIDEsIDIgb3IgMyAoUk9VTkRfRE9XTiwgUk9VTkRfSEFMRl9VUCwgUk9VTkRfSEFMRl9FVkVOLCBST1VORF9VUClcclxuICAgICAqL1xyXG4gICAgUC5yb3VuZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgICB2YXIgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgIEJpZyA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgICAgIGlmIChkcCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRwID0gMDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRwICE9PSB+fmRwIHx8IGRwIDwgMCB8fCBkcCA+IE1BWF9EUCkge1xyXG4gICAgICAgICAgICB0aHJvd0VycignIXJvdW5kIScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBybmQoeCA9IG5ldyBCaWcoeCksIGRwLCBybSA9PSBudWxsID8gQmlnLlJNIDogcm0pO1xyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWcsXHJcbiAgICAgKiByb3VuZGVkLCBpZiBuZWNlc3NhcnksIHRvIGEgbWF4aW11bSBvZiBCaWcuRFAgZGVjaW1hbCBwbGFjZXMgdXNpbmdcclxuICAgICAqIHJvdW5kaW5nIG1vZGUgQmlnLlJNLlxyXG4gICAgICovXHJcbiAgICBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVzdGltYXRlLCByLCBhcHByb3gsXHJcbiAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICBCaWcgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgICAgaSA9IHgucyxcclxuICAgICAgICAgICAgZSA9IHguZSxcclxuICAgICAgICAgICAgaGFsZiA9IG5ldyBCaWcoJzAuNScpO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWcoeCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiBuZWdhdGl2ZSwgdGhyb3cgTmFOLlxyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvd0VycihOYU4pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXN0aW1hdGUuXHJcbiAgICAgICAgaSA9IE1hdGguc3FydCh4LnRvU3RyaW5nKCkpO1xyXG5cclxuICAgICAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIHJlc3VsdCBleHBvbmVudC5cclxuICAgICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSAxIC8gMCkge1xyXG4gICAgICAgICAgICBlc3RpbWF0ZSA9IHhjLmpvaW4oJycpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCEoZXN0aW1hdGUubGVuZ3RoICsgZSAmIDEpKSB7XHJcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZSArPSAnMCc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHIgPSBuZXcgQmlnKCBNYXRoLnNxcnQoZXN0aW1hdGUpLnRvU3RyaW5nKCkgKTtcclxuICAgICAgICAgICAgci5lID0gKChlICsgMSkgLyAyIHwgMCkgLSAoZSA8IDAgfHwgZSAmIDEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHIgPSBuZXcgQmlnKGkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpID0gci5lICsgKEJpZy5EUCArPSA0KTtcclxuXHJcbiAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgYXBwcm94ID0gcjtcclxuICAgICAgICAgICAgciA9IGhhbGYudGltZXMoIGFwcHJveC5wbHVzKCB4LmRpdihhcHByb3gpICkgKTtcclxuICAgICAgICB9IHdoaWxlICggYXBwcm94LmMuc2xpY2UoMCwgaSkuam9pbignJykgIT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgci5jLnNsaWNlKDAsIGkpLmpvaW4oJycpICk7XHJcblxyXG4gICAgICAgIHJuZChyLCBCaWcuRFAgLT0gNCwgQmlnLlJNKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZyB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgdGltZXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWcgeS5cclxuICAgICAqL1xyXG4gICAgUC5tdWwgPSBQLnRpbWVzID0gZnVuY3Rpb24gKHkpIHtcclxuICAgICAgICB2YXIgYyxcclxuICAgICAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgICB5YyA9ICh5ID0gbmV3IEJpZyh5KSkuYyxcclxuICAgICAgICAgICAgYSA9IHhjLmxlbmd0aCxcclxuICAgICAgICAgICAgYiA9IHljLmxlbmd0aCxcclxuICAgICAgICAgICAgaSA9IHguZSxcclxuICAgICAgICAgICAgaiA9IHkuZTtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHNpZ24gb2YgcmVzdWx0LlxyXG4gICAgICAgIHkucyA9IHgucyA9PSB5LnMgPyAxIDogLTE7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBzaWduZWQgMCBpZiBlaXRoZXIgMC5cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJpZyh5LnMgKiAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEluaXRpYWxpc2UgZXhwb25lbnQgb2YgcmVzdWx0IGFzIHguZSArIHkuZS5cclxuICAgICAgICB5LmUgPSBpICsgajtcclxuXHJcbiAgICAgICAgLy8gSWYgYXJyYXkgeGMgaGFzIGZld2VyIGRpZ2l0cyB0aGFuIHljLCBzd2FwIHhjIGFuZCB5YywgYW5kIGxlbmd0aHMuXHJcbiAgICAgICAgaWYgKGEgPCBiKSB7XHJcbiAgICAgICAgICAgIGMgPSB4YztcclxuICAgICAgICAgICAgeGMgPSB5YztcclxuICAgICAgICAgICAgeWMgPSBjO1xyXG4gICAgICAgICAgICBqID0gYTtcclxuICAgICAgICAgICAgYSA9IGI7XHJcbiAgICAgICAgICAgIGIgPSBqO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5pdGlhbGlzZSBjb2VmZmljaWVudCBhcnJheSBvZiByZXN1bHQgd2l0aCB6ZXJvcy5cclxuICAgICAgICBmb3IgKGMgPSBuZXcgQXJyYXkoaiA9IGEgKyBiKTsgai0tOyBjW2pdID0gMCkge1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTXVsdGlwbHkuXHJcblxyXG4gICAgICAgIC8vIGkgaXMgaW5pdGlhbGx5IHhjLmxlbmd0aC5cclxuICAgICAgICBmb3IgKGkgPSBiOyBpLS07KSB7XHJcbiAgICAgICAgICAgIGIgPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gYSBpcyB5Yy5sZW5ndGguXHJcbiAgICAgICAgICAgIGZvciAoaiA9IGEgKyBpOyBqID4gaTspIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDdXJyZW50IHN1bSBvZiBwcm9kdWN0cyBhdCB0aGlzIGRpZ2l0IHBvc2l0aW9uLCBwbHVzIGNhcnJ5LlxyXG4gICAgICAgICAgICAgICAgYiA9IGNbal0gKyB5Y1tpXSAqIHhjW2ogLSBpIC0gMV0gKyBiO1xyXG4gICAgICAgICAgICAgICAgY1tqLS1dID0gYiAlIDEwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNhcnJ5XHJcbiAgICAgICAgICAgICAgICBiID0gYiAvIDEwIHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjW2pdID0gKGNbal0gKyBiKSAlIDEwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSW5jcmVtZW50IHJlc3VsdCBleHBvbmVudCBpZiB0aGVyZSBpcyBhIGZpbmFsIGNhcnJ5LlxyXG4gICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICsreS5lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBsZWFkaW5nIHplcm8uXHJcbiAgICAgICAgaWYgKCFjWzBdKSB7XHJcbiAgICAgICAgICAgIGMuc2hpZnQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSBjLmxlbmd0aDsgIWNbLS1pXTsgYy5wb3AoKSkge1xyXG4gICAgICAgIH1cclxuICAgICAgICB5LmMgPSBjO1xyXG5cclxuICAgICAgICByZXR1cm4geTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZy5cclxuICAgICAqIFJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGlzIEJpZyBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudCBlcXVhbCB0b1xyXG4gICAgICogb3IgZ3JlYXRlciB0aGFuIEJpZy5FX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgICAqIEJpZy5FX05FRy5cclxuICAgICAqL1xyXG4gICAgUC50b1N0cmluZyA9IFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB4ID0gdGhpcyxcclxuICAgICAgICAgICAgQmlnID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgICAgICAgZSA9IHguZSxcclxuICAgICAgICAgICAgc3RyID0geC5jLmpvaW4oJycpLFxyXG4gICAgICAgICAgICBzdHJMID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24/XHJcbiAgICAgICAgaWYgKGUgPD0gQmlnLkVfTkVHIHx8IGUgPj0gQmlnLkVfUE9TKSB7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyAoc3RyTCA+IDEgPyAnLicgKyBzdHIuc2xpY2UoMSkgOiAnJykgK1xyXG4gICAgICAgICAgICAgIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxuXHJcbiAgICAgICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICg7ICsrZTsgc3RyID0gJzAnICsgc3RyKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RyID0gJzAuJyArIHN0cjtcclxuXHJcbiAgICAgICAgLy8gUG9zaXRpdmUgZXhwb25lbnQ/XHJcbiAgICAgICAgfSBlbHNlIGlmIChlID4gMCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKCsrZSA+IHN0ckwpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgemVyb3MuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGUgLT0gc3RyTDsgZS0tIDsgc3RyICs9ICcwJykge1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUgPCBzdHJMKSB7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnQgemVyby5cclxuICAgICAgICB9IGVsc2UgaWYgKHN0ckwgPiAxKSB7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdm9pZCAnLTAnXHJcbiAgICAgICAgcmV0dXJuIHgucyA8IDAgJiYgeC5jWzBdID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgICAqIElmIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvUHJlY2lzaW9uIGFuZCBmb3JtYXQgYXJlIG5vdCByZXF1aXJlZCB0aGV5XHJcbiAgICAgKiBjYW4gc2FmZWx5IGJlIGNvbW1lbnRlZC1vdXQgb3IgZGVsZXRlZC4gTm8gcmVkdW5kYW50IGNvZGUgd2lsbCBiZSBsZWZ0LlxyXG4gICAgICogZm9ybWF0IGlzIHVzZWQgb25seSBieSB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkIGFuZCB0b1ByZWNpc2lvbi5cclxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgICAqL1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgaW4gZXhwb25lbnRpYWxcclxuICAgICAqIG5vdGF0aW9uIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIGFuZCByb3VuZGVkLCBpZiBuZWNlc3NhcnksIHVzaW5nXHJcbiAgICAgKiBCaWcuUk0uXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWF9EUCBpbmNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIFAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCkge1xyXG5cclxuICAgICAgICBpZiAoZHAgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkcCA9IHRoaXMuYy5sZW5ndGggLSAxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHAgIT09IH5+ZHAgfHwgZHAgPCAwIHx8IGRwID4gTUFYX0RQKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyKCchdG9FeHAhJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZyBpbiBub3JtYWwgbm90YXRpb25cclxuICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIGFuZCByb3VuZGVkLCBpZiBuZWNlc3NhcnksIHVzaW5nIEJpZy5STS5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwKSB7XHJcbiAgICAgICAgdmFyIHN0cixcclxuICAgICAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgICAgIEJpZyA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgICAgICAgIG5lZyA9IEJpZy5FX05FRyxcclxuICAgICAgICAgICAgcG9zID0gQmlnLkVfUE9TO1xyXG5cclxuICAgICAgICAvLyBQcmV2ZW50IHRoZSBwb3NzaWJpbGl0eSBvZiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICBCaWcuRV9ORUcgPSAtKEJpZy5FX1BPUyA9IDEgLyAwKTtcclxuXHJcbiAgICAgICAgaWYgKGRwID09IG51bGwpIHtcclxuICAgICAgICAgICAgc3RyID0geC50b1N0cmluZygpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHAgPT09IH5+ZHAgJiYgZHAgPj0gMCAmJiBkcCA8PSBNQVhfRFApIHtcclxuICAgICAgICAgICAgc3RyID0gZm9ybWF0KHgsIHguZSArIGRwKTtcclxuXHJcbiAgICAgICAgICAgIC8vICgtMCkudG9GaXhlZCgpIGlzICcwJywgYnV0ICgtMC4xKS50b0ZpeGVkKCkgaXMgJy0wJy5cclxuICAgICAgICAgICAgLy8gKC0wKS50b0ZpeGVkKDEpIGlzICcwLjAnLCBidXQgKC0wLjAxKS50b0ZpeGVkKDEpIGlzICctMC4wJy5cclxuICAgICAgICAgICAgaWYgKHgucyA8IDAgJiYgeC5jWzBdICYmIHN0ci5pbmRleE9mKCctJykgPCAwKSB7XHJcbiAgICAgICAgLy9FLmcuIC0wLjUgaWYgcm91bmRlZCB0byAtMCB3aWxsIGNhdXNlIHRvU3RyaW5nIHRvIG9taXQgdGhlIG1pbnVzIHNpZ24uXHJcbiAgICAgICAgICAgICAgICBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgQmlnLkVfTkVHID0gbmVnO1xyXG4gICAgICAgIEJpZy5FX1BPUyA9IHBvcztcclxuXHJcbiAgICAgICAgaWYgKCFzdHIpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnIoJyF0b0ZpeCEnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWcgcm91bmRlZCB0byBzZFxyXG4gICAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIEJpZy5STS4gVXNlIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHNkIGlzIGxlc3NcclxuICAgICAqIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZVxyXG4gICAgICogdmFsdWUgaW4gbm9ybWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIHNkIHtudW1iZXJ9IEludGVnZXIsIDEgdG8gTUFYX0RQIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCkge1xyXG5cclxuICAgICAgICBpZiAoc2QgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoc2QgIT09IH5+c2QgfHwgc2QgPCAxIHx8IHNkID4gTUFYX0RQKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyKCchdG9QcmUhJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIHNkIC0gMSwgMik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBFeHBvcnRcclxuXHJcblxyXG4gICAgQmlnID0gYmlnRmFjdG9yeSgpO1xyXG5cclxuICAgIC8vQU1ELlxyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBCaWc7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgLy8gTm9kZSBhbmQgb3RoZXIgQ29tbW9uSlMtbGlrZSBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLlxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gQmlnO1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzLkJpZyA9IEJpZztcclxuXHJcbiAgICAvL0Jyb3dzZXIuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdsb2JhbC5CaWcgPSBCaWc7XHJcbiAgICB9XHJcbn0pKHRoaXMpO1xyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/big.js/big.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/combiner/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/bip174/src/lib/combiner/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst parser_1 = __webpack_require__(/*! ../parser */ \"./node_modules/bip174/src/lib/parser/index.js\");\nfunction combine(psbts) {\n  const self = psbts[0];\n  const selfKeyVals = parser_1.psbtToKeyVals(self);\n  const others = psbts.slice(1);\n  if (others.length === 0) throw new Error('Combine: Nothing to combine');\n  const selfTx = getTx(self);\n  if (selfTx === undefined) {\n    throw new Error('Combine: Self missing transaction');\n  }\n  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);\n  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);\n  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);\n  for (const other of others) {\n    const otherTx = getTx(other);\n    if (\n      otherTx === undefined ||\n      !otherTx.toBuffer().equals(selfTx.toBuffer())\n    ) {\n      throw new Error(\n        'Combine: One of the Psbts does not have the same transaction.',\n      );\n    }\n    const otherKeyVals = parser_1.psbtToKeyVals(other);\n    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);\n    otherGlobalSet.forEach(\n      keyPusher(\n        selfGlobalSet,\n        selfKeyVals.globalKeyVals,\n        otherKeyVals.globalKeyVals,\n      ),\n    );\n    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);\n    otherInputSets.forEach((inputSet, idx) =>\n      inputSet.forEach(\n        keyPusher(\n          selfInputSets[idx],\n          selfKeyVals.inputKeyVals[idx],\n          otherKeyVals.inputKeyVals[idx],\n        ),\n      ),\n    );\n    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);\n    otherOutputSets.forEach((outputSet, idx) =>\n      outputSet.forEach(\n        keyPusher(\n          selfOutputSets[idx],\n          selfKeyVals.outputKeyVals[idx],\n          otherKeyVals.outputKeyVals[idx],\n        ),\n      ),\n    );\n  }\n  return parser_1.psbtFromKeyVals(selfTx, {\n    globalMapKeyVals: selfKeyVals.globalKeyVals,\n    inputKeyVals: selfKeyVals.inputKeyVals,\n    outputKeyVals: selfKeyVals.outputKeyVals,\n  });\n}\nexports.combine = combine;\nfunction keyPusher(selfSet, selfKeyVals, otherKeyVals) {\n  return key => {\n    if (selfSet.has(key)) return;\n    const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];\n    selfKeyVals.push(newKv);\n    selfSet.add(key);\n  };\n}\nfunction getTx(psbt) {\n  return psbt.globalMap.unsignedTx;\n}\nfunction getKeySet(keyVals) {\n  const set = new Set();\n  keyVals.forEach(keyVal => {\n    const hex = keyVal.key.toString('hex');\n    if (set.has(hex))\n      throw new Error('Combine: KeyValue Map keys should be unique');\n    set.add(hex);\n  });\n  return set;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29tYmluZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsZ0VBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb21iaW5lci9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcGFyc2VyXzEgPSByZXF1aXJlKCcuLi9wYXJzZXInKTtcbmZ1bmN0aW9uIGNvbWJpbmUocHNidHMpIHtcbiAgY29uc3Qgc2VsZiA9IHBzYnRzWzBdO1xuICBjb25zdCBzZWxmS2V5VmFscyA9IHBhcnNlcl8xLnBzYnRUb0tleVZhbHMoc2VsZik7XG4gIGNvbnN0IG90aGVycyA9IHBzYnRzLnNsaWNlKDEpO1xuICBpZiAob3RoZXJzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdDb21iaW5lOiBOb3RoaW5nIHRvIGNvbWJpbmUnKTtcbiAgY29uc3Qgc2VsZlR4ID0gZ2V0VHgoc2VsZik7XG4gIGlmIChzZWxmVHggPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29tYmluZTogU2VsZiBtaXNzaW5nIHRyYW5zYWN0aW9uJyk7XG4gIH1cbiAgY29uc3Qgc2VsZkdsb2JhbFNldCA9IGdldEtleVNldChzZWxmS2V5VmFscy5nbG9iYWxLZXlWYWxzKTtcbiAgY29uc3Qgc2VsZklucHV0U2V0cyA9IHNlbGZLZXlWYWxzLmlucHV0S2V5VmFscy5tYXAoZ2V0S2V5U2V0KTtcbiAgY29uc3Qgc2VsZk91dHB1dFNldHMgPSBzZWxmS2V5VmFscy5vdXRwdXRLZXlWYWxzLm1hcChnZXRLZXlTZXQpO1xuICBmb3IgKGNvbnN0IG90aGVyIG9mIG90aGVycykge1xuICAgIGNvbnN0IG90aGVyVHggPSBnZXRUeChvdGhlcik7XG4gICAgaWYgKFxuICAgICAgb3RoZXJUeCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAhb3RoZXJUeC50b0J1ZmZlcigpLmVxdWFscyhzZWxmVHgudG9CdWZmZXIoKSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0NvbWJpbmU6IE9uZSBvZiB0aGUgUHNidHMgZG9lcyBub3QgaGF2ZSB0aGUgc2FtZSB0cmFuc2FjdGlvbi4nLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb3RoZXJLZXlWYWxzID0gcGFyc2VyXzEucHNidFRvS2V5VmFscyhvdGhlcik7XG4gICAgY29uc3Qgb3RoZXJHbG9iYWxTZXQgPSBnZXRLZXlTZXQob3RoZXJLZXlWYWxzLmdsb2JhbEtleVZhbHMpO1xuICAgIG90aGVyR2xvYmFsU2V0LmZvckVhY2goXG4gICAgICBrZXlQdXNoZXIoXG4gICAgICAgIHNlbGZHbG9iYWxTZXQsXG4gICAgICAgIHNlbGZLZXlWYWxzLmdsb2JhbEtleVZhbHMsXG4gICAgICAgIG90aGVyS2V5VmFscy5nbG9iYWxLZXlWYWxzLFxuICAgICAgKSxcbiAgICApO1xuICAgIGNvbnN0IG90aGVySW5wdXRTZXRzID0gb3RoZXJLZXlWYWxzLmlucHV0S2V5VmFscy5tYXAoZ2V0S2V5U2V0KTtcbiAgICBvdGhlcklucHV0U2V0cy5mb3JFYWNoKChpbnB1dFNldCwgaWR4KSA9PlxuICAgICAgaW5wdXRTZXQuZm9yRWFjaChcbiAgICAgICAga2V5UHVzaGVyKFxuICAgICAgICAgIHNlbGZJbnB1dFNldHNbaWR4XSxcbiAgICAgICAgICBzZWxmS2V5VmFscy5pbnB1dEtleVZhbHNbaWR4XSxcbiAgICAgICAgICBvdGhlcktleVZhbHMuaW5wdXRLZXlWYWxzW2lkeF0sXG4gICAgICAgICksXG4gICAgICApLFxuICAgICk7XG4gICAgY29uc3Qgb3RoZXJPdXRwdXRTZXRzID0gb3RoZXJLZXlWYWxzLm91dHB1dEtleVZhbHMubWFwKGdldEtleVNldCk7XG4gICAgb3RoZXJPdXRwdXRTZXRzLmZvckVhY2goKG91dHB1dFNldCwgaWR4KSA9PlxuICAgICAgb3V0cHV0U2V0LmZvckVhY2goXG4gICAgICAgIGtleVB1c2hlcihcbiAgICAgICAgICBzZWxmT3V0cHV0U2V0c1tpZHhdLFxuICAgICAgICAgIHNlbGZLZXlWYWxzLm91dHB1dEtleVZhbHNbaWR4XSxcbiAgICAgICAgICBvdGhlcktleVZhbHMub3V0cHV0S2V5VmFsc1tpZHhdLFxuICAgICAgICApLFxuICAgICAgKSxcbiAgICApO1xuICB9XG4gIHJldHVybiBwYXJzZXJfMS5wc2J0RnJvbUtleVZhbHMoc2VsZlR4LCB7XG4gICAgZ2xvYmFsTWFwS2V5VmFsczogc2VsZktleVZhbHMuZ2xvYmFsS2V5VmFscyxcbiAgICBpbnB1dEtleVZhbHM6IHNlbGZLZXlWYWxzLmlucHV0S2V5VmFscyxcbiAgICBvdXRwdXRLZXlWYWxzOiBzZWxmS2V5VmFscy5vdXRwdXRLZXlWYWxzLFxuICB9KTtcbn1cbmV4cG9ydHMuY29tYmluZSA9IGNvbWJpbmU7XG5mdW5jdGlvbiBrZXlQdXNoZXIoc2VsZlNldCwgc2VsZktleVZhbHMsIG90aGVyS2V5VmFscykge1xuICByZXR1cm4ga2V5ID0+IHtcbiAgICBpZiAoc2VsZlNldC5oYXMoa2V5KSkgcmV0dXJuO1xuICAgIGNvbnN0IG5ld0t2ID0gb3RoZXJLZXlWYWxzLmZpbHRlcihrdiA9PiBrdi5rZXkudG9TdHJpbmcoJ2hleCcpID09PSBrZXkpWzBdO1xuICAgIHNlbGZLZXlWYWxzLnB1c2gobmV3S3YpO1xuICAgIHNlbGZTZXQuYWRkKGtleSk7XG4gIH07XG59XG5mdW5jdGlvbiBnZXRUeChwc2J0KSB7XG4gIHJldHVybiBwc2J0Lmdsb2JhbE1hcC51bnNpZ25lZFR4O1xufVxuZnVuY3Rpb24gZ2V0S2V5U2V0KGtleVZhbHMpIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICBrZXlWYWxzLmZvckVhY2goa2V5VmFsID0+IHtcbiAgICBjb25zdCBoZXggPSBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICBpZiAoc2V0LmhhcyhoZXgpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21iaW5lOiBLZXlWYWx1ZSBNYXAga2V5cyBzaG91bGQgYmUgdW5pcXVlJyk7XG4gICAgc2V0LmFkZChoZXgpO1xuICB9KTtcbiAgcmV0dXJuIHNldDtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/combiner/index.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/global/globalXpub.js":
/*!********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/global/globalXpub.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nconst range = n => [...Array(n).keys()];\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {\n    throw new Error(\n      'Decode Error: could not decode globalXpub with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {\n    throw new Error(\n      'Decode Error: globalXpub has invalid extended pubkey in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if ((keyVal.value.length / 4) % 1 !== 0) {\n    throw new Error(\n      'Decode Error: Global GLOBAL_XPUB value length should be multiple of 4',\n    );\n  }\n  const extendedPubkey = keyVal.key.slice(1);\n  const data = {\n    masterFingerprint: keyVal.value.slice(0, 4),\n    extendedPubkey,\n    path: 'm',\n  };\n  for (const i of range(keyVal.value.length / 4 - 1)) {\n    const val = keyVal.value.readUInt32LE(i * 4 + 4);\n    const isHard = !!(val & 0x80000000);\n    const idx = val & 0x7fffffff;\n    data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n  }\n  return data;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);\n  const key = Buffer.concat([head, data.extendedPubkey]);\n  const splitPath = data.path.split('/');\n  const value = Buffer.allocUnsafe(splitPath.length * 4);\n  data.masterFingerprint.copy(value, 0);\n  let offset = 4;\n  splitPath.slice(1).forEach(level => {\n    const isHard = level.slice(-1) === \"'\";\n    let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n    if (isHard) num += 0x80000000;\n    value.writeUInt32LE(num, offset);\n    offset += 4;\n  });\n  return {\n    key,\n    value,\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }';\nfunction check(data) {\n  const epk = data.extendedPubkey;\n  const mfp = data.masterFingerprint;\n  const p = data.path;\n  return (\n    Buffer.isBuffer(epk) &&\n    epk.length === 78 &&\n    [2, 3].indexOf(epk[45]) > -1 &&\n    Buffer.isBuffer(mfp) &&\n    mfp.length === 4 &&\n    typeof p === 'string' &&\n    !!p.match(/^m(\\/\\d+'?)*$/)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.extendedPubkey.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => v.extendedPubkey.equals(item.extendedPubkey)).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2dsb2JhbC9nbG9iYWxYcHViLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyxxRUFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGNBQWMsTUFBTTtBQUNwQjtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsS0FBSywyQkFBMkIsd0JBQXdCLGVBQWU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksTUFBTTtBQUNWO0FBQ0E7QUFDQSxJQUFJLE1BQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2dsb2JhbC9nbG9iYWxYcHViLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi8uLi90eXBlRmllbGRzJyk7XG5jb25zdCByYW5nZSA9IG4gPT4gWy4uLkFycmF5KG4pLmtleXMoKV07XG5mdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuR2xvYmFsVHlwZXMuR0xPQkFMX1hQVUIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIGdsb2JhbFhwdWIgd2l0aCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICBpZiAoa2V5VmFsLmtleS5sZW5ndGggIT09IDc5IHx8ICFbMiwgM10uaW5jbHVkZXMoa2V5VmFsLmtleVs0Nl0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogZ2xvYmFsWHB1YiBoYXMgaW52YWxpZCBleHRlbmRlZCBwdWJrZXkgaW4ga2V5IDB4JyArXG4gICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICk7XG4gIH1cbiAgaWYgKChrZXlWYWwudmFsdWUubGVuZ3RoIC8gNCkgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogR2xvYmFsIEdMT0JBTF9YUFVCIHZhbHVlIGxlbmd0aCBzaG91bGQgYmUgbXVsdGlwbGUgb2YgNCcsXG4gICAgKTtcbiAgfVxuICBjb25zdCBleHRlbmRlZFB1YmtleSA9IGtleVZhbC5rZXkuc2xpY2UoMSk7XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgbWFzdGVyRmluZ2VycHJpbnQ6IGtleVZhbC52YWx1ZS5zbGljZSgwLCA0KSxcbiAgICBleHRlbmRlZFB1YmtleSxcbiAgICBwYXRoOiAnbScsXG4gIH07XG4gIGZvciAoY29uc3QgaSBvZiByYW5nZShrZXlWYWwudmFsdWUubGVuZ3RoIC8gNCAtIDEpKSB7XG4gICAgY29uc3QgdmFsID0ga2V5VmFsLnZhbHVlLnJlYWRVSW50MzJMRShpICogNCArIDQpO1xuICAgIGNvbnN0IGlzSGFyZCA9ICEhKHZhbCAmIDB4ODAwMDAwMDApO1xuICAgIGNvbnN0IGlkeCA9IHZhbCAmIDB4N2ZmZmZmZmY7XG4gICAgZGF0YS5wYXRoICs9ICcvJyArIGlkeC50b1N0cmluZygxMCkgKyAoaXNIYXJkID8gXCInXCIgOiAnJyk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IGhlYWQgPSBCdWZmZXIuZnJvbShbdHlwZUZpZWxkc18xLkdsb2JhbFR5cGVzLkdMT0JBTF9YUFVCXSk7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5jb25jYXQoW2hlYWQsIGRhdGEuZXh0ZW5kZWRQdWJrZXldKTtcbiAgY29uc3Qgc3BsaXRQYXRoID0gZGF0YS5wYXRoLnNwbGl0KCcvJyk7XG4gIGNvbnN0IHZhbHVlID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNwbGl0UGF0aC5sZW5ndGggKiA0KTtcbiAgZGF0YS5tYXN0ZXJGaW5nZXJwcmludC5jb3B5KHZhbHVlLCAwKTtcbiAgbGV0IG9mZnNldCA9IDQ7XG4gIHNwbGl0UGF0aC5zbGljZSgxKS5mb3JFYWNoKGxldmVsID0+IHtcbiAgICBjb25zdCBpc0hhcmQgPSBsZXZlbC5zbGljZSgtMSkgPT09IFwiJ1wiO1xuICAgIGxldCBudW0gPSAweDdmZmZmZmZmICYgcGFyc2VJbnQoaXNIYXJkID8gbGV2ZWwuc2xpY2UoMCwgLTEpIDogbGV2ZWwsIDEwKTtcbiAgICBpZiAoaXNIYXJkKSBudW0gKz0gMHg4MDAwMDAwMDtcbiAgICB2YWx1ZS53cml0ZVVJbnQzMkxFKG51bSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIHZhbHVlLFxuICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID1cbiAgJ3sgbWFzdGVyRmluZ2VycHJpbnQ6IEJ1ZmZlcjsgZXh0ZW5kZWRQdWJrZXk6IEJ1ZmZlcjsgcGF0aDogc3RyaW5nOyB9JztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgY29uc3QgZXBrID0gZGF0YS5leHRlbmRlZFB1YmtleTtcbiAgY29uc3QgbWZwID0gZGF0YS5tYXN0ZXJGaW5nZXJwcmludDtcbiAgY29uc3QgcCA9IGRhdGEucGF0aDtcbiAgcmV0dXJuIChcbiAgICBCdWZmZXIuaXNCdWZmZXIoZXBrKSAmJlxuICAgIGVway5sZW5ndGggPT09IDc4ICYmXG4gICAgWzIsIDNdLmluZGV4T2YoZXBrWzQ1XSkgPiAtMSAmJlxuICAgIEJ1ZmZlci5pc0J1ZmZlcihtZnApICYmXG4gICAgbWZwLmxlbmd0aCA9PT0gNCAmJlxuICAgIHR5cGVvZiBwID09PSAnc3RyaW5nJyAmJlxuICAgICEhcC5tYXRjaCgvXm0oXFwvXFxkKyc/KSokLylcbiAgKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZFRvQXJyYXkoYXJyYXksIGl0ZW0sIGR1cGVTZXQpIHtcbiAgY29uc3QgZHVwZVN0cmluZyA9IGl0ZW0uZXh0ZW5kZWRQdWJrZXkudG9TdHJpbmcoJ2hleCcpO1xuICBpZiAoZHVwZVNldC5oYXMoZHVwZVN0cmluZykpIHJldHVybiBmYWxzZTtcbiAgZHVwZVNldC5hZGQoZHVwZVN0cmluZyk7XG4gIHJldHVybiAoXG4gICAgYXJyYXkuZmlsdGVyKHYgPT4gdi5leHRlbmRlZFB1YmtleS5lcXVhbHMoaXRlbS5leHRlbmRlZFB1YmtleSkpLmxlbmd0aCA9PT0gMFxuICApO1xufVxuZXhwb3J0cy5jYW5BZGRUb0FycmF5ID0gY2FuQWRkVG9BcnJheTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/global/globalXpub.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/global/unsignedTx.js":
/*!********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/global/unsignedTx.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nfunction encode(data) {\n  return {\n    key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),\n    value: data.toBuffer(),\n  };\n}\nexports.encode = encode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2dsb2JhbC91bnNpZ25lZFR4LmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyxxRUFBa0I7QUFDL0M7QUFDQTtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2dsb2JhbC91bnNpZ25lZFR4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi8uLi90eXBlRmllbGRzJyk7XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICByZXR1cm4ge1xuICAgIGtleTogQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5HbG9iYWxUeXBlcy5VTlNJR05FRF9UWF0pLFxuICAgIHZhbHVlOiBkYXRhLnRvQnVmZmVyKCksXG4gIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/global/unsignedTx.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nconst globalXpub = __webpack_require__(/*! ./global/globalXpub */ \"./node_modules/bip174/src/lib/converter/global/globalXpub.js\");\nconst unsignedTx = __webpack_require__(/*! ./global/unsignedTx */ \"./node_modules/bip174/src/lib/converter/global/unsignedTx.js\");\nconst finalScriptSig = __webpack_require__(/*! ./input/finalScriptSig */ \"./node_modules/bip174/src/lib/converter/input/finalScriptSig.js\");\nconst finalScriptWitness = __webpack_require__(/*! ./input/finalScriptWitness */ \"./node_modules/bip174/src/lib/converter/input/finalScriptWitness.js\");\nconst nonWitnessUtxo = __webpack_require__(/*! ./input/nonWitnessUtxo */ \"./node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js\");\nconst partialSig = __webpack_require__(/*! ./input/partialSig */ \"./node_modules/bip174/src/lib/converter/input/partialSig.js\");\nconst porCommitment = __webpack_require__(/*! ./input/porCommitment */ \"./node_modules/bip174/src/lib/converter/input/porCommitment.js\");\nconst sighashType = __webpack_require__(/*! ./input/sighashType */ \"./node_modules/bip174/src/lib/converter/input/sighashType.js\");\nconst tapKeySig = __webpack_require__(/*! ./input/tapKeySig */ \"./node_modules/bip174/src/lib/converter/input/tapKeySig.js\");\nconst tapLeafScript = __webpack_require__(/*! ./input/tapLeafScript */ \"./node_modules/bip174/src/lib/converter/input/tapLeafScript.js\");\nconst tapMerkleRoot = __webpack_require__(/*! ./input/tapMerkleRoot */ \"./node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js\");\nconst tapScriptSig = __webpack_require__(/*! ./input/tapScriptSig */ \"./node_modules/bip174/src/lib/converter/input/tapScriptSig.js\");\nconst witnessUtxo = __webpack_require__(/*! ./input/witnessUtxo */ \"./node_modules/bip174/src/lib/converter/input/witnessUtxo.js\");\nconst tapTree = __webpack_require__(/*! ./output/tapTree */ \"./node_modules/bip174/src/lib/converter/output/tapTree.js\");\nconst bip32Derivation = __webpack_require__(/*! ./shared/bip32Derivation */ \"./node_modules/bip174/src/lib/converter/shared/bip32Derivation.js\");\nconst checkPubkey = __webpack_require__(/*! ./shared/checkPubkey */ \"./node_modules/bip174/src/lib/converter/shared/checkPubkey.js\");\nconst redeemScript = __webpack_require__(/*! ./shared/redeemScript */ \"./node_modules/bip174/src/lib/converter/shared/redeemScript.js\");\nconst tapBip32Derivation = __webpack_require__(/*! ./shared/tapBip32Derivation */ \"./node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js\");\nconst tapInternalKey = __webpack_require__(/*! ./shared/tapInternalKey */ \"./node_modules/bip174/src/lib/converter/shared/tapInternalKey.js\");\nconst witnessScript = __webpack_require__(/*! ./shared/witnessScript */ \"./node_modules/bip174/src/lib/converter/shared/witnessScript.js\");\nconst globals = {\n  unsignedTx,\n  globalXpub,\n  // pass an Array of key bytes that require pubkey beside the key\n  checkPubkey: checkPubkey.makeChecker([]),\n};\nexports.globals = globals;\nconst inputs = {\n  nonWitnessUtxo,\n  partialSig,\n  sighashType,\n  finalScriptSig,\n  finalScriptWitness,\n  porCommitment,\n  witnessUtxo,\n  bip32Derivation: bip32Derivation.makeConverter(\n    typeFields_1.InputTypes.BIP32_DERIVATION,\n  ),\n  redeemScript: redeemScript.makeConverter(\n    typeFields_1.InputTypes.REDEEM_SCRIPT,\n  ),\n  witnessScript: witnessScript.makeConverter(\n    typeFields_1.InputTypes.WITNESS_SCRIPT,\n  ),\n  checkPubkey: checkPubkey.makeChecker([\n    typeFields_1.InputTypes.PARTIAL_SIG,\n    typeFields_1.InputTypes.BIP32_DERIVATION,\n  ]),\n  tapKeySig,\n  tapScriptSig,\n  tapLeafScript,\n  tapBip32Derivation: tapBip32Derivation.makeConverter(\n    typeFields_1.InputTypes.TAP_BIP32_DERIVATION,\n  ),\n  tapInternalKey: tapInternalKey.makeConverter(\n    typeFields_1.InputTypes.TAP_INTERNAL_KEY,\n  ),\n  tapMerkleRoot,\n};\nexports.inputs = inputs;\nconst outputs = {\n  bip32Derivation: bip32Derivation.makeConverter(\n    typeFields_1.OutputTypes.BIP32_DERIVATION,\n  ),\n  redeemScript: redeemScript.makeConverter(\n    typeFields_1.OutputTypes.REDEEM_SCRIPT,\n  ),\n  witnessScript: witnessScript.makeConverter(\n    typeFields_1.OutputTypes.WITNESS_SCRIPT,\n  ),\n  checkPubkey: checkPubkey.makeChecker([\n    typeFields_1.OutputTypes.BIP32_DERIVATION,\n  ]),\n  tapBip32Derivation: tapBip32Derivation.makeConverter(\n    typeFields_1.OutputTypes.TAP_BIP32_DERIVATION,\n  ),\n  tapTree,\n  tapInternalKey: tapInternalKey.makeConverter(\n    typeFields_1.OutputTypes.TAP_INTERNAL_KEY,\n  ),\n};\nexports.outputs = outputs;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLGtFQUFlO0FBQzVDLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFxQjtBQUNoRCxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBcUI7QUFDaEQsdUJBQXVCLG1CQUFPLENBQUMsK0ZBQXdCO0FBQ3ZELDJCQUEyQixtQkFBTyxDQUFDLHVHQUE0QjtBQUMvRCx1QkFBdUIsbUJBQU8sQ0FBQywrRkFBd0I7QUFDdkQsbUJBQW1CLG1CQUFPLENBQUMsdUZBQW9CO0FBQy9DLHNCQUFzQixtQkFBTyxDQUFDLDZGQUF1QjtBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBcUI7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMscUZBQW1CO0FBQzdDLHNCQUFzQixtQkFBTyxDQUFDLDZGQUF1QjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBdUI7QUFDckQscUJBQXFCLG1CQUFPLENBQUMsMkZBQXNCO0FBQ25ELG9CQUFvQixtQkFBTyxDQUFDLHlGQUFxQjtBQUNqRCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBa0I7QUFDMUMsd0JBQXdCLG1CQUFPLENBQUMsbUdBQTBCO0FBQzFELG9CQUFvQixtQkFBTyxDQUFDLDJGQUFzQjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQyw2RkFBdUI7QUFDcEQsMkJBQTJCLG1CQUFPLENBQUMseUdBQTZCO0FBQ2hFLHVCQUF1QixtQkFBTyxDQUFDLGlHQUF5QjtBQUN4RCxzQkFBc0IsbUJBQU8sQ0FBQywrRkFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uL3R5cGVGaWVsZHMnKTtcbmNvbnN0IGdsb2JhbFhwdWIgPSByZXF1aXJlKCcuL2dsb2JhbC9nbG9iYWxYcHViJyk7XG5jb25zdCB1bnNpZ25lZFR4ID0gcmVxdWlyZSgnLi9nbG9iYWwvdW5zaWduZWRUeCcpO1xuY29uc3QgZmluYWxTY3JpcHRTaWcgPSByZXF1aXJlKCcuL2lucHV0L2ZpbmFsU2NyaXB0U2lnJyk7XG5jb25zdCBmaW5hbFNjcmlwdFdpdG5lc3MgPSByZXF1aXJlKCcuL2lucHV0L2ZpbmFsU2NyaXB0V2l0bmVzcycpO1xuY29uc3Qgbm9uV2l0bmVzc1V0eG8gPSByZXF1aXJlKCcuL2lucHV0L25vbldpdG5lc3NVdHhvJyk7XG5jb25zdCBwYXJ0aWFsU2lnID0gcmVxdWlyZSgnLi9pbnB1dC9wYXJ0aWFsU2lnJyk7XG5jb25zdCBwb3JDb21taXRtZW50ID0gcmVxdWlyZSgnLi9pbnB1dC9wb3JDb21taXRtZW50Jyk7XG5jb25zdCBzaWdoYXNoVHlwZSA9IHJlcXVpcmUoJy4vaW5wdXQvc2lnaGFzaFR5cGUnKTtcbmNvbnN0IHRhcEtleVNpZyA9IHJlcXVpcmUoJy4vaW5wdXQvdGFwS2V5U2lnJyk7XG5jb25zdCB0YXBMZWFmU2NyaXB0ID0gcmVxdWlyZSgnLi9pbnB1dC90YXBMZWFmU2NyaXB0Jyk7XG5jb25zdCB0YXBNZXJrbGVSb290ID0gcmVxdWlyZSgnLi9pbnB1dC90YXBNZXJrbGVSb290Jyk7XG5jb25zdCB0YXBTY3JpcHRTaWcgPSByZXF1aXJlKCcuL2lucHV0L3RhcFNjcmlwdFNpZycpO1xuY29uc3Qgd2l0bmVzc1V0eG8gPSByZXF1aXJlKCcuL2lucHV0L3dpdG5lc3NVdHhvJyk7XG5jb25zdCB0YXBUcmVlID0gcmVxdWlyZSgnLi9vdXRwdXQvdGFwVHJlZScpO1xuY29uc3QgYmlwMzJEZXJpdmF0aW9uID0gcmVxdWlyZSgnLi9zaGFyZWQvYmlwMzJEZXJpdmF0aW9uJyk7XG5jb25zdCBjaGVja1B1YmtleSA9IHJlcXVpcmUoJy4vc2hhcmVkL2NoZWNrUHVia2V5Jyk7XG5jb25zdCByZWRlZW1TY3JpcHQgPSByZXF1aXJlKCcuL3NoYXJlZC9yZWRlZW1TY3JpcHQnKTtcbmNvbnN0IHRhcEJpcDMyRGVyaXZhdGlvbiA9IHJlcXVpcmUoJy4vc2hhcmVkL3RhcEJpcDMyRGVyaXZhdGlvbicpO1xuY29uc3QgdGFwSW50ZXJuYWxLZXkgPSByZXF1aXJlKCcuL3NoYXJlZC90YXBJbnRlcm5hbEtleScpO1xuY29uc3Qgd2l0bmVzc1NjcmlwdCA9IHJlcXVpcmUoJy4vc2hhcmVkL3dpdG5lc3NTY3JpcHQnKTtcbmNvbnN0IGdsb2JhbHMgPSB7XG4gIHVuc2lnbmVkVHgsXG4gIGdsb2JhbFhwdWIsXG4gIC8vIHBhc3MgYW4gQXJyYXkgb2Yga2V5IGJ5dGVzIHRoYXQgcmVxdWlyZSBwdWJrZXkgYmVzaWRlIHRoZSBrZXlcbiAgY2hlY2tQdWJrZXk6IGNoZWNrUHVia2V5Lm1ha2VDaGVja2VyKFtdKSxcbn07XG5leHBvcnRzLmdsb2JhbHMgPSBnbG9iYWxzO1xuY29uc3QgaW5wdXRzID0ge1xuICBub25XaXRuZXNzVXR4byxcbiAgcGFydGlhbFNpZyxcbiAgc2lnaGFzaFR5cGUsXG4gIGZpbmFsU2NyaXB0U2lnLFxuICBmaW5hbFNjcmlwdFdpdG5lc3MsXG4gIHBvckNvbW1pdG1lbnQsXG4gIHdpdG5lc3NVdHhvLFxuICBiaXAzMkRlcml2YXRpb246IGJpcDMyRGVyaXZhdGlvbi5tYWtlQ29udmVydGVyKFxuICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkJJUDMyX0RFUklWQVRJT04sXG4gICksXG4gIHJlZGVlbVNjcmlwdDogcmVkZWVtU2NyaXB0Lm1ha2VDb252ZXJ0ZXIoXG4gICAgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuUkVERUVNX1NDUklQVCxcbiAgKSxcbiAgd2l0bmVzc1NjcmlwdDogd2l0bmVzc1NjcmlwdC5tYWtlQ29udmVydGVyKFxuICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLldJVE5FU1NfU0NSSVBULFxuICApLFxuICBjaGVja1B1YmtleTogY2hlY2tQdWJrZXkubWFrZUNoZWNrZXIoW1xuICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlBBUlRJQUxfU0lHLFxuICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkJJUDMyX0RFUklWQVRJT04sXG4gIF0pLFxuICB0YXBLZXlTaWcsXG4gIHRhcFNjcmlwdFNpZyxcbiAgdGFwTGVhZlNjcmlwdCxcbiAgdGFwQmlwMzJEZXJpdmF0aW9uOiB0YXBCaXAzMkRlcml2YXRpb24ubWFrZUNvbnZlcnRlcihcbiAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfQklQMzJfREVSSVZBVElPTixcbiAgKSxcbiAgdGFwSW50ZXJuYWxLZXk6IHRhcEludGVybmFsS2V5Lm1ha2VDb252ZXJ0ZXIoXG4gICAgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0lOVEVSTkFMX0tFWSxcbiAgKSxcbiAgdGFwTWVya2xlUm9vdCxcbn07XG5leHBvcnRzLmlucHV0cyA9IGlucHV0cztcbmNvbnN0IG91dHB1dHMgPSB7XG4gIGJpcDMyRGVyaXZhdGlvbjogYmlwMzJEZXJpdmF0aW9uLm1ha2VDb252ZXJ0ZXIoXG4gICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLkJJUDMyX0RFUklWQVRJT04sXG4gICksXG4gIHJlZGVlbVNjcmlwdDogcmVkZWVtU2NyaXB0Lm1ha2VDb252ZXJ0ZXIoXG4gICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlJFREVFTV9TQ1JJUFQsXG4gICksXG4gIHdpdG5lc3NTY3JpcHQ6IHdpdG5lc3NTY3JpcHQubWFrZUNvbnZlcnRlcihcbiAgICB0eXBlRmllbGRzXzEuT3V0cHV0VHlwZXMuV0lUTkVTU19TQ1JJUFQsXG4gICksXG4gIGNoZWNrUHVia2V5OiBjaGVja1B1YmtleS5tYWtlQ2hlY2tlcihbXG4gICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLkJJUDMyX0RFUklWQVRJT04sXG4gIF0pLFxuICB0YXBCaXAzMkRlcml2YXRpb246IHRhcEJpcDMyRGVyaXZhdGlvbi5tYWtlQ29udmVydGVyKFxuICAgIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5UQVBfQklQMzJfREVSSVZBVElPTixcbiAgKSxcbiAgdGFwVHJlZSxcbiAgdGFwSW50ZXJuYWxLZXk6IHRhcEludGVybmFsS2V5Lm1ha2VDb252ZXJ0ZXIoXG4gICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlRBUF9JTlRFUk5BTF9LRVksXG4gICksXG59O1xuZXhwb3J0cy5vdXRwdXRzID0gb3V0cHV0cztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/index.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/finalScriptSig.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/finalScriptSig.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {\n    throw new Error(\n      'Decode Error: could not decode finalScriptSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);\n  return {\n    key,\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.finalScriptSig === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L2ZpbmFsU2NyaXB0U2lnLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyxxRUFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCO0FBQ0EsU0FBUyxNQUFNO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvaW5wdXQvZmluYWxTY3JpcHRTaWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uLy4uL3R5cGVGaWVsZHMnKTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgaWYgKGtleVZhbC5rZXlbMF0gIT09IHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkZJTkFMX1NDUklQVFNJRykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgZmluYWxTY3JpcHRTaWcgd2l0aCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICByZXR1cm4ga2V5VmFsLnZhbHVlO1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICBjb25zdCBrZXkgPSBCdWZmZXIuZnJvbShbdHlwZUZpZWxkc18xLklucHV0VHlwZXMuRklOQUxfU0NSSVBUU0lHXSk7XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIHZhbHVlOiBkYXRhLFxuICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID0gJ0J1ZmZlcic7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoZGF0YSk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgcmV0dXJuICEhY3VycmVudERhdGEgJiYgISFuZXdEYXRhICYmIGN1cnJlbnREYXRhLmZpbmFsU2NyaXB0U2lnID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmNhbkFkZCA9IGNhbkFkZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/input/finalScriptSig.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/finalScriptWitness.js":
/*!***************************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/finalScriptWitness.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {\n    throw new Error(\n      'Decode Error: could not decode finalScriptWitness with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);\n  return {\n    key,\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return (\n    !!currentData && !!newData && currentData.finalScriptWitness === undefined\n  );\n}\nexports.canAdd = canAdd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L2ZpbmFsU2NyaXB0V2l0bmVzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLG1CQUFPLENBQUMscUVBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGdCQUFnQjtBQUNoQjtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci9pbnB1dC9maW5hbFNjcmlwdFdpdG5lc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uLy4uL3R5cGVGaWVsZHMnKTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgaWYgKGtleVZhbC5rZXlbMF0gIT09IHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkZJTkFMX1NDUklQVFdJVE5FU1MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIGZpbmFsU2NyaXB0V2l0bmVzcyB3aXRoIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIHJldHVybiBrZXlWYWwudmFsdWU7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5GSU5BTF9TQ1JJUFRXSVRORVNTXSk7XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIHZhbHVlOiBkYXRhLFxuICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID0gJ0J1ZmZlcic7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoZGF0YSk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgcmV0dXJuIChcbiAgICAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS5maW5hbFNjcmlwdFdpdG5lc3MgPT09IHVuZGVmaW5lZFxuICApO1xufVxuZXhwb3J0cy5jYW5BZGQgPSBjYW5BZGQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/input/finalScriptWitness.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode nonWitnessUtxo with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  return {\n    key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L25vbldpdG5lc3NVdHhvLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyxxRUFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCO0FBQ0EsU0FBUyxNQUFNO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvaW5wdXQvbm9uV2l0bmVzc1V0eG8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uLy4uL3R5cGVGaWVsZHMnKTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgaWYgKGtleVZhbC5rZXlbMF0gIT09IHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLk5PTl9XSVRORVNTX1VUWE8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIG5vbldpdG5lc3NVdHhvIHdpdGgga2V5IDB4JyArXG4gICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGtleVZhbC52YWx1ZTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5OT05fV0lUTkVTU19VVFhPXSksXG4gICAgdmFsdWU6IGRhdGEsXG4gIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPSAnQnVmZmVyJztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICByZXR1cm4gISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEubm9uV2l0bmVzc1V0eG8gPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuY2FuQWRkID0gY2FuQWRkO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/partialSig.js":
/*!*******************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/partialSig.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {\n    throw new Error(\n      'Decode Error: could not decode partialSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (\n    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||\n    ![2, 3, 4].includes(keyVal.key[1])\n  ) {\n    throw new Error(\n      'Decode Error: partialSig has invalid pubkey in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const pubkey = keyVal.key.slice(1);\n  return {\n    pubkey,\n    signature: keyVal.value,\n  };\n}\nexports.decode = decode;\nfunction encode(pSig) {\n  const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);\n  return {\n    key: Buffer.concat([head, pSig.pubkey]),\n    value: pSig.signature,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ pubkey: Buffer; signature: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.pubkey) &&\n    Buffer.isBuffer(data.signature) &&\n    [33, 65].includes(data.pubkey.length) &&\n    [2, 3, 4].includes(data.pubkey[0]) &&\n    isDerSigWithSighash(data.signature)\n  );\n}\nexports.check = check;\nfunction isDerSigWithSighash(buf) {\n  if (!Buffer.isBuffer(buf) || buf.length < 9) return false;\n  if (buf[0] !== 0x30) return false;\n  if (buf.length !== buf[1] + 3) return false;\n  if (buf[2] !== 0x02) return false;\n  const rLen = buf[3];\n  if (rLen > 33 || rLen < 1) return false;\n  if (buf[3 + rLen + 1] !== 0x02) return false;\n  const sLen = buf[3 + rLen + 2];\n  if (sLen > 33 || sLen < 1) return false;\n  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;\n  return true;\n}\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.pubkey.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n}\nexports.canAddToArray = canAddToArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3BhcnRpYWxTaWcuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLHFFQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0IsTUFBTSxnQkFBZ0Isb0JBQW9CO0FBQzFEO0FBQ0E7QUFDQSxJQUFJLE1BQU07QUFDVixJQUFJLE1BQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsT0FBTyxNQUFNO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvaW5wdXQvcGFydGlhbFNpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZSgnLi4vLi4vdHlwZUZpZWxkcycpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICBpZiAoa2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuUEFSVElBTF9TSUcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIHBhcnRpYWxTaWcgd2l0aCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICBpZiAoXG4gICAgIShrZXlWYWwua2V5Lmxlbmd0aCA9PT0gMzQgfHwga2V5VmFsLmtleS5sZW5ndGggPT09IDY2KSB8fFxuICAgICFbMiwgMywgNF0uaW5jbHVkZXMoa2V5VmFsLmtleVsxXSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogcGFydGlhbFNpZyBoYXMgaW52YWxpZCBwdWJrZXkgaW4ga2V5IDB4JyArXG4gICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICk7XG4gIH1cbiAgY29uc3QgcHVia2V5ID0ga2V5VmFsLmtleS5zbGljZSgxKTtcbiAgcmV0dXJuIHtcbiAgICBwdWJrZXksXG4gICAgc2lnbmF0dXJlOiBrZXlWYWwudmFsdWUsXG4gIH07XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShwU2lnKSB7XG4gIGNvbnN0IGhlYWQgPSBCdWZmZXIuZnJvbShbdHlwZUZpZWxkc18xLklucHV0VHlwZXMuUEFSVElBTF9TSUddKTtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IEJ1ZmZlci5jb25jYXQoW2hlYWQsIHBTaWcucHVia2V5XSksXG4gICAgdmFsdWU6IHBTaWcuc2lnbmF0dXJlLFxuICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID0gJ3sgcHVia2V5OiBCdWZmZXI7IHNpZ25hdHVyZTogQnVmZmVyOyB9JztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgcmV0dXJuIChcbiAgICBCdWZmZXIuaXNCdWZmZXIoZGF0YS5wdWJrZXkpICYmXG4gICAgQnVmZmVyLmlzQnVmZmVyKGRhdGEuc2lnbmF0dXJlKSAmJlxuICAgIFszMywgNjVdLmluY2x1ZGVzKGRhdGEucHVia2V5Lmxlbmd0aCkgJiZcbiAgICBbMiwgMywgNF0uaW5jbHVkZXMoZGF0YS5wdWJrZXlbMF0pICYmXG4gICAgaXNEZXJTaWdXaXRoU2lnaGFzaChkYXRhLnNpZ25hdHVyZSlcbiAgKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGlzRGVyU2lnV2l0aFNpZ2hhc2goYnVmKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikgfHwgYnVmLmxlbmd0aCA8IDkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGJ1ZlswXSAhPT0gMHgzMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoYnVmLmxlbmd0aCAhPT0gYnVmWzFdICsgMykgcmV0dXJuIGZhbHNlO1xuICBpZiAoYnVmWzJdICE9PSAweDAyKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHJMZW4gPSBidWZbM107XG4gIGlmIChyTGVuID4gMzMgfHwgckxlbiA8IDEpIHJldHVybiBmYWxzZTtcbiAgaWYgKGJ1ZlszICsgckxlbiArIDFdICE9PSAweDAyKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHNMZW4gPSBidWZbMyArIHJMZW4gKyAyXTtcbiAgaWYgKHNMZW4gPiAzMyB8fCBzTGVuIDwgMSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoYnVmLmxlbmd0aCAhPT0gMyArIHJMZW4gKyAyICsgc0xlbiArIDIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjYW5BZGRUb0FycmF5KGFycmF5LCBpdGVtLCBkdXBlU2V0KSB7XG4gIGNvbnN0IGR1cGVTdHJpbmcgPSBpdGVtLnB1YmtleS50b1N0cmluZygnaGV4Jyk7XG4gIGlmIChkdXBlU2V0LmhhcyhkdXBlU3RyaW5nKSkgcmV0dXJuIGZhbHNlO1xuICBkdXBlU2V0LmFkZChkdXBlU3RyaW5nKTtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucHVia2V5LmVxdWFscyhpdGVtLnB1YmtleSkpLmxlbmd0aCA9PT0gMDtcbn1cbmV4cG9ydHMuY2FuQWRkVG9BcnJheSA9IGNhbkFkZFRvQXJyYXk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/input/partialSig.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/porCommitment.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/porCommitment.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {\n    throw new Error(\n      'Decode Error: could not decode porCommitment with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value.toString('utf8');\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);\n  return {\n    key,\n    value: Buffer.from(data, 'utf8'),\n  };\n}\nexports.encode = encode;\nexports.expected = 'string';\nfunction check(data) {\n  return typeof data === 'string';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.porCommitment === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3BvckNvbW1pdG1lbnQuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLHFFQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0EsY0FBYztBQUNkLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvaW5wdXQvcG9yQ29tbWl0bWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZSgnLi4vLi4vdHlwZUZpZWxkcycpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICBpZiAoa2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuUE9SX0NPTU1JVE1FTlQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIHBvckNvbW1pdG1lbnQgd2l0aCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICByZXR1cm4ga2V5VmFsLnZhbHVlLnRvU3RyaW5nKCd1dGY4Jyk7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5QT1JfQ09NTUlUTUVOVF0pO1xuICByZXR1cm4ge1xuICAgIGtleSxcbiAgICB2YWx1ZTogQnVmZmVyLmZyb20oZGF0YSwgJ3V0ZjgnKSxcbiAgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5leHBlY3RlZCA9ICdzdHJpbmcnO1xuZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICByZXR1cm4gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gY2FuQWRkKGN1cnJlbnREYXRhLCBuZXdEYXRhKSB7XG4gIHJldHVybiAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS5wb3JDb21taXRtZW50ID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmNhbkFkZCA9IGNhbkFkZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/input/porCommitment.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/sighashType.js":
/*!********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/sighashType.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {\n    throw new Error(\n      'Decode Error: could not decode sighashType with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value.readUInt32LE(0);\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);\n  const value = Buffer.allocUnsafe(4);\n  value.writeUInt32LE(data, 0);\n  return {\n    key,\n    value,\n  };\n}\nexports.encode = encode;\nexports.expected = 'number';\nfunction check(data) {\n  return typeof data === 'number';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.sighashType === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3NpZ2hhc2hUeXBlLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyxxRUFBa0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3NpZ2hhc2hUeXBlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi8uLi90eXBlRmllbGRzJyk7XG5mdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gIGlmIChrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5TSUdIQVNIX1RZUEUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIHNpZ2hhc2hUeXBlIHdpdGgga2V5IDB4JyArXG4gICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGtleVZhbC52YWx1ZS5yZWFkVUludDMyTEUoMCk7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5TSUdIQVNIX1RZUEVdKTtcbiAgY29uc3QgdmFsdWUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNCk7XG4gIHZhbHVlLndyaXRlVUludDMyTEUoZGF0YSwgMCk7XG4gIHJldHVybiB7XG4gICAga2V5LFxuICAgIHZhbHVlLFxuICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID0gJ251bWJlcic7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgcmV0dXJuICEhY3VycmVudERhdGEgJiYgISFuZXdEYXRhICYmIGN1cnJlbnREYXRhLnNpZ2hhc2hUeXBlID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmNhbkFkZCA9IGNhbkFkZDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/input/sighashType.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/tapKeySig.js":
/*!******************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/tapKeySig.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapKeySig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (!check(keyVal.value)) {\n    throw new Error(\n      'Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature',\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(value) {\n  const key = Buffer.from([typeFields_1.InputTypes.TAP_KEY_SIG]);\n  return { key, value };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapKeySig === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3RhcEtleVNpZy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLG1CQUFPLENBQUMscUVBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjLE1BQU07QUFDcEIsV0FBVztBQUNYO0FBQ0EsY0FBYztBQUNkLGdCQUFnQjtBQUNoQjtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3RhcEtleVNpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZSgnLi4vLi4vdHlwZUZpZWxkcycpO1xuZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICBpZiAoXG4gICAga2V5VmFsLmtleVswXSAhPT0gdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0tFWV9TSUcgfHxcbiAgICBrZXlWYWwua2V5Lmxlbmd0aCAhPT0gMVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIHRhcEtleVNpZyB3aXRoIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIGlmICghY2hlY2soa2V5VmFsLnZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IHRhcEtleVNpZyBub3QgYSB2YWxpZCA2NC02NS1ieXRlIEJJUDM0MCBzaWduYXR1cmUnLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGtleVZhbC52YWx1ZTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKHZhbHVlKSB7XG4gIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFt0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfS0VZX1NJR10pO1xuICByZXR1cm4geyBrZXksIHZhbHVlIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPSAnQnVmZmVyJztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSAmJiAoZGF0YS5sZW5ndGggPT09IDY0IHx8IGRhdGEubGVuZ3RoID09PSA2NSk7XG59XG5leHBvcnRzLmNoZWNrID0gY2hlY2s7XG5mdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgcmV0dXJuICEhY3VycmVudERhdGEgJiYgISFuZXdEYXRhICYmIGN1cnJlbnREYXRhLnRhcEtleVNpZyA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5jYW5BZGQgPSBjYW5BZGQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/input/tapKeySig.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/tapLeafScript.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/tapLeafScript.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {\n    throw new Error(\n      'Decode Error: could not decode tapLeafScript with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if ((keyVal.key.length - 2) % 32 !== 0) {\n    throw new Error(\n      'Decode Error: tapLeafScript has invalid control block in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const leafVersion = keyVal.value[keyVal.value.length - 1];\n  if ((keyVal.key[1] & 0xfe) !== leafVersion) {\n    throw new Error(\n      'Decode Error: tapLeafScript bad leaf version in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const script = keyVal.value.slice(0, -1);\n  const controlBlock = keyVal.key.slice(1);\n  return { controlBlock, script, leafVersion };\n}\nexports.decode = decode;\nfunction encode(tScript) {\n  const head = Buffer.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);\n  const verBuf = Buffer.from([tScript.leafVersion]);\n  return {\n    key: Buffer.concat([head, tScript.controlBlock]),\n    value: Buffer.concat([tScript.script, verBuf]),\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ controlBlock: Buffer; leafVersion: number, script: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.controlBlock) &&\n    (data.controlBlock.length - 1) % 32 === 0 &&\n    (data.controlBlock[0] & 0xfe) === data.leafVersion &&\n    Buffer.isBuffer(data.script)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.controlBlock.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => v.controlBlock.equals(item.controlBlock)).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3RhcExlYWZTY3JpcHQuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLHFFQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBLFNBQVMsTUFBTTtBQUNmLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0EsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixLQUFLLHNCQUFzQixzQ0FBc0M7QUFDakU7QUFDQTtBQUNBLElBQUksTUFBTTtBQUNWO0FBQ0E7QUFDQSxJQUFJLE1BQU07QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3RhcExlYWZTY3JpcHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uLy4uL3R5cGVGaWVsZHMnKTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgaWYgKGtleVZhbC5rZXlbMF0gIT09IHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9MRUFGX1NDUklQVCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgdGFwTGVhZlNjcmlwdCB3aXRoIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIGlmICgoa2V5VmFsLmtleS5sZW5ndGggLSAyKSAlIDMyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogdGFwTGVhZlNjcmlwdCBoYXMgaW52YWxpZCBjb250cm9sIGJsb2NrIGluIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIGNvbnN0IGxlYWZWZXJzaW9uID0ga2V5VmFsLnZhbHVlW2tleVZhbC52YWx1ZS5sZW5ndGggLSAxXTtcbiAgaWYgKChrZXlWYWwua2V5WzFdICYgMHhmZSkgIT09IGxlYWZWZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogdGFwTGVhZlNjcmlwdCBiYWQgbGVhZiB2ZXJzaW9uIGluIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIGNvbnN0IHNjcmlwdCA9IGtleVZhbC52YWx1ZS5zbGljZSgwLCAtMSk7XG4gIGNvbnN0IGNvbnRyb2xCbG9jayA9IGtleVZhbC5rZXkuc2xpY2UoMSk7XG4gIHJldHVybiB7IGNvbnRyb2xCbG9jaywgc2NyaXB0LCBsZWFmVmVyc2lvbiB9O1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBlbmNvZGUodFNjcmlwdCkge1xuICBjb25zdCBoZWFkID0gQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9MRUFGX1NDUklQVF0pO1xuICBjb25zdCB2ZXJCdWYgPSBCdWZmZXIuZnJvbShbdFNjcmlwdC5sZWFmVmVyc2lvbl0pO1xuICByZXR1cm4ge1xuICAgIGtleTogQnVmZmVyLmNvbmNhdChbaGVhZCwgdFNjcmlwdC5jb250cm9sQmxvY2tdKSxcbiAgICB2YWx1ZTogQnVmZmVyLmNvbmNhdChbdFNjcmlwdC5zY3JpcHQsIHZlckJ1Zl0pLFxuICB9O1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5leHBvcnRzLmV4cGVjdGVkID1cbiAgJ3sgY29udHJvbEJsb2NrOiBCdWZmZXI7IGxlYWZWZXJzaW9uOiBudW1iZXIsIHNjcmlwdDogQnVmZmVyOyB9JztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgcmV0dXJuIChcbiAgICBCdWZmZXIuaXNCdWZmZXIoZGF0YS5jb250cm9sQmxvY2spICYmXG4gICAgKGRhdGEuY29udHJvbEJsb2NrLmxlbmd0aCAtIDEpICUgMzIgPT09IDAgJiZcbiAgICAoZGF0YS5jb250cm9sQmxvY2tbMF0gJiAweGZlKSA9PT0gZGF0YS5sZWFmVmVyc2lvbiAmJlxuICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLnNjcmlwdClcbiAgKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZFRvQXJyYXkoYXJyYXksIGl0ZW0sIGR1cGVTZXQpIHtcbiAgY29uc3QgZHVwZVN0cmluZyA9IGl0ZW0uY29udHJvbEJsb2NrLnRvU3RyaW5nKCdoZXgnKTtcbiAgaWYgKGR1cGVTZXQuaGFzKGR1cGVTdHJpbmcpKSByZXR1cm4gZmFsc2U7XG4gIGR1cGVTZXQuYWRkKGR1cGVTdHJpbmcpO1xuICByZXR1cm4gKFxuICAgIGFycmF5LmZpbHRlcih2ID0+IHYuY29udHJvbEJsb2NrLmVxdWFscyhpdGVtLmNvbnRyb2xCbG9jaykpLmxlbmd0aCA9PT0gMFxuICApO1xufVxuZXhwb3J0cy5jYW5BZGRUb0FycmF5ID0gY2FuQWRkVG9BcnJheTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/input/tapLeafScript.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapMerkleRoot with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (!check(keyVal.value)) {\n    throw new Error('Decode Error: tapMerkleRoot not a 32-byte hash');\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(value) {\n  const key = Buffer.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);\n  return { key, value };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data) && data.length === 32;\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3RhcE1lcmtsZVJvb3QuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixtQkFBTyxDQUFDLHFFQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjLE1BQU07QUFDcEIsV0FBVztBQUNYO0FBQ0EsY0FBYztBQUNkLGdCQUFnQjtBQUNoQjtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3RhcE1lcmtsZVJvb3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uLy4uL3R5cGVGaWVsZHMnKTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgaWYgKFxuICAgIGtleVZhbC5rZXlbMF0gIT09IHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9NRVJLTEVfUk9PVCB8fFxuICAgIGtleVZhbC5rZXkubGVuZ3RoICE9PSAxXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgdGFwTWVya2xlUm9vdCB3aXRoIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIGlmICghY2hlY2soa2V5VmFsLnZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlIEVycm9yOiB0YXBNZXJrbGVSb290IG5vdCBhIDMyLWJ5dGUgaGFzaCcpO1xuICB9XG4gIHJldHVybiBrZXlWYWwudmFsdWU7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZSh2YWx1ZSkge1xuICBjb25zdCBrZXkgPSBCdWZmZXIuZnJvbShbdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX01FUktMRV9ST09UXSk7XG4gIHJldHVybiB7IGtleSwgdmFsdWUgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5leHBlY3RlZCA9ICdCdWZmZXInO1xuZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGRhdGEpICYmIGRhdGEubGVuZ3RoID09PSAzMjtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICByZXR1cm4gISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEudGFwTWVya2xlUm9vdCA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5jYW5BZGQgPSBjYW5BZGQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/tapScriptSig.js":
/*!*********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/tapScriptSig.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {\n    throw new Error(\n      'Decode Error: could not decode tapScriptSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.key.length !== 65) {\n    throw new Error(\n      'Decode Error: tapScriptSig has invalid key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {\n    throw new Error(\n      'Decode Error: tapScriptSig has invalid signature in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const pubkey = keyVal.key.slice(1, 33);\n  const leafHash = keyVal.key.slice(33);\n  return {\n    pubkey,\n    leafHash,\n    signature: keyVal.value,\n  };\n}\nexports.decode = decode;\nfunction encode(tSig) {\n  const head = Buffer.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);\n  return {\n    key: Buffer.concat([head, tSig.pubkey, tSig.leafHash]),\n    value: tSig.signature,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.pubkey) &&\n    Buffer.isBuffer(data.leafHash) &&\n    Buffer.isBuffer(data.signature) &&\n    data.pubkey.length === 32 &&\n    data.leafHash.length === 32 &&\n    (data.signature.length === 64 || data.signature.length === 65)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString =\n    item.pubkey.toString('hex') + item.leafHash.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(\n      v => v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash),\n    ).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3RhcFNjcmlwdFNpZy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLG1CQUFPLENBQUMscUVBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxnQkFBZ0IsTUFBTSxnQkFBZ0Isa0JBQWtCLG9CQUFvQjtBQUM1RTtBQUNBO0FBQ0EsSUFBSSxNQUFNO0FBQ1YsSUFBSSxNQUFNO0FBQ1YsSUFBSSxNQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci9pbnB1dC90YXBTY3JpcHRTaWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uLy4uL3R5cGVGaWVsZHMnKTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgaWYgKGtleVZhbC5rZXlbMF0gIT09IHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9TQ1JJUFRfU0lHKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSB0YXBTY3JpcHRTaWcgd2l0aCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICBpZiAoa2V5VmFsLmtleS5sZW5ndGggIT09IDY1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0RlY29kZSBFcnJvcjogdGFwU2NyaXB0U2lnIGhhcyBpbnZhbGlkIGtleSAweCcgK1xuICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICB9XG4gIGlmIChrZXlWYWwudmFsdWUubGVuZ3RoICE9PSA2NCAmJiBrZXlWYWwudmFsdWUubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IHRhcFNjcmlwdFNpZyBoYXMgaW52YWxpZCBzaWduYXR1cmUgaW4ga2V5IDB4JyArXG4gICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICk7XG4gIH1cbiAgY29uc3QgcHVia2V5ID0ga2V5VmFsLmtleS5zbGljZSgxLCAzMyk7XG4gIGNvbnN0IGxlYWZIYXNoID0ga2V5VmFsLmtleS5zbGljZSgzMyk7XG4gIHJldHVybiB7XG4gICAgcHVia2V5LFxuICAgIGxlYWZIYXNoLFxuICAgIHNpZ25hdHVyZToga2V5VmFsLnZhbHVlLFxuICB9O1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5mdW5jdGlvbiBlbmNvZGUodFNpZykge1xuICBjb25zdCBoZWFkID0gQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9TQ1JJUFRfU0lHXSk7XG4gIHJldHVybiB7XG4gICAga2V5OiBCdWZmZXIuY29uY2F0KFtoZWFkLCB0U2lnLnB1YmtleSwgdFNpZy5sZWFmSGFzaF0pLFxuICAgIHZhbHVlOiB0U2lnLnNpZ25hdHVyZSxcbiAgfTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5leHBlY3RlZCA9ICd7IHB1YmtleTogQnVmZmVyOyBsZWFmSGFzaDogQnVmZmVyOyBzaWduYXR1cmU6IEJ1ZmZlcjsgfSc7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gIHJldHVybiAoXG4gICAgQnVmZmVyLmlzQnVmZmVyKGRhdGEucHVia2V5KSAmJlxuICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLmxlYWZIYXNoKSAmJlxuICAgIEJ1ZmZlci5pc0J1ZmZlcihkYXRhLnNpZ25hdHVyZSkgJiZcbiAgICBkYXRhLnB1YmtleS5sZW5ndGggPT09IDMyICYmXG4gICAgZGF0YS5sZWFmSGFzaC5sZW5ndGggPT09IDMyICYmXG4gICAgKGRhdGEuc2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQgfHwgZGF0YS5zaWduYXR1cmUubGVuZ3RoID09PSA2NSlcbiAgKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZFRvQXJyYXkoYXJyYXksIGl0ZW0sIGR1cGVTZXQpIHtcbiAgY29uc3QgZHVwZVN0cmluZyA9XG4gICAgaXRlbS5wdWJrZXkudG9TdHJpbmcoJ2hleCcpICsgaXRlbS5sZWFmSGFzaC50b1N0cmluZygnaGV4Jyk7XG4gIGlmIChkdXBlU2V0LmhhcyhkdXBlU3RyaW5nKSkgcmV0dXJuIGZhbHNlO1xuICBkdXBlU2V0LmFkZChkdXBlU3RyaW5nKTtcbiAgcmV0dXJuIChcbiAgICBhcnJheS5maWx0ZXIoXG4gICAgICB2ID0+IHYucHVia2V5LmVxdWFscyhpdGVtLnB1YmtleSkgJiYgdi5sZWFmSGFzaC5lcXVhbHMoaXRlbS5sZWFmSGFzaCksXG4gICAgKS5sZW5ndGggPT09IDBcbiAgKTtcbn1cbmV4cG9ydHMuY2FuQWRkVG9BcnJheSA9IGNhbkFkZFRvQXJyYXk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/input/tapScriptSig.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/input/witnessUtxo.js":
/*!********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/input/witnessUtxo.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nconst tools_1 = __webpack_require__(/*! ../tools */ \"./node_modules/bip174/src/lib/converter/tools.js\");\nconst varuint = __webpack_require__(/*! ../varint */ \"./node_modules/bip174/src/lib/converter/varint.js\");\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode witnessUtxo with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const value = tools_1.readUInt64LE(keyVal.value, 0);\n  let _offset = 8;\n  const scriptLen = varuint.decode(keyVal.value, _offset);\n  _offset += varuint.encodingLength(scriptLen);\n  const script = keyVal.value.slice(_offset);\n  if (script.length !== scriptLen) {\n    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');\n  }\n  return {\n    script,\n    value,\n  };\n}\nexports.decode = decode;\nfunction encode(data) {\n  const { script, value } = data;\n  const varintLen = varuint.encodingLength(script.length);\n  const result = Buffer.allocUnsafe(8 + varintLen + script.length);\n  tools_1.writeUInt64LE(result, value, 0);\n  varuint.encode(script.length, result, 8);\n  script.copy(result, 8 + varintLen);\n  return {\n    key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),\n    value: result,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ script: Buffer; value: number; }';\nfunction check(data) {\n  return Buffer.isBuffer(data.script) && typeof data.value === 'number';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.witnessUtxo === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3dpdG5lc3NVdHhvLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyxxRUFBa0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQVU7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsZ0JBQWdCLE1BQU0sZ0JBQWdCLGdCQUFnQjtBQUN0RDtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL2lucHV0L3dpdG5lc3NVdHhvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi8uLi90eXBlRmllbGRzJyk7XG5jb25zdCB0b29sc18xID0gcmVxdWlyZSgnLi4vdG9vbHMnKTtcbmNvbnN0IHZhcnVpbnQgPSByZXF1aXJlKCcuLi92YXJpbnQnKTtcbmZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgaWYgKGtleVZhbC5rZXlbMF0gIT09IHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLldJVE5FU1NfVVRYTykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgd2l0bmVzc1V0eG8gd2l0aCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICBjb25zdCB2YWx1ZSA9IHRvb2xzXzEucmVhZFVJbnQ2NExFKGtleVZhbC52YWx1ZSwgMCk7XG4gIGxldCBfb2Zmc2V0ID0gODtcbiAgY29uc3Qgc2NyaXB0TGVuID0gdmFydWludC5kZWNvZGUoa2V5VmFsLnZhbHVlLCBfb2Zmc2V0KTtcbiAgX29mZnNldCArPSB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHNjcmlwdExlbik7XG4gIGNvbnN0IHNjcmlwdCA9IGtleVZhbC52YWx1ZS5zbGljZShfb2Zmc2V0KTtcbiAgaWYgKHNjcmlwdC5sZW5ndGggIT09IHNjcmlwdExlbikge1xuICAgIHRocm93IG5ldyBFcnJvcignRGVjb2RlIEVycm9yOiBXSVRORVNTX1VUWE8gc2NyaXB0IGlzIG5vdCBwcm9wZXIgbGVuZ3RoJyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY3JpcHQsXG4gICAgdmFsdWUsXG4gIH07XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gIGNvbnN0IHsgc2NyaXB0LCB2YWx1ZSB9ID0gZGF0YTtcbiAgY29uc3QgdmFyaW50TGVuID0gdmFydWludC5lbmNvZGluZ0xlbmd0aChzY3JpcHQubGVuZ3RoKTtcbiAgY29uc3QgcmVzdWx0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDggKyB2YXJpbnRMZW4gKyBzY3JpcHQubGVuZ3RoKTtcbiAgdG9vbHNfMS53cml0ZVVJbnQ2NExFKHJlc3VsdCwgdmFsdWUsIDApO1xuICB2YXJ1aW50LmVuY29kZShzY3JpcHQubGVuZ3RoLCByZXN1bHQsIDgpO1xuICBzY3JpcHQuY29weShyZXN1bHQsIDggKyB2YXJpbnRMZW4pO1xuICByZXR1cm4ge1xuICAgIGtleTogQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLldJVE5FU1NfVVRYT10pLFxuICAgIHZhbHVlOiByZXN1bHQsXG4gIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPSAneyBzY3JpcHQ6IEJ1ZmZlcjsgdmFsdWU6IG51bWJlcjsgfSc7XG5mdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoZGF0YS5zY3JpcHQpICYmIHR5cGVvZiBkYXRhLnZhbHVlID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICByZXR1cm4gISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEud2l0bmVzc1V0eG8gPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuY2FuQWRkID0gY2FuQWRkO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/input/witnessUtxo.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/output/tapTree.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/output/tapTree.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typeFields_1 = __webpack_require__(/*! ../../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nconst varuint = __webpack_require__(/*! ../varint */ \"./node_modules/bip174/src/lib/converter/varint.js\");\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapTree with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  let _offset = 0;\n  const data = [];\n  while (_offset < keyVal.value.length) {\n    const depth = keyVal.value[_offset++];\n    const leafVersion = keyVal.value[_offset++];\n    const scriptLen = varuint.decode(keyVal.value, _offset);\n    _offset += varuint.encodingLength(scriptLen);\n    data.push({\n      depth,\n      leafVersion,\n      script: keyVal.value.slice(_offset, _offset + scriptLen),\n    });\n    _offset += scriptLen;\n  }\n  return { leaves: data };\n}\nexports.decode = decode;\nfunction encode(tree) {\n  const key = Buffer.from([typeFields_1.OutputTypes.TAP_TREE]);\n  const bufs = [].concat(\n    ...tree.leaves.map(tapLeaf => [\n      Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),\n      varuint.encode(tapLeaf.script.length),\n      tapLeaf.script,\n    ]),\n  );\n  return {\n    key,\n    value: Buffer.concat(bufs),\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }';\nfunction check(data) {\n  return (\n    Array.isArray(data.leaves) &&\n    data.leaves.every(\n      tapLeaf =>\n        tapLeaf.depth >= 0 &&\n        tapLeaf.depth <= 128 &&\n        (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion &&\n        Buffer.isBuffer(tapLeaf.script),\n    )\n  );\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapTree === undefined;\n}\nexports.canAdd = canAdd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL291dHB1dC90YXBUcmVlLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyxxRUFBa0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBLE1BQU0sTUFBTTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0EsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixLQUFLLFdBQVcsZUFBZSxzQ0FBc0MsR0FBRztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxNQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL291dHB1dC90YXBUcmVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0eXBlRmllbGRzXzEgPSByZXF1aXJlKCcuLi8uLi90eXBlRmllbGRzJyk7XG5jb25zdCB2YXJ1aW50ID0gcmVxdWlyZSgnLi4vdmFyaW50Jyk7XG5mdW5jdGlvbiBkZWNvZGUoa2V5VmFsKSB7XG4gIGlmIChcbiAgICBrZXlWYWwua2V5WzBdICE9PSB0eXBlRmllbGRzXzEuT3V0cHV0VHlwZXMuVEFQX1RSRUUgfHxcbiAgICBrZXlWYWwua2V5Lmxlbmd0aCAhPT0gMVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnRGVjb2RlIEVycm9yOiBjb3VsZCBub3QgZGVjb2RlIHRhcFRyZWUgd2l0aCBrZXkgMHgnICtcbiAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcbiAgfVxuICBsZXQgX29mZnNldCA9IDA7XG4gIGNvbnN0IGRhdGEgPSBbXTtcbiAgd2hpbGUgKF9vZmZzZXQgPCBrZXlWYWwudmFsdWUubGVuZ3RoKSB7XG4gICAgY29uc3QgZGVwdGggPSBrZXlWYWwudmFsdWVbX29mZnNldCsrXTtcbiAgICBjb25zdCBsZWFmVmVyc2lvbiA9IGtleVZhbC52YWx1ZVtfb2Zmc2V0KytdO1xuICAgIGNvbnN0IHNjcmlwdExlbiA9IHZhcnVpbnQuZGVjb2RlKGtleVZhbC52YWx1ZSwgX29mZnNldCk7XG4gICAgX29mZnNldCArPSB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHNjcmlwdExlbik7XG4gICAgZGF0YS5wdXNoKHtcbiAgICAgIGRlcHRoLFxuICAgICAgbGVhZlZlcnNpb24sXG4gICAgICBzY3JpcHQ6IGtleVZhbC52YWx1ZS5zbGljZShfb2Zmc2V0LCBfb2Zmc2V0ICsgc2NyaXB0TGVuKSxcbiAgICB9KTtcbiAgICBfb2Zmc2V0ICs9IHNjcmlwdExlbjtcbiAgfVxuICByZXR1cm4geyBsZWF2ZXM6IGRhdGEgfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RlKHRyZWUpIHtcbiAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20oW3R5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5UQVBfVFJFRV0pO1xuICBjb25zdCBidWZzID0gW10uY29uY2F0KFxuICAgIC4uLnRyZWUubGVhdmVzLm1hcCh0YXBMZWFmID0+IFtcbiAgICAgIEJ1ZmZlci5vZih0YXBMZWFmLmRlcHRoLCB0YXBMZWFmLmxlYWZWZXJzaW9uKSxcbiAgICAgIHZhcnVpbnQuZW5jb2RlKHRhcExlYWYuc2NyaXB0Lmxlbmd0aCksXG4gICAgICB0YXBMZWFmLnNjcmlwdCxcbiAgICBdKSxcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBrZXksXG4gICAgdmFsdWU6IEJ1ZmZlci5jb25jYXQoYnVmcyksXG4gIH07XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZXhwZWN0ZWQgPVxuICAneyBsZWF2ZXM6IFt7IGRlcHRoOiBudW1iZXI7IGxlYWZWZXJzaW9uOiBudW1iZXIsIHNjcmlwdDogQnVmZmVyOyB9XSB9JztcbmZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KGRhdGEubGVhdmVzKSAmJlxuICAgIGRhdGEubGVhdmVzLmV2ZXJ5KFxuICAgICAgdGFwTGVhZiA9PlxuICAgICAgICB0YXBMZWFmLmRlcHRoID49IDAgJiZcbiAgICAgICAgdGFwTGVhZi5kZXB0aCA8PSAxMjggJiZcbiAgICAgICAgKHRhcExlYWYubGVhZlZlcnNpb24gJiAweGZlKSA9PT0gdGFwTGVhZi5sZWFmVmVyc2lvbiAmJlxuICAgICAgICBCdWZmZXIuaXNCdWZmZXIodGFwTGVhZi5zY3JpcHQpLFxuICAgIClcbiAgKTtcbn1cbmV4cG9ydHMuY2hlY2sgPSBjaGVjaztcbmZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICByZXR1cm4gISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEudGFwVHJlZSA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5jYW5BZGQgPSBjYW5BZGQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/output/tapTree.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/shared/bip32Derivation.js":
/*!*************************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/shared/bip32Derivation.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst range = n => [...Array(n).keys()];\nconst isValidDERKey = pubkey =>\n  (pubkey.length === 33 && [2, 3].includes(pubkey[0])) ||\n  (pubkey.length === 65 && 4 === pubkey[0]);\nfunction makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode bip32Derivation with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    const pubkey = keyVal.key.slice(1);\n    if (!isValidPubkey(pubkey)) {\n      throw new Error(\n        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    if ((keyVal.value.length / 4) % 1 !== 0) {\n      throw new Error(\n        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',\n      );\n    }\n    const data = {\n      masterFingerprint: keyVal.value.slice(0, 4),\n      pubkey,\n      path: 'm',\n    };\n    for (const i of range(keyVal.value.length / 4 - 1)) {\n      const val = keyVal.value.readUInt32LE(i * 4 + 4);\n      const isHard = !!(val & 0x80000000);\n      const idx = val & 0x7fffffff;\n      data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n    }\n    return data;\n  }\n  function encode(data) {\n    const head = Buffer.from([TYPE_BYTE]);\n    const key = Buffer.concat([head, data.pubkey]);\n    const splitPath = data.path.split('/');\n    const value = Buffer.allocUnsafe(splitPath.length * 4);\n    data.masterFingerprint.copy(value, 0);\n    let offset = 4;\n    splitPath.slice(1).forEach(level => {\n      const isHard = level.slice(-1) === \"'\";\n      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n      if (isHard) num += 0x80000000;\n      value.writeUInt32LE(num, offset);\n      offset += 4;\n    });\n    return {\n      key,\n      value,\n    };\n  }\n  const expected =\n    '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';\n  function check(data) {\n    return (\n      Buffer.isBuffer(data.pubkey) &&\n      Buffer.isBuffer(data.masterFingerprint) &&\n      typeof data.path === 'string' &&\n      isValidPubkey(data.pubkey) &&\n      data.masterFingerprint.length === 4\n    );\n  }\n  function canAddToArray(array, item, dupeSet) {\n    const dupeString = item.pubkey.toString('hex');\n    if (dupeSet.has(dupeString)) return false;\n    dupeSet.add(dupeString);\n    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray,\n  };\n}\nexports.makeConverter = makeConverter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3NoYXJlZC9iaXAzMkRlcml2YXRpb24uanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QixnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTywyQkFBMkIsZ0JBQWdCLGVBQWU7QUFDakU7QUFDQTtBQUNBLE1BQU0sTUFBTTtBQUNaLE1BQU0sTUFBTTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci9zaGFyZWQvYmlwMzJEZXJpdmF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByYW5nZSA9IG4gPT4gWy4uLkFycmF5KG4pLmtleXMoKV07XG5jb25zdCBpc1ZhbGlkREVSS2V5ID0gcHVia2V5ID0+XG4gIChwdWJrZXkubGVuZ3RoID09PSAzMyAmJiBbMiwgM10uaW5jbHVkZXMocHVia2V5WzBdKSkgfHxcbiAgKHB1YmtleS5sZW5ndGggPT09IDY1ICYmIDQgPT09IHB1YmtleVswXSk7XG5mdW5jdGlvbiBtYWtlQ29udmVydGVyKFRZUEVfQllURSwgaXNWYWxpZFB1YmtleSA9IGlzVmFsaWRERVJLZXkpIHtcbiAgZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICAgIGlmIChrZXlWYWwua2V5WzBdICE9PSBUWVBFX0JZVEUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSBiaXAzMkRlcml2YXRpb24gd2l0aCBrZXkgMHgnICtcbiAgICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmtleSA9IGtleVZhbC5rZXkuc2xpY2UoMSk7XG4gICAgaWYgKCFpc1ZhbGlkUHVia2V5KHB1YmtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0RlY29kZSBFcnJvcjogYmlwMzJEZXJpdmF0aW9uIGhhcyBpbnZhbGlkIHB1YmtleSBpbiBrZXkgMHgnICtcbiAgICAgICAgICBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICgoa2V5VmFsLnZhbHVlLmxlbmd0aCAvIDQpICUgMSAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRGVjb2RlIEVycm9yOiBJbnB1dCBCSVAzMl9ERVJJVkFUSU9OIHZhbHVlIGxlbmd0aCBzaG91bGQgYmUgbXVsdGlwbGUgb2YgNCcsXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgbWFzdGVyRmluZ2VycHJpbnQ6IGtleVZhbC52YWx1ZS5zbGljZSgwLCA0KSxcbiAgICAgIHB1YmtleSxcbiAgICAgIHBhdGg6ICdtJyxcbiAgICB9O1xuICAgIGZvciAoY29uc3QgaSBvZiByYW5nZShrZXlWYWwudmFsdWUubGVuZ3RoIC8gNCAtIDEpKSB7XG4gICAgICBjb25zdCB2YWwgPSBrZXlWYWwudmFsdWUucmVhZFVJbnQzMkxFKGkgKiA0ICsgNCk7XG4gICAgICBjb25zdCBpc0hhcmQgPSAhISh2YWwgJiAweDgwMDAwMDAwKTtcbiAgICAgIGNvbnN0IGlkeCA9IHZhbCAmIDB4N2ZmZmZmZmY7XG4gICAgICBkYXRhLnBhdGggKz0gJy8nICsgaWR4LnRvU3RyaW5nKDEwKSArIChpc0hhcmQgPyBcIidcIiA6ICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICBjb25zdCBoZWFkID0gQnVmZmVyLmZyb20oW1RZUEVfQllURV0pO1xuICAgIGNvbnN0IGtleSA9IEJ1ZmZlci5jb25jYXQoW2hlYWQsIGRhdGEucHVia2V5XSk7XG4gICAgY29uc3Qgc3BsaXRQYXRoID0gZGF0YS5wYXRoLnNwbGl0KCcvJyk7XG4gICAgY29uc3QgdmFsdWUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc3BsaXRQYXRoLmxlbmd0aCAqIDQpO1xuICAgIGRhdGEubWFzdGVyRmluZ2VycHJpbnQuY29weSh2YWx1ZSwgMCk7XG4gICAgbGV0IG9mZnNldCA9IDQ7XG4gICAgc3BsaXRQYXRoLnNsaWNlKDEpLmZvckVhY2gobGV2ZWwgPT4ge1xuICAgICAgY29uc3QgaXNIYXJkID0gbGV2ZWwuc2xpY2UoLTEpID09PSBcIidcIjtcbiAgICAgIGxldCBudW0gPSAweDdmZmZmZmZmICYgcGFyc2VJbnQoaXNIYXJkID8gbGV2ZWwuc2xpY2UoMCwgLTEpIDogbGV2ZWwsIDEwKTtcbiAgICAgIGlmIChpc0hhcmQpIG51bSArPSAweDgwMDAwMDAwO1xuICAgICAgdmFsdWUud3JpdGVVSW50MzJMRShudW0sIG9mZnNldCk7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5LFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuICBjb25zdCBleHBlY3RlZCA9XG4gICAgJ3sgbWFzdGVyRmluZ2VycHJpbnQ6IEJ1ZmZlcjsgcHVia2V5OiBCdWZmZXI7IHBhdGg6IHN0cmluZzsgfSc7XG4gIGZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgICByZXR1cm4gKFxuICAgICAgQnVmZmVyLmlzQnVmZmVyKGRhdGEucHVia2V5KSAmJlxuICAgICAgQnVmZmVyLmlzQnVmZmVyKGRhdGEubWFzdGVyRmluZ2VycHJpbnQpICYmXG4gICAgICB0eXBlb2YgZGF0YS5wYXRoID09PSAnc3RyaW5nJyAmJlxuICAgICAgaXNWYWxpZFB1YmtleShkYXRhLnB1YmtleSkgJiZcbiAgICAgIGRhdGEubWFzdGVyRmluZ2VycHJpbnQubGVuZ3RoID09PSA0XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5BZGRUb0FycmF5KGFycmF5LCBpdGVtLCBkdXBlU2V0KSB7XG4gICAgY29uc3QgZHVwZVN0cmluZyA9IGl0ZW0ucHVia2V5LnRvU3RyaW5nKCdoZXgnKTtcbiAgICBpZiAoZHVwZVNldC5oYXMoZHVwZVN0cmluZykpIHJldHVybiBmYWxzZTtcbiAgICBkdXBlU2V0LmFkZChkdXBlU3RyaW5nKTtcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKHYgPT4gdi5wdWJrZXkuZXF1YWxzKGl0ZW0ucHVia2V5KSkubGVuZ3RoID09PSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGVjb2RlLFxuICAgIGVuY29kZSxcbiAgICBjaGVjayxcbiAgICBleHBlY3RlZCxcbiAgICBjYW5BZGRUb0FycmF5LFxuICB9O1xufVxuZXhwb3J0cy5tYWtlQ29udmVydGVyID0gbWFrZUNvbnZlcnRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/shared/bip32Derivation.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/shared/checkPubkey.js":
/*!*********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/shared/checkPubkey.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction makeChecker(pubkeyTypes) {\n  return checkPubkey;\n  function checkPubkey(keyVal) {\n    let pubkey;\n    if (pubkeyTypes.includes(keyVal.key[0])) {\n      pubkey = keyVal.key.slice(1);\n      if (\n        !(pubkey.length === 33 || pubkey.length === 65) ||\n        ![2, 3, 4].includes(pubkey[0])\n      ) {\n        throw new Error(\n          'Format Error: invalid pubkey in key 0x' + keyVal.key.toString('hex'),\n        );\n      }\n    }\n    return pubkey;\n  }\n}\nexports.makeChecker = makeChecker;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3NoYXJlZC9jaGVja1B1YmtleS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3NoYXJlZC9jaGVja1B1YmtleS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gbWFrZUNoZWNrZXIocHVia2V5VHlwZXMpIHtcbiAgcmV0dXJuIGNoZWNrUHVia2V5O1xuICBmdW5jdGlvbiBjaGVja1B1YmtleShrZXlWYWwpIHtcbiAgICBsZXQgcHVia2V5O1xuICAgIGlmIChwdWJrZXlUeXBlcy5pbmNsdWRlcyhrZXlWYWwua2V5WzBdKSkge1xuICAgICAgcHVia2V5ID0ga2V5VmFsLmtleS5zbGljZSgxKTtcbiAgICAgIGlmIChcbiAgICAgICAgIShwdWJrZXkubGVuZ3RoID09PSAzMyB8fCBwdWJrZXkubGVuZ3RoID09PSA2NSkgfHxcbiAgICAgICAgIVsyLCAzLCA0XS5pbmNsdWRlcyhwdWJrZXlbMF0pXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdGb3JtYXQgRXJyb3I6IGludmFsaWQgcHVia2V5IGluIGtleSAweCcgKyBrZXlWYWwua2V5LnRvU3RyaW5nKCdoZXgnKSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHB1YmtleTtcbiAgfVxufVxuZXhwb3J0cy5tYWtlQ2hlY2tlciA9IG1ha2VDaGVja2VyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/shared/checkPubkey.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/shared/redeemScript.js":
/*!**********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/shared/redeemScript.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode redeemScript with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(data) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return {\n      key,\n      value: data,\n    };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data);\n  }\n  function canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.redeemScript === undefined;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3NoYXJlZC9yZWRlZW1TY3JpcHQuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3NoYXJlZC9yZWRlZW1TY3JpcHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIG1ha2VDb252ZXJ0ZXIoVFlQRV9CWVRFKSB7XG4gIGZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgICBpZiAoa2V5VmFsLmtleVswXSAhPT0gVFlQRV9CWVRFKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgcmVkZWVtU2NyaXB0IHdpdGgga2V5IDB4JyArXG4gICAgICAgICAga2V5VmFsLmtleS50b1N0cmluZygnaGV4JyksXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ga2V5VmFsLnZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGVuY29kZShkYXRhKSB7XG4gICAgY29uc3Qga2V5ID0gQnVmZmVyLmZyb20oW1RZUEVfQllURV0pO1xuICAgIHJldHVybiB7XG4gICAgICBrZXksXG4gICAgICB2YWx1ZTogZGF0YSxcbiAgICB9O1xuICB9XG4gIGNvbnN0IGV4cGVjdGVkID0gJ0J1ZmZlcic7XG4gIGZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGRhdGEpO1xuICB9XG4gIGZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICAgIHJldHVybiAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS5yZWRlZW1TY3JpcHQgPT09IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRlY29kZSxcbiAgICBlbmNvZGUsXG4gICAgY2hlY2ssXG4gICAgZXhwZWN0ZWQsXG4gICAgY2FuQWRkLFxuICB9O1xufVxuZXhwb3J0cy5tYWtlQ29udmVydGVyID0gbWFrZUNvbnZlcnRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/shared/redeemScript.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js":
/*!****************************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst varuint = __webpack_require__(/*! ../varint */ \"./node_modules/bip174/src/lib/converter/varint.js\");\nconst bip32Derivation = __webpack_require__(/*! ./bip32Derivation */ \"./node_modules/bip174/src/lib/converter/shared/bip32Derivation.js\");\nconst isValidBIP340Key = pubkey => pubkey.length === 32;\nfunction makeConverter(TYPE_BYTE) {\n  const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);\n  function decode(keyVal) {\n    const nHashes = varuint.decode(keyVal.value);\n    const nHashesLen = varuint.encodingLength(nHashes);\n    const base = parent.decode({\n      key: keyVal.key,\n      value: keyVal.value.slice(nHashesLen + nHashes * 32),\n    });\n    const leafHashes = new Array(nHashes);\n    for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {\n      leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);\n    }\n    return Object.assign({}, base, { leafHashes });\n  }\n  function encode(data) {\n    const base = parent.encode(data);\n    const nHashesLen = varuint.encodingLength(data.leafHashes.length);\n    const nHashesBuf = Buffer.allocUnsafe(nHashesLen);\n    varuint.encode(data.leafHashes.length, nHashesBuf);\n    const value = Buffer.concat([nHashesBuf, ...data.leafHashes, base.value]);\n    return Object.assign({}, base, { value });\n  }\n  const expected =\n    '{ ' +\n    'masterFingerprint: Buffer; ' +\n    'pubkey: Buffer; ' +\n    'path: string; ' +\n    'leafHashes: Buffer[]; ' +\n    '}';\n  function check(data) {\n    return (\n      Array.isArray(data.leafHashes) &&\n      data.leafHashes.every(\n        leafHash => Buffer.isBuffer(leafHash) && leafHash.length === 32,\n      ) &&\n      parent.check(data)\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray: parent.canAddToArray,\n  };\n}\nexports.makeConverter = makeConverter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3NoYXJlZC90YXBCaXAzMkRlcml2YXRpb24uanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLG9FQUFXO0FBQ25DLHdCQUF3QixtQkFBTyxDQUFDLDRGQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwwQ0FBMEMsYUFBYTtBQUN2RDtBQUNBO0FBQ0EsMkJBQTJCLFVBQVUsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixNQUFNO0FBQzdCO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEIsMkJBQTJCLFVBQVUsT0FBTztBQUM1QztBQUNBO0FBQ0EsT0FBTztBQUNQLGdDQUFnQztBQUNoQyxxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLDJCQUEyQjtBQUMzQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3NoYXJlZC90YXBCaXAzMkRlcml2YXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHZhcnVpbnQgPSByZXF1aXJlKCcuLi92YXJpbnQnKTtcbmNvbnN0IGJpcDMyRGVyaXZhdGlvbiA9IHJlcXVpcmUoJy4vYmlwMzJEZXJpdmF0aW9uJyk7XG5jb25zdCBpc1ZhbGlkQklQMzQwS2V5ID0gcHVia2V5ID0+IHB1YmtleS5sZW5ndGggPT09IDMyO1xuZnVuY3Rpb24gbWFrZUNvbnZlcnRlcihUWVBFX0JZVEUpIHtcbiAgY29uc3QgcGFyZW50ID0gYmlwMzJEZXJpdmF0aW9uLm1ha2VDb252ZXJ0ZXIoVFlQRV9CWVRFLCBpc1ZhbGlkQklQMzQwS2V5KTtcbiAgZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICAgIGNvbnN0IG5IYXNoZXMgPSB2YXJ1aW50LmRlY29kZShrZXlWYWwudmFsdWUpO1xuICAgIGNvbnN0IG5IYXNoZXNMZW4gPSB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKG5IYXNoZXMpO1xuICAgIGNvbnN0IGJhc2UgPSBwYXJlbnQuZGVjb2RlKHtcbiAgICAgIGtleToga2V5VmFsLmtleSxcbiAgICAgIHZhbHVlOiBrZXlWYWwudmFsdWUuc2xpY2Uobkhhc2hlc0xlbiArIG5IYXNoZXMgKiAzMiksXG4gICAgfSk7XG4gICAgY29uc3QgbGVhZkhhc2hlcyA9IG5ldyBBcnJheShuSGFzaGVzKTtcbiAgICBmb3IgKGxldCBpID0gMCwgX29mZnNldCA9IG5IYXNoZXNMZW47IGkgPCBuSGFzaGVzOyBpKyssIF9vZmZzZXQgKz0gMzIpIHtcbiAgICAgIGxlYWZIYXNoZXNbaV0gPSBrZXlWYWwudmFsdWUuc2xpY2UoX29mZnNldCwgX29mZnNldCArIDMyKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGJhc2UsIHsgbGVhZkhhc2hlcyB9KTtcbiAgfVxuICBmdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgIGNvbnN0IGJhc2UgPSBwYXJlbnQuZW5jb2RlKGRhdGEpO1xuICAgIGNvbnN0IG5IYXNoZXNMZW4gPSB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKGRhdGEubGVhZkhhc2hlcy5sZW5ndGgpO1xuICAgIGNvbnN0IG5IYXNoZXNCdWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUobkhhc2hlc0xlbik7XG4gICAgdmFydWludC5lbmNvZGUoZGF0YS5sZWFmSGFzaGVzLmxlbmd0aCwgbkhhc2hlc0J1Zik7XG4gICAgY29uc3QgdmFsdWUgPSBCdWZmZXIuY29uY2F0KFtuSGFzaGVzQnVmLCAuLi5kYXRhLmxlYWZIYXNoZXMsIGJhc2UudmFsdWVdKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYmFzZSwgeyB2YWx1ZSB9KTtcbiAgfVxuICBjb25zdCBleHBlY3RlZCA9XG4gICAgJ3sgJyArXG4gICAgJ21hc3RlckZpbmdlcnByaW50OiBCdWZmZXI7ICcgK1xuICAgICdwdWJrZXk6IEJ1ZmZlcjsgJyArXG4gICAgJ3BhdGg6IHN0cmluZzsgJyArXG4gICAgJ2xlYWZIYXNoZXM6IEJ1ZmZlcltdOyAnICtcbiAgICAnfSc7XG4gIGZ1bmN0aW9uIGNoZWNrKGRhdGEpIHtcbiAgICByZXR1cm4gKFxuICAgICAgQXJyYXkuaXNBcnJheShkYXRhLmxlYWZIYXNoZXMpICYmXG4gICAgICBkYXRhLmxlYWZIYXNoZXMuZXZlcnkoXG4gICAgICAgIGxlYWZIYXNoID0+IEJ1ZmZlci5pc0J1ZmZlcihsZWFmSGFzaCkgJiYgbGVhZkhhc2gubGVuZ3RoID09PSAzMixcbiAgICAgICkgJiZcbiAgICAgIHBhcmVudC5jaGVjayhkYXRhKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZWNvZGUsXG4gICAgZW5jb2RlLFxuICAgIGNoZWNrLFxuICAgIGV4cGVjdGVkLFxuICAgIGNhbkFkZFRvQXJyYXk6IHBhcmVudC5jYW5BZGRUb0FycmF5LFxuICB9O1xufVxuZXhwb3J0cy5tYWtlQ29udmVydGVyID0gbWFrZUNvbnZlcnRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/shared/tapInternalKey.js":
/*!************************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/shared/tapInternalKey.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {\n      throw new Error(\n        'Decode Error: could not decode tapInternalKey with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    if (keyVal.value.length !== 32) {\n      throw new Error(\n        'Decode Error: tapInternalKey not a 32-byte x-only pubkey',\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(value) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return { key, value };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data) && data.length === 32;\n  }\n  function canAdd(currentData, newData) {\n    return (\n      !!currentData && !!newData && currentData.tapInternalKey === undefined\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3NoYXJlZC90YXBJbnRlcm5hbEtleS5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3NoYXJlZC90YXBJbnRlcm5hbEtleS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gbWFrZUNvbnZlcnRlcihUWVBFX0JZVEUpIHtcbiAgZnVuY3Rpb24gZGVjb2RlKGtleVZhbCkge1xuICAgIGlmIChrZXlWYWwua2V5WzBdICE9PSBUWVBFX0JZVEUgfHwga2V5VmFsLmtleS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0RlY29kZSBFcnJvcjogY291bGQgbm90IGRlY29kZSB0YXBJbnRlcm5hbEtleSB3aXRoIGtleSAweCcgK1xuICAgICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGtleVZhbC52YWx1ZS5sZW5ndGggIT09IDMyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdEZWNvZGUgRXJyb3I6IHRhcEludGVybmFsS2V5IG5vdCBhIDMyLWJ5dGUgeC1vbmx5IHB1YmtleScsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ga2V5VmFsLnZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGVuY29kZSh2YWx1ZSkge1xuICAgIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFtUWVBFX0JZVEVdKTtcbiAgICByZXR1cm4geyBrZXksIHZhbHVlIH07XG4gIH1cbiAgY29uc3QgZXhwZWN0ZWQgPSAnQnVmZmVyJztcbiAgZnVuY3Rpb24gY2hlY2soZGF0YSkge1xuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoZGF0YSkgJiYgZGF0YS5sZW5ndGggPT09IDMyO1xuICB9XG4gIGZ1bmN0aW9uIGNhbkFkZChjdXJyZW50RGF0YSwgbmV3RGF0YSkge1xuICAgIHJldHVybiAoXG4gICAgICAhIWN1cnJlbnREYXRhICYmICEhbmV3RGF0YSAmJiBjdXJyZW50RGF0YS50YXBJbnRlcm5hbEtleSA9PT0gdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRlY29kZSxcbiAgICBlbmNvZGUsXG4gICAgY2hlY2ssXG4gICAgZXhwZWN0ZWQsXG4gICAgY2FuQWRkLFxuICB9O1xufVxuZXhwb3J0cy5tYWtlQ29udmVydGVyID0gbWFrZUNvbnZlcnRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/shared/tapInternalKey.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/shared/witnessScript.js":
/*!***********************************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/shared/witnessScript.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode witnessScript with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(data) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return {\n      key,\n      value: data,\n    };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data);\n  }\n  function canAdd(currentData, newData) {\n    return (\n      !!currentData && !!newData && currentData.witnessScript === undefined\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3NoYXJlZC93aXRuZXNzU2NyaXB0LmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvc2hhcmVkL3dpdG5lc3NTY3JpcHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIG1ha2VDb252ZXJ0ZXIoVFlQRV9CWVRFKSB7XG4gIGZ1bmN0aW9uIGRlY29kZShrZXlWYWwpIHtcbiAgICBpZiAoa2V5VmFsLmtleVswXSAhPT0gVFlQRV9CWVRFKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdEZWNvZGUgRXJyb3I6IGNvdWxkIG5vdCBkZWNvZGUgd2l0bmVzc1NjcmlwdCB3aXRoIGtleSAweCcgK1xuICAgICAgICAgIGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleVZhbC52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuICAgIGNvbnN0IGtleSA9IEJ1ZmZlci5mcm9tKFtUWVBFX0JZVEVdKTtcbiAgICByZXR1cm4ge1xuICAgICAga2V5LFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgfTtcbiAgfVxuICBjb25zdCBleHBlY3RlZCA9ICdCdWZmZXInO1xuICBmdW5jdGlvbiBjaGVjayhkYXRhKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5BZGQoY3VycmVudERhdGEsIG5ld0RhdGEpIHtcbiAgICByZXR1cm4gKFxuICAgICAgISFjdXJyZW50RGF0YSAmJiAhIW5ld0RhdGEgJiYgY3VycmVudERhdGEud2l0bmVzc1NjcmlwdCA9PT0gdW5kZWZpbmVkXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRlY29kZSxcbiAgICBlbmNvZGUsXG4gICAgY2hlY2ssXG4gICAgZXhwZWN0ZWQsXG4gICAgY2FuQWRkLFxuICB9O1xufVxuZXhwb3J0cy5tYWtlQ29udmVydGVyID0gbWFrZUNvbnZlcnRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/shared/witnessScript.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/tools.js":
/*!********************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/tools.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst varuint = __webpack_require__(/*! ./varint */ \"./node_modules/bip174/src/lib/converter/varint.js\");\nexports.range = n => [...Array(n).keys()];\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction keyValsToBuffer(keyVals) {\n  const buffers = keyVals.map(keyValToBuffer);\n  buffers.push(Buffer.from([0]));\n  return Buffer.concat(buffers);\n}\nexports.keyValsToBuffer = keyValsToBuffer;\nfunction keyValToBuffer(keyVal) {\n  const keyLen = keyVal.key.length;\n  const valLen = keyVal.value.length;\n  const keyVarIntLen = varuint.encodingLength(keyLen);\n  const valVarIntLen = varuint.encodingLength(valLen);\n  const buffer = Buffer.allocUnsafe(\n    keyVarIntLen + keyLen + valVarIntLen + valLen,\n  );\n  varuint.encode(keyLen, buffer, 0);\n  keyVal.key.copy(buffer, keyVarIntLen);\n  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);\n  keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);\n  return buffer;\n}\nexports.keyValToBuffer = keyValToBuffer;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3Rvb2xzLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBVTtBQUNsQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsU0FBUyxNQUFNO0FBQ2Y7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3Rvb2xzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB2YXJ1aW50ID0gcmVxdWlyZSgnLi92YXJpbnQnKTtcbmV4cG9ydHMucmFuZ2UgPSBuID0+IFsuLi5BcnJheShuKS5rZXlzKCldO1xuZnVuY3Rpb24gcmV2ZXJzZUJ1ZmZlcihidWZmZXIpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPCAxKSByZXR1cm4gYnVmZmVyO1xuICBsZXQgaiA9IGJ1ZmZlci5sZW5ndGggLSAxO1xuICBsZXQgdG1wID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgdG1wID0gYnVmZmVyW2ldO1xuICAgIGJ1ZmZlcltpXSA9IGJ1ZmZlcltqXTtcbiAgICBidWZmZXJbal0gPSB0bXA7XG4gICAgai0tO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLnJldmVyc2VCdWZmZXIgPSByZXZlcnNlQnVmZmVyO1xuZnVuY3Rpb24ga2V5VmFsc1RvQnVmZmVyKGtleVZhbHMpIHtcbiAgY29uc3QgYnVmZmVycyA9IGtleVZhbHMubWFwKGtleVZhbFRvQnVmZmVyKTtcbiAgYnVmZmVycy5wdXNoKEJ1ZmZlci5mcm9tKFswXSkpO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChidWZmZXJzKTtcbn1cbmV4cG9ydHMua2V5VmFsc1RvQnVmZmVyID0ga2V5VmFsc1RvQnVmZmVyO1xuZnVuY3Rpb24ga2V5VmFsVG9CdWZmZXIoa2V5VmFsKSB7XG4gIGNvbnN0IGtleUxlbiA9IGtleVZhbC5rZXkubGVuZ3RoO1xuICBjb25zdCB2YWxMZW4gPSBrZXlWYWwudmFsdWUubGVuZ3RoO1xuICBjb25zdCBrZXlWYXJJbnRMZW4gPSB2YXJ1aW50LmVuY29kaW5nTGVuZ3RoKGtleUxlbik7XG4gIGNvbnN0IHZhbFZhckludExlbiA9IHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgodmFsTGVuKTtcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKFxuICAgIGtleVZhckludExlbiArIGtleUxlbiArIHZhbFZhckludExlbiArIHZhbExlbixcbiAgKTtcbiAgdmFydWludC5lbmNvZGUoa2V5TGVuLCBidWZmZXIsIDApO1xuICBrZXlWYWwua2V5LmNvcHkoYnVmZmVyLCBrZXlWYXJJbnRMZW4pO1xuICB2YXJ1aW50LmVuY29kZSh2YWxMZW4sIGJ1ZmZlciwga2V5VmFySW50TGVuICsga2V5TGVuKTtcbiAga2V5VmFsLnZhbHVlLmNvcHkoYnVmZmVyLCBrZXlWYXJJbnRMZW4gKyBrZXlMZW4gKyB2YWxWYXJJbnRMZW4pO1xuICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5rZXlWYWxUb0J1ZmZlciA9IGtleVZhbFRvQnVmZmVyO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi9tYXN0ZXIvaW5kZXguanMjTDExMjdcbmZ1bmN0aW9uIHZlcmlmdWludCh2YWx1ZSwgbWF4KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxuICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuICBpZiAodmFsdWUgPCAwKVxuICAgIHRocm93IG5ldyBFcnJvcignc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKTtcbiAgaWYgKHZhbHVlID4gbWF4KSB0aHJvdyBuZXcgRXJyb3IoJ1JhbmdlRXJyb3I6IHZhbHVlIG91dCBvZiByYW5nZScpO1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKVxuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cbmZ1bmN0aW9uIHJlYWRVSW50NjRMRShidWZmZXIsIG9mZnNldCkge1xuICBjb25zdCBhID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQpO1xuICBsZXQgYiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgNCk7XG4gIGIgKj0gMHgxMDAwMDAwMDA7XG4gIHZlcmlmdWludChiICsgYSwgMHgwMDFmZmZmZmZmZmZmZmZmKTtcbiAgcmV0dXJuIGIgKyBhO1xufVxuZXhwb3J0cy5yZWFkVUludDY0TEUgPSByZWFkVUludDY0TEU7XG5mdW5jdGlvbiB3cml0ZVVJbnQ2NExFKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCkge1xuICB2ZXJpZnVpbnQodmFsdWUsIDB4MDAxZmZmZmZmZmZmZmZmZik7XG4gIGJ1ZmZlci53cml0ZUludDMyTEUodmFsdWUgJiAtMSwgb2Zmc2V0KTtcbiAgYnVmZmVyLndyaXRlVUludDMyTEUoTWF0aC5mbG9vcih2YWx1ZSAvIDB4MTAwMDAwMDAwKSwgb2Zmc2V0ICsgNCk7XG4gIHJldHVybiBvZmZzZXQgKyA4O1xufVxuZXhwb3J0cy53cml0ZVVJbnQ2NExFID0gd3JpdGVVSW50NjRMRTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/tools.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/converter/varint.js":
/*!*********************************************************!*\
  !*** ./node_modules/bip174/src/lib/converter/varint.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// Number.MAX_SAFE_INTEGER\nconst MAX_SAFE_INTEGER = 9007199254740991;\nfunction checkUInt53(n) {\n  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)\n    throw new RangeError('value out of range');\n}\nfunction encode(_number, buffer, offset) {\n  checkUInt53(_number);\n  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));\n  if (!Buffer.isBuffer(buffer))\n    throw new TypeError('buffer must be a Buffer instance');\n  if (!offset) offset = 0;\n  // 8 bit\n  if (_number < 0xfd) {\n    buffer.writeUInt8(_number, offset);\n    Object.assign(encode, { bytes: 1 });\n    // 16 bit\n  } else if (_number <= 0xffff) {\n    buffer.writeUInt8(0xfd, offset);\n    buffer.writeUInt16LE(_number, offset + 1);\n    Object.assign(encode, { bytes: 3 });\n    // 32 bit\n  } else if (_number <= 0xffffffff) {\n    buffer.writeUInt8(0xfe, offset);\n    buffer.writeUInt32LE(_number, offset + 1);\n    Object.assign(encode, { bytes: 5 });\n    // 64 bit\n  } else {\n    buffer.writeUInt8(0xff, offset);\n    buffer.writeUInt32LE(_number >>> 0, offset + 1);\n    buffer.writeUInt32LE((_number / 0x100000000) | 0, offset + 5);\n    Object.assign(encode, { bytes: 9 });\n  }\n  return buffer;\n}\nexports.encode = encode;\nfunction decode(buffer, offset) {\n  if (!Buffer.isBuffer(buffer))\n    throw new TypeError('buffer must be a Buffer instance');\n  if (!offset) offset = 0;\n  const first = buffer.readUInt8(offset);\n  // 8 bit\n  if (first < 0xfd) {\n    Object.assign(decode, { bytes: 1 });\n    return first;\n    // 16 bit\n  } else if (first === 0xfd) {\n    Object.assign(decode, { bytes: 3 });\n    return buffer.readUInt16LE(offset + 1);\n    // 32 bit\n  } else if (first === 0xfe) {\n    Object.assign(decode, { bytes: 5 });\n    return buffer.readUInt32LE(offset + 1);\n    // 64 bit\n  } else {\n    Object.assign(decode, { bytes: 9 });\n    const lo = buffer.readUInt32LE(offset + 1);\n    const hi = buffer.readUInt32LE(offset + 5);\n    const _number = hi * 0x0100000000 + lo;\n    checkUInt53(_number);\n    return _number;\n  }\n}\nexports.decode = decode;\nfunction encodingLength(_number) {\n  checkUInt53(_number);\n  return _number < 0xfd\n    ? 1\n    : _number <= 0xffff\n    ? 3\n    : _number <= 0xffffffff\n    ? 5\n    : 9;\n}\nexports.encodingLength = encodingLength;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvY29udmVydGVyL3ZhcmludC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCLE9BQU8sTUFBTTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLE9BQU8sTUFBTTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0EsSUFBSTtBQUNKLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBLElBQUk7QUFDSiw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvdmFyaW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5mdW5jdGlvbiBjaGVja1VJbnQ1MyhuKSB7XG4gIGlmIChuIDwgMCB8fCBuID4gTUFYX1NBRkVfSU5URUdFUiB8fCBuICUgMSAhPT0gMClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgb3V0IG9mIHJhbmdlJyk7XG59XG5mdW5jdGlvbiBlbmNvZGUoX251bWJlciwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgY2hlY2tVSW50NTMoX251bWJlcik7XG4gIGlmICghYnVmZmVyKSBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgoX251bWJlcikpO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7XG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwO1xuICAvLyA4IGJpdFxuICBpZiAoX251bWJlciA8IDB4ZmQpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OChfbnVtYmVyLCBvZmZzZXQpO1xuICAgIE9iamVjdC5hc3NpZ24oZW5jb2RlLCB7IGJ5dGVzOiAxIH0pO1xuICAgIC8vIDE2IGJpdFxuICB9IGVsc2UgaWYgKF9udW1iZXIgPD0gMHhmZmZmKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgoMHhmZCwgb2Zmc2V0KTtcbiAgICBidWZmZXIud3JpdGVVSW50MTZMRShfbnVtYmVyLCBvZmZzZXQgKyAxKTtcbiAgICBPYmplY3QuYXNzaWduKGVuY29kZSwgeyBieXRlczogMyB9KTtcbiAgICAvLyAzMiBiaXRcbiAgfSBlbHNlIGlmIChfbnVtYmVyIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZlLCBvZmZzZXQpO1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKF9udW1iZXIsIG9mZnNldCArIDEpO1xuICAgIE9iamVjdC5hc3NpZ24oZW5jb2RlLCB7IGJ5dGVzOiA1IH0pO1xuICAgIC8vIDY0IGJpdFxuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmYsIG9mZnNldCk7XG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUoX251bWJlciA+Pj4gMCwgb2Zmc2V0ICsgMSk7XG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUoKF9udW1iZXIgLyAweDEwMDAwMDAwMCkgfCAwLCBvZmZzZXQgKyA1KTtcbiAgICBPYmplY3QuYXNzaWduKGVuY29kZSwgeyBieXRlczogOSB9KTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5mdW5jdGlvbiBkZWNvZGUoYnVmZmVyLCBvZmZzZXQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO1xuICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMDtcbiAgY29uc3QgZmlyc3QgPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIC8vIDggYml0XG4gIGlmIChmaXJzdCA8IDB4ZmQpIHtcbiAgICBPYmplY3QuYXNzaWduKGRlY29kZSwgeyBieXRlczogMSB9KTtcbiAgICByZXR1cm4gZmlyc3Q7XG4gICAgLy8gMTYgYml0XG4gIH0gZWxzZSBpZiAoZmlyc3QgPT09IDB4ZmQpIHtcbiAgICBPYmplY3QuYXNzaWduKGRlY29kZSwgeyBieXRlczogMyB9KTtcbiAgICByZXR1cm4gYnVmZmVyLnJlYWRVSW50MTZMRShvZmZzZXQgKyAxKTtcbiAgICAvLyAzMiBiaXRcbiAgfSBlbHNlIGlmIChmaXJzdCA9PT0gMHhmZSkge1xuICAgIE9iamVjdC5hc3NpZ24oZGVjb2RlLCB7IGJ5dGVzOiA1IH0pO1xuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDEpO1xuICAgIC8vIDY0IGJpdFxuICB9IGVsc2Uge1xuICAgIE9iamVjdC5hc3NpZ24oZGVjb2RlLCB7IGJ5dGVzOiA5IH0pO1xuICAgIGNvbnN0IGxvID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyAxKTtcbiAgICBjb25zdCBoaSA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgNSk7XG4gICAgY29uc3QgX251bWJlciA9IGhpICogMHgwMTAwMDAwMDAwICsgbG87XG4gICAgY2hlY2tVSW50NTMoX251bWJlcik7XG4gICAgcmV0dXJuIF9udW1iZXI7XG4gIH1cbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGgoX251bWJlcikge1xuICBjaGVja1VJbnQ1MyhfbnVtYmVyKTtcbiAgcmV0dXJuIF9udW1iZXIgPCAweGZkXG4gICAgPyAxXG4gICAgOiBfbnVtYmVyIDw9IDB4ZmZmZlxuICAgID8gM1xuICAgIDogX251bWJlciA8PSAweGZmZmZmZmZmXG4gICAgPyA1XG4gICAgOiA5O1xufVxuZXhwb3J0cy5lbmNvZGluZ0xlbmd0aCA9IGVuY29kaW5nTGVuZ3RoO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/converter/varint.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/parser/fromBuffer.js":
/*!**********************************************************!*\
  !*** ./node_modules/bip174/src/lib/parser/fromBuffer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst convert = __webpack_require__(/*! ../converter */ \"./node_modules/bip174/src/lib/converter/index.js\");\nconst tools_1 = __webpack_require__(/*! ../converter/tools */ \"./node_modules/bip174/src/lib/converter/tools.js\");\nconst varuint = __webpack_require__(/*! ../converter/varint */ \"./node_modules/bip174/src/lib/converter/varint.js\");\nconst typeFields_1 = __webpack_require__(/*! ../typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nfunction psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n  function varSlice() {\n    const keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    const key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n  function readUInt32BE() {\n    const num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n  function readUInt8() {\n    const num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value,\n    };\n  }\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n    const isEnd = buffer.readUInt8(offset) === 0;\n    if (isEnd) {\n      offset++;\n    }\n    return isEnd;\n  }\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n  if (readUInt8() !== 0xff) {\n    throw new Error(\n      'Format Error: Magic Number must be followed by 0xff separator',\n    );\n  }\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = keyVal.key.toString('hex');\n    if (globalKeyIndex[hexKey]) {\n      throw new Error(\n        'Format Error: Keys must be unique for global keymap: key ' + hexKey,\n      );\n    }\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n  const unsignedTxMaps = globalMapKeyVals.filter(\n    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,\n  );\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n  const unsignedTx = txGetter(unsignedTxMaps[0].value);\n  // Get input and output counts to loop the respective fields\n  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (inputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each input: ' +\n            'input index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n    inputKeyVals.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (outputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each output: ' +\n            'output index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n    outputKeyVals.push(output);\n  }\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals,\n  });\n}\nexports.psbtFromBuffer = psbtFromBuffer;\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(\n      `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,\n    );\n  }\n}\nexports.checkKeyBuffer = checkKeyBuffer;\nfunction psbtFromKeyVals(\n  unsignedTx,\n  { globalMapKeyVals, inputKeyVals, outputKeyVals },\n) {\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx,\n  };\n  let txCount = 0;\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case typeFields_1.GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer(\n          'global',\n          keyVal.key,\n          typeFields_1.GlobalTypes.UNSIGNED_TX,\n        );\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n        txCount++;\n        break;\n      case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  }\n  // Get input and output counts to loop the respective fields\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const input = {};\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.NON_WITNESS_UTXO,\n          );\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error(\n              'Format Error: Input has multiple NON_WITNESS_UTXO',\n            );\n          }\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_UTXO,\n          );\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.SIGHASH_TYPE,\n          );\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.REDEEM_SCRIPT,\n          );\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_SCRIPT,\n          );\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n          input.bip32Derivation.push(\n            convert.inputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTSIG,\n          );\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,\n          );\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(\n            keyVal,\n          );\n          break;\n        case typeFields_1.InputTypes.POR_COMMITMENT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.POR_COMMITMENT,\n          );\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_KEY_SIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_KEY_SIG,\n          );\n          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_SCRIPT_SIG:\n          if (input.tapScriptSig === undefined) {\n            input.tapScriptSig = [];\n          }\n          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:\n          if (input.tapLeafScript === undefined) {\n            input.tapLeafScript = [];\n          }\n          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:\n          if (input.tapBip32Derivation === undefined) {\n            input.tapBip32Derivation = [];\n          }\n          input.tapBip32Derivation.push(\n            convert.inputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_INTERNAL_KEY,\n          );\n          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_MERKLE_ROOT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_MERKLE_ROOT,\n          );\n          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);\n          break;\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n    inputs.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const output = {};\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.REDEEM_SCRIPT,\n          );\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.WITNESS_SCRIPT,\n          );\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n          output.bip32Derivation.push(\n            convert.outputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_INTERNAL_KEY,\n          );\n          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_TREE:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_TREE,\n          );\n          output.tapTree = convert.outputs.tapTree.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:\n          if (output.tapBip32Derivation === undefined) {\n            output.tapBip32Derivation = [];\n          }\n          output.tapBip32Derivation.push(\n            convert.outputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n    outputs.push(output);\n  }\n  return { globalMap, inputs, outputs };\n}\nexports.psbtFromKeyVals = psbtFromKeyVals;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvcGFyc2VyL2Zyb21CdWZmZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLHNFQUFjO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLDRFQUFvQjtBQUM1QyxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBcUI7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsa0VBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0EsK0JBQStCLE1BQU0sT0FBTyx1QkFBdUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxJQUFJLCtDQUErQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLHVCQUF1QiIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9wYXJzZXIvZnJvbUJ1ZmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29udmVydCA9IHJlcXVpcmUoJy4uL2NvbnZlcnRlcicpO1xuY29uc3QgdG9vbHNfMSA9IHJlcXVpcmUoJy4uL2NvbnZlcnRlci90b29scycpO1xuY29uc3QgdmFydWludCA9IHJlcXVpcmUoJy4uL2NvbnZlcnRlci92YXJpbnQnKTtcbmNvbnN0IHR5cGVGaWVsZHNfMSA9IHJlcXVpcmUoJy4uL3R5cGVGaWVsZHMnKTtcbmZ1bmN0aW9uIHBzYnRGcm9tQnVmZmVyKGJ1ZmZlciwgdHhHZXR0ZXIpIHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZ1bmN0aW9uIHZhclNsaWNlKCkge1xuICAgIGNvbnN0IGtleUxlbiA9IHZhcnVpbnQuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gdmFydWludC5lbmNvZGluZ0xlbmd0aChrZXlMZW4pO1xuICAgIGNvbnN0IGtleSA9IGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGtleUxlbik7XG4gICAgb2Zmc2V0ICs9IGtleUxlbjtcbiAgICByZXR1cm4ga2V5O1xuICB9XG4gIGZ1bmN0aW9uIHJlYWRVSW50MzJCRSgpIHtcbiAgICBjb25zdCBudW0gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIG51bTtcbiAgfVxuICBmdW5jdGlvbiByZWFkVUludDgoKSB7XG4gICAgY29uc3QgbnVtID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCArPSAxO1xuICAgIHJldHVybiBudW07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0S2V5VmFsdWUoKSB7XG4gICAgY29uc3Qga2V5ID0gdmFyU2xpY2UoKTtcbiAgICBjb25zdCB2YWx1ZSA9IHZhclNsaWNlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tFbmRPZktleVZhbFBhaXJzKCkge1xuICAgIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IFVuZXhwZWN0ZWQgRW5kIG9mIFBTQlQnKTtcbiAgICB9XG4gICAgY29uc3QgaXNFbmQgPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCkgPT09IDA7XG4gICAgaWYgKGlzRW5kKSB7XG4gICAgICBvZmZzZXQrKztcbiAgICB9XG4gICAgcmV0dXJuIGlzRW5kO1xuICB9XG4gIGlmIChyZWFkVUludDMyQkUoKSAhPT0gMHg3MDczNjI3NCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBJbnZhbGlkIE1hZ2ljIE51bWJlcicpO1xuICB9XG4gIGlmIChyZWFkVUludDgoKSAhPT0gMHhmZikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdGb3JtYXQgRXJyb3I6IE1hZ2ljIE51bWJlciBtdXN0IGJlIGZvbGxvd2VkIGJ5IDB4ZmYgc2VwYXJhdG9yJyxcbiAgICApO1xuICB9XG4gIGNvbnN0IGdsb2JhbE1hcEtleVZhbHMgPSBbXTtcbiAgY29uc3QgZ2xvYmFsS2V5SW5kZXggPSB7fTtcbiAgd2hpbGUgKCFjaGVja0VuZE9mS2V5VmFsUGFpcnMoKSkge1xuICAgIGNvbnN0IGtleVZhbCA9IGdldEtleVZhbHVlKCk7XG4gICAgY29uc3QgaGV4S2V5ID0ga2V5VmFsLmtleS50b1N0cmluZygnaGV4Jyk7XG4gICAgaWYgKGdsb2JhbEtleUluZGV4W2hleEtleV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Zvcm1hdCBFcnJvcjogS2V5cyBtdXN0IGJlIHVuaXF1ZSBmb3IgZ2xvYmFsIGtleW1hcDoga2V5ICcgKyBoZXhLZXksXG4gICAgICApO1xuICAgIH1cbiAgICBnbG9iYWxLZXlJbmRleFtoZXhLZXldID0gMTtcbiAgICBnbG9iYWxNYXBLZXlWYWxzLnB1c2goa2V5VmFsKTtcbiAgfVxuICBjb25zdCB1bnNpZ25lZFR4TWFwcyA9IGdsb2JhbE1hcEtleVZhbHMuZmlsdGVyKFxuICAgIGtleVZhbCA9PiBrZXlWYWwua2V5WzBdID09PSB0eXBlRmllbGRzXzEuR2xvYmFsVHlwZXMuVU5TSUdORURfVFgsXG4gICk7XG4gIGlmICh1bnNpZ25lZFR4TWFwcy5sZW5ndGggIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogT25seSBvbmUgVU5TSUdORURfVFggYWxsb3dlZCcpO1xuICB9XG4gIGNvbnN0IHVuc2lnbmVkVHggPSB0eEdldHRlcih1bnNpZ25lZFR4TWFwc1swXS52YWx1ZSk7XG4gIC8vIEdldCBpbnB1dCBhbmQgb3V0cHV0IGNvdW50cyB0byBsb29wIHRoZSByZXNwZWN0aXZlIGZpZWxkc1xuICBjb25zdCB7IGlucHV0Q291bnQsIG91dHB1dENvdW50IH0gPSB1bnNpZ25lZFR4LmdldElucHV0T3V0cHV0Q291bnRzKCk7XG4gIGNvbnN0IGlucHV0S2V5VmFscyA9IFtdO1xuICBjb25zdCBvdXRwdXRLZXlWYWxzID0gW107XG4gIC8vIEdldCBpbnB1dCBmaWVsZHNcbiAgZm9yIChjb25zdCBpbmRleCBvZiB0b29sc18xLnJhbmdlKGlucHV0Q291bnQpKSB7XG4gICAgY29uc3QgaW5wdXRLZXlJbmRleCA9IHt9O1xuICAgIGNvbnN0IGlucHV0ID0gW107XG4gICAgd2hpbGUgKCFjaGVja0VuZE9mS2V5VmFsUGFpcnMoKSkge1xuICAgICAgY29uc3Qga2V5VmFsID0gZ2V0S2V5VmFsdWUoKTtcbiAgICAgIGNvbnN0IGhleEtleSA9IGtleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgaWYgKGlucHV0S2V5SW5kZXhbaGV4S2V5XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Zvcm1hdCBFcnJvcjogS2V5cyBtdXN0IGJlIHVuaXF1ZSBmb3IgZWFjaCBpbnB1dDogJyArXG4gICAgICAgICAgICAnaW5wdXQgaW5kZXggJyArXG4gICAgICAgICAgICBpbmRleCArXG4gICAgICAgICAgICAnIGtleSAnICtcbiAgICAgICAgICAgIGhleEtleSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlucHV0S2V5SW5kZXhbaGV4S2V5XSA9IDE7XG4gICAgICBpbnB1dC5wdXNoKGtleVZhbCk7XG4gICAgfVxuICAgIGlucHV0S2V5VmFscy5wdXNoKGlucHV0KTtcbiAgfVxuICBmb3IgKGNvbnN0IGluZGV4IG9mIHRvb2xzXzEucmFuZ2Uob3V0cHV0Q291bnQpKSB7XG4gICAgY29uc3Qgb3V0cHV0S2V5SW5kZXggPSB7fTtcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICB3aGlsZSAoIWNoZWNrRW5kT2ZLZXlWYWxQYWlycygpKSB7XG4gICAgICBjb25zdCBrZXlWYWwgPSBnZXRLZXlWYWx1ZSgpO1xuICAgICAgY29uc3QgaGV4S2V5ID0ga2V5VmFsLmtleS50b1N0cmluZygnaGV4Jyk7XG4gICAgICBpZiAob3V0cHV0S2V5SW5kZXhbaGV4S2V5XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Zvcm1hdCBFcnJvcjogS2V5cyBtdXN0IGJlIHVuaXF1ZSBmb3IgZWFjaCBvdXRwdXQ6ICcgK1xuICAgICAgICAgICAgJ291dHB1dCBpbmRleCAnICtcbiAgICAgICAgICAgIGluZGV4ICtcbiAgICAgICAgICAgICcga2V5ICcgK1xuICAgICAgICAgICAgaGV4S2V5LFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgb3V0cHV0S2V5SW5kZXhbaGV4S2V5XSA9IDE7XG4gICAgICBvdXRwdXQucHVzaChrZXlWYWwpO1xuICAgIH1cbiAgICBvdXRwdXRLZXlWYWxzLnB1c2gob3V0cHV0KTtcbiAgfVxuICByZXR1cm4gcHNidEZyb21LZXlWYWxzKHVuc2lnbmVkVHgsIHtcbiAgICBnbG9iYWxNYXBLZXlWYWxzLFxuICAgIGlucHV0S2V5VmFscyxcbiAgICBvdXRwdXRLZXlWYWxzLFxuICB9KTtcbn1cbmV4cG9ydHMucHNidEZyb21CdWZmZXIgPSBwc2J0RnJvbUJ1ZmZlcjtcbmZ1bmN0aW9uIGNoZWNrS2V5QnVmZmVyKHR5cGUsIGtleUJ1Ziwga2V5TnVtKSB7XG4gIGlmICgha2V5QnVmLmVxdWFscyhCdWZmZXIuZnJvbShba2V5TnVtXSkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEZvcm1hdCBFcnJvcjogSW52YWxpZCAke3R5cGV9IGtleTogJHtrZXlCdWYudG9TdHJpbmcoJ2hleCcpfWAsXG4gICAgKTtcbiAgfVxufVxuZXhwb3J0cy5jaGVja0tleUJ1ZmZlciA9IGNoZWNrS2V5QnVmZmVyO1xuZnVuY3Rpb24gcHNidEZyb21LZXlWYWxzKFxuICB1bnNpZ25lZFR4LFxuICB7IGdsb2JhbE1hcEtleVZhbHMsIGlucHV0S2V5VmFscywgb3V0cHV0S2V5VmFscyB9LFxuKSB7XG4gIC8vIFRoYXQgd2FzIGVhc3kgOi0pXG4gIGNvbnN0IGdsb2JhbE1hcCA9IHtcbiAgICB1bnNpZ25lZFR4LFxuICB9O1xuICBsZXQgdHhDb3VudCA9IDA7XG4gIGZvciAoY29uc3Qga2V5VmFsIG9mIGdsb2JhbE1hcEtleVZhbHMpIHtcbiAgICAvLyBJZiBhIGdsb2JhbE1hcCBpdGVtIG5lZWRzIHB1YmtleSwgdW5jb21tZW50XG4gICAgLy8gY29uc3QgcHVia2V5ID0gY29udmVydC5nbG9iYWxzLmNoZWNrUHVia2V5KGtleVZhbCk7XG4gICAgc3dpdGNoIChrZXlWYWwua2V5WzBdKSB7XG4gICAgICBjYXNlIHR5cGVGaWVsZHNfMS5HbG9iYWxUeXBlcy5VTlNJR05FRF9UWDpcbiAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgJ2dsb2JhbCcsXG4gICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICB0eXBlRmllbGRzXzEuR2xvYmFsVHlwZXMuVU5TSUdORURfVFgsXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0eENvdW50ID4gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBHbG9iYWxNYXAgaGFzIG11bHRpcGxlIFVOU0lHTkVEX1RYJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHhDb3VudCsrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHlwZUZpZWxkc18xLkdsb2JhbFR5cGVzLkdMT0JBTF9YUFVCOlxuICAgICAgICBpZiAoZ2xvYmFsTWFwLmdsb2JhbFhwdWIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGdsb2JhbE1hcC5nbG9iYWxYcHViID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsTWFwLmdsb2JhbFhwdWIucHVzaChjb252ZXJ0Lmdsb2JhbHMuZ2xvYmFsWHB1Yi5kZWNvZGUoa2V5VmFsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gVGhpcyB3aWxsIGFsbG93IGluY2x1c2lvbiBkdXJpbmcgc2VyaWFsaXphdGlvbi5cbiAgICAgICAgaWYgKCFnbG9iYWxNYXAudW5rbm93bktleVZhbHMpIGdsb2JhbE1hcC51bmtub3duS2V5VmFscyA9IFtdO1xuICAgICAgICBnbG9iYWxNYXAudW5rbm93bktleVZhbHMucHVzaChrZXlWYWwpO1xuICAgIH1cbiAgfVxuICAvLyBHZXQgaW5wdXQgYW5kIG91dHB1dCBjb3VudHMgdG8gbG9vcCB0aGUgcmVzcGVjdGl2ZSBmaWVsZHNcbiAgY29uc3QgaW5wdXRDb3VudCA9IGlucHV0S2V5VmFscy5sZW5ndGg7XG4gIGNvbnN0IG91dHB1dENvdW50ID0gb3V0cHV0S2V5VmFscy5sZW5ndGg7XG4gIGNvbnN0IGlucHV0cyA9IFtdO1xuICBjb25zdCBvdXRwdXRzID0gW107XG4gIC8vIEdldCBpbnB1dCBmaWVsZHNcbiAgZm9yIChjb25zdCBpbmRleCBvZiB0b29sc18xLnJhbmdlKGlucHV0Q291bnQpKSB7XG4gICAgY29uc3QgaW5wdXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleVZhbCBvZiBpbnB1dEtleVZhbHNbaW5kZXhdKSB7XG4gICAgICBjb252ZXJ0LmlucHV0cy5jaGVja1B1YmtleShrZXlWYWwpO1xuICAgICAgc3dpdGNoIChrZXlWYWwua2V5WzBdKSB7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuTk9OX1dJVE5FU1NfVVRYTzpcbiAgICAgICAgICBjaGVja0tleUJ1ZmZlcihcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuTk9OX1dJVE5FU1NfVVRYTyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdGb3JtYXQgRXJyb3I6IElucHV0IGhhcyBtdWx0aXBsZSBOT05fV0lUTkVTU19VVFhPJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0Lm5vbldpdG5lc3NVdHhvID0gY29udmVydC5pbnB1dHMubm9uV2l0bmVzc1V0eG8uZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuV0lUTkVTU19VVFhPOlxuICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKFxuICAgICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICAgIGtleVZhbC5rZXksXG4gICAgICAgICAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5XSVRORVNTX1VUWE8sXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaW5wdXQud2l0bmVzc1V0eG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IElucHV0IGhhcyBtdWx0aXBsZSBXSVRORVNTX1VUWE8nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQud2l0bmVzc1V0eG8gPSBjb252ZXJ0LmlucHV0cy53aXRuZXNzVXR4by5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5QQVJUSUFMX1NJRzpcbiAgICAgICAgICBpZiAoaW5wdXQucGFydGlhbFNpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnB1dC5wYXJ0aWFsU2lnID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0LnBhcnRpYWxTaWcucHVzaChjb252ZXJ0LmlucHV0cy5wYXJ0aWFsU2lnLmRlY29kZShrZXlWYWwpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5TSUdIQVNIX1RZUEU6XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlNJR0hBU0hfVFlQRSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpbnB1dC5zaWdoYXNoVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogSW5wdXQgaGFzIG11bHRpcGxlIFNJR0hBU0hfVFlQRScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dC5zaWdoYXNoVHlwZSA9IGNvbnZlcnQuaW5wdXRzLnNpZ2hhc2hUeXBlLmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlJFREVFTV9TQ1JJUFQ6XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlJFREVFTV9TQ1JJUFQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaW5wdXQucmVkZWVtU2NyaXB0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IEVycm9yOiBJbnB1dCBoYXMgbXVsdGlwbGUgUkVERUVNX1NDUklQVCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dC5yZWRlZW1TY3JpcHQgPSBjb252ZXJ0LmlucHV0cy5yZWRlZW1TY3JpcHQuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuV0lUTkVTU19TQ1JJUFQ6XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLldJVE5FU1NfU0NSSVBULFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGlucHV0LndpdG5lc3NTY3JpcHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IElucHV0IGhhcyBtdWx0aXBsZSBXSVRORVNTX1NDUklQVCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dC53aXRuZXNzU2NyaXB0ID0gY29udmVydC5pbnB1dHMud2l0bmVzc1NjcmlwdC5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5CSVAzMl9ERVJJVkFUSU9OOlxuICAgICAgICAgIGlmIChpbnB1dC5iaXAzMkRlcml2YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5wdXQuYmlwMzJEZXJpdmF0aW9uID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0LmJpcDMyRGVyaXZhdGlvbi5wdXNoKFxuICAgICAgICAgICAgY29udmVydC5pbnB1dHMuYmlwMzJEZXJpdmF0aW9uLmRlY29kZShrZXlWYWwpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuRklOQUxfU0NSSVBUU0lHOlxuICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKFxuICAgICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICAgIGtleVZhbC5rZXksXG4gICAgICAgICAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5GSU5BTF9TQ1JJUFRTSUcsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbnB1dC5maW5hbFNjcmlwdFNpZyA9IGNvbnZlcnQuaW5wdXRzLmZpbmFsU2NyaXB0U2lnLmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkZJTkFMX1NDUklQVFdJVE5FU1M6XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLkZJTkFMX1NDUklQVFdJVE5FU1MsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3MgPSBjb252ZXJ0LmlucHV0cy5maW5hbFNjcmlwdFdpdG5lc3MuZGVjb2RlKFxuICAgICAgICAgICAga2V5VmFsLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuUE9SX0NPTU1JVE1FTlQ6XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlBPUl9DT01NSVRNRU5ULFxuICAgICAgICAgICk7XG4gICAgICAgICAgaW5wdXQucG9yQ29tbWl0bWVudCA9IGNvbnZlcnQuaW5wdXRzLnBvckNvbW1pdG1lbnQuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0tFWV9TSUc6XG4gICAgICAgICAgY2hlY2tLZXlCdWZmZXIoXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9LRVlfU0lHLFxuICAgICAgICAgICk7XG4gICAgICAgICAgaW5wdXQudGFwS2V5U2lnID0gY29udmVydC5pbnB1dHMudGFwS2V5U2lnLmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9TQ1JJUFRfU0lHOlxuICAgICAgICAgIGlmIChpbnB1dC50YXBTY3JpcHRTaWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5wdXQudGFwU2NyaXB0U2lnID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0LnRhcFNjcmlwdFNpZy5wdXNoKGNvbnZlcnQuaW5wdXRzLnRhcFNjcmlwdFNpZy5kZWNvZGUoa2V5VmFsKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0xFQUZfU0NSSVBUOlxuICAgICAgICAgIGlmIChpbnB1dC50YXBMZWFmU2NyaXB0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlucHV0LnRhcExlYWZTY3JpcHQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQudGFwTGVhZlNjcmlwdC5wdXNoKGNvbnZlcnQuaW5wdXRzLnRhcExlYWZTY3JpcHQuZGVjb2RlKGtleVZhbCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5JbnB1dFR5cGVzLlRBUF9CSVAzMl9ERVJJVkFUSU9OOlxuICAgICAgICAgIGlmIChpbnB1dC50YXBCaXAzMkRlcml2YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5wdXQudGFwQmlwMzJEZXJpdmF0aW9uID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlucHV0LnRhcEJpcDMyRGVyaXZhdGlvbi5wdXNoKFxuICAgICAgICAgICAgY29udmVydC5pbnB1dHMudGFwQmlwMzJEZXJpdmF0aW9uLmRlY29kZShrZXlWYWwpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0lOVEVSTkFMX0tFWTpcbiAgICAgICAgICBjaGVja0tleUJ1ZmZlcihcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX0lOVEVSTkFMX0tFWSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlucHV0LnRhcEludGVybmFsS2V5ID0gY29udmVydC5pbnB1dHMudGFwSW50ZXJuYWxLZXkuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLklucHV0VHlwZXMuVEFQX01FUktMRV9ST09UOlxuICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKFxuICAgICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICAgIGtleVZhbC5rZXksXG4gICAgICAgICAgICB0eXBlRmllbGRzXzEuSW5wdXRUeXBlcy5UQVBfTUVSS0xFX1JPT1QsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpbnB1dC50YXBNZXJrbGVSb290ID0gY29udmVydC5pbnB1dHMudGFwTWVya2xlUm9vdC5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBUaGlzIHdpbGwgYWxsb3cgaW5jbHVzaW9uIGR1cmluZyBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgIGlmICghaW5wdXQudW5rbm93bktleVZhbHMpIGlucHV0LnVua25vd25LZXlWYWxzID0gW107XG4gICAgICAgICAgaW5wdXQudW5rbm93bktleVZhbHMucHVzaChrZXlWYWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnB1dHMucHVzaChpbnB1dCk7XG4gIH1cbiAgZm9yIChjb25zdCBpbmRleCBvZiB0b29sc18xLnJhbmdlKG91dHB1dENvdW50KSkge1xuICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5VmFsIG9mIG91dHB1dEtleVZhbHNbaW5kZXhdKSB7XG4gICAgICBjb252ZXJ0Lm91dHB1dHMuY2hlY2tQdWJrZXkoa2V5VmFsKTtcbiAgICAgIHN3aXRjaCAoa2V5VmFsLmtleVswXSkge1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5SRURFRU1fU0NSSVBUOlxuICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKFxuICAgICAgICAgICAgJ291dHB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlJFREVFTV9TQ1JJUFQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAob3V0cHV0LnJlZGVlbVNjcmlwdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogT3V0cHV0IGhhcyBtdWx0aXBsZSBSRURFRU1fU0NSSVBUJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5yZWRlZW1TY3JpcHQgPSBjb252ZXJ0Lm91dHB1dHMucmVkZWVtU2NyaXB0LmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5XSVRORVNTX1NDUklQVDpcbiAgICAgICAgICBjaGVja0tleUJ1ZmZlcihcbiAgICAgICAgICAgICdvdXRwdXQnLFxuICAgICAgICAgICAga2V5VmFsLmtleSxcbiAgICAgICAgICAgIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5XSVRORVNTX1NDUklQVCxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChvdXRwdXQud2l0bmVzc1NjcmlwdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Zvcm1hdCBFcnJvcjogT3V0cHV0IGhhcyBtdWx0aXBsZSBXSVRORVNTX1NDUklQVCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQud2l0bmVzc1NjcmlwdCA9IGNvbnZlcnQub3V0cHV0cy53aXRuZXNzU2NyaXB0LmRlY29kZShrZXlWYWwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5CSVAzMl9ERVJJVkFUSU9OOlxuICAgICAgICAgIGlmIChvdXRwdXQuYmlwMzJEZXJpdmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG91dHB1dC5iaXAzMkRlcml2YXRpb24gPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0cHV0LmJpcDMyRGVyaXZhdGlvbi5wdXNoKFxuICAgICAgICAgICAgY29udmVydC5vdXRwdXRzLmJpcDMyRGVyaXZhdGlvbi5kZWNvZGUoa2V5VmFsKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHR5cGVGaWVsZHNfMS5PdXRwdXRUeXBlcy5UQVBfSU5URVJOQUxfS0VZOlxuICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKFxuICAgICAgICAgICAgJ291dHB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlRBUF9JTlRFUk5BTF9LRVksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBvdXRwdXQudGFwSW50ZXJuYWxLZXkgPSBjb252ZXJ0Lm91dHB1dHMudGFwSW50ZXJuYWxLZXkuZGVjb2RlKGtleVZhbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlRBUF9UUkVFOlxuICAgICAgICAgIGNoZWNrS2V5QnVmZmVyKFxuICAgICAgICAgICAgJ291dHB1dCcsXG4gICAgICAgICAgICBrZXlWYWwua2V5LFxuICAgICAgICAgICAgdHlwZUZpZWxkc18xLk91dHB1dFR5cGVzLlRBUF9UUkVFLFxuICAgICAgICAgICk7XG4gICAgICAgICAgb3V0cHV0LnRhcFRyZWUgPSBjb252ZXJ0Lm91dHB1dHMudGFwVHJlZS5kZWNvZGUoa2V5VmFsKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB0eXBlRmllbGRzXzEuT3V0cHV0VHlwZXMuVEFQX0JJUDMyX0RFUklWQVRJT046XG4gICAgICAgICAgaWYgKG91dHB1dC50YXBCaXAzMkRlcml2YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3V0cHV0LnRhcEJpcDMyRGVyaXZhdGlvbiA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXRwdXQudGFwQmlwMzJEZXJpdmF0aW9uLnB1c2goXG4gICAgICAgICAgICBjb252ZXJ0Lm91dHB1dHMudGFwQmlwMzJEZXJpdmF0aW9uLmRlY29kZShrZXlWYWwpLFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFvdXRwdXQudW5rbm93bktleVZhbHMpIG91dHB1dC51bmtub3duS2V5VmFscyA9IFtdO1xuICAgICAgICAgIG91dHB1dC51bmtub3duS2V5VmFscy5wdXNoKGtleVZhbCk7XG4gICAgICB9XG4gICAgfVxuICAgIG91dHB1dHMucHVzaChvdXRwdXQpO1xuICB9XG4gIHJldHVybiB7IGdsb2JhbE1hcCwgaW5wdXRzLCBvdXRwdXRzIH07XG59XG5leHBvcnRzLnBzYnRGcm9tS2V5VmFscyA9IHBzYnRGcm9tS2V5VmFscztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/parser/fromBuffer.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/parser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/bip174/src/lib/parser/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nfunction __export(m) {\n  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__export(__webpack_require__(/*! ./fromBuffer */ \"./node_modules/bip174/src/lib/parser/fromBuffer.js\"));\n__export(__webpack_require__(/*! ./toBuffer */ \"./node_modules/bip174/src/lib/parser/toBuffer.js\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvcGFyc2VyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFNBQVMsbUJBQU8sQ0FBQyx3RUFBYztBQUMvQixTQUFTLG1CQUFPLENBQUMsb0VBQVkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvcGFyc2VyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vZnJvbUJ1ZmZlcicpKTtcbl9fZXhwb3J0KHJlcXVpcmUoJy4vdG9CdWZmZXInKSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/parser/index.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/parser/toBuffer.js":
/*!********************************************************!*\
  !*** ./node_modules/bip174/src/lib/parser/toBuffer.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst convert = __webpack_require__(/*! ../converter */ \"./node_modules/bip174/src/lib/converter/index.js\");\nconst tools_1 = __webpack_require__(/*! ../converter/tools */ \"./node_modules/bip174/src/lib/converter/tools.js\");\nfunction psbtToBuffer({ globalMap, inputs, outputs }) {\n  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({\n    globalMap,\n    inputs,\n    outputs,\n  });\n  const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);\n  const keyValsOrEmptyToBuffer = keyVals =>\n    keyVals.length === 0\n      ? [Buffer.from([0])]\n      : keyVals.map(tools_1.keyValsToBuffer);\n  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);\n  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);\n  const header = Buffer.allocUnsafe(5);\n  header.writeUIntBE(0x70736274ff, 0, 5);\n  return Buffer.concat(\n    [header, globalBuffer].concat(inputBuffers, outputBuffers),\n  );\n}\nexports.psbtToBuffer = psbtToBuffer;\nconst sortKeyVals = (a, b) => {\n  return a.key.compare(b.key);\n};\nfunction keyValsFromMap(keyValMap, converterFactory) {\n  const keyHexSet = new Set();\n  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {\n    if (key === 'unknownKeyVals') return result;\n    // We are checking for undefined anyways. So ignore TS error\n    // @ts-ignore\n    const converter = converterFactory[key];\n    if (converter === undefined) return result;\n    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(\n      converter.encode,\n    );\n    const keyHexes = encodedKeyVals.map(kv => kv.key.toString('hex'));\n    keyHexes.forEach(hex => {\n      if (keyHexSet.has(hex))\n        throw new Error('Serialize Error: Duplicate key: ' + hex);\n      keyHexSet.add(hex);\n    });\n    return result.concat(encodedKeyVals);\n  }, []);\n  // Get other keyVals that have not yet been gotten\n  const otherKeyVals = keyValMap.unknownKeyVals\n    ? keyValMap.unknownKeyVals.filter(keyVal => {\n        return !keyHexSet.has(keyVal.key.toString('hex'));\n      })\n    : [];\n  return keyVals.concat(otherKeyVals).sort(sortKeyVals);\n}\nfunction psbtToKeyVals({ globalMap, inputs, outputs }) {\n  // First parse the global keyVals\n  // Get any extra keyvals to pass along\n  return {\n    globalKeyVals: keyValsFromMap(globalMap, convert.globals),\n    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),\n    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),\n  };\n}\nexports.psbtToKeyVals = psbtToKeyVals;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvcGFyc2VyL3RvQnVmZmVyLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBYztBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBb0I7QUFDNUMsd0JBQXdCLDRCQUE0QjtBQUNwRCxVQUFVLDZDQUE2QztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL3BhcnNlci90b0J1ZmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29udmVydCA9IHJlcXVpcmUoJy4uL2NvbnZlcnRlcicpO1xuY29uc3QgdG9vbHNfMSA9IHJlcXVpcmUoJy4uL2NvbnZlcnRlci90b29scycpO1xuZnVuY3Rpb24gcHNidFRvQnVmZmVyKHsgZ2xvYmFsTWFwLCBpbnB1dHMsIG91dHB1dHMgfSkge1xuICBjb25zdCB7IGdsb2JhbEtleVZhbHMsIGlucHV0S2V5VmFscywgb3V0cHV0S2V5VmFscyB9ID0gcHNidFRvS2V5VmFscyh7XG4gICAgZ2xvYmFsTWFwLFxuICAgIGlucHV0cyxcbiAgICBvdXRwdXRzLFxuICB9KTtcbiAgY29uc3QgZ2xvYmFsQnVmZmVyID0gdG9vbHNfMS5rZXlWYWxzVG9CdWZmZXIoZ2xvYmFsS2V5VmFscyk7XG4gIGNvbnN0IGtleVZhbHNPckVtcHR5VG9CdWZmZXIgPSBrZXlWYWxzID0+XG4gICAga2V5VmFscy5sZW5ndGggPT09IDBcbiAgICAgID8gW0J1ZmZlci5mcm9tKFswXSldXG4gICAgICA6IGtleVZhbHMubWFwKHRvb2xzXzEua2V5VmFsc1RvQnVmZmVyKTtcbiAgY29uc3QgaW5wdXRCdWZmZXJzID0ga2V5VmFsc09yRW1wdHlUb0J1ZmZlcihpbnB1dEtleVZhbHMpO1xuICBjb25zdCBvdXRwdXRCdWZmZXJzID0ga2V5VmFsc09yRW1wdHlUb0J1ZmZlcihvdXRwdXRLZXlWYWxzKTtcbiAgY29uc3QgaGVhZGVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDUpO1xuICBoZWFkZXIud3JpdGVVSW50QkUoMHg3MDczNjI3NGZmLCAwLCA1KTtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoXG4gICAgW2hlYWRlciwgZ2xvYmFsQnVmZmVyXS5jb25jYXQoaW5wdXRCdWZmZXJzLCBvdXRwdXRCdWZmZXJzKSxcbiAgKTtcbn1cbmV4cG9ydHMucHNidFRvQnVmZmVyID0gcHNidFRvQnVmZmVyO1xuY29uc3Qgc29ydEtleVZhbHMgPSAoYSwgYikgPT4ge1xuICByZXR1cm4gYS5rZXkuY29tcGFyZShiLmtleSk7XG59O1xuZnVuY3Rpb24ga2V5VmFsc0Zyb21NYXAoa2V5VmFsTWFwLCBjb252ZXJ0ZXJGYWN0b3J5KSB7XG4gIGNvbnN0IGtleUhleFNldCA9IG5ldyBTZXQoKTtcbiAgY29uc3Qga2V5VmFscyA9IE9iamVjdC5lbnRyaWVzKGtleVZhbE1hcCkucmVkdWNlKChyZXN1bHQsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmIChrZXkgPT09ICd1bmtub3duS2V5VmFscycpIHJldHVybiByZXN1bHQ7XG4gICAgLy8gV2UgYXJlIGNoZWNraW5nIGZvciB1bmRlZmluZWQgYW55d2F5cy4gU28gaWdub3JlIFRTIGVycm9yXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGNvbnZlcnRlciA9IGNvbnZlcnRlckZhY3Rvcnlba2V5XTtcbiAgICBpZiAoY29udmVydGVyID09PSB1bmRlZmluZWQpIHJldHVybiByZXN1bHQ7XG4gICAgY29uc3QgZW5jb2RlZEtleVZhbHMgPSAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pLm1hcChcbiAgICAgIGNvbnZlcnRlci5lbmNvZGUsXG4gICAgKTtcbiAgICBjb25zdCBrZXlIZXhlcyA9IGVuY29kZWRLZXlWYWxzLm1hcChrdiA9PiBrdi5rZXkudG9TdHJpbmcoJ2hleCcpKTtcbiAgICBrZXlIZXhlcy5mb3JFYWNoKGhleCA9PiB7XG4gICAgICBpZiAoa2V5SGV4U2V0LmhhcyhoZXgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcmlhbGl6ZSBFcnJvcjogRHVwbGljYXRlIGtleTogJyArIGhleCk7XG4gICAgICBrZXlIZXhTZXQuYWRkKGhleCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoZW5jb2RlZEtleVZhbHMpO1xuICB9LCBbXSk7XG4gIC8vIEdldCBvdGhlciBrZXlWYWxzIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW4gZ290dGVuXG4gIGNvbnN0IG90aGVyS2V5VmFscyA9IGtleVZhbE1hcC51bmtub3duS2V5VmFsc1xuICAgID8ga2V5VmFsTWFwLnVua25vd25LZXlWYWxzLmZpbHRlcihrZXlWYWwgPT4ge1xuICAgICAgICByZXR1cm4gIWtleUhleFNldC5oYXMoa2V5VmFsLmtleS50b1N0cmluZygnaGV4JykpO1xuICAgICAgfSlcbiAgICA6IFtdO1xuICByZXR1cm4ga2V5VmFscy5jb25jYXQob3RoZXJLZXlWYWxzKS5zb3J0KHNvcnRLZXlWYWxzKTtcbn1cbmZ1bmN0aW9uIHBzYnRUb0tleVZhbHMoeyBnbG9iYWxNYXAsIGlucHV0cywgb3V0cHV0cyB9KSB7XG4gIC8vIEZpcnN0IHBhcnNlIHRoZSBnbG9iYWwga2V5VmFsc1xuICAvLyBHZXQgYW55IGV4dHJhIGtleXZhbHMgdG8gcGFzcyBhbG9uZ1xuICByZXR1cm4ge1xuICAgIGdsb2JhbEtleVZhbHM6IGtleVZhbHNGcm9tTWFwKGdsb2JhbE1hcCwgY29udmVydC5nbG9iYWxzKSxcbiAgICBpbnB1dEtleVZhbHM6IGlucHV0cy5tYXAoaSA9PiBrZXlWYWxzRnJvbU1hcChpLCBjb252ZXJ0LmlucHV0cykpLFxuICAgIG91dHB1dEtleVZhbHM6IG91dHB1dHMubWFwKG8gPT4ga2V5VmFsc0Zyb21NYXAobywgY29udmVydC5vdXRwdXRzKSksXG4gIH07XG59XG5leHBvcnRzLnBzYnRUb0tleVZhbHMgPSBwc2J0VG9LZXlWYWxzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/parser/toBuffer.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/psbt.js":
/*!*********************************************!*\
  !*** ./node_modules/bip174/src/lib/psbt.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst combiner_1 = __webpack_require__(/*! ./combiner */ \"./node_modules/bip174/src/lib/combiner/index.js\");\nconst parser_1 = __webpack_require__(/*! ./parser */ \"./node_modules/bip174/src/lib/parser/index.js\");\nconst typeFields_1 = __webpack_require__(/*! ./typeFields */ \"./node_modules/bip174/src/lib/typeFields.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/bip174/src/lib/utils.js\");\nclass Psbt {\n  constructor(tx) {\n    this.inputs = [];\n    this.outputs = [];\n    this.globalMap = {\n      unsignedTx: tx,\n    };\n  }\n  static fromBase64(data, txFromBuffer) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n  static fromHex(data, txFromBuffer) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n  static fromBuffer(buffer, txFromBuffer) {\n    const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);\n    const psbt = new this(results.globalMap.unsignedTx);\n    Object.assign(psbt, results);\n    return psbt;\n  }\n  toBase64() {\n    const buffer = this.toBuffer();\n    return buffer.toString('base64');\n  }\n  toHex() {\n    const buffer = this.toBuffer();\n    return buffer.toString('hex');\n  }\n  toBuffer() {\n    return parser_1.psbtToBuffer(this);\n  }\n  updateGlobal(updateData) {\n    utils_1.updateGlobal(updateData, this.globalMap);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.updateInput(updateData, input);\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const output = utils_1.checkForOutput(this.outputs, outputIndex);\n    utils_1.updateOutput(updateData, output);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    utils_1.checkHasKey(\n      keyVal,\n      this.globalMap.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.GlobalTypes),\n    );\n    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];\n    this.globalMap.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.checkHasKey(\n      keyVal,\n      input.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.InputTypes),\n    );\n    if (!input.unknownKeyVals) input.unknownKeyVals = [];\n    input.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    const output = utils_1.checkForOutput(this.outputs, outputIndex);\n    utils_1.checkHasKey(\n      keyVal,\n      output.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.OutputTypes),\n    );\n    if (!output.unknownKeyVals) output.unknownKeyVals = [];\n    output.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addInput(inputData) {\n    this.globalMap.unsignedTx.addInput(inputData);\n    this.inputs.push({\n      unknownKeyVals: [],\n    });\n    const addKeyVals = inputData.unknownKeyVals || [];\n    const inputIndex = this.inputs.length - 1;\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n    addKeyVals.forEach(keyVal =>\n      this.addUnknownKeyValToInput(inputIndex, keyVal),\n    );\n    utils_1.addInputAttributes(this.inputs, inputData);\n    return this;\n  }\n  addOutput(outputData) {\n    this.globalMap.unsignedTx.addOutput(outputData);\n    this.outputs.push({\n      unknownKeyVals: [],\n    });\n    const addKeyVals = outputData.unknownKeyVals || [];\n    const outputIndex = this.outputs.length - 1;\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n    addKeyVals.forEach(keyVal =>\n      this.addUnknownKeyValToOutput(outputIndex, keyVal),\n    );\n    utils_1.addOutputAttributes(this.outputs, outputData);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.inputCheckUncleanFinalized(inputIndex, input);\n    for (const key of Object.keys(input)) {\n      if (\n        ![\n          'witnessUtxo',\n          'nonWitnessUtxo',\n          'finalScriptSig',\n          'finalScriptWitness',\n          'unknownKeyVals',\n        ].includes(key)\n      ) {\n        // @ts-ignore\n        delete input[key];\n      }\n    }\n    return this;\n  }\n  combine(...those) {\n    // Combine this with those.\n    // Return self for chaining.\n    const result = combiner_1.combine([this].concat(those));\n    Object.assign(this, result);\n    return this;\n  }\n  getTransaction() {\n    return this.globalMap.unsignedTx.toBuffer();\n  }\n}\nexports.Psbt = Psbt;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvcHNidC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLG1CQUFPLENBQUMsbUVBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsK0RBQVU7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMsaUVBQWM7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsdURBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi9wc2J0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb21iaW5lcl8xID0gcmVxdWlyZSgnLi9jb21iaW5lcicpO1xuY29uc3QgcGFyc2VyXzEgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xuY29uc3QgdHlwZUZpZWxkc18xID0gcmVxdWlyZSgnLi90eXBlRmllbGRzJyk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZSgnLi91dGlscycpO1xuY2xhc3MgUHNidCB7XG4gIGNvbnN0cnVjdG9yKHR4KSB7XG4gICAgdGhpcy5pbnB1dHMgPSBbXTtcbiAgICB0aGlzLm91dHB1dHMgPSBbXTtcbiAgICB0aGlzLmdsb2JhbE1hcCA9IHtcbiAgICAgIHVuc2lnbmVkVHg6IHR4LFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGZyb21CYXNlNjQoZGF0YSwgdHhGcm9tQnVmZmVyKSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSwgJ2Jhc2U2NCcpO1xuICAgIHJldHVybiB0aGlzLmZyb21CdWZmZXIoYnVmZmVyLCB0eEZyb21CdWZmZXIpO1xuICB9XG4gIHN0YXRpYyBmcm9tSGV4KGRhdGEsIHR4RnJvbUJ1ZmZlcikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRhdGEsICdoZXgnKTtcbiAgICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyKGJ1ZmZlciwgdHhGcm9tQnVmZmVyKTtcbiAgfVxuICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIHR4RnJvbUJ1ZmZlcikge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBwYXJzZXJfMS5wc2J0RnJvbUJ1ZmZlcihidWZmZXIsIHR4RnJvbUJ1ZmZlcik7XG4gICAgY29uc3QgcHNidCA9IG5ldyB0aGlzKHJlc3VsdHMuZ2xvYmFsTWFwLnVuc2lnbmVkVHgpO1xuICAgIE9iamVjdC5hc3NpZ24ocHNidCwgcmVzdWx0cyk7XG4gICAgcmV0dXJuIHBzYnQ7XG4gIH1cbiAgdG9CYXNlNjQoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy50b0J1ZmZlcigpO1xuICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9XG4gIHRvSGV4KCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuICB0b0J1ZmZlcigpIHtcbiAgICByZXR1cm4gcGFyc2VyXzEucHNidFRvQnVmZmVyKHRoaXMpO1xuICB9XG4gIHVwZGF0ZUdsb2JhbCh1cGRhdGVEYXRhKSB7XG4gICAgdXRpbHNfMS51cGRhdGVHbG9iYWwodXBkYXRlRGF0YSwgdGhpcy5nbG9iYWxNYXApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHVwZGF0ZURhdGEpIHtcbiAgICBjb25zdCBpbnB1dCA9IHV0aWxzXzEuY2hlY2tGb3JJbnB1dCh0aGlzLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgdXRpbHNfMS51cGRhdGVJbnB1dCh1cGRhdGVEYXRhLCBpbnB1dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdXBkYXRlT3V0cHV0KG91dHB1dEluZGV4LCB1cGRhdGVEYXRhKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gdXRpbHNfMS5jaGVja0Zvck91dHB1dCh0aGlzLm91dHB1dHMsIG91dHB1dEluZGV4KTtcbiAgICB1dGlsc18xLnVwZGF0ZU91dHB1dCh1cGRhdGVEYXRhLCBvdXRwdXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZFVua25vd25LZXlWYWxUb0dsb2JhbChrZXlWYWwpIHtcbiAgICB1dGlsc18xLmNoZWNrSGFzS2V5KFxuICAgICAga2V5VmFsLFxuICAgICAgdGhpcy5nbG9iYWxNYXAudW5rbm93bktleVZhbHMsXG4gICAgICB1dGlsc18xLmdldEVudW1MZW5ndGgodHlwZUZpZWxkc18xLkdsb2JhbFR5cGVzKSxcbiAgICApO1xuICAgIGlmICghdGhpcy5nbG9iYWxNYXAudW5rbm93bktleVZhbHMpIHRoaXMuZ2xvYmFsTWFwLnVua25vd25LZXlWYWxzID0gW107XG4gICAgdGhpcy5nbG9iYWxNYXAudW5rbm93bktleVZhbHMucHVzaChrZXlWYWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZFVua25vd25LZXlWYWxUb0lucHV0KGlucHV0SW5kZXgsIGtleVZhbCkge1xuICAgIGNvbnN0IGlucHV0ID0gdXRpbHNfMS5jaGVja0ZvcklucHV0KHRoaXMuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICB1dGlsc18xLmNoZWNrSGFzS2V5KFxuICAgICAga2V5VmFsLFxuICAgICAgaW5wdXQudW5rbm93bktleVZhbHMsXG4gICAgICB1dGlsc18xLmdldEVudW1MZW5ndGgodHlwZUZpZWxkc18xLklucHV0VHlwZXMpLFxuICAgICk7XG4gICAgaWYgKCFpbnB1dC51bmtub3duS2V5VmFscykgaW5wdXQudW5rbm93bktleVZhbHMgPSBbXTtcbiAgICBpbnB1dC51bmtub3duS2V5VmFscy5wdXNoKGtleVZhbCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYWRkVW5rbm93bktleVZhbFRvT3V0cHV0KG91dHB1dEluZGV4LCBrZXlWYWwpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB1dGlsc18xLmNoZWNrRm9yT3V0cHV0KHRoaXMub3V0cHV0cywgb3V0cHV0SW5kZXgpO1xuICAgIHV0aWxzXzEuY2hlY2tIYXNLZXkoXG4gICAgICBrZXlWYWwsXG4gICAgICBvdXRwdXQudW5rbm93bktleVZhbHMsXG4gICAgICB1dGlsc18xLmdldEVudW1MZW5ndGgodHlwZUZpZWxkc18xLk91dHB1dFR5cGVzKSxcbiAgICApO1xuICAgIGlmICghb3V0cHV0LnVua25vd25LZXlWYWxzKSBvdXRwdXQudW5rbm93bktleVZhbHMgPSBbXTtcbiAgICBvdXRwdXQudW5rbm93bktleVZhbHMucHVzaChrZXlWYWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZElucHV0KGlucHV0RGF0YSkge1xuICAgIHRoaXMuZ2xvYmFsTWFwLnVuc2lnbmVkVHguYWRkSW5wdXQoaW5wdXREYXRhKTtcbiAgICB0aGlzLmlucHV0cy5wdXNoKHtcbiAgICAgIHVua25vd25LZXlWYWxzOiBbXSxcbiAgICB9KTtcbiAgICBjb25zdCBhZGRLZXlWYWxzID0gaW5wdXREYXRhLnVua25vd25LZXlWYWxzIHx8IFtdO1xuICAgIGNvbnN0IGlucHV0SW5kZXggPSB0aGlzLmlucHV0cy5sZW5ndGggLSAxO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhZGRLZXlWYWxzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duS2V5VmFscyBtdXN0IGJlIGFuIEFycmF5Jyk7XG4gICAgfVxuICAgIGFkZEtleVZhbHMuZm9yRWFjaChrZXlWYWwgPT5cbiAgICAgIHRoaXMuYWRkVW5rbm93bktleVZhbFRvSW5wdXQoaW5wdXRJbmRleCwga2V5VmFsKSxcbiAgICApO1xuICAgIHV0aWxzXzEuYWRkSW5wdXRBdHRyaWJ1dGVzKHRoaXMuaW5wdXRzLCBpbnB1dERhdGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZE91dHB1dChvdXRwdXREYXRhKSB7XG4gICAgdGhpcy5nbG9iYWxNYXAudW5zaWduZWRUeC5hZGRPdXRwdXQob3V0cHV0RGF0YSk7XG4gICAgdGhpcy5vdXRwdXRzLnB1c2goe1xuICAgICAgdW5rbm93bktleVZhbHM6IFtdLFxuICAgIH0pO1xuICAgIGNvbnN0IGFkZEtleVZhbHMgPSBvdXRwdXREYXRhLnVua25vd25LZXlWYWxzIHx8IFtdO1xuICAgIGNvbnN0IG91dHB1dEluZGV4ID0gdGhpcy5vdXRwdXRzLmxlbmd0aCAtIDE7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFkZEtleVZhbHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd25LZXlWYWxzIG11c3QgYmUgYW4gQXJyYXknKTtcbiAgICB9XG4gICAgYWRkS2V5VmFscy5mb3JFYWNoKGtleVZhbCA9PlxuICAgICAgdGhpcy5hZGRVbmtub3duS2V5VmFsVG9PdXRwdXQob3V0cHV0SW5kZXgsIGtleVZhbCksXG4gICAgKTtcbiAgICB1dGlsc18xLmFkZE91dHB1dEF0dHJpYnV0ZXModGhpcy5vdXRwdXRzLCBvdXRwdXREYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhckZpbmFsaXplZElucHV0KGlucHV0SW5kZXgpIHtcbiAgICBjb25zdCBpbnB1dCA9IHV0aWxzXzEuY2hlY2tGb3JJbnB1dCh0aGlzLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgdXRpbHNfMS5pbnB1dENoZWNrVW5jbGVhbkZpbmFsaXplZChpbnB1dEluZGV4LCBpbnB1dCk7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5wdXQpKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFbXG4gICAgICAgICAgJ3dpdG5lc3NVdHhvJyxcbiAgICAgICAgICAnbm9uV2l0bmVzc1V0eG8nLFxuICAgICAgICAgICdmaW5hbFNjcmlwdFNpZycsXG4gICAgICAgICAgJ2ZpbmFsU2NyaXB0V2l0bmVzcycsXG4gICAgICAgICAgJ3Vua25vd25LZXlWYWxzJyxcbiAgICAgICAgXS5pbmNsdWRlcyhrZXkpXG4gICAgICApIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBkZWxldGUgaW5wdXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29tYmluZSguLi50aG9zZSkge1xuICAgIC8vIENvbWJpbmUgdGhpcyB3aXRoIHRob3NlLlxuICAgIC8vIFJldHVybiBzZWxmIGZvciBjaGFpbmluZy5cbiAgICBjb25zdCByZXN1bHQgPSBjb21iaW5lcl8xLmNvbWJpbmUoW3RoaXNdLmNvbmNhdCh0aG9zZSkpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVzdWx0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nbG9iYWxNYXAudW5zaWduZWRUeC50b0J1ZmZlcigpO1xuICB9XG59XG5leHBvcnRzLlBzYnQgPSBQc2J0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/psbt.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/typeFields.js":
/*!***************************************************!*\
  !*** ./node_modules/bip174/src/lib/typeFields.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar GlobalTypes;\n(function(GlobalTypes) {\n  GlobalTypes[(GlobalTypes['UNSIGNED_TX'] = 0)] = 'UNSIGNED_TX';\n  GlobalTypes[(GlobalTypes['GLOBAL_XPUB'] = 1)] = 'GLOBAL_XPUB';\n})((GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {})));\nexports.GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'];\nvar InputTypes;\n(function(InputTypes) {\n  InputTypes[(InputTypes['NON_WITNESS_UTXO'] = 0)] = 'NON_WITNESS_UTXO';\n  InputTypes[(InputTypes['WITNESS_UTXO'] = 1)] = 'WITNESS_UTXO';\n  InputTypes[(InputTypes['PARTIAL_SIG'] = 2)] = 'PARTIAL_SIG';\n  InputTypes[(InputTypes['SIGHASH_TYPE'] = 3)] = 'SIGHASH_TYPE';\n  InputTypes[(InputTypes['REDEEM_SCRIPT'] = 4)] = 'REDEEM_SCRIPT';\n  InputTypes[(InputTypes['WITNESS_SCRIPT'] = 5)] = 'WITNESS_SCRIPT';\n  InputTypes[(InputTypes['BIP32_DERIVATION'] = 6)] = 'BIP32_DERIVATION';\n  InputTypes[(InputTypes['FINAL_SCRIPTSIG'] = 7)] = 'FINAL_SCRIPTSIG';\n  InputTypes[(InputTypes['FINAL_SCRIPTWITNESS'] = 8)] = 'FINAL_SCRIPTWITNESS';\n  InputTypes[(InputTypes['POR_COMMITMENT'] = 9)] = 'POR_COMMITMENT';\n  InputTypes[(InputTypes['TAP_KEY_SIG'] = 19)] = 'TAP_KEY_SIG';\n  InputTypes[(InputTypes['TAP_SCRIPT_SIG'] = 20)] = 'TAP_SCRIPT_SIG';\n  InputTypes[(InputTypes['TAP_LEAF_SCRIPT'] = 21)] = 'TAP_LEAF_SCRIPT';\n  InputTypes[(InputTypes['TAP_BIP32_DERIVATION'] = 22)] =\n    'TAP_BIP32_DERIVATION';\n  InputTypes[(InputTypes['TAP_INTERNAL_KEY'] = 23)] = 'TAP_INTERNAL_KEY';\n  InputTypes[(InputTypes['TAP_MERKLE_ROOT'] = 24)] = 'TAP_MERKLE_ROOT';\n})((InputTypes = exports.InputTypes || (exports.InputTypes = {})));\nexports.INPUT_TYPE_NAMES = [\n  'nonWitnessUtxo',\n  'witnessUtxo',\n  'partialSig',\n  'sighashType',\n  'redeemScript',\n  'witnessScript',\n  'bip32Derivation',\n  'finalScriptSig',\n  'finalScriptWitness',\n  'porCommitment',\n  'tapKeySig',\n  'tapScriptSig',\n  'tapLeafScript',\n  'tapBip32Derivation',\n  'tapInternalKey',\n  'tapMerkleRoot',\n];\nvar OutputTypes;\n(function(OutputTypes) {\n  OutputTypes[(OutputTypes['REDEEM_SCRIPT'] = 0)] = 'REDEEM_SCRIPT';\n  OutputTypes[(OutputTypes['WITNESS_SCRIPT'] = 1)] = 'WITNESS_SCRIPT';\n  OutputTypes[(OutputTypes['BIP32_DERIVATION'] = 2)] = 'BIP32_DERIVATION';\n  OutputTypes[(OutputTypes['TAP_INTERNAL_KEY'] = 5)] = 'TAP_INTERNAL_KEY';\n  OutputTypes[(OutputTypes['TAP_TREE'] = 6)] = 'TAP_TREE';\n  OutputTypes[(OutputTypes['TAP_BIP32_DERIVATION'] = 7)] =\n    'TAP_BIP32_DERIVATION';\n})((OutputTypes = exports.OutputTypes || (exports.OutputTypes = {})));\nexports.OUTPUT_TYPE_NAMES = [\n  'redeemScript',\n  'witnessScript',\n  'bip32Derivation',\n  'tapInternalKey',\n  'tapTree',\n  'tapBip32Derivation',\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvdHlwZUZpZWxkcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMseUNBQXlDLG1CQUFtQixLQUFLO0FBQ2xFLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUNBQXVDLGtCQUFrQixLQUFLO0FBQy9ELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx5Q0FBeUMsbUJBQW1CLEtBQUs7QUFDbEUseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL2JpcDE3NC9zcmMvbGliL3R5cGVGaWVsZHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBHbG9iYWxUeXBlcztcbihmdW5jdGlvbihHbG9iYWxUeXBlcykge1xuICBHbG9iYWxUeXBlc1soR2xvYmFsVHlwZXNbJ1VOU0lHTkVEX1RYJ10gPSAwKV0gPSAnVU5TSUdORURfVFgnO1xuICBHbG9iYWxUeXBlc1soR2xvYmFsVHlwZXNbJ0dMT0JBTF9YUFVCJ10gPSAxKV0gPSAnR0xPQkFMX1hQVUInO1xufSkoKEdsb2JhbFR5cGVzID0gZXhwb3J0cy5HbG9iYWxUeXBlcyB8fCAoZXhwb3J0cy5HbG9iYWxUeXBlcyA9IHt9KSkpO1xuZXhwb3J0cy5HTE9CQUxfVFlQRV9OQU1FUyA9IFsndW5zaWduZWRUeCcsICdnbG9iYWxYcHViJ107XG52YXIgSW5wdXRUeXBlcztcbihmdW5jdGlvbihJbnB1dFR5cGVzKSB7XG4gIElucHV0VHlwZXNbKElucHV0VHlwZXNbJ05PTl9XSVRORVNTX1VUWE8nXSA9IDApXSA9ICdOT05fV0lUTkVTU19VVFhPJztcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snV0lUTkVTU19VVFhPJ10gPSAxKV0gPSAnV0lUTkVTU19VVFhPJztcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snUEFSVElBTF9TSUcnXSA9IDIpXSA9ICdQQVJUSUFMX1NJRyc7XG4gIElucHV0VHlwZXNbKElucHV0VHlwZXNbJ1NJR0hBU0hfVFlQRSddID0gMyldID0gJ1NJR0hBU0hfVFlQRSc7XG4gIElucHV0VHlwZXNbKElucHV0VHlwZXNbJ1JFREVFTV9TQ1JJUFQnXSA9IDQpXSA9ICdSRURFRU1fU0NSSVBUJztcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snV0lUTkVTU19TQ1JJUFQnXSA9IDUpXSA9ICdXSVRORVNTX1NDUklQVCc7XG4gIElucHV0VHlwZXNbKElucHV0VHlwZXNbJ0JJUDMyX0RFUklWQVRJT04nXSA9IDYpXSA9ICdCSVAzMl9ERVJJVkFUSU9OJztcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snRklOQUxfU0NSSVBUU0lHJ10gPSA3KV0gPSAnRklOQUxfU0NSSVBUU0lHJztcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snRklOQUxfU0NSSVBUV0lUTkVTUyddID0gOCldID0gJ0ZJTkFMX1NDUklQVFdJVE5FU1MnO1xuICBJbnB1dFR5cGVzWyhJbnB1dFR5cGVzWydQT1JfQ09NTUlUTUVOVCddID0gOSldID0gJ1BPUl9DT01NSVRNRU5UJztcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snVEFQX0tFWV9TSUcnXSA9IDE5KV0gPSAnVEFQX0tFWV9TSUcnO1xuICBJbnB1dFR5cGVzWyhJbnB1dFR5cGVzWydUQVBfU0NSSVBUX1NJRyddID0gMjApXSA9ICdUQVBfU0NSSVBUX1NJRyc7XG4gIElucHV0VHlwZXNbKElucHV0VHlwZXNbJ1RBUF9MRUFGX1NDUklQVCddID0gMjEpXSA9ICdUQVBfTEVBRl9TQ1JJUFQnO1xuICBJbnB1dFR5cGVzWyhJbnB1dFR5cGVzWydUQVBfQklQMzJfREVSSVZBVElPTiddID0gMjIpXSA9XG4gICAgJ1RBUF9CSVAzMl9ERVJJVkFUSU9OJztcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snVEFQX0lOVEVSTkFMX0tFWSddID0gMjMpXSA9ICdUQVBfSU5URVJOQUxfS0VZJztcbiAgSW5wdXRUeXBlc1soSW5wdXRUeXBlc1snVEFQX01FUktMRV9ST09UJ10gPSAyNCldID0gJ1RBUF9NRVJLTEVfUk9PVCc7XG59KSgoSW5wdXRUeXBlcyA9IGV4cG9ydHMuSW5wdXRUeXBlcyB8fCAoZXhwb3J0cy5JbnB1dFR5cGVzID0ge30pKSk7XG5leHBvcnRzLklOUFVUX1RZUEVfTkFNRVMgPSBbXG4gICdub25XaXRuZXNzVXR4bycsXG4gICd3aXRuZXNzVXR4bycsXG4gICdwYXJ0aWFsU2lnJyxcbiAgJ3NpZ2hhc2hUeXBlJyxcbiAgJ3JlZGVlbVNjcmlwdCcsXG4gICd3aXRuZXNzU2NyaXB0JyxcbiAgJ2JpcDMyRGVyaXZhdGlvbicsXG4gICdmaW5hbFNjcmlwdFNpZycsXG4gICdmaW5hbFNjcmlwdFdpdG5lc3MnLFxuICAncG9yQ29tbWl0bWVudCcsXG4gICd0YXBLZXlTaWcnLFxuICAndGFwU2NyaXB0U2lnJyxcbiAgJ3RhcExlYWZTY3JpcHQnLFxuICAndGFwQmlwMzJEZXJpdmF0aW9uJyxcbiAgJ3RhcEludGVybmFsS2V5JyxcbiAgJ3RhcE1lcmtsZVJvb3QnLFxuXTtcbnZhciBPdXRwdXRUeXBlcztcbihmdW5jdGlvbihPdXRwdXRUeXBlcykge1xuICBPdXRwdXRUeXBlc1soT3V0cHV0VHlwZXNbJ1JFREVFTV9TQ1JJUFQnXSA9IDApXSA9ICdSRURFRU1fU0NSSVBUJztcbiAgT3V0cHV0VHlwZXNbKE91dHB1dFR5cGVzWydXSVRORVNTX1NDUklQVCddID0gMSldID0gJ1dJVE5FU1NfU0NSSVBUJztcbiAgT3V0cHV0VHlwZXNbKE91dHB1dFR5cGVzWydCSVAzMl9ERVJJVkFUSU9OJ10gPSAyKV0gPSAnQklQMzJfREVSSVZBVElPTic7XG4gIE91dHB1dFR5cGVzWyhPdXRwdXRUeXBlc1snVEFQX0lOVEVSTkFMX0tFWSddID0gNSldID0gJ1RBUF9JTlRFUk5BTF9LRVknO1xuICBPdXRwdXRUeXBlc1soT3V0cHV0VHlwZXNbJ1RBUF9UUkVFJ10gPSA2KV0gPSAnVEFQX1RSRUUnO1xuICBPdXRwdXRUeXBlc1soT3V0cHV0VHlwZXNbJ1RBUF9CSVAzMl9ERVJJVkFUSU9OJ10gPSA3KV0gPVxuICAgICdUQVBfQklQMzJfREVSSVZBVElPTic7XG59KSgoT3V0cHV0VHlwZXMgPSBleHBvcnRzLk91dHB1dFR5cGVzIHx8IChleHBvcnRzLk91dHB1dFR5cGVzID0ge30pKSk7XG5leHBvcnRzLk9VVFBVVF9UWVBFX05BTUVTID0gW1xuICAncmVkZWVtU2NyaXB0JyxcbiAgJ3dpdG5lc3NTY3JpcHQnLFxuICAnYmlwMzJEZXJpdmF0aW9uJyxcbiAgJ3RhcEludGVybmFsS2V5JyxcbiAgJ3RhcFRyZWUnLFxuICAndGFwQmlwMzJEZXJpdmF0aW9uJyxcbl07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/typeFields.js\n"));

/***/ }),

/***/ "./node_modules/bip174/src/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/bip174/src/lib/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst converter = __webpack_require__(/*! ./converter */ \"./node_modules/bip174/src/lib/converter/index.js\");\nfunction checkForInput(inputs, inputIndex) {\n  const input = inputs[inputIndex];\n  if (input === undefined) throw new Error(`No input #${inputIndex}`);\n  return input;\n}\nexports.checkForInput = checkForInput;\nfunction checkForOutput(outputs, outputIndex) {\n  const output = outputs[outputIndex];\n  if (output === undefined) throw new Error(`No output #${outputIndex}`);\n  return output;\n}\nexports.checkForOutput = checkForOutput;\nfunction checkHasKey(checkKeyVal, keyVals, enumLength) {\n  if (checkKeyVal.key[0] < enumLength) {\n    throw new Error(\n      `Use the method for your specific key instead of addUnknownKeyVal*`,\n    );\n  }\n  if (\n    keyVals &&\n    keyVals.filter(kv => kv.key.equals(checkKeyVal.key)).length !== 0\n  ) {\n    throw new Error(`Duplicate Key: ${checkKeyVal.key.toString('hex')}`);\n  }\n}\nexports.checkHasKey = checkHasKey;\nfunction getEnumLength(myenum) {\n  let count = 0;\n  Object.keys(myenum).forEach(val => {\n    if (Number(isNaN(Number(val)))) {\n      count++;\n    }\n  });\n  return count;\n}\nexports.getEnumLength = getEnumLength;\nfunction inputCheckUncleanFinalized(inputIndex, input) {\n  let result = false;\n  if (input.nonWitnessUtxo || input.witnessUtxo) {\n    const needScriptSig = !!input.redeemScript;\n    const needWitnessScript = !!input.witnessScript;\n    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;\n    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;\n    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;\n    result = scriptSigOK && witnessScriptOK && hasOneFinal;\n  }\n  if (result === false) {\n    throw new Error(\n      `Input #${inputIndex} has too much or too little data to clean`,\n    );\n  }\n}\nexports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;\nfunction throwForUpdateMaker(typeName, name, expected, data) {\n  throw new Error(\n    `Data for ${typeName} key ${name} is incorrect: Expected ` +\n      `${expected} and got ${JSON.stringify(data)}`,\n  );\n}\nfunction updateMaker(typeName) {\n  return (updateData, mainData) => {\n    for (const name of Object.keys(updateData)) {\n      // @ts-ignore\n      const data = updateData[name];\n      // @ts-ignore\n      const { canAdd, canAddToArray, check, expected } =\n        // @ts-ignore\n        converter[typeName + 's'][name] || {};\n      const isArray = !!canAddToArray;\n      // If unknown data. ignore and do not add\n      if (check) {\n        if (isArray) {\n          if (\n            !Array.isArray(data) ||\n            // @ts-ignore\n            (mainData[name] && !Array.isArray(mainData[name]))\n          ) {\n            throw new Error(`Key type ${name} must be an array`);\n          }\n          if (!data.every(check)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n          // @ts-ignore\n          const arr = mainData[name] || [];\n          const dupeCheckSet = new Set();\n          if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {\n            throw new Error('Can not add duplicate data to array');\n          }\n          // @ts-ignore\n          mainData[name] = arr.concat(data);\n        } else {\n          if (!check(data)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n          if (!canAdd(mainData, data)) {\n            throw new Error(`Can not add duplicate data to ${typeName}`);\n          }\n          // @ts-ignore\n          mainData[name] = data;\n        }\n      }\n    }\n  };\n}\nexports.updateGlobal = updateMaker('global');\nexports.updateInput = updateMaker('input');\nexports.updateOutput = updateMaker('output');\nfunction addInputAttributes(inputs, data) {\n  const index = inputs.length - 1;\n  const input = checkForInput(inputs, index);\n  exports.updateInput(data, input);\n}\nexports.addInputAttributes = addInputAttributes;\nfunction addOutputAttributes(outputs, data) {\n  const index = outputs.length - 1;\n  const output = checkForOutput(outputs, index);\n  exports.updateOutput(data, output);\n}\nexports.addOutputAttributes = addOutputAttributes;\nfunction defaultVersionSetter(version, txBuf) {\n  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {\n    throw new Error('Set Version: Invalid Transaction');\n  }\n  txBuf.writeUInt32LE(version, 0);\n  return txBuf;\n}\nexports.defaultVersionSetter = defaultVersionSetter;\nfunction defaultLocktimeSetter(locktime, txBuf) {\n  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {\n    throw new Error('Set Locktime: Invalid Transaction');\n  }\n  txBuf.writeUInt32LE(locktime, txBuf.length - 4);\n  return txBuf;\n}\nexports.defaultLocktimeSetter = defaultLocktimeSetter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlwMTc0L3NyYy9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLHFFQUFhO0FBQ3ZDO0FBQ0E7QUFDQSx3REFBd0QsV0FBVztBQUNuRTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwwREFBMEQsWUFBWTtBQUN0RTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdDQUFnQztBQUN0RTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsZ0JBQWdCLFVBQVUsTUFBTSxNQUFNO0FBQ3RDLFNBQVMsVUFBVSxVQUFVLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5Q0FBeUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxPQUFPLE1BQU07QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsT0FBTyxNQUFNO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXAxNzQvc3JjL2xpYi91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29udmVydGVyID0gcmVxdWlyZSgnLi9jb252ZXJ0ZXInKTtcbmZ1bmN0aW9uIGNoZWNrRm9ySW5wdXQoaW5wdXRzLCBpbnB1dEluZGV4KSB7XG4gIGNvbnN0IGlucHV0ID0gaW5wdXRzW2lucHV0SW5kZXhdO1xuICBpZiAoaW5wdXQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBObyBpbnB1dCAjJHtpbnB1dEluZGV4fWApO1xuICByZXR1cm4gaW5wdXQ7XG59XG5leHBvcnRzLmNoZWNrRm9ySW5wdXQgPSBjaGVja0ZvcklucHV0O1xuZnVuY3Rpb24gY2hlY2tGb3JPdXRwdXQob3V0cHV0cywgb3V0cHV0SW5kZXgpIHtcbiAgY29uc3Qgb3V0cHV0ID0gb3V0cHV0c1tvdXRwdXRJbmRleF07XG4gIGlmIChvdXRwdXQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBObyBvdXRwdXQgIyR7b3V0cHV0SW5kZXh9YCk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5leHBvcnRzLmNoZWNrRm9yT3V0cHV0ID0gY2hlY2tGb3JPdXRwdXQ7XG5mdW5jdGlvbiBjaGVja0hhc0tleShjaGVja0tleVZhbCwga2V5VmFscywgZW51bUxlbmd0aCkge1xuICBpZiAoY2hlY2tLZXlWYWwua2V5WzBdIDwgZW51bUxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVc2UgdGhlIG1ldGhvZCBmb3IgeW91ciBzcGVjaWZpYyBrZXkgaW5zdGVhZCBvZiBhZGRVbmtub3duS2V5VmFsKmAsXG4gICAgKTtcbiAgfVxuICBpZiAoXG4gICAga2V5VmFscyAmJlxuICAgIGtleVZhbHMuZmlsdGVyKGt2ID0+IGt2LmtleS5lcXVhbHMoY2hlY2tLZXlWYWwua2V5KSkubGVuZ3RoICE9PSAwXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIEtleTogJHtjaGVja0tleVZhbC5rZXkudG9TdHJpbmcoJ2hleCcpfWApO1xuICB9XG59XG5leHBvcnRzLmNoZWNrSGFzS2V5ID0gY2hlY2tIYXNLZXk7XG5mdW5jdGlvbiBnZXRFbnVtTGVuZ3RoKG15ZW51bSkge1xuICBsZXQgY291bnQgPSAwO1xuICBPYmplY3Qua2V5cyhteWVudW0pLmZvckVhY2godmFsID0+IHtcbiAgICBpZiAoTnVtYmVyKGlzTmFOKE51bWJlcih2YWwpKSkpIHtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNvdW50O1xufVxuZXhwb3J0cy5nZXRFbnVtTGVuZ3RoID0gZ2V0RW51bUxlbmd0aDtcbmZ1bmN0aW9uIGlucHV0Q2hlY2tVbmNsZWFuRmluYWxpemVkKGlucHV0SW5kZXgsIGlucHV0KSB7XG4gIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKGlucHV0Lm5vbldpdG5lc3NVdHhvIHx8IGlucHV0LndpdG5lc3NVdHhvKSB7XG4gICAgY29uc3QgbmVlZFNjcmlwdFNpZyA9ICEhaW5wdXQucmVkZWVtU2NyaXB0O1xuICAgIGNvbnN0IG5lZWRXaXRuZXNzU2NyaXB0ID0gISFpbnB1dC53aXRuZXNzU2NyaXB0O1xuICAgIGNvbnN0IHNjcmlwdFNpZ09LID0gIW5lZWRTY3JpcHRTaWcgfHwgISFpbnB1dC5maW5hbFNjcmlwdFNpZztcbiAgICBjb25zdCB3aXRuZXNzU2NyaXB0T0sgPSAhbmVlZFdpdG5lc3NTY3JpcHQgfHwgISFpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3M7XG4gICAgY29uc3QgaGFzT25lRmluYWwgPSAhIWlucHV0LmZpbmFsU2NyaXB0U2lnIHx8ICEhaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzO1xuICAgIHJlc3VsdCA9IHNjcmlwdFNpZ09LICYmIHdpdG5lc3NTY3JpcHRPSyAmJiBoYXNPbmVGaW5hbDtcbiAgfVxuICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnB1dCAjJHtpbnB1dEluZGV4fSBoYXMgdG9vIG11Y2ggb3IgdG9vIGxpdHRsZSBkYXRhIHRvIGNsZWFuYCxcbiAgICApO1xuICB9XG59XG5leHBvcnRzLmlucHV0Q2hlY2tVbmNsZWFuRmluYWxpemVkID0gaW5wdXRDaGVja1VuY2xlYW5GaW5hbGl6ZWQ7XG5mdW5jdGlvbiB0aHJvd0ZvclVwZGF0ZU1ha2VyKHR5cGVOYW1lLCBuYW1lLCBleHBlY3RlZCwgZGF0YSkge1xuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYERhdGEgZm9yICR7dHlwZU5hbWV9IGtleSAke25hbWV9IGlzIGluY29ycmVjdDogRXhwZWN0ZWQgYCArXG4gICAgICBgJHtleHBlY3RlZH0gYW5kIGdvdCAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWAsXG4gICk7XG59XG5mdW5jdGlvbiB1cGRhdGVNYWtlcih0eXBlTmFtZSkge1xuICByZXR1cm4gKHVwZGF0ZURhdGEsIG1haW5EYXRhKSA9PiB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKHVwZGF0ZURhdGEpKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBkYXRhID0gdXBkYXRlRGF0YVtuYW1lXTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHsgY2FuQWRkLCBjYW5BZGRUb0FycmF5LCBjaGVjaywgZXhwZWN0ZWQgfSA9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29udmVydGVyW3R5cGVOYW1lICsgJ3MnXVtuYW1lXSB8fCB7fTtcbiAgICAgIGNvbnN0IGlzQXJyYXkgPSAhIWNhbkFkZFRvQXJyYXk7XG4gICAgICAvLyBJZiB1bmtub3duIGRhdGEuIGlnbm9yZSBhbmQgZG8gbm90IGFkZFxuICAgICAgaWYgKGNoZWNrKSB7XG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoZGF0YSkgfHxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIChtYWluRGF0YVtuYW1lXSAmJiAhQXJyYXkuaXNBcnJheShtYWluRGF0YVtuYW1lXSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSB0eXBlICR7bmFtZX0gbXVzdCBiZSBhbiBhcnJheWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWRhdGEuZXZlcnkoY2hlY2spKSB7XG4gICAgICAgICAgICB0aHJvd0ZvclVwZGF0ZU1ha2VyKHR5cGVOYW1lLCBuYW1lLCBleHBlY3RlZCwgZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjb25zdCBhcnIgPSBtYWluRGF0YVtuYW1lXSB8fCBbXTtcbiAgICAgICAgICBjb25zdCBkdXBlQ2hlY2tTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgaWYgKCFkYXRhLmV2ZXJ5KHYgPT4gY2FuQWRkVG9BcnJheShhcnIsIHYsIGR1cGVDaGVja1NldCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWRkIGR1cGxpY2F0ZSBkYXRhIHRvIGFycmF5Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBtYWluRGF0YVtuYW1lXSA9IGFyci5jb25jYXQoZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjaGVjayhkYXRhKSkge1xuICAgICAgICAgICAgdGhyb3dGb3JVcGRhdGVNYWtlcih0eXBlTmFtZSwgbmFtZSwgZXhwZWN0ZWQsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNhbkFkZChtYWluRGF0YSwgZGF0YSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG5vdCBhZGQgZHVwbGljYXRlIGRhdGEgdG8gJHt0eXBlTmFtZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIG1haW5EYXRhW25hbWVdID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmV4cG9ydHMudXBkYXRlR2xvYmFsID0gdXBkYXRlTWFrZXIoJ2dsb2JhbCcpO1xuZXhwb3J0cy51cGRhdGVJbnB1dCA9IHVwZGF0ZU1ha2VyKCdpbnB1dCcpO1xuZXhwb3J0cy51cGRhdGVPdXRwdXQgPSB1cGRhdGVNYWtlcignb3V0cHV0Jyk7XG5mdW5jdGlvbiBhZGRJbnB1dEF0dHJpYnV0ZXMoaW5wdXRzLCBkYXRhKSB7XG4gIGNvbnN0IGluZGV4ID0gaW5wdXRzLmxlbmd0aCAtIDE7XG4gIGNvbnN0IGlucHV0ID0gY2hlY2tGb3JJbnB1dChpbnB1dHMsIGluZGV4KTtcbiAgZXhwb3J0cy51cGRhdGVJbnB1dChkYXRhLCBpbnB1dCk7XG59XG5leHBvcnRzLmFkZElucHV0QXR0cmlidXRlcyA9IGFkZElucHV0QXR0cmlidXRlcztcbmZ1bmN0aW9uIGFkZE91dHB1dEF0dHJpYnV0ZXMob3V0cHV0cywgZGF0YSkge1xuICBjb25zdCBpbmRleCA9IG91dHB1dHMubGVuZ3RoIC0gMTtcbiAgY29uc3Qgb3V0cHV0ID0gY2hlY2tGb3JPdXRwdXQob3V0cHV0cywgaW5kZXgpO1xuICBleHBvcnRzLnVwZGF0ZU91dHB1dChkYXRhLCBvdXRwdXQpO1xufVxuZXhwb3J0cy5hZGRPdXRwdXRBdHRyaWJ1dGVzID0gYWRkT3V0cHV0QXR0cmlidXRlcztcbmZ1bmN0aW9uIGRlZmF1bHRWZXJzaW9uU2V0dGVyKHZlcnNpb24sIHR4QnVmKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHR4QnVmKSB8fCB0eEJ1Zi5sZW5ndGggPCA0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTZXQgVmVyc2lvbjogSW52YWxpZCBUcmFuc2FjdGlvbicpO1xuICB9XG4gIHR4QnVmLndyaXRlVUludDMyTEUodmVyc2lvbiwgMCk7XG4gIHJldHVybiB0eEJ1Zjtcbn1cbmV4cG9ydHMuZGVmYXVsdFZlcnNpb25TZXR0ZXIgPSBkZWZhdWx0VmVyc2lvblNldHRlcjtcbmZ1bmN0aW9uIGRlZmF1bHRMb2NrdGltZVNldHRlcihsb2NrdGltZSwgdHhCdWYpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodHhCdWYpIHx8IHR4QnVmLmxlbmd0aCA8IDQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NldCBMb2NrdGltZTogSW52YWxpZCBUcmFuc2FjdGlvbicpO1xuICB9XG4gIHR4QnVmLndyaXRlVUludDMyTEUobG9ja3RpbWUsIHR4QnVmLmxlbmd0aCAtIDQpO1xuICByZXR1cm4gdHhCdWY7XG59XG5leHBvcnRzLmRlZmF1bHRMb2NrdGltZVNldHRlciA9IGRlZmF1bHRMb2NrdGltZVNldHRlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bip174/src/lib/utils.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/address.js":
/*!***************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/address.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toOutputScript =\n  exports.fromOutputScript =\n  exports.toBech32 =\n  exports.toBase58Check =\n  exports.fromBech32 =\n  exports.fromBase58Check =\n    void 0;\nconst networks = __webpack_require__(/*! ./networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\");\nconst payments = __webpack_require__(/*! ./payments */ \"./node_modules/bitcoinjs-lib/src/payments/index.js\");\nconst bscript = __webpack_require__(/*! ./script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst bech32_1 = __webpack_require__(/*! bech32 */ \"./node_modules/bech32/dist/index.js\");\nconst bs58check = __webpack_require__(/*! bs58check */ \"./node_modules/bs58check/index.js\");\nconst FUTURE_SEGWIT_MAX_SIZE = 40;\nconst FUTURE_SEGWIT_MIN_SIZE = 2;\nconst FUTURE_SEGWIT_MAX_VERSION = 16;\nconst FUTURE_SEGWIT_MIN_VERSION = 2;\nconst FUTURE_SEGWIT_VERSION_DIFF = 0x50;\nconst FUTURE_SEGWIT_VERSION_WARNING =\n  'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +\n  'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +\n  'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +\n  'then decide when it is safe to use which version of segwit.';\nfunction _toFutureSegwitAddress(output, network) {\n  const data = output.slice(2);\n  if (\n    data.length < FUTURE_SEGWIT_MIN_SIZE ||\n    data.length > FUTURE_SEGWIT_MAX_SIZE\n  )\n    throw new TypeError('Invalid program length for segwit address');\n  const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;\n  if (\n    version < FUTURE_SEGWIT_MIN_VERSION ||\n    version > FUTURE_SEGWIT_MAX_VERSION\n  )\n    throw new TypeError('Invalid version for segwit address');\n  if (output[1] !== data.length)\n    throw new TypeError('Invalid script for segwit address');\n  console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n  return toBech32(data, version, network.bech32);\n}\n/**\n * decode address with base58 specification,  return address version and address hash if valid\n */\nfunction fromBase58Check(address) {\n  const payload = Buffer.from(bs58check.decode(address));\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return { version, hash };\n}\nexports.fromBase58Check = fromBase58Check;\n/**\n * decode address with bech32 specification,  return address version、address prefix and address data if valid\n */\nfunction fromBech32(address) {\n  let result;\n  let version;\n  try {\n    result = bech32_1.bech32.decode(address);\n  } catch (e) {}\n  if (result) {\n    version = result.words[0];\n    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');\n  } else {\n    result = bech32_1.bech32m.decode(address);\n    version = result.words[0];\n    if (version === 0) throw new TypeError(address + ' uses wrong encoding');\n  }\n  const data = bech32_1.bech32.fromWords(result.words.slice(1));\n  return {\n    version,\n    prefix: result.prefix,\n    data: Buffer.from(data),\n  };\n}\nexports.fromBech32 = fromBech32;\n/**\n * encode address hash to base58 address with version\n */\nfunction toBase58Check(hash, version) {\n  (0, types_1.typeforce)(\n    (0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8),\n    arguments,\n  );\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\nexports.toBase58Check = toBase58Check;\n/**\n * encode address hash to bech32 address with version and prefix\n */\nfunction toBech32(data, version, prefix) {\n  const words = bech32_1.bech32.toWords(data);\n  words.unshift(version);\n  return version === 0\n    ? bech32_1.bech32.encode(prefix, words)\n    : bech32_1.bech32m.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\n/**\n * decode address from output script with network, return address if matched\n */\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2tr({ output, network }).address;\n  } catch (e) {}\n  try {\n    return _toFutureSegwitAddress(output, network);\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\nexports.fromOutputScript = fromOutputScript;\n/**\n * encodes address to output script with network, return output script if address matched\n */\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      } else if (decodeBech32.version === 1) {\n        if (decodeBech32.data.length === 32)\n          return payments.p2tr({ pubkey: decodeBech32.data }).output;\n      } else if (\n        decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&\n        decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&\n        decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&\n        decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE\n      ) {\n        console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n        return bscript.compile([\n          decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,\n          decodeBech32.data,\n        ]);\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\nexports.toOutputScript = toOutputScript;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLEVBQUUsd0JBQXdCO0FBQzFCLEVBQUUsZ0JBQWdCO0FBQ2xCLEVBQUUscUJBQXFCO0FBQ3ZCLEVBQUUsa0JBQWtCO0FBQ3BCLEVBQUUsdUJBQXVCO0FBQ3pCO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsZ0VBQVk7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsc0VBQVk7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsNERBQVU7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsMERBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsbURBQVE7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsb0RBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0MsSUFBSTtBQUNKO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QyxJQUFJO0FBQ0o7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDLElBQUk7QUFDSjtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0MsSUFBSTtBQUNKO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QyxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBLDZCQUE2Qix5QkFBeUI7QUFDdEQsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5QkFBeUI7QUFDNUQ7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNELFFBQVE7QUFDUjtBQUNBLGlDQUFpQywyQkFBMkI7QUFDNUQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9hZGRyZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRvT3V0cHV0U2NyaXB0ID1cbiAgZXhwb3J0cy5mcm9tT3V0cHV0U2NyaXB0ID1cbiAgZXhwb3J0cy50b0JlY2gzMiA9XG4gIGV4cG9ydHMudG9CYXNlNThDaGVjayA9XG4gIGV4cG9ydHMuZnJvbUJlY2gzMiA9XG4gIGV4cG9ydHMuZnJvbUJhc2U1OENoZWNrID1cbiAgICB2b2lkIDA7XG5jb25zdCBuZXR3b3JrcyA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcbmNvbnN0IHBheW1lbnRzID0gcmVxdWlyZSgnLi9wYXltZW50cycpO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgYmVjaDMyXzEgPSByZXF1aXJlKCdiZWNoMzInKTtcbmNvbnN0IGJzNThjaGVjayA9IHJlcXVpcmUoJ2JzNThjaGVjaycpO1xuY29uc3QgRlVUVVJFX1NFR1dJVF9NQVhfU0laRSA9IDQwO1xuY29uc3QgRlVUVVJFX1NFR1dJVF9NSU5fU0laRSA9IDI7XG5jb25zdCBGVVRVUkVfU0VHV0lUX01BWF9WRVJTSU9OID0gMTY7XG5jb25zdCBGVVRVUkVfU0VHV0lUX01JTl9WRVJTSU9OID0gMjtcbmNvbnN0IEZVVFVSRV9TRUdXSVRfVkVSU0lPTl9ESUZGID0gMHg1MDtcbmNvbnN0IEZVVFVSRV9TRUdXSVRfVkVSU0lPTl9XQVJOSU5HID1cbiAgJ1dBUk5JTkc6IFNlbmRpbmcgdG8gYSBmdXR1cmUgc2Vnd2l0IHZlcnNpb24gYWRkcmVzcyBjYW4gbGVhZCB0byBsb3NzIG9mIGZ1bmRzLiAnICtcbiAgJ0VuZCB1c2VycyBNVVNUIGJlIHdhcm5lZCBjYXJlZnVsbHkgaW4gdGhlIEdVSSBhbmQgYXNrZWQgaWYgdGhleSB3aXNoIHRvIHByb2NlZWQgJyArXG4gICd3aXRoIGNhdXRpb24uIFdhbGxldHMgc2hvdWxkIHZlcmlmeSB0aGUgc2Vnd2l0IHZlcnNpb24gZnJvbSB0aGUgb3V0cHV0IG9mIGZyb21CZWNoMzIsICcgK1xuICAndGhlbiBkZWNpZGUgd2hlbiBpdCBpcyBzYWZlIHRvIHVzZSB3aGljaCB2ZXJzaW9uIG9mIHNlZ3dpdC4nO1xuZnVuY3Rpb24gX3RvRnV0dXJlU2Vnd2l0QWRkcmVzcyhvdXRwdXQsIG5ldHdvcmspIHtcbiAgY29uc3QgZGF0YSA9IG91dHB1dC5zbGljZSgyKTtcbiAgaWYgKFxuICAgIGRhdGEubGVuZ3RoIDwgRlVUVVJFX1NFR1dJVF9NSU5fU0laRSB8fFxuICAgIGRhdGEubGVuZ3RoID4gRlVUVVJFX1NFR1dJVF9NQVhfU0laRVxuICApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwcm9ncmFtIGxlbmd0aCBmb3Igc2Vnd2l0IGFkZHJlc3MnKTtcbiAgY29uc3QgdmVyc2lvbiA9IG91dHB1dFswXSAtIEZVVFVSRV9TRUdXSVRfVkVSU0lPTl9ESUZGO1xuICBpZiAoXG4gICAgdmVyc2lvbiA8IEZVVFVSRV9TRUdXSVRfTUlOX1ZFUlNJT04gfHxcbiAgICB2ZXJzaW9uID4gRlVUVVJFX1NFR1dJVF9NQVhfVkVSU0lPTlxuICApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB2ZXJzaW9uIGZvciBzZWd3aXQgYWRkcmVzcycpO1xuICBpZiAob3V0cHV0WzFdICE9PSBkYXRhLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHNjcmlwdCBmb3Igc2Vnd2l0IGFkZHJlc3MnKTtcbiAgY29uc29sZS53YXJuKEZVVFVSRV9TRUdXSVRfVkVSU0lPTl9XQVJOSU5HKTtcbiAgcmV0dXJuIHRvQmVjaDMyKGRhdGEsIHZlcnNpb24sIG5ldHdvcmsuYmVjaDMyKTtcbn1cbi8qKlxuICogZGVjb2RlIGFkZHJlc3Mgd2l0aCBiYXNlNTggc3BlY2lmaWNhdGlvbiwgIHJldHVybiBhZGRyZXNzIHZlcnNpb24gYW5kIGFkZHJlc3MgaGFzaCBpZiB2YWxpZFxuICovXG5mdW5jdGlvbiBmcm9tQmFzZTU4Q2hlY2soYWRkcmVzcykge1xuICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmZyb20oYnM1OGNoZWNrLmRlY29kZShhZGRyZXNzKSk7XG4gIC8vIFRPRE86IDQuMC4wLCBtb3ZlIHRvIFwidG9PdXRwdXRTY3JpcHRcIlxuICBpZiAocGF5bG9hZC5sZW5ndGggPCAyMSkgdGhyb3cgbmV3IFR5cGVFcnJvcihhZGRyZXNzICsgJyBpcyB0b28gc2hvcnQnKTtcbiAgaWYgKHBheWxvYWQubGVuZ3RoID4gMjEpIHRocm93IG5ldyBUeXBlRXJyb3IoYWRkcmVzcyArICcgaXMgdG9vIGxvbmcnKTtcbiAgY29uc3QgdmVyc2lvbiA9IHBheWxvYWQucmVhZFVJbnQ4KDApO1xuICBjb25zdCBoYXNoID0gcGF5bG9hZC5zbGljZSgxKTtcbiAgcmV0dXJuIHsgdmVyc2lvbiwgaGFzaCB9O1xufVxuZXhwb3J0cy5mcm9tQmFzZTU4Q2hlY2sgPSBmcm9tQmFzZTU4Q2hlY2s7XG4vKipcbiAqIGRlY29kZSBhZGRyZXNzIHdpdGggYmVjaDMyIHNwZWNpZmljYXRpb24sICByZXR1cm4gYWRkcmVzcyB2ZXJzaW9u44CBYWRkcmVzcyBwcmVmaXggYW5kIGFkZHJlc3MgZGF0YSBpZiB2YWxpZFxuICovXG5mdW5jdGlvbiBmcm9tQmVjaDMyKGFkZHJlc3MpIHtcbiAgbGV0IHJlc3VsdDtcbiAgbGV0IHZlcnNpb247XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gYmVjaDMyXzEuYmVjaDMyLmRlY29kZShhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZSkge31cbiAgaWYgKHJlc3VsdCkge1xuICAgIHZlcnNpb24gPSByZXN1bHQud29yZHNbMF07XG4gICAgaWYgKHZlcnNpb24gIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoYWRkcmVzcyArICcgdXNlcyB3cm9uZyBlbmNvZGluZycpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGJlY2gzMl8xLmJlY2gzMm0uZGVjb2RlKGFkZHJlc3MpO1xuICAgIHZlcnNpb24gPSByZXN1bHQud29yZHNbMF07XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoYWRkcmVzcyArICcgdXNlcyB3cm9uZyBlbmNvZGluZycpO1xuICB9XG4gIGNvbnN0IGRhdGEgPSBiZWNoMzJfMS5iZWNoMzIuZnJvbVdvcmRzKHJlc3VsdC53b3Jkcy5zbGljZSgxKSk7XG4gIHJldHVybiB7XG4gICAgdmVyc2lvbixcbiAgICBwcmVmaXg6IHJlc3VsdC5wcmVmaXgsXG4gICAgZGF0YTogQnVmZmVyLmZyb20oZGF0YSksXG4gIH07XG59XG5leHBvcnRzLmZyb21CZWNoMzIgPSBmcm9tQmVjaDMyO1xuLyoqXG4gKiBlbmNvZGUgYWRkcmVzcyBoYXNoIHRvIGJhc2U1OCBhZGRyZXNzIHdpdGggdmVyc2lvblxuICovXG5mdW5jdGlvbiB0b0Jhc2U1OENoZWNrKGhhc2gsIHZlcnNpb24pIHtcbiAgKDAsIHR5cGVzXzEudHlwZWZvcmNlKShcbiAgICAoMCwgdHlwZXNfMS50dXBsZSkodHlwZXNfMS5IYXNoMTYwYml0LCB0eXBlc18xLlVJbnQ4KSxcbiAgICBhcmd1bWVudHMsXG4gICk7XG4gIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjEpO1xuICBwYXlsb2FkLndyaXRlVUludDgodmVyc2lvbiwgMCk7XG4gIGhhc2guY29weShwYXlsb2FkLCAxKTtcbiAgcmV0dXJuIGJzNThjaGVjay5lbmNvZGUocGF5bG9hZCk7XG59XG5leHBvcnRzLnRvQmFzZTU4Q2hlY2sgPSB0b0Jhc2U1OENoZWNrO1xuLyoqXG4gKiBlbmNvZGUgYWRkcmVzcyBoYXNoIHRvIGJlY2gzMiBhZGRyZXNzIHdpdGggdmVyc2lvbiBhbmQgcHJlZml4XG4gKi9cbmZ1bmN0aW9uIHRvQmVjaDMyKGRhdGEsIHZlcnNpb24sIHByZWZpeCkge1xuICBjb25zdCB3b3JkcyA9IGJlY2gzMl8xLmJlY2gzMi50b1dvcmRzKGRhdGEpO1xuICB3b3Jkcy51bnNoaWZ0KHZlcnNpb24pO1xuICByZXR1cm4gdmVyc2lvbiA9PT0gMFxuICAgID8gYmVjaDMyXzEuYmVjaDMyLmVuY29kZShwcmVmaXgsIHdvcmRzKVxuICAgIDogYmVjaDMyXzEuYmVjaDMybS5lbmNvZGUocHJlZml4LCB3b3Jkcyk7XG59XG5leHBvcnRzLnRvQmVjaDMyID0gdG9CZWNoMzI7XG4vKipcbiAqIGRlY29kZSBhZGRyZXNzIGZyb20gb3V0cHV0IHNjcmlwdCB3aXRoIG5ldHdvcmssIHJldHVybiBhZGRyZXNzIGlmIG1hdGNoZWRcbiAqL1xuZnVuY3Rpb24gZnJvbU91dHB1dFNjcmlwdChvdXRwdXQsIG5ldHdvcmspIHtcbiAgLy8gVE9ETzogTmV0d29ya1xuICBuZXR3b3JrID0gbmV0d29yayB8fCBuZXR3b3Jrcy5iaXRjb2luO1xuICB0cnkge1xuICAgIHJldHVybiBwYXltZW50cy5wMnBraCh7IG91dHB1dCwgbmV0d29yayB9KS5hZGRyZXNzO1xuICB9IGNhdGNoIChlKSB7fVxuICB0cnkge1xuICAgIHJldHVybiBwYXltZW50cy5wMnNoKHsgb3V0cHV0LCBuZXR3b3JrIH0pLmFkZHJlc3M7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHBheW1lbnRzLnAyd3BraCh7IG91dHB1dCwgbmV0d29yayB9KS5hZGRyZXNzO1xuICB9IGNhdGNoIChlKSB7fVxuICB0cnkge1xuICAgIHJldHVybiBwYXltZW50cy5wMndzaCh7IG91dHB1dCwgbmV0d29yayB9KS5hZGRyZXNzO1xuICB9IGNhdGNoIChlKSB7fVxuICB0cnkge1xuICAgIHJldHVybiBwYXltZW50cy5wMnRyKHsgb3V0cHV0LCBuZXR3b3JrIH0pLmFkZHJlc3M7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHRyeSB7XG4gICAgcmV0dXJuIF90b0Z1dHVyZVNlZ3dpdEFkZHJlc3Mob3V0cHV0LCBuZXR3b3JrKTtcbiAgfSBjYXRjaCAoZSkge31cbiAgdGhyb3cgbmV3IEVycm9yKGJzY3JpcHQudG9BU00ob3V0cHV0KSArICcgaGFzIG5vIG1hdGNoaW5nIEFkZHJlc3MnKTtcbn1cbmV4cG9ydHMuZnJvbU91dHB1dFNjcmlwdCA9IGZyb21PdXRwdXRTY3JpcHQ7XG4vKipcbiAqIGVuY29kZXMgYWRkcmVzcyB0byBvdXRwdXQgc2NyaXB0IHdpdGggbmV0d29yaywgcmV0dXJuIG91dHB1dCBzY3JpcHQgaWYgYWRkcmVzcyBtYXRjaGVkXG4gKi9cbmZ1bmN0aW9uIHRvT3V0cHV0U2NyaXB0KGFkZHJlc3MsIG5ldHdvcmspIHtcbiAgbmV0d29yayA9IG5ldHdvcmsgfHwgbmV0d29ya3MuYml0Y29pbjtcbiAgbGV0IGRlY29kZUJhc2U1ODtcbiAgbGV0IGRlY29kZUJlY2gzMjtcbiAgdHJ5IHtcbiAgICBkZWNvZGVCYXNlNTggPSBmcm9tQmFzZTU4Q2hlY2soYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIGlmIChkZWNvZGVCYXNlNTgpIHtcbiAgICBpZiAoZGVjb2RlQmFzZTU4LnZlcnNpb24gPT09IG5ldHdvcmsucHViS2V5SGFzaClcbiAgICAgIHJldHVybiBwYXltZW50cy5wMnBraCh7IGhhc2g6IGRlY29kZUJhc2U1OC5oYXNoIH0pLm91dHB1dDtcbiAgICBpZiAoZGVjb2RlQmFzZTU4LnZlcnNpb24gPT09IG5ldHdvcmsuc2NyaXB0SGFzaClcbiAgICAgIHJldHVybiBwYXltZW50cy5wMnNoKHsgaGFzaDogZGVjb2RlQmFzZTU4Lmhhc2ggfSkub3V0cHV0O1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBkZWNvZGVCZWNoMzIgPSBmcm9tQmVjaDMyKGFkZHJlc3MpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKGRlY29kZUJlY2gzMikge1xuICAgICAgaWYgKGRlY29kZUJlY2gzMi5wcmVmaXggIT09IG5ldHdvcmsuYmVjaDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYWRkcmVzcyArICcgaGFzIGFuIGludmFsaWQgcHJlZml4Jyk7XG4gICAgICBpZiAoZGVjb2RlQmVjaDMyLnZlcnNpb24gPT09IDApIHtcbiAgICAgICAgaWYgKGRlY29kZUJlY2gzMi5kYXRhLmxlbmd0aCA9PT0gMjApXG4gICAgICAgICAgcmV0dXJuIHBheW1lbnRzLnAyd3BraCh7IGhhc2g6IGRlY29kZUJlY2gzMi5kYXRhIH0pLm91dHB1dDtcbiAgICAgICAgaWYgKGRlY29kZUJlY2gzMi5kYXRhLmxlbmd0aCA9PT0gMzIpXG4gICAgICAgICAgcmV0dXJuIHBheW1lbnRzLnAyd3NoKHsgaGFzaDogZGVjb2RlQmVjaDMyLmRhdGEgfSkub3V0cHV0O1xuICAgICAgfSBlbHNlIGlmIChkZWNvZGVCZWNoMzIudmVyc2lvbiA9PT0gMSkge1xuICAgICAgICBpZiAoZGVjb2RlQmVjaDMyLmRhdGEubGVuZ3RoID09PSAzMilcbiAgICAgICAgICByZXR1cm4gcGF5bWVudHMucDJ0cih7IHB1YmtleTogZGVjb2RlQmVjaDMyLmRhdGEgfSkub3V0cHV0O1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgZGVjb2RlQmVjaDMyLnZlcnNpb24gPj0gRlVUVVJFX1NFR1dJVF9NSU5fVkVSU0lPTiAmJlxuICAgICAgICBkZWNvZGVCZWNoMzIudmVyc2lvbiA8PSBGVVRVUkVfU0VHV0lUX01BWF9WRVJTSU9OICYmXG4gICAgICAgIGRlY29kZUJlY2gzMi5kYXRhLmxlbmd0aCA+PSBGVVRVUkVfU0VHV0lUX01JTl9TSVpFICYmXG4gICAgICAgIGRlY29kZUJlY2gzMi5kYXRhLmxlbmd0aCA8PSBGVVRVUkVfU0VHV0lUX01BWF9TSVpFXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZS53YXJuKEZVVFVSRV9TRUdXSVRfVkVSU0lPTl9XQVJOSU5HKTtcbiAgICAgICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbXG4gICAgICAgICAgZGVjb2RlQmVjaDMyLnZlcnNpb24gKyBGVVRVUkVfU0VHV0lUX1ZFUlNJT05fRElGRixcbiAgICAgICAgICBkZWNvZGVCZWNoMzIuZGF0YSxcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihhZGRyZXNzICsgJyBoYXMgbm8gbWF0Y2hpbmcgU2NyaXB0Jyk7XG59XG5leHBvcnRzLnRvT3V0cHV0U2NyaXB0ID0gdG9PdXRwdXRTY3JpcHQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/address.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/bip66.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/bip66.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\n// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki\n// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n// NOTE: SIGHASH byte ignored AND restricted, truncate before use\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encode = exports.decode = exports.check = void 0;\nfunction check(buffer) {\n  if (buffer.length < 8) return false;\n  if (buffer.length > 72) return false;\n  if (buffer[0] !== 0x30) return false;\n  if (buffer[1] !== buffer.length - 2) return false;\n  if (buffer[2] !== 0x02) return false;\n  const lenR = buffer[3];\n  if (lenR === 0) return false;\n  if (5 + lenR >= buffer.length) return false;\n  if (buffer[4 + lenR] !== 0x02) return false;\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) return false;\n  if (6 + lenR + lenS !== buffer.length) return false;\n  if (buffer[4] & 0x80) return false;\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;\n  if (buffer[lenR + 6] & 0x80) return false;\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    return false;\n  return true;\n}\nexports.check = check;\nfunction decode(buffer) {\n  if (buffer.length < 8) throw new Error('DER sequence length is too short');\n  if (buffer.length > 72) throw new Error('DER sequence length is too long');\n  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');\n  if (buffer[1] !== buffer.length - 2)\n    throw new Error('DER sequence length is invalid');\n  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');\n  const lenR = buffer[3];\n  if (lenR === 0) throw new Error('R length is zero');\n  if (5 + lenR >= buffer.length) throw new Error('R length is too long');\n  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) throw new Error('S length is zero');\n  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');\n  if (buffer[4] & 0x80) throw new Error('R value is negative');\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))\n    throw new Error('R value excessively padded');\n  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    throw new Error('S value excessively padded');\n  // non-BIP66 - extract R, S values\n  return {\n    r: buffer.slice(4, 4 + lenR),\n    s: buffer.slice(6 + lenR),\n  };\n}\nexports.decode = decode;\n/*\n * Expects r and s to be positive DER integers.\n *\n * The DER format uses the most significant bit as a sign bit (& 0x80).\n * If the significant bit is set AND the integer is positive, a 0x00 is prepended.\n *\n * Examples:\n *\n *      0 =>     0x00\n *      1 =>     0x01\n *     -1 =>     0xff\n *    127 =>     0x7f\n *   -127 =>     0x81\n *    128 =>   0x0080\n *   -128 =>     0x80\n *    255 =>   0x00ff\n *   -255 =>   0xff01\n *  16300 =>   0x3fac\n * -16300 =>   0xc054\n *  62300 => 0x00f35c\n * -62300 => 0xff0ca4\n */\nfunction encode(r, s) {\n  const lenR = r.length;\n  const lenS = s.length;\n  if (lenR === 0) throw new Error('R length is zero');\n  if (lenS === 0) throw new Error('S length is zero');\n  if (lenR > 33) throw new Error('R length is too long');\n  if (lenS > 33) throw new Error('S length is too long');\n  if (r[0] & 0x80) throw new Error('R value is negative');\n  if (s[0] & 0x80) throw new Error('S value is negative');\n  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))\n    throw new Error('R value excessively padded');\n  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))\n    throw new Error('S value excessively padded');\n  const signature = Buffer.allocUnsafe(6 + lenR + lenS);\n  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n  signature[0] = 0x30;\n  signature[1] = signature.length - 2;\n  signature[2] = 0x02;\n  signature[3] = r.length;\n  r.copy(signature, 4);\n  signature[4 + lenR] = 0x02;\n  signature[5 + lenR] = s.length;\n  s.copy(signature, 6 + lenR);\n  return signature;\n}\nexports.encode = encode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvYmlwNjYuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjLEdBQUcsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL2JpcDY2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIFJlZmVyZW5jZSBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY2Lm1lZGlhd2lraVxuLy8gRm9ybWF0OiAweDMwIFt0b3RhbC1sZW5ndGhdIDB4MDIgW1ItbGVuZ3RoXSBbUl0gMHgwMiBbUy1sZW5ndGhdIFtTXVxuLy8gTk9URTogU0lHSEFTSCBieXRlIGlnbm9yZWQgQU5EIHJlc3RyaWN0ZWQsIHRydW5jYXRlIGJlZm9yZSB1c2Vcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5jaGVjayA9IHZvaWQgMDtcbmZ1bmN0aW9uIGNoZWNrKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA8IDgpIHJldHVybiBmYWxzZTtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPiA3MikgcmV0dXJuIGZhbHNlO1xuICBpZiAoYnVmZmVyWzBdICE9PSAweDMwKSByZXR1cm4gZmFsc2U7XG4gIGlmIChidWZmZXJbMV0gIT09IGJ1ZmZlci5sZW5ndGggLSAyKSByZXR1cm4gZmFsc2U7XG4gIGlmIChidWZmZXJbMl0gIT09IDB4MDIpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbGVuUiA9IGJ1ZmZlclszXTtcbiAgaWYgKGxlblIgPT09IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKDUgKyBsZW5SID49IGJ1ZmZlci5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgaWYgKGJ1ZmZlcls0ICsgbGVuUl0gIT09IDB4MDIpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgbGVuUyA9IGJ1ZmZlcls1ICsgbGVuUl07XG4gIGlmIChsZW5TID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmICg2ICsgbGVuUiArIGxlblMgIT09IGJ1ZmZlci5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgaWYgKGJ1ZmZlcls0XSAmIDB4ODApIHJldHVybiBmYWxzZTtcbiAgaWYgKGxlblIgPiAxICYmIGJ1ZmZlcls0XSA9PT0gMHgwMCAmJiAhKGJ1ZmZlcls1XSAmIDB4ODApKSByZXR1cm4gZmFsc2U7XG4gIGlmIChidWZmZXJbbGVuUiArIDZdICYgMHg4MCkgcmV0dXJuIGZhbHNlO1xuICBpZiAobGVuUyA+IDEgJiYgYnVmZmVyW2xlblIgKyA2XSA9PT0gMHgwMCAmJiAhKGJ1ZmZlcltsZW5SICsgN10gJiAweDgwKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5jaGVjayA9IGNoZWNrO1xuZnVuY3Rpb24gZGVjb2RlKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA8IDgpIHRocm93IG5ldyBFcnJvcignREVSIHNlcXVlbmNlIGxlbmd0aCBpcyB0b28gc2hvcnQnKTtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPiA3MikgdGhyb3cgbmV3IEVycm9yKCdERVIgc2VxdWVuY2UgbGVuZ3RoIGlzIHRvbyBsb25nJyk7XG4gIGlmIChidWZmZXJbMF0gIT09IDB4MzApIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgREVSIHNlcXVlbmNlJyk7XG4gIGlmIChidWZmZXJbMV0gIT09IGJ1ZmZlci5sZW5ndGggLSAyKVxuICAgIHRocm93IG5ldyBFcnJvcignREVSIHNlcXVlbmNlIGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIGlmIChidWZmZXJbMl0gIT09IDB4MDIpIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgREVSIGludGVnZXInKTtcbiAgY29uc3QgbGVuUiA9IGJ1ZmZlclszXTtcbiAgaWYgKGxlblIgPT09IDApIHRocm93IG5ldyBFcnJvcignUiBsZW5ndGggaXMgemVybycpO1xuICBpZiAoNSArIGxlblIgPj0gYnVmZmVyLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdSIGxlbmd0aCBpcyB0b28gbG9uZycpO1xuICBpZiAoYnVmZmVyWzQgKyBsZW5SXSAhPT0gMHgwMikgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBERVIgaW50ZWdlciAoMiknKTtcbiAgY29uc3QgbGVuUyA9IGJ1ZmZlcls1ICsgbGVuUl07XG4gIGlmIChsZW5TID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ1MgbGVuZ3RoIGlzIHplcm8nKTtcbiAgaWYgKDYgKyBsZW5SICsgbGVuUyAhPT0gYnVmZmVyLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIGlmIChidWZmZXJbNF0gJiAweDgwKSB0aHJvdyBuZXcgRXJyb3IoJ1IgdmFsdWUgaXMgbmVnYXRpdmUnKTtcbiAgaWYgKGxlblIgPiAxICYmIGJ1ZmZlcls0XSA9PT0gMHgwMCAmJiAhKGJ1ZmZlcls1XSAmIDB4ODApKVxuICAgIHRocm93IG5ldyBFcnJvcignUiB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWQnKTtcbiAgaWYgKGJ1ZmZlcltsZW5SICsgNl0gJiAweDgwKSB0aHJvdyBuZXcgRXJyb3IoJ1MgdmFsdWUgaXMgbmVnYXRpdmUnKTtcbiAgaWYgKGxlblMgPiAxICYmIGJ1ZmZlcltsZW5SICsgNl0gPT09IDB4MDAgJiYgIShidWZmZXJbbGVuUiArIDddICYgMHg4MCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTIHZhbHVlIGV4Y2Vzc2l2ZWx5IHBhZGRlZCcpO1xuICAvLyBub24tQklQNjYgLSBleHRyYWN0IFIsIFMgdmFsdWVzXG4gIHJldHVybiB7XG4gICAgcjogYnVmZmVyLnNsaWNlKDQsIDQgKyBsZW5SKSxcbiAgICBzOiBidWZmZXIuc2xpY2UoNiArIGxlblIpLFxuICB9O1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4vKlxuICogRXhwZWN0cyByIGFuZCBzIHRvIGJlIHBvc2l0aXZlIERFUiBpbnRlZ2Vycy5cbiAqXG4gKiBUaGUgREVSIGZvcm1hdCB1c2VzIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBhcyBhIHNpZ24gYml0ICgmIDB4ODApLlxuICogSWYgdGhlIHNpZ25pZmljYW50IGJpdCBpcyBzZXQgQU5EIHRoZSBpbnRlZ2VyIGlzIHBvc2l0aXZlLCBhIDB4MDAgaXMgcHJlcGVuZGVkLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgMCA9PiAgICAgMHgwMFxuICogICAgICAxID0+ICAgICAweDAxXG4gKiAgICAgLTEgPT4gICAgIDB4ZmZcbiAqICAgIDEyNyA9PiAgICAgMHg3ZlxuICogICAtMTI3ID0+ICAgICAweDgxXG4gKiAgICAxMjggPT4gICAweDAwODBcbiAqICAgLTEyOCA9PiAgICAgMHg4MFxuICogICAgMjU1ID0+ICAgMHgwMGZmXG4gKiAgIC0yNTUgPT4gICAweGZmMDFcbiAqICAxNjMwMCA9PiAgIDB4M2ZhY1xuICogLTE2MzAwID0+ICAgMHhjMDU0XG4gKiAgNjIzMDAgPT4gMHgwMGYzNWNcbiAqIC02MjMwMCA9PiAweGZmMGNhNFxuICovXG5mdW5jdGlvbiBlbmNvZGUociwgcykge1xuICBjb25zdCBsZW5SID0gci5sZW5ndGg7XG4gIGNvbnN0IGxlblMgPSBzLmxlbmd0aDtcbiAgaWYgKGxlblIgPT09IDApIHRocm93IG5ldyBFcnJvcignUiBsZW5ndGggaXMgemVybycpO1xuICBpZiAobGVuUyA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyB6ZXJvJyk7XG4gIGlmIChsZW5SID4gMzMpIHRocm93IG5ldyBFcnJvcignUiBsZW5ndGggaXMgdG9vIGxvbmcnKTtcbiAgaWYgKGxlblMgPiAzMykgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyB0b28gbG9uZycpO1xuICBpZiAoclswXSAmIDB4ODApIHRocm93IG5ldyBFcnJvcignUiB2YWx1ZSBpcyBuZWdhdGl2ZScpO1xuICBpZiAoc1swXSAmIDB4ODApIHRocm93IG5ldyBFcnJvcignUyB2YWx1ZSBpcyBuZWdhdGl2ZScpO1xuICBpZiAobGVuUiA+IDEgJiYgclswXSA9PT0gMHgwMCAmJiAhKHJbMV0gJiAweDgwKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1IgdmFsdWUgZXhjZXNzaXZlbHkgcGFkZGVkJyk7XG4gIGlmIChsZW5TID4gMSAmJiBzWzBdID09PSAweDAwICYmICEoc1sxXSAmIDB4ODApKVxuICAgIHRocm93IG5ldyBFcnJvcignUyB2YWx1ZSBleGNlc3NpdmVseSBwYWRkZWQnKTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gQnVmZmVyLmFsbG9jVW5zYWZlKDYgKyBsZW5SICsgbGVuUyk7XG4gIC8vIDB4MzAgW3RvdGFsLWxlbmd0aF0gMHgwMiBbUi1sZW5ndGhdIFtSXSAweDAyIFtTLWxlbmd0aF0gW1NdXG4gIHNpZ25hdHVyZVswXSA9IDB4MzA7XG4gIHNpZ25hdHVyZVsxXSA9IHNpZ25hdHVyZS5sZW5ndGggLSAyO1xuICBzaWduYXR1cmVbMl0gPSAweDAyO1xuICBzaWduYXR1cmVbM10gPSByLmxlbmd0aDtcbiAgci5jb3B5KHNpZ25hdHVyZSwgNCk7XG4gIHNpZ25hdHVyZVs0ICsgbGVuUl0gPSAweDAyO1xuICBzaWduYXR1cmVbNSArIGxlblJdID0gcy5sZW5ndGg7XG4gIHMuY29weShzaWduYXR1cmUsIDYgKyBsZW5SKTtcbiAgcmV0dXJuIHNpZ25hdHVyZTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/bip66.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/block.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/block.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Block = void 0;\nconst bufferutils_1 = __webpack_require__(/*! ./bufferutils */ \"./node_modules/bitcoinjs-lib/src/bufferutils.js\");\nconst bcrypto = __webpack_require__(/*! ./crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\");\nconst merkle_1 = __webpack_require__(/*! ./merkle */ \"./node_modules/bitcoinjs-lib/src/merkle.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"./node_modules/bitcoinjs-lib/src/transaction.js\");\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst { typeforce } = types;\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{ getHash: types.Function }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = (0, merkle_1.fastMerkleRoot)(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(out =>\n        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Buffer &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      bufferutils_1.varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString('hex');\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    bufferutils_1.varuint.encode(\n      this.transactions.length,\n      buffer,\n      bufferWriter.offset,\n    );\n    bufferWriter.offset += bufferutils_1.varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n}\nexports.Block = Block;\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvYmxvY2suanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixzQkFBc0IsbUJBQU8sQ0FBQyxzRUFBZTtBQUM3QyxnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBVTtBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyw0REFBVTtBQUNuQyxzQkFBc0IsbUJBQU8sQ0FBQyxzRUFBZTtBQUM3QyxjQUFjLG1CQUFPLENBQUMsMERBQVM7QUFDL0IsUUFBUSxZQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE1BQU07QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9ibG9jay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CbG9jayA9IHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcnV0aWxzXzEgPSByZXF1aXJlKCcuL2J1ZmZlcnV0aWxzJyk7XG5jb25zdCBiY3J5cHRvID0gcmVxdWlyZSgnLi9jcnlwdG8nKTtcbmNvbnN0IG1lcmtsZV8xID0gcmVxdWlyZSgnLi9tZXJrbGUnKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKCcuL3RyYW5zYWN0aW9uJyk7XG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IHsgdHlwZWZvcmNlIH0gPSB0eXBlcztcbmNvbnN0IGVycm9yTWVya2xlTm9UeGVzID0gbmV3IFR5cGVFcnJvcihcbiAgJ0Nhbm5vdCBjb21wdXRlIG1lcmtsZSByb290IGZvciB6ZXJvIHRyYW5zYWN0aW9ucycsXG4pO1xuY29uc3QgZXJyb3JXaXRuZXNzTm90U2Vnd2l0ID0gbmV3IFR5cGVFcnJvcihcbiAgJ0Nhbm5vdCBjb21wdXRlIHdpdG5lc3MgY29tbWl0IGZvciBub24tc2Vnd2l0IGJsb2NrJyxcbik7XG5jbGFzcyBCbG9jayB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudmVyc2lvbiA9IDE7XG4gICAgdGhpcy5wcmV2SGFzaCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1lcmtsZVJvb3QgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aW1lc3RhbXAgPSAwO1xuICAgIHRoaXMud2l0bmVzc0NvbW1pdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJpdHMgPSAwO1xuICAgIHRoaXMubm9uY2UgPSAwO1xuICAgIHRoaXMudHJhbnNhY3Rpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHN0YXRpYyBmcm9tQnVmZmVyKGJ1ZmZlcikge1xuICAgIGlmIChidWZmZXIubGVuZ3RoIDwgODApIHRocm93IG5ldyBFcnJvcignQnVmZmVyIHRvbyBzbWFsbCAoPCA4MCBieXRlcyknKTtcbiAgICBjb25zdCBidWZmZXJSZWFkZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJSZWFkZXIoYnVmZmVyKTtcbiAgICBjb25zdCBibG9jayA9IG5ldyBCbG9jaygpO1xuICAgIGJsb2NrLnZlcnNpb24gPSBidWZmZXJSZWFkZXIucmVhZEludDMyKCk7XG4gICAgYmxvY2sucHJldkhhc2ggPSBidWZmZXJSZWFkZXIucmVhZFNsaWNlKDMyKTtcbiAgICBibG9jay5tZXJrbGVSb290ID0gYnVmZmVyUmVhZGVyLnJlYWRTbGljZSgzMik7XG4gICAgYmxvY2sudGltZXN0YW1wID0gYnVmZmVyUmVhZGVyLnJlYWRVSW50MzIoKTtcbiAgICBibG9jay5iaXRzID0gYnVmZmVyUmVhZGVyLnJlYWRVSW50MzIoKTtcbiAgICBibG9jay5ub25jZSA9IGJ1ZmZlclJlYWRlci5yZWFkVUludDMyKCk7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDgwKSByZXR1cm4gYmxvY2s7XG4gICAgY29uc3QgcmVhZFRyYW5zYWN0aW9uID0gKCkgPT4ge1xuICAgICAgY29uc3QgdHggPSB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLmZyb21CdWZmZXIoXG4gICAgICAgIGJ1ZmZlclJlYWRlci5idWZmZXIuc2xpY2UoYnVmZmVyUmVhZGVyLm9mZnNldCksXG4gICAgICAgIHRydWUsXG4gICAgICApO1xuICAgICAgYnVmZmVyUmVhZGVyLm9mZnNldCArPSB0eC5ieXRlTGVuZ3RoKCk7XG4gICAgICByZXR1cm4gdHg7XG4gICAgfTtcbiAgICBjb25zdCBuVHJhbnNhY3Rpb25zID0gYnVmZmVyUmVhZGVyLnJlYWRWYXJJbnQoKTtcbiAgICBibG9jay50cmFuc2FjdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5UcmFuc2FjdGlvbnM7ICsraSkge1xuICAgICAgY29uc3QgdHggPSByZWFkVHJhbnNhY3Rpb24oKTtcbiAgICAgIGJsb2NrLnRyYW5zYWN0aW9ucy5wdXNoKHR4KTtcbiAgICB9XG4gICAgY29uc3Qgd2l0bmVzc0NvbW1pdCA9IGJsb2NrLmdldFdpdG5lc3NDb21taXQoKTtcbiAgICAvLyBUaGlzIEJsb2NrIGNvbnRhaW5zIGEgd2l0bmVzcyBjb21taXRcbiAgICBpZiAod2l0bmVzc0NvbW1pdCkgYmxvY2sud2l0bmVzc0NvbW1pdCA9IHdpdG5lc3NDb21taXQ7XG4gICAgcmV0dXJuIGJsb2NrO1xuICB9XG4gIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgIHJldHVybiBCbG9jay5mcm9tQnVmZmVyKEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpKTtcbiAgfVxuICBzdGF0aWMgY2FsY3VsYXRlVGFyZ2V0KGJpdHMpIHtcbiAgICBjb25zdCBleHBvbmVudCA9ICgoYml0cyAmIDB4ZmYwMDAwMDApID4+IDI0KSAtIDM7XG4gICAgY29uc3QgbWFudGlzc2EgPSBiaXRzICYgMHgwMDdmZmZmZjtcbiAgICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICAgIHRhcmdldC53cml0ZVVJbnRCRShtYW50aXNzYSwgMjkgLSBleHBvbmVudCwgMyk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBzdGF0aWMgY2FsY3VsYXRlTWVya2xlUm9vdCh0cmFuc2FjdGlvbnMsIGZvcldpdG5lc3MpIHtcbiAgICB0eXBlZm9yY2UoW3sgZ2V0SGFzaDogdHlwZXMuRnVuY3Rpb24gfV0sIHRyYW5zYWN0aW9ucyk7XG4gICAgaWYgKHRyYW5zYWN0aW9ucy5sZW5ndGggPT09IDApIHRocm93IGVycm9yTWVya2xlTm9UeGVzO1xuICAgIGlmIChmb3JXaXRuZXNzICYmICF0eGVzSGF2ZVdpdG5lc3NDb21taXQodHJhbnNhY3Rpb25zKSlcbiAgICAgIHRocm93IGVycm9yV2l0bmVzc05vdFNlZ3dpdDtcbiAgICBjb25zdCBoYXNoZXMgPSB0cmFuc2FjdGlvbnMubWFwKHRyYW5zYWN0aW9uID0+XG4gICAgICB0cmFuc2FjdGlvbi5nZXRIYXNoKGZvcldpdG5lc3MpLFxuICAgICk7XG4gICAgY29uc3Qgcm9vdEhhc2ggPSAoMCwgbWVya2xlXzEuZmFzdE1lcmtsZVJvb3QpKGhhc2hlcywgYmNyeXB0by5oYXNoMjU2KTtcbiAgICByZXR1cm4gZm9yV2l0bmVzc1xuICAgICAgPyBiY3J5cHRvLmhhc2gyNTYoXG4gICAgICAgICAgQnVmZmVyLmNvbmNhdChbcm9vdEhhc2gsIHRyYW5zYWN0aW9uc1swXS5pbnNbMF0ud2l0bmVzc1swXV0pLFxuICAgICAgICApXG4gICAgICA6IHJvb3RIYXNoO1xuICB9XG4gIGdldFdpdG5lc3NDb21taXQoKSB7XG4gICAgaWYgKCF0eGVzSGF2ZVdpdG5lc3NDb21taXQodGhpcy50cmFuc2FjdGlvbnMpKSByZXR1cm4gbnVsbDtcbiAgICAvLyBUaGUgbWVya2xlIHJvb3QgZm9yIHRoZSB3aXRuZXNzIGRhdGEgaXMgaW4gYW4gT1BfUkVUVVJOIG91dHB1dC5cbiAgICAvLyBUaGVyZSBpcyBubyBydWxlIGZvciB0aGUgaW5kZXggb2YgdGhlIG91dHB1dCwgc28gdXNlIGZpbHRlciB0byBmaW5kIGl0LlxuICAgIC8vIFRoZSByb290IGlzIHByZXBlbmRlZCB3aXRoIDB4YWEyMWE5ZWQgc28gY2hlY2sgZm9yIDB4NmEyNGFhMjFhOWVkXG4gICAgLy8gSWYgbXVsdGlwbGUgY29tbWl0cyBhcmUgZm91bmQsIHRoZSBvdXRwdXQgd2l0aCBoaWdoZXN0IGluZGV4IGlzIGFzc3VtZWQuXG4gICAgY29uc3Qgd2l0bmVzc0NvbW1pdHMgPSB0aGlzLnRyYW5zYWN0aW9uc1swXS5vdXRzXG4gICAgICAuZmlsdGVyKG91dCA9PlxuICAgICAgICBvdXQuc2NyaXB0LnNsaWNlKDAsIDYpLmVxdWFscyhCdWZmZXIuZnJvbSgnNmEyNGFhMjFhOWVkJywgJ2hleCcpKSxcbiAgICAgIClcbiAgICAgIC5tYXAob3V0ID0+IG91dC5zY3JpcHQuc2xpY2UoNiwgMzgpKTtcbiAgICBpZiAod2l0bmVzc0NvbW1pdHMubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgICAvLyBVc2UgdGhlIGNvbW1pdCB3aXRoIHRoZSBoaWdoZXN0IG91dHB1dCAoc2hvdWxkIG9ubHkgYmUgb25lIHRob3VnaClcbiAgICBjb25zdCByZXN1bHQgPSB3aXRuZXNzQ29tbWl0c1t3aXRuZXNzQ29tbWl0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAoIShyZXN1bHQgaW5zdGFuY2VvZiBCdWZmZXIgJiYgcmVzdWx0Lmxlbmd0aCA9PT0gMzIpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGhhc1dpdG5lc3NDb21taXQoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy53aXRuZXNzQ29tbWl0IGluc3RhbmNlb2YgQnVmZmVyICYmXG4gICAgICB0aGlzLndpdG5lc3NDb21taXQubGVuZ3RoID09PSAzMlxuICAgIClcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmdldFdpdG5lc3NDb21taXQoKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGhhc1dpdG5lc3MoKSB7XG4gICAgcmV0dXJuIGFueVR4SGFzV2l0bmVzcyh0aGlzLnRyYW5zYWN0aW9ucyk7XG4gIH1cbiAgd2VpZ2h0KCkge1xuICAgIGNvbnN0IGJhc2UgPSB0aGlzLmJ5dGVMZW5ndGgoZmFsc2UsIGZhbHNlKTtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuYnl0ZUxlbmd0aChmYWxzZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGJhc2UgKiAzICsgdG90YWw7XG4gIH1cbiAgYnl0ZUxlbmd0aChoZWFkZXJzT25seSwgYWxsb3dXaXRuZXNzID0gdHJ1ZSkge1xuICAgIGlmIChoZWFkZXJzT25seSB8fCAhdGhpcy50cmFuc2FjdGlvbnMpIHJldHVybiA4MDtcbiAgICByZXR1cm4gKFxuICAgICAgODAgK1xuICAgICAgYnVmZmVydXRpbHNfMS52YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHRoaXMudHJhbnNhY3Rpb25zLmxlbmd0aCkgK1xuICAgICAgdGhpcy50cmFuc2FjdGlvbnMucmVkdWNlKChhLCB4KSA9PiBhICsgeC5ieXRlTGVuZ3RoKGFsbG93V2l0bmVzcyksIDApXG4gICAgKTtcbiAgfVxuICBnZXRIYXNoKCkge1xuICAgIHJldHVybiBiY3J5cHRvLmhhc2gyNTYodGhpcy50b0J1ZmZlcih0cnVlKSk7XG4gIH1cbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuICgwLCBidWZmZXJ1dGlsc18xLnJldmVyc2VCdWZmZXIpKHRoaXMuZ2V0SGFzaCgpKS50b1N0cmluZygnaGV4Jyk7XG4gIH1cbiAgZ2V0VVRDRGF0ZSgpIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoMCk7IC8vIGVwb2NoXG4gICAgZGF0ZS5zZXRVVENTZWNvbmRzKHRoaXMudGltZXN0YW1wKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuICAvLyBUT0RPOiBidWZmZXIsIG9mZnNldCBjb21wYXRpYmlsaXR5XG4gIHRvQnVmZmVyKGhlYWRlcnNPbmx5KSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRoaXMuYnl0ZUxlbmd0aChoZWFkZXJzT25seSkpO1xuICAgIGNvbnN0IGJ1ZmZlcldyaXRlciA9IG5ldyBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlcihidWZmZXIpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZUludDMyKHRoaXMudmVyc2lvbik7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UodGhpcy5wcmV2SGFzaCk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UodGhpcy5tZXJrbGVSb290KTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIodGhpcy50aW1lc3RhbXApO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMih0aGlzLmJpdHMpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMih0aGlzLm5vbmNlKTtcbiAgICBpZiAoaGVhZGVyc09ubHkgfHwgIXRoaXMudHJhbnNhY3Rpb25zKSByZXR1cm4gYnVmZmVyO1xuICAgIGJ1ZmZlcnV0aWxzXzEudmFydWludC5lbmNvZGUoXG4gICAgICB0aGlzLnRyYW5zYWN0aW9ucy5sZW5ndGgsXG4gICAgICBidWZmZXIsXG4gICAgICBidWZmZXJXcml0ZXIub2Zmc2V0LFxuICAgICk7XG4gICAgYnVmZmVyV3JpdGVyLm9mZnNldCArPSBidWZmZXJ1dGlsc18xLnZhcnVpbnQuZW5jb2RlLmJ5dGVzO1xuICAgIHRoaXMudHJhbnNhY3Rpb25zLmZvckVhY2godHggPT4ge1xuICAgICAgY29uc3QgdHhTaXplID0gdHguYnl0ZUxlbmd0aCgpOyAvLyBUT0RPOiBleHRyYWN0IGZyb20gdG9CdWZmZXI/XG4gICAgICB0eC50b0J1ZmZlcihidWZmZXIsIGJ1ZmZlcldyaXRlci5vZmZzZXQpO1xuICAgICAgYnVmZmVyV3JpdGVyLm9mZnNldCArPSB0eFNpemU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfVxuICB0b0hleChoZWFkZXJzT25seSkge1xuICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKGhlYWRlcnNPbmx5KS50b1N0cmluZygnaGV4Jyk7XG4gIH1cbiAgY2hlY2tUeFJvb3RzKCkge1xuICAgIC8vIElmIHRoZSBCbG9jayBoYXMgc2Vnd2l0IHRyYW5zYWN0aW9ucyBidXQgbm8gd2l0bmVzcyBjb21taXQsXG4gICAgLy8gdGhlcmUncyBubyB3YXkgaXQgY2FuIGJlIHZhbGlkLCBzbyBmYWlsIHRoZSBjaGVjay5cbiAgICBjb25zdCBoYXNXaXRuZXNzQ29tbWl0ID0gdGhpcy5oYXNXaXRuZXNzQ29tbWl0KCk7XG4gICAgaWYgKCFoYXNXaXRuZXNzQ29tbWl0ICYmIHRoaXMuaGFzV2l0bmVzcygpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuX19jaGVja01lcmtsZVJvb3QoKSAmJlxuICAgICAgKGhhc1dpdG5lc3NDb21taXQgPyB0aGlzLl9fY2hlY2tXaXRuZXNzQ29tbWl0KCkgOiB0cnVlKVxuICAgICk7XG4gIH1cbiAgY2hlY2tQcm9vZk9mV29yaygpIHtcbiAgICBjb25zdCBoYXNoID0gKDAsIGJ1ZmZlcnV0aWxzXzEucmV2ZXJzZUJ1ZmZlcikodGhpcy5nZXRIYXNoKCkpO1xuICAgIGNvbnN0IHRhcmdldCA9IEJsb2NrLmNhbGN1bGF0ZVRhcmdldCh0aGlzLmJpdHMpO1xuICAgIHJldHVybiBoYXNoLmNvbXBhcmUodGFyZ2V0KSA8PSAwO1xuICB9XG4gIF9fY2hlY2tNZXJrbGVSb290KCkge1xuICAgIGlmICghdGhpcy50cmFuc2FjdGlvbnMpIHRocm93IGVycm9yTWVya2xlTm9UeGVzO1xuICAgIGNvbnN0IGFjdHVhbE1lcmtsZVJvb3QgPSBCbG9jay5jYWxjdWxhdGVNZXJrbGVSb290KHRoaXMudHJhbnNhY3Rpb25zKTtcbiAgICByZXR1cm4gdGhpcy5tZXJrbGVSb290LmNvbXBhcmUoYWN0dWFsTWVya2xlUm9vdCkgPT09IDA7XG4gIH1cbiAgX19jaGVja1dpdG5lc3NDb21taXQoKSB7XG4gICAgaWYgKCF0aGlzLnRyYW5zYWN0aW9ucykgdGhyb3cgZXJyb3JNZXJrbGVOb1R4ZXM7XG4gICAgaWYgKCF0aGlzLmhhc1dpdG5lc3NDb21taXQoKSkgdGhyb3cgZXJyb3JXaXRuZXNzTm90U2Vnd2l0O1xuICAgIGNvbnN0IGFjdHVhbFdpdG5lc3NDb21taXQgPSBCbG9jay5jYWxjdWxhdGVNZXJrbGVSb290KFxuICAgICAgdGhpcy50cmFuc2FjdGlvbnMsXG4gICAgICB0cnVlLFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMud2l0bmVzc0NvbW1pdC5jb21wYXJlKGFjdHVhbFdpdG5lc3NDb21taXQpID09PSAwO1xuICB9XG59XG5leHBvcnRzLkJsb2NrID0gQmxvY2s7XG5mdW5jdGlvbiB0eGVzSGF2ZVdpdG5lc3NDb21taXQodHJhbnNhY3Rpb25zKSB7XG4gIHJldHVybiAoXG4gICAgdHJhbnNhY3Rpb25zIGluc3RhbmNlb2YgQXJyYXkgJiZcbiAgICB0cmFuc2FjdGlvbnNbMF0gJiZcbiAgICB0cmFuc2FjdGlvbnNbMF0uaW5zICYmXG4gICAgdHJhbnNhY3Rpb25zWzBdLmlucyBpbnN0YW5jZW9mIEFycmF5ICYmXG4gICAgdHJhbnNhY3Rpb25zWzBdLmluc1swXSAmJlxuICAgIHRyYW5zYWN0aW9uc1swXS5pbnNbMF0ud2l0bmVzcyAmJlxuICAgIHRyYW5zYWN0aW9uc1swXS5pbnNbMF0ud2l0bmVzcyBpbnN0YW5jZW9mIEFycmF5ICYmXG4gICAgdHJhbnNhY3Rpb25zWzBdLmluc1swXS53aXRuZXNzLmxlbmd0aCA+IDBcbiAgKTtcbn1cbmZ1bmN0aW9uIGFueVR4SGFzV2l0bmVzcyh0cmFuc2FjdGlvbnMpIHtcbiAgcmV0dXJuIChcbiAgICB0cmFuc2FjdGlvbnMgaW5zdGFuY2VvZiBBcnJheSAmJlxuICAgIHRyYW5zYWN0aW9ucy5zb21lKFxuICAgICAgdHggPT5cbiAgICAgICAgdHlwZW9mIHR4ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eC5pbnMgaW5zdGFuY2VvZiBBcnJheSAmJlxuICAgICAgICB0eC5pbnMuc29tZShcbiAgICAgICAgICBpbnB1dCA9PlxuICAgICAgICAgICAgdHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgaW5wdXQud2l0bmVzcyBpbnN0YW5jZW9mIEFycmF5ICYmXG4gICAgICAgICAgICBpbnB1dC53aXRuZXNzLmxlbmd0aCA+IDAsXG4gICAgICAgICksXG4gICAgKVxuICApO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/block.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/bufferutils.js":
/*!*******************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/bufferutils.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BufferReader =\n  exports.BufferWriter =\n  exports.cloneBuffer =\n  exports.reverseBuffer =\n  exports.writeUInt64LE =\n  exports.readUInt64LE =\n  exports.varuint =\n    void 0;\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst { typeforce } = types;\nconst varuint = __webpack_require__(/*! varuint-bitcoin */ \"./node_modules/varuint-bitcoin/index.js\");\nexports.varuint = varuint;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\n/**\n * Writes a 64-bit unsigned integer in little-endian format to the specified buffer at the given offset.\n *\n * @param buffer - The buffer to write the value to.\n * @param value - The 64-bit unsigned integer value to write.\n * @param offset - The offset in the buffer where the value should be written.\n * @returns The new offset after writing the value.\n */\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\n/**\n * Reverses the order of bytes in a buffer.\n * @param buffer - The buffer to reverse.\n * @returns A new buffer with the bytes reversed.\n */\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction cloneBuffer(buffer) {\n  const clone = Buffer.allocUnsafe(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\nexports.cloneBuffer = cloneBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n  static withCapacity(size) {\n    return new BufferWriter(Buffer.alloc(size));\n  }\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  writeUInt8(i) {\n    this.offset = this.buffer.writeUInt8(i, this.offset);\n  }\n  writeInt32(i) {\n    this.offset = this.buffer.writeInt32LE(i, this.offset);\n  }\n  writeUInt32(i) {\n    this.offset = this.buffer.writeUInt32LE(i, this.offset);\n  }\n  writeUInt64(i) {\n    this.offset = writeUInt64LE(this.buffer, i, this.offset);\n  }\n  writeVarInt(i) {\n    varuint.encode(i, this.buffer, this.offset);\n    this.offset += varuint.encode.bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.offset += slice.copy(this.buffer, this.offset);\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n  end() {\n    if (this.buffer.length === this.offset) {\n      return this.buffer;\n    }\n    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);\n  }\n}\nexports.BufferWriter = BufferWriter;\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  readUInt8() {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt64() {\n    const result = readUInt64LE(this.buffer, this.offset);\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n  readSlice(n) {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\nexports.BufferReader = BufferReader;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvYnVmZmVydXRpbHMuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQixFQUFFLG9CQUFvQjtBQUN0QixFQUFFLG1CQUFtQjtBQUNyQixFQUFFLHFCQUFxQjtBQUN2QixFQUFFLHFCQUFxQjtBQUN2QixFQUFFLG9CQUFvQjtBQUN0QixFQUFFLGVBQWU7QUFDakI7QUFDQSxjQUFjLG1CQUFPLENBQUMsMERBQVM7QUFDL0IsUUFBUSxZQUFZO0FBQ3BCLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFpQjtBQUN6QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1CQUFtQixXQUFXLFlBQVk7QUFDN0U7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvYnVmZmVydXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnVmZmVyUmVhZGVyID1cbiAgZXhwb3J0cy5CdWZmZXJXcml0ZXIgPVxuICBleHBvcnRzLmNsb25lQnVmZmVyID1cbiAgZXhwb3J0cy5yZXZlcnNlQnVmZmVyID1cbiAgZXhwb3J0cy53cml0ZVVJbnQ2NExFID1cbiAgZXhwb3J0cy5yZWFkVUludDY0TEUgPVxuICBleHBvcnRzLnZhcnVpbnQgPVxuICAgIHZvaWQgMDtcbmNvbnN0IHR5cGVzID0gcmVxdWlyZSgnLi90eXBlcycpO1xuY29uc3QgeyB0eXBlZm9yY2UgfSA9IHR5cGVzO1xuY29uc3QgdmFydWludCA9IHJlcXVpcmUoJ3ZhcnVpbnQtYml0Y29pbicpO1xuZXhwb3J0cy52YXJ1aW50ID0gdmFydWludDtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvbWFzdGVyL2luZGV4LmpzI0wxMTI3XG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcbiAgaWYgKHZhbHVlIDwgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG4gIGlmICh2YWx1ZSA+IG1heCkgdGhyb3cgbmV3IEVycm9yKCdSYW5nZUVycm9yOiB2YWx1ZSBvdXQgb2YgcmFuZ2UnKTtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jyk7XG59XG5mdW5jdGlvbiByZWFkVUludDY0TEUoYnVmZmVyLCBvZmZzZXQpIHtcbiAgY29uc3QgYSA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgbGV0IGIgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDQpO1xuICBiICo9IDB4MTAwMDAwMDAwO1xuICB2ZXJpZnVpbnQoYiArIGEsIDB4MDAxZmZmZmZmZmZmZmZmZik7XG4gIHJldHVybiBiICsgYTtcbn1cbmV4cG9ydHMucmVhZFVJbnQ2NExFID0gcmVhZFVJbnQ2NExFO1xuLyoqXG4gKiBXcml0ZXMgYSA2NC1iaXQgdW5zaWduZWQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdCB0byB0aGUgc3BlY2lmaWVkIGJ1ZmZlciBhdCB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSBidWZmZXIgLSBUaGUgYnVmZmVyIHRvIHdyaXRlIHRoZSB2YWx1ZSB0by5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSA2NC1iaXQgdW5zaWduZWQgaW50ZWdlciB2YWx1ZSB0byB3cml0ZS5cbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGluIHRoZSBidWZmZXIgd2hlcmUgdGhlIHZhbHVlIHNob3VsZCBiZSB3cml0dGVuLlxuICogQHJldHVybnMgVGhlIG5ldyBvZmZzZXQgYWZ0ZXIgd3JpdGluZyB0aGUgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHdyaXRlVUludDY0TEUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0KSB7XG4gIHZlcmlmdWludCh2YWx1ZSwgMHgwMDFmZmZmZmZmZmZmZmZmKTtcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh2YWx1ZSAmIC0xLCBvZmZzZXQpO1xuICBidWZmZXIud3JpdGVVSW50MzJMRShNYXRoLmZsb29yKHZhbHVlIC8gMHgxMDAwMDAwMDApLCBvZmZzZXQgKyA0KTtcbiAgcmV0dXJuIG9mZnNldCArIDg7XG59XG5leHBvcnRzLndyaXRlVUludDY0TEUgPSB3cml0ZVVJbnQ2NExFO1xuLyoqXG4gKiBSZXZlcnNlcyB0aGUgb3JkZXIgb2YgYnl0ZXMgaW4gYSBidWZmZXIuXG4gKiBAcGFyYW0gYnVmZmVyIC0gVGhlIGJ1ZmZlciB0byByZXZlcnNlLlxuICogQHJldHVybnMgQSBuZXcgYnVmZmVyIHdpdGggdGhlIGJ5dGVzIHJldmVyc2VkLlxuICovXG5mdW5jdGlvbiByZXZlcnNlQnVmZmVyKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA8IDEpIHJldHVybiBidWZmZXI7XG4gIGxldCBqID0gYnVmZmVyLmxlbmd0aCAtIDE7XG4gIGxldCB0bXAgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGggLyAyOyBpKyspIHtcbiAgICB0bXAgPSBidWZmZXJbaV07XG4gICAgYnVmZmVyW2ldID0gYnVmZmVyW2pdO1xuICAgIGJ1ZmZlcltqXSA9IHRtcDtcbiAgICBqLS07XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMucmV2ZXJzZUJ1ZmZlciA9IHJldmVyc2VCdWZmZXI7XG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIpIHtcbiAgY29uc3QgY2xvbmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmZmVyLmxlbmd0aCk7XG4gIGJ1ZmZlci5jb3B5KGNsb25lKTtcbiAgcmV0dXJuIGNsb25lO1xufVxuZXhwb3J0cy5jbG9uZUJ1ZmZlciA9IGNsb25lQnVmZmVyO1xuLyoqXG4gKiBIZWxwZXIgY2xhc3MgZm9yIHNlcmlhbGl6YXRpb24gb2YgYml0Y29pbiBkYXRhIHR5cGVzIGludG8gYSBwcmUtYWxsb2NhdGVkIGJ1ZmZlci5cbiAqL1xuY2xhc3MgQnVmZmVyV3JpdGVyIHtcbiAgc3RhdGljIHdpdGhDYXBhY2l0eShzaXplKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoQnVmZmVyLmFsbG9jKHNpemUpKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihidWZmZXIsIG9mZnNldCA9IDApIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0eXBlZm9yY2UodHlwZXMudHVwbGUodHlwZXMuQnVmZmVyLCB0eXBlcy5VSW50MzIpLCBbYnVmZmVyLCBvZmZzZXRdKTtcbiAgfVxuICB3cml0ZVVJbnQ4KGkpIHtcbiAgICB0aGlzLm9mZnNldCA9IHRoaXMuYnVmZmVyLndyaXRlVUludDgoaSwgdGhpcy5vZmZzZXQpO1xuICB9XG4gIHdyaXRlSW50MzIoaSkge1xuICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5idWZmZXIud3JpdGVJbnQzMkxFKGksIHRoaXMub2Zmc2V0KTtcbiAgfVxuICB3cml0ZVVJbnQzMihpKSB7XG4gICAgdGhpcy5vZmZzZXQgPSB0aGlzLmJ1ZmZlci53cml0ZVVJbnQzMkxFKGksIHRoaXMub2Zmc2V0KTtcbiAgfVxuICB3cml0ZVVJbnQ2NChpKSB7XG4gICAgdGhpcy5vZmZzZXQgPSB3cml0ZVVJbnQ2NExFKHRoaXMuYnVmZmVyLCBpLCB0aGlzLm9mZnNldCk7XG4gIH1cbiAgd3JpdGVWYXJJbnQoaSkge1xuICAgIHZhcnVpbnQuZW5jb2RlKGksIHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCk7XG4gICAgdGhpcy5vZmZzZXQgKz0gdmFydWludC5lbmNvZGUuYnl0ZXM7XG4gIH1cbiAgd3JpdGVTbGljZShzbGljZSkge1xuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPCB0aGlzLm9mZnNldCArIHNsaWNlLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgd3JpdGUgc2xpY2Ugb3V0IG9mIGJvdW5kcycpO1xuICAgIH1cbiAgICB0aGlzLm9mZnNldCArPSBzbGljZS5jb3B5KHRoaXMuYnVmZmVyLCB0aGlzLm9mZnNldCk7XG4gIH1cbiAgd3JpdGVWYXJTbGljZShzbGljZSkge1xuICAgIHRoaXMud3JpdGVWYXJJbnQoc2xpY2UubGVuZ3RoKTtcbiAgICB0aGlzLndyaXRlU2xpY2Uoc2xpY2UpO1xuICB9XG4gIHdyaXRlVmVjdG9yKHZlY3Rvcikge1xuICAgIHRoaXMud3JpdGVWYXJJbnQodmVjdG9yLmxlbmd0aCk7XG4gICAgdmVjdG9yLmZvckVhY2goYnVmID0+IHRoaXMud3JpdGVWYXJTbGljZShidWYpKTtcbiAgfVxuICBlbmQoKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gdGhpcy5vZmZzZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBidWZmZXIgc2l6ZSAke3RoaXMuYnVmZmVyLmxlbmd0aH0sIG9mZnNldCAke3RoaXMub2Zmc2V0fWApO1xuICB9XG59XG5leHBvcnRzLkJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlcjtcbi8qKlxuICogSGVscGVyIGNsYXNzIGZvciByZWFkaW5nIG9mIGJpdGNvaW4gZGF0YSB0eXBlcyBmcm9tIGEgYnVmZmVyLlxuICovXG5jbGFzcyBCdWZmZXJSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihidWZmZXIsIG9mZnNldCA9IDApIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0eXBlZm9yY2UodHlwZXMudHVwbGUodHlwZXMuQnVmZmVyLCB0eXBlcy5VSW50MzIpLCBbYnVmZmVyLCBvZmZzZXRdKTtcbiAgfVxuICByZWFkVUludDgoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5idWZmZXIucmVhZFVJbnQ4KHRoaXMub2Zmc2V0KTtcbiAgICB0aGlzLm9mZnNldCsrO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmVhZEludDMyKCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYnVmZmVyLnJlYWRJbnQzMkxFKHRoaXMub2Zmc2V0KTtcbiAgICB0aGlzLm9mZnNldCArPSA0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmVhZFVJbnQzMigpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDMyTEUodGhpcy5vZmZzZXQpO1xuICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZWFkVUludDY0KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHJlYWRVSW50NjRMRSh0aGlzLmJ1ZmZlciwgdGhpcy5vZmZzZXQpO1xuICAgIHRoaXMub2Zmc2V0ICs9IDg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZWFkVmFySW50KCkge1xuICAgIGNvbnN0IHZpID0gdmFydWludC5kZWNvZGUodGhpcy5idWZmZXIsIHRoaXMub2Zmc2V0KTtcbiAgICB0aGlzLm9mZnNldCArPSB2YXJ1aW50LmRlY29kZS5ieXRlcztcbiAgICByZXR1cm4gdmk7XG4gIH1cbiAgcmVhZFNsaWNlKG4pIHtcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoIDwgdGhpcy5vZmZzZXQgKyBuKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIHNsaWNlIG91dCBvZiBib3VuZHMnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5idWZmZXIuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgbik7XG4gICAgdGhpcy5vZmZzZXQgKz0gbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlYWRWYXJTbGljZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkU2xpY2UodGhpcy5yZWFkVmFySW50KCkpO1xuICB9XG4gIHJlYWRWZWN0b3IoKSB7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLnJlYWRWYXJJbnQoKTtcbiAgICBjb25zdCB2ZWN0b3IgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHZlY3Rvci5wdXNoKHRoaXMucmVhZFZhclNsaWNlKCkpO1xuICAgIHJldHVybiB2ZWN0b3I7XG4gIH1cbn1cbmV4cG9ydHMuQnVmZmVyUmVhZGVyID0gQnVmZmVyUmVhZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/bufferutils.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/crypto.js":
/*!**************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/crypto.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.taggedHash =\n  exports.TAGGED_HASH_PREFIXES =\n  exports.TAGS =\n  exports.hash256 =\n  exports.hash160 =\n  exports.sha256 =\n  exports.sha1 =\n  exports.ripemd160 =\n    void 0;\n/**\n * A module for hashing functions.\n * include ripemd160、sha1、sha256、hash160、hash256、taggedHash\n *\n * @packageDocumentation\n */\nconst ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"./node_modules/@noble/hashes/ripemd160.js\");\nconst sha1_1 = __webpack_require__(/*! @noble/hashes/sha1 */ \"./node_modules/@noble/hashes/sha1.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/@noble/hashes/sha256.js\");\nfunction ripemd160(buffer) {\n  return Buffer.from((0, ripemd160_1.ripemd160)(Uint8Array.from(buffer)));\n}\nexports.ripemd160 = ripemd160;\nfunction sha1(buffer) {\n  return Buffer.from((0, sha1_1.sha1)(Uint8Array.from(buffer)));\n}\nexports.sha1 = sha1;\nfunction sha256(buffer) {\n  return Buffer.from((0, sha256_1.sha256)(Uint8Array.from(buffer)));\n}\nexports.sha256 = sha256;\nfunction hash160(buffer) {\n  return Buffer.from(\n    (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(Uint8Array.from(buffer))),\n  );\n}\nexports.hash160 = hash160;\nfunction hash256(buffer) {\n  return Buffer.from(\n    (0, sha256_1.sha256)((0, sha256_1.sha256)(Uint8Array.from(buffer))),\n  );\n}\nexports.hash256 = hash256;\nexports.TAGS = [\n  'BIP0340/challenge',\n  'BIP0340/aux',\n  'BIP0340/nonce',\n  'TapLeaf',\n  'TapBranch',\n  'TapSighash',\n  'TapTweak',\n  'KeyAgg list',\n  'KeyAgg coefficient',\n];\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\n/**\n * Defines the tagged hash prefixes used in the crypto module.\n */\nexports.TAGGED_HASH_PREFIXES = {\n  'BIP0340/challenge': Buffer.from([\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n  ]),\n  'BIP0340/aux': Buffer.from([\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n  ]),\n  'BIP0340/nonce': Buffer.from([\n    7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244,\n    52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73,\n    119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215,\n    62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47,\n  ]),\n  TapLeaf: Buffer.from([\n    174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211,\n    95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143,\n    220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181,\n    64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238,\n  ]),\n  TapBranch: Buffer.from([\n    25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247,\n    33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25,\n    65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33,\n    111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21,\n  ]),\n  TapSighash: Buffer.from([\n    244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61,\n    149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244,\n    10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149,\n    253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49,\n  ]),\n  TapTweak: Buffer.from([\n    232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66,\n    156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232,\n    15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156,\n    188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233,\n  ]),\n  'KeyAgg list': Buffer.from([\n    72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126,\n    215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28,\n    151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49,\n    156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240,\n  ]),\n  'KeyAgg coefficient': Buffer.from([\n    191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100,\n    130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191,\n    201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130,\n    78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129,\n  ]),\n};\nfunction taggedHash(prefix, data) {\n  return sha256(Buffer.concat([exports.TAGGED_HASH_PREFIXES[prefix], data]));\n}\nexports.taggedHash = taggedHash;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvY3J5cHRvLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsRUFBRSw0QkFBNEI7QUFDOUIsRUFBRSxZQUFZO0FBQ2QsRUFBRSxlQUFlO0FBQ2pCLEVBQUUsZUFBZTtBQUNqQixFQUFFLGNBQWM7QUFDaEIsRUFBRSxZQUFZO0FBQ2QsRUFBRSxpQkFBaUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQywwRUFBeUI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLGdFQUFvQjtBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBc0I7QUFDL0M7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsU0FBUyxNQUFNO0FBQ2Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsdUJBQXVCLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9jcnlwdG8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGFnZ2VkSGFzaCA9XG4gIGV4cG9ydHMuVEFHR0VEX0hBU0hfUFJFRklYRVMgPVxuICBleHBvcnRzLlRBR1MgPVxuICBleHBvcnRzLmhhc2gyNTYgPVxuICBleHBvcnRzLmhhc2gxNjAgPVxuICBleHBvcnRzLnNoYTI1NiA9XG4gIGV4cG9ydHMuc2hhMSA9XG4gIGV4cG9ydHMucmlwZW1kMTYwID1cbiAgICB2b2lkIDA7XG4vKipcbiAqIEEgbW9kdWxlIGZvciBoYXNoaW5nIGZ1bmN0aW9ucy5cbiAqIGluY2x1ZGUgcmlwZW1kMTYw44CBc2hhMeOAgXNoYTI1NuOAgWhhc2gxNjDjgIFoYXNoMjU244CBdGFnZ2VkSGFzaFxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5jb25zdCByaXBlbWQxNjBfMSA9IHJlcXVpcmUoJ0Bub2JsZS9oYXNoZXMvcmlwZW1kMTYwJyk7XG5jb25zdCBzaGExXzEgPSByZXF1aXJlKCdAbm9ibGUvaGFzaGVzL3NoYTEnKTtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZSgnQG5vYmxlL2hhc2hlcy9zaGEyNTYnKTtcbmZ1bmN0aW9uIHJpcGVtZDE2MChidWZmZXIpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCByaXBlbWQxNjBfMS5yaXBlbWQxNjApKFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpKSk7XG59XG5leHBvcnRzLnJpcGVtZDE2MCA9IHJpcGVtZDE2MDtcbmZ1bmN0aW9uIHNoYTEoYnVmZmVyKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgc2hhMV8xLnNoYTEpKFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpKSk7XG59XG5leHBvcnRzLnNoYTEgPSBzaGExO1xuZnVuY3Rpb24gc2hhMjU2KGJ1ZmZlcikge1xuICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIHNoYTI1Nl8xLnNoYTI1NikoVWludDhBcnJheS5mcm9tKGJ1ZmZlcikpKTtcbn1cbmV4cG9ydHMuc2hhMjU2ID0gc2hhMjU2O1xuZnVuY3Rpb24gaGFzaDE2MChidWZmZXIpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICgwLCByaXBlbWQxNjBfMS5yaXBlbWQxNjApKCgwLCBzaGEyNTZfMS5zaGEyNTYpKFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpKSksXG4gICk7XG59XG5leHBvcnRzLmhhc2gxNjAgPSBoYXNoMTYwO1xuZnVuY3Rpb24gaGFzaDI1NihidWZmZXIpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICgwLCBzaGEyNTZfMS5zaGEyNTYpKCgwLCBzaGEyNTZfMS5zaGEyNTYpKFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpKSksXG4gICk7XG59XG5leHBvcnRzLmhhc2gyNTYgPSBoYXNoMjU2O1xuZXhwb3J0cy5UQUdTID0gW1xuICAnQklQMDM0MC9jaGFsbGVuZ2UnLFxuICAnQklQMDM0MC9hdXgnLFxuICAnQklQMDM0MC9ub25jZScsXG4gICdUYXBMZWFmJyxcbiAgJ1RhcEJyYW5jaCcsXG4gICdUYXBTaWdoYXNoJyxcbiAgJ1RhcFR3ZWFrJyxcbiAgJ0tleUFnZyBsaXN0JyxcbiAgJ0tleUFnZyBjb2VmZmljaWVudCcsXG5dO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuLyoqXG4gKiBEZWZpbmVzIHRoZSB0YWdnZWQgaGFzaCBwcmVmaXhlcyB1c2VkIGluIHRoZSBjcnlwdG8gbW9kdWxlLlxuICovXG5leHBvcnRzLlRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge1xuICAnQklQMDM0MC9jaGFsbGVuZ2UnOiBCdWZmZXIuZnJvbShbXG4gICAgMTIzLCAxODEsIDQ1LCAxMjIsIDE1OSwgMjM5LCA4OCwgNTAsIDYyLCAxNzcsIDE5MSwgMTIyLCA2NCwgMTI1LCAxNzksIDEzMCxcbiAgICAyMTAsIDI0MywgMjQyLCAyMTYsIDI3LCAxNzcsIDM0LCA3OSwgNzMsIDI1NCwgODEsIDE0MywgMTA5LCA3MiwgMjExLCAxMjQsXG4gICAgMTIzLCAxODEsIDQ1LCAxMjIsIDE1OSwgMjM5LCA4OCwgNTAsIDYyLCAxNzcsIDE5MSwgMTIyLCA2NCwgMTI1LCAxNzksIDEzMCxcbiAgICAyMTAsIDI0MywgMjQyLCAyMTYsIDI3LCAxNzcsIDM0LCA3OSwgNzMsIDI1NCwgODEsIDE0MywgMTA5LCA3MiwgMjExLCAxMjQsXG4gIF0pLFxuICAnQklQMDM0MC9hdXgnOiBCdWZmZXIuZnJvbShbXG4gICAgMjQxLCAyMzksIDc4LCA5NCwgMTkyLCA5OSwgMjAyLCAyMTgsIDEwOSwgMTQ4LCAyMDIsIDI1MCwgMTU3LCAxNTIsIDEyNiwgMTYwLFxuICAgIDEwNSwgMzgsIDg4LCA1NywgMjM2LCAxOTMsIDMxLCAxNTEsIDQ1LCAxMTksIDE2NSwgNDYsIDIxNiwgMTkzLCAyMDQsIDE0NCxcbiAgICAyNDEsIDIzOSwgNzgsIDk0LCAxOTIsIDk5LCAyMDIsIDIxOCwgMTA5LCAxNDgsIDIwMiwgMjUwLCAxNTcsIDE1MiwgMTI2LCAxNjAsXG4gICAgMTA1LCAzOCwgODgsIDU3LCAyMzYsIDE5MywgMzEsIDE1MSwgNDUsIDExOSwgMTY1LCA0NiwgMjE2LCAxOTMsIDIwNCwgMTQ0LFxuICBdKSxcbiAgJ0JJUDAzNDAvbm9uY2UnOiBCdWZmZXIuZnJvbShbXG4gICAgNywgNzMsIDExOSwgNTIsIDE2NywgMTU1LCAyMDMsIDUzLCA5MSwgMTU1LCAxNDAsIDEyNSwgMywgNzksIDE4LCAyOCwgMjQ0LFxuICAgIDUyLCAyMTUsIDYyLCAyNDcsIDQ1LCAyMTgsIDI1LCAxMzUsIDAsIDk3LCAyNTEsIDgyLCAxOTEsIDIzNSwgNDcsIDcsIDczLFxuICAgIDExOSwgNTIsIDE2NywgMTU1LCAyMDMsIDUzLCA5MSwgMTU1LCAxNDAsIDEyNSwgMywgNzksIDE4LCAyOCwgMjQ0LCA1MiwgMjE1LFxuICAgIDYyLCAyNDcsIDQ1LCAyMTgsIDI1LCAxMzUsIDAsIDk3LCAyNTEsIDgyLCAxOTEsIDIzNSwgNDcsXG4gIF0pLFxuICBUYXBMZWFmOiBCdWZmZXIuZnJvbShbXG4gICAgMTc0LCAyMzQsIDE0MywgMjIwLCA2NiwgOCwgMTUyLCA0OSwgNSwgMTE1LCA3NSwgODgsIDgsIDI5LCAzMCwgMzgsIDU2LCAyMTEsXG4gICAgOTUsIDI4LCAxODEsIDY0LCA4LCAyMTIsIDIxMSwgODcsIDIwMiwgMywgMTkwLCAxMjAsIDIzMywgMjM4LCAxNzQsIDIzNCwgMTQzLFxuICAgIDIyMCwgNjYsIDgsIDE1MiwgNDksIDUsIDExNSwgNzUsIDg4LCA4LCAyOSwgMzAsIDM4LCA1NiwgMjExLCA5NSwgMjgsIDE4MSxcbiAgICA2NCwgOCwgMjEyLCAyMTEsIDg3LCAyMDIsIDMsIDE5MCwgMTIwLCAyMzMsIDIzOCxcbiAgXSksXG4gIFRhcEJyYW5jaDogQnVmZmVyLmZyb20oW1xuICAgIDI1LCA2NSwgMTYxLCAyNDIsIDIyOSwgMTEwLCAxODUsIDk1LCAxNjIsIDE2OSwgMjQxLCAxNDgsIDE5MCwgOTIsIDEsIDI0NyxcbiAgICAzMywgMTExLCA1MSwgMjM3LCAxMzAsIDE3NiwgMTQ1LCA3MCwgNTIsIDE0NCwgMjA4LCA5MSwgMjQ1LCAyMiwgMTYwLCAyMSwgMjUsXG4gICAgNjUsIDE2MSwgMjQyLCAyMjksIDExMCwgMTg1LCA5NSwgMTYyLCAxNjksIDI0MSwgMTQ4LCAxOTAsIDkyLCAxLCAyNDcsIDMzLFxuICAgIDExMSwgNTEsIDIzNywgMTMwLCAxNzYsIDE0NSwgNzAsIDUyLCAxNDQsIDIwOCwgOTEsIDI0NSwgMjIsIDE2MCwgMjEsXG4gIF0pLFxuICBUYXBTaWdoYXNoOiBCdWZmZXIuZnJvbShbXG4gICAgMjQ0LCAxMCwgNzIsIDIyMywgNzUsIDQyLCAxMTIsIDIwMCwgMTgwLCAxNDYsIDc1LCAyNDIsIDEwMSwgNzAsIDk3LCAyMzcsIDYxLFxuICAgIDE0OSwgMjUzLCAxMDIsIDE2MywgMTksIDIzNSwgMTM1LCAzNSwgMTE3LCAxNTEsIDE5OCwgNDAsIDIyOCwgMTYwLCA0OSwgMjQ0LFxuICAgIDEwLCA3MiwgMjIzLCA3NSwgNDIsIDExMiwgMjAwLCAxODAsIDE0NiwgNzUsIDI0MiwgMTAxLCA3MCwgOTcsIDIzNywgNjEsIDE0OSxcbiAgICAyNTMsIDEwMiwgMTYzLCAxOSwgMjM1LCAxMzUsIDM1LCAxMTcsIDE1MSwgMTk4LCA0MCwgMjI4LCAxNjAsIDQ5LFxuICBdKSxcbiAgVGFwVHdlYWs6IEJ1ZmZlci5mcm9tKFtcbiAgICAyMzIsIDE1LCAyMjUsIDk5LCAxNTYsIDE1NiwgMTYwLCA4MCwgMjI3LCAxNzUsIDI3LCA1NywgMTkzLCA2NywgMTk4LCA2MiwgNjYsXG4gICAgMTU2LCAxODgsIDIzNSwgMjEsIDIxNywgNjQsIDI1MSwgMTgxLCAxOTcsIDE2MSwgMjQ0LCAxNzUsIDg3LCAxOTcsIDIzMywgMjMyLFxuICAgIDE1LCAyMjUsIDk5LCAxNTYsIDE1NiwgMTYwLCA4MCwgMjI3LCAxNzUsIDI3LCA1NywgMTkzLCA2NywgMTk4LCA2MiwgNjYsIDE1NixcbiAgICAxODgsIDIzNSwgMjEsIDIxNywgNjQsIDI1MSwgMTgxLCAxOTcsIDE2MSwgMjQ0LCAxNzUsIDg3LCAxOTcsIDIzMyxcbiAgXSksXG4gICdLZXlBZ2cgbGlzdCc6IEJ1ZmZlci5mcm9tKFtcbiAgICA3MiwgMjgsIDE1MSwgMjgsIDYwLCAxMSwgNzAsIDIxNSwgMjQwLCAxNzgsIDExNywgMTc0LCA4OSwgMTQxLCA3OCwgNDQsIDEyNixcbiAgICAyMTUsIDQ5LCAxNTYsIDg5LCA3NCwgOTIsIDExMCwgMTk5LCAxNTgsIDE2MCwgMjEyLCAxNTMsIDIsIDE0OCwgMjQwLCA3MiwgMjgsXG4gICAgMTUxLCAyOCwgNjAsIDExLCA3MCwgMjE1LCAyNDAsIDE3OCwgMTE3LCAxNzQsIDg5LCAxNDEsIDc4LCA0NCwgMTI2LCAyMTUsIDQ5LFxuICAgIDE1NiwgODksIDc0LCA5MiwgMTEwLCAxOTksIDE1OCwgMTYwLCAyMTIsIDE1MywgMiwgMTQ4LCAyNDAsXG4gIF0pLFxuICAnS2V5QWdnIGNvZWZmaWNpZW50JzogQnVmZmVyLmZyb20oW1xuICAgIDE5MSwgMjAxLCA0LCAzLCA3NywgMjgsIDEzNiwgMjMyLCAyMDAsIDE0LCAzNCwgMjI5LCA2MSwgMzYsIDg2LCAxMDksIDEwMCxcbiAgICAxMzAsIDc4LCAyMTQsIDY2LCAxMTQsIDEyOSwgMTkyLCAxNDUsIDAsIDI0OSwgNzcsIDIwNSwgODIsIDIwMSwgMTI5LCAxOTEsXG4gICAgMjAxLCA0LCAzLCA3NywgMjgsIDEzNiwgMjMyLCAyMDAsIDE0LCAzNCwgMjI5LCA2MSwgMzYsIDg2LCAxMDksIDEwMCwgMTMwLFxuICAgIDc4LCAyMTQsIDY2LCAxMTQsIDEyOSwgMTkyLCAxNDUsIDAsIDI0OSwgNzcsIDIwNSwgODIsIDIwMSwgMTI5LFxuICBdKSxcbn07XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHByZWZpeCwgZGF0YSkge1xuICByZXR1cm4gc2hhMjU2KEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuVEFHR0VEX0hBU0hfUFJFRklYRVNbcHJlZml4XSwgZGF0YV0pKTtcbn1cbmV4cG9ydHMudGFnZ2VkSGFzaCA9IHRhZ2dlZEhhc2g7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/crypto.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/ecc_lib.js":
/*!***************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/ecc_lib.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getEccLib = exports.initEccLib = void 0;\nconst _ECCLIB_CACHE = {};\n/**\n * Initializes the ECC library with the provided instance.\n * If `eccLib` is `undefined`, the library will be cleared.\n * If `eccLib` is a new instance, it will be verified before setting it as the active library.\n *\n * @param eccLib The instance of the ECC library to initialize.\n * @param opts Extra initialization options. Use {DANGER_DO_NOT_VERIFY_ECCLIB:true} if ecc verification should not be executed. Not recommended!\n */\nfunction initEccLib(eccLib, opts) {\n  if (!eccLib) {\n    // allow clearing the library\n    _ECCLIB_CACHE.eccLib = eccLib;\n  } else if (eccLib !== _ECCLIB_CACHE.eccLib) {\n    if (!opts?.DANGER_DO_NOT_VERIFY_ECCLIB)\n      // new instance, verify it\n      verifyEcc(eccLib);\n    _ECCLIB_CACHE.eccLib = eccLib;\n  }\n}\nexports.initEccLib = initEccLib;\n/**\n * Retrieves the ECC Library instance.\n * Throws an error if the ECC Library is not provided.\n * You must call initEccLib() with a valid TinySecp256k1Interface instance before calling this function.\n * @returns The ECC Library instance.\n * @throws Error if the ECC Library is not provided.\n */\nfunction getEccLib() {\n  if (!_ECCLIB_CACHE.eccLib)\n    throw new Error(\n      'No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance',\n    );\n  return _ECCLIB_CACHE.eccLib;\n}\nexports.getEccLib = getEccLib;\nconst h = hex => Buffer.from(hex, 'hex');\n/**\n * Verifies the ECC functionality.\n *\n * @param ecc - The TinySecp256k1Interface object.\n */\nfunction verifyEcc(ecc) {\n  assert(typeof ecc.isXOnlyPoint === 'function');\n  assert(\n    ecc.isXOnlyPoint(\n      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000001'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000000'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    ),\n  );\n  assert(typeof ecc.xOnlyPointAddTweak === 'function');\n  tweakAddVectors.forEach(t => {\n    const r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));\n    if (t.result === null) {\n      assert(r === null);\n    } else {\n      assert(r !== null);\n      assert(r.parity === t.parity);\n      assert(Buffer.from(r.xOnlyPubkey).equals(h(t.result)));\n    }\n  });\n}\nfunction assert(bool) {\n  if (!bool) throw new Error('ecc library invalid');\n}\nconst tweakAddVectors = [\n  {\n    pubkey: '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    tweak: 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',\n    parity: -1,\n    result: null,\n  },\n  {\n    pubkey: '1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b',\n    tweak: 'a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac',\n    parity: 1,\n    result: 'e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf',\n  },\n  {\n    pubkey: '2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991',\n    tweak: '823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47',\n    parity: 0,\n    result: '9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c',\n  },\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvZWNjX2xpYi5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtDQUFrQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9lY2NfbGliLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVjY0xpYiA9IGV4cG9ydHMuaW5pdEVjY0xpYiA9IHZvaWQgMDtcbmNvbnN0IF9FQ0NMSUJfQ0FDSEUgPSB7fTtcbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIEVDQyBsaWJyYXJ5IHdpdGggdGhlIHByb3ZpZGVkIGluc3RhbmNlLlxuICogSWYgYGVjY0xpYmAgaXMgYHVuZGVmaW5lZGAsIHRoZSBsaWJyYXJ5IHdpbGwgYmUgY2xlYXJlZC5cbiAqIElmIGBlY2NMaWJgIGlzIGEgbmV3IGluc3RhbmNlLCBpdCB3aWxsIGJlIHZlcmlmaWVkIGJlZm9yZSBzZXR0aW5nIGl0IGFzIHRoZSBhY3RpdmUgbGlicmFyeS5cbiAqXG4gKiBAcGFyYW0gZWNjTGliIFRoZSBpbnN0YW5jZSBvZiB0aGUgRUNDIGxpYnJhcnkgdG8gaW5pdGlhbGl6ZS5cbiAqIEBwYXJhbSBvcHRzIEV4dHJhIGluaXRpYWxpemF0aW9uIG9wdGlvbnMuIFVzZSB7REFOR0VSX0RPX05PVF9WRVJJRllfRUNDTElCOnRydWV9IGlmIGVjYyB2ZXJpZmljYXRpb24gc2hvdWxkIG5vdCBiZSBleGVjdXRlZC4gTm90IHJlY29tbWVuZGVkIVxuICovXG5mdW5jdGlvbiBpbml0RWNjTGliKGVjY0xpYiwgb3B0cykge1xuICBpZiAoIWVjY0xpYikge1xuICAgIC8vIGFsbG93IGNsZWFyaW5nIHRoZSBsaWJyYXJ5XG4gICAgX0VDQ0xJQl9DQUNIRS5lY2NMaWIgPSBlY2NMaWI7XG4gIH0gZWxzZSBpZiAoZWNjTGliICE9PSBfRUNDTElCX0NBQ0hFLmVjY0xpYikge1xuICAgIGlmICghb3B0cz8uREFOR0VSX0RPX05PVF9WRVJJRllfRUNDTElCKVxuICAgICAgLy8gbmV3IGluc3RhbmNlLCB2ZXJpZnkgaXRcbiAgICAgIHZlcmlmeUVjYyhlY2NMaWIpO1xuICAgIF9FQ0NMSUJfQ0FDSEUuZWNjTGliID0gZWNjTGliO1xuICB9XG59XG5leHBvcnRzLmluaXRFY2NMaWIgPSBpbml0RWNjTGliO1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIEVDQyBMaWJyYXJ5IGluc3RhbmNlLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBFQ0MgTGlicmFyeSBpcyBub3QgcHJvdmlkZWQuXG4gKiBZb3UgbXVzdCBjYWxsIGluaXRFY2NMaWIoKSB3aXRoIGEgdmFsaWQgVGlueVNlY3AyNTZrMUludGVyZmFjZSBpbnN0YW5jZSBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICogQHJldHVybnMgVGhlIEVDQyBMaWJyYXJ5IGluc3RhbmNlLlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgRUNDIExpYnJhcnkgaXMgbm90IHByb3ZpZGVkLlxuICovXG5mdW5jdGlvbiBnZXRFY2NMaWIoKSB7XG4gIGlmICghX0VDQ0xJQl9DQUNIRS5lY2NMaWIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ05vIEVDQyBMaWJyYXJ5IHByb3ZpZGVkLiBZb3UgbXVzdCBjYWxsIGluaXRFY2NMaWIoKSB3aXRoIGEgdmFsaWQgVGlueVNlY3AyNTZrMUludGVyZmFjZSBpbnN0YW5jZScsXG4gICAgKTtcbiAgcmV0dXJuIF9FQ0NMSUJfQ0FDSEUuZWNjTGliO1xufVxuZXhwb3J0cy5nZXRFY2NMaWIgPSBnZXRFY2NMaWI7XG5jb25zdCBoID0gaGV4ID0+IEJ1ZmZlci5mcm9tKGhleCwgJ2hleCcpO1xuLyoqXG4gKiBWZXJpZmllcyB0aGUgRUNDIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogQHBhcmFtIGVjYyAtIFRoZSBUaW55U2VjcDI1NmsxSW50ZXJmYWNlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ5RWNjKGVjYykge1xuICBhc3NlcnQodHlwZW9mIGVjYy5pc1hPbmx5UG9pbnQgPT09ICdmdW5jdGlvbicpO1xuICBhc3NlcnQoXG4gICAgZWNjLmlzWE9ubHlQb2ludChcbiAgICAgIGgoJzc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OTgnKSxcbiAgICApLFxuICApO1xuICBhc3NlcnQoXG4gICAgZWNjLmlzWE9ubHlQb2ludChcbiAgICAgIGgoJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZWZmZmZjMmUnKSxcbiAgICApLFxuICApO1xuICBhc3NlcnQoXG4gICAgZWNjLmlzWE9ubHlQb2ludChcbiAgICAgIGgoJ2Y5MzA4YTAxOTI1OGMzMTA0OTM0NGY4NWY4OWQ1MjI5YjUzMWM4NDU4MzZmOTliMDg2MDFmMTEzYmNlMDM2ZjknKSxcbiAgICApLFxuICApO1xuICBhc3NlcnQoXG4gICAgZWNjLmlzWE9ubHlQb2ludChcbiAgICAgIGgoJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnKSxcbiAgICApLFxuICApO1xuICBhc3NlcnQoXG4gICAgIWVjYy5pc1hPbmx5UG9pbnQoXG4gICAgICBoKCcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyksXG4gICAgKSxcbiAgKTtcbiAgYXNzZXJ0KFxuICAgICFlY2MuaXNYT25seVBvaW50KFxuICAgICAgaCgnZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpLFxuICAgICksXG4gICk7XG4gIGFzc2VydCh0eXBlb2YgZWNjLnhPbmx5UG9pbnRBZGRUd2VhayA9PT0gJ2Z1bmN0aW9uJyk7XG4gIHR3ZWFrQWRkVmVjdG9ycy5mb3JFYWNoKHQgPT4ge1xuICAgIGNvbnN0IHIgPSBlY2MueE9ubHlQb2ludEFkZFR3ZWFrKGgodC5wdWJrZXkpLCBoKHQudHdlYWspKTtcbiAgICBpZiAodC5yZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIGFzc2VydChyID09PSBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KHIgIT09IG51bGwpO1xuICAgICAgYXNzZXJ0KHIucGFyaXR5ID09PSB0LnBhcml0eSk7XG4gICAgICBhc3NlcnQoQnVmZmVyLmZyb20oci54T25seVB1YmtleSkuZXF1YWxzKGgodC5yZXN1bHQpKSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFzc2VydChib29sKSB7XG4gIGlmICghYm9vbCkgdGhyb3cgbmV3IEVycm9yKCdlY2MgbGlicmFyeSBpbnZhbGlkJyk7XG59XG5jb25zdCB0d2Vha0FkZFZlY3RvcnMgPSBbXG4gIHtcbiAgICBwdWJrZXk6ICc3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4JyxcbiAgICB0d2VhazogJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDAnLFxuICAgIHBhcml0eTogLTEsXG4gICAgcmVzdWx0OiBudWxsLFxuICB9LFxuICB7XG4gICAgcHVia2V5OiAnMTYxN2QzOGVkOGQ4NjU3ZGE0ZDQ3NjFlODA1N2JjMzk2ZWE5ZTRiOWQyOTc3NmQ0YmUwOTYwMTZkYmQyNTA5YicsXG4gICAgdHdlYWs6ICdhODM5N2E5MzVmMGRmY2ViYTZiYTk2MThmNjQ1MWVmNGQ4MDYzN2FiZjRlNmFmMjY2OWZiYzlkZTZhOGZkMmFjJyxcbiAgICBwYXJpdHk6IDEsXG4gICAgcmVzdWx0OiAnZTQ3OGY5OWRhYjkxMDUyYWIzOWEzM2VhMzVmZDVlNmU0OTMzZjRkMjgwMjNjZDU5N2M5YTFmNjc2MDM0NmFkZicsXG4gIH0sXG4gIHtcbiAgICBwdWJrZXk6ICcyYzBiN2NmOTUzMjRhMDdkMDUzOThiMjQwMTc0ZGMwYzJiZTQ0NGQ5NmIxNTlhYTZjN2Y3YjFlNjY4NjgwOTkxJyxcbiAgICB0d2VhazogJzgyM2MzY2QyMTQyNzQ0YjA3NWE4N2VhZGU3ZTFiODY3OGJhMzA4ZDU2NjIyNmEwMDU2Y2EyYjdhNzZmODZiNDcnLFxuICAgIHBhcml0eTogMCxcbiAgICByZXN1bHQ6ICc5NTM0ZjhkYzhjNmRlZGEyZGMwMDc2NTU5ODFjNzhiNDljNWQ5NmM3NzhmYmYzNjM0NjJhMTFlYzlkZmQ5NDhjJyxcbiAgfSxcbl07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/ecc_lib.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.initEccLib =\n  exports.Transaction =\n  exports.opcodes =\n  exports.Psbt =\n  exports.Block =\n  exports.script =\n  exports.payments =\n  exports.networks =\n  exports.crypto =\n  exports.address =\n    void 0;\nconst address = __webpack_require__(/*! ./address */ \"./node_modules/bitcoinjs-lib/src/address.js\");\nexports.address = address;\nconst crypto = __webpack_require__(/*! ./crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\");\nexports.crypto = crypto;\nconst networks = __webpack_require__(/*! ./networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\");\nexports.networks = networks;\nconst payments = __webpack_require__(/*! ./payments */ \"./node_modules/bitcoinjs-lib/src/payments/index.js\");\nexports.payments = payments;\nconst script = __webpack_require__(/*! ./script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nexports.script = script;\nvar block_1 = __webpack_require__(/*! ./block */ \"./node_modules/bitcoinjs-lib/src/block.js\");\nObject.defineProperty(exports, \"Block\", ({\n  enumerable: true,\n  get: function () {\n    return block_1.Block;\n  },\n}));\nvar psbt_1 = __webpack_require__(/*! ./psbt */ \"./node_modules/bitcoinjs-lib/src/psbt.js\");\nObject.defineProperty(exports, \"Psbt\", ({\n  enumerable: true,\n  get: function () {\n    return psbt_1.Psbt;\n  },\n}));\n/** @hidden */\nvar ops_1 = __webpack_require__(/*! ./ops */ \"./node_modules/bitcoinjs-lib/src/ops.js\");\nObject.defineProperty(exports, \"opcodes\", ({\n  enumerable: true,\n  get: function () {\n    return ops_1.OPS;\n  },\n}));\nvar transaction_1 = __webpack_require__(/*! ./transaction */ \"./node_modules/bitcoinjs-lib/src/transaction.js\");\nObject.defineProperty(exports, \"Transaction\", ({\n  enumerable: true,\n  get: function () {\n    return transaction_1.Transaction;\n  },\n}));\nvar ecc_lib_1 = __webpack_require__(/*! ./ecc_lib */ \"./node_modules/bitcoinjs-lib/src/ecc_lib.js\");\nObject.defineProperty(exports, \"initEccLib\", ({\n  enumerable: true,\n  get: function () {\n    return ecc_lib_1.initEccLib;\n  },\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLEVBQUUsbUJBQW1CO0FBQ3JCLEVBQUUsZUFBZTtBQUNqQixFQUFFLFlBQVk7QUFDZCxFQUFFLGFBQWE7QUFDZixFQUFFLGNBQWM7QUFDaEIsRUFBRSxnQkFBZ0I7QUFDbEIsRUFBRSxnQkFBZ0I7QUFDbEIsRUFBRSxjQUFjO0FBQ2hCLEVBQUUsZUFBZTtBQUNqQjtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDhEQUFXO0FBQ25DLGVBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsNERBQVU7QUFDakMsY0FBYztBQUNkLGlCQUFpQixtQkFBTyxDQUFDLGdFQUFZO0FBQ3JDLGdCQUFnQjtBQUNoQixpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBWTtBQUNyQyxnQkFBZ0I7QUFDaEIsZUFBZSxtQkFBTyxDQUFDLDREQUFVO0FBQ2pDLGNBQWM7QUFDZCxjQUFjLG1CQUFPLENBQUMsMERBQVM7QUFDL0IseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLEVBQUM7QUFDRixhQUFhLG1CQUFPLENBQUMsd0RBQVE7QUFDN0Isd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLEVBQUM7QUFDRjtBQUNBLFlBQVksbUJBQU8sQ0FBQyxzREFBTztBQUMzQiwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsRUFBQztBQUNGLG9CQUFvQixtQkFBTyxDQUFDLHNFQUFlO0FBQzNDLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFQUFDO0FBQ0YsZ0JBQWdCLG1CQUFPLENBQUMsOERBQVc7QUFDbkMsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5pdEVjY0xpYiA9XG4gIGV4cG9ydHMuVHJhbnNhY3Rpb24gPVxuICBleHBvcnRzLm9wY29kZXMgPVxuICBleHBvcnRzLlBzYnQgPVxuICBleHBvcnRzLkJsb2NrID1cbiAgZXhwb3J0cy5zY3JpcHQgPVxuICBleHBvcnRzLnBheW1lbnRzID1cbiAgZXhwb3J0cy5uZXR3b3JrcyA9XG4gIGV4cG9ydHMuY3J5cHRvID1cbiAgZXhwb3J0cy5hZGRyZXNzID1cbiAgICB2b2lkIDA7XG5jb25zdCBhZGRyZXNzID0gcmVxdWlyZSgnLi9hZGRyZXNzJyk7XG5leHBvcnRzLmFkZHJlc3MgPSBhZGRyZXNzO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnLi9jcnlwdG8nKTtcbmV4cG9ydHMuY3J5cHRvID0gY3J5cHRvO1xuY29uc3QgbmV0d29ya3MgPSByZXF1aXJlKCcuL25ldHdvcmtzJyk7XG5leHBvcnRzLm5ldHdvcmtzID0gbmV0d29ya3M7XG5jb25zdCBwYXltZW50cyA9IHJlcXVpcmUoJy4vcGF5bWVudHMnKTtcbmV4cG9ydHMucGF5bWVudHMgPSBwYXltZW50cztcbmNvbnN0IHNjcmlwdCA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG5leHBvcnRzLnNjcmlwdCA9IHNjcmlwdDtcbnZhciBibG9ja18xID0gcmVxdWlyZSgnLi9ibG9jaycpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdCbG9jaycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGJsb2NrXzEuQmxvY2s7XG4gIH0sXG59KTtcbnZhciBwc2J0XzEgPSByZXF1aXJlKCcuL3BzYnQnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnUHNidCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBzYnRfMS5Qc2J0O1xuICB9LFxufSk7XG4vKiogQGhpZGRlbiAqL1xudmFyIG9wc18xID0gcmVxdWlyZSgnLi9vcHMnKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnb3Bjb2RlcycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG9wc18xLk9QUztcbiAgfSxcbn0pO1xudmFyIHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKCcuL3RyYW5zYWN0aW9uJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ1RyYW5zYWN0aW9uJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbjtcbiAgfSxcbn0pO1xudmFyIGVjY19saWJfMSA9IHJlcXVpcmUoJy4vZWNjX2xpYicpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdpbml0RWNjTGliJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZWNjX2xpYl8xLmluaXRFY2NMaWI7XG4gIH0sXG59KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/index.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/merkle.js":
/*!**************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/merkle.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fastMerkleRoot = void 0;\n/**\n * Calculates the Merkle root of an array of buffers using a specified digest function.\n *\n * @param values - The array of buffers.\n * @param digestFn - The digest function used to calculate the hash of the concatenated buffers.\n * @returns The Merkle root as a buffer.\n * @throws {TypeError} If the values parameter is not an array or the digestFn parameter is not a function.\n */\nfunction fastMerkleRoot(values, digestFn) {\n  if (!Array.isArray(values)) throw TypeError('Expected values Array');\n  if (typeof digestFn !== 'function')\n    throw TypeError('Expected digest Function');\n  let length = values.length;\n  const results = values.concat();\n  while (length > 1) {\n    let j = 0;\n    for (let i = 0; i < length; i += 2, ++j) {\n      const left = results[i];\n      const right = i + 1 === length ? left : results[i + 1];\n      const data = Buffer.concat([left, right]);\n      results[j] = digestFn(data);\n    }\n    length = j;\n  }\n  return results[0];\n}\nexports.fastMerkleRoot = fastMerkleRoot;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvbWVya2xlLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvbWVya2xlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZhc3RNZXJrbGVSb290ID0gdm9pZCAwO1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBNZXJrbGUgcm9vdCBvZiBhbiBhcnJheSBvZiBidWZmZXJzIHVzaW5nIGEgc3BlY2lmaWVkIGRpZ2VzdCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIGFycmF5IG9mIGJ1ZmZlcnMuXG4gKiBAcGFyYW0gZGlnZXN0Rm4gLSBUaGUgZGlnZXN0IGZ1bmN0aW9uIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBoYXNoIG9mIHRoZSBjb25jYXRlbmF0ZWQgYnVmZmVycy5cbiAqIEByZXR1cm5zIFRoZSBNZXJrbGUgcm9vdCBhcyBhIGJ1ZmZlci5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIHZhbHVlcyBwYXJhbWV0ZXIgaXMgbm90IGFuIGFycmF5IG9yIHRoZSBkaWdlc3RGbiBwYXJhbWV0ZXIgaXMgbm90IGEgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZhc3RNZXJrbGVSb290KHZhbHVlcywgZGlnZXN0Rm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHRocm93IFR5cGVFcnJvcignRXhwZWN0ZWQgdmFsdWVzIEFycmF5Jyk7XG4gIGlmICh0eXBlb2YgZGlnZXN0Rm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdFeHBlY3RlZCBkaWdlc3QgRnVuY3Rpb24nKTtcbiAgbGV0IGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdHMgPSB2YWx1ZXMuY29uY2F0KCk7XG4gIHdoaWxlIChsZW5ndGggPiAxKSB7XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDIsICsraikge1xuICAgICAgY29uc3QgbGVmdCA9IHJlc3VsdHNbaV07XG4gICAgICBjb25zdCByaWdodCA9IGkgKyAxID09PSBsZW5ndGggPyBsZWZ0IDogcmVzdWx0c1tpICsgMV07XG4gICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmNvbmNhdChbbGVmdCwgcmlnaHRdKTtcbiAgICAgIHJlc3VsdHNbal0gPSBkaWdlc3RGbihkYXRhKTtcbiAgICB9XG4gICAgbGVuZ3RoID0gajtcbiAgfVxuICByZXR1cm4gcmVzdWx0c1swXTtcbn1cbmV4cG9ydHMuZmFzdE1lcmtsZVJvb3QgPSBmYXN0TWVya2xlUm9vdDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/merkle.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/networks.js":
/*!****************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/networks.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n// https://en.bitcoin.it/wiki/List_of_address_prefixes\n// Dogecoin BIP32 is a proposed standard: https://bitcointalk.org/index.php?topic=409731\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.testnet = exports.regtest = exports.bitcoin = void 0;\n/**\n * Represents the Bitcoin network configuration.\n */\nexports.bitcoin = {\n  /**\n   * The message prefix used for signing Bitcoin messages.\n   */\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  /**\n   * The Bech32 prefix used for Bitcoin addresses.\n   */\n  bech32: 'bc',\n  /**\n   * The BIP32 key prefixes for Bitcoin.\n   */\n  bip32: {\n    /**\n     * The public key prefix for BIP32 extended public keys.\n     */\n    public: 0x0488b21e,\n    /**\n     * The private key prefix for BIP32 extended private keys.\n     */\n    private: 0x0488ade4,\n  },\n  /**\n   * The prefix for Bitcoin public key hashes.\n   */\n  pubKeyHash: 0x00,\n  /**\n   * The prefix for Bitcoin script hashes.\n   */\n  scriptHash: 0x05,\n  /**\n   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.\n   */\n  wif: 0x80,\n};\n/**\n * Represents the regtest network configuration.\n */\nexports.regtest = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bcrt',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n/**\n * Represents the testnet network configuration.\n */\nexports.testnet = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'tb',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvbmV0d29ya3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxlQUFlLEdBQUcsZUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvbmV0d29ya3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly9lbi5iaXRjb2luLml0L3dpa2kvTGlzdF9vZl9hZGRyZXNzX3ByZWZpeGVzXG4vLyBEb2dlY29pbiBCSVAzMiBpcyBhIHByb3Bvc2VkIHN0YW5kYXJkOiBodHRwczovL2JpdGNvaW50YWxrLm9yZy9pbmRleC5waHA/dG9waWM9NDA5NzMxXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50ZXN0bmV0ID0gZXhwb3J0cy5yZWd0ZXN0ID0gZXhwb3J0cy5iaXRjb2luID0gdm9pZCAwO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBCaXRjb2luIG5ldHdvcmsgY29uZmlndXJhdGlvbi5cbiAqL1xuZXhwb3J0cy5iaXRjb2luID0ge1xuICAvKipcbiAgICogVGhlIG1lc3NhZ2UgcHJlZml4IHVzZWQgZm9yIHNpZ25pbmcgQml0Y29pbiBtZXNzYWdlcy5cbiAgICovXG4gIG1lc3NhZ2VQcmVmaXg6ICdcXHgxOEJpdGNvaW4gU2lnbmVkIE1lc3NhZ2U6XFxuJyxcbiAgLyoqXG4gICAqIFRoZSBCZWNoMzIgcHJlZml4IHVzZWQgZm9yIEJpdGNvaW4gYWRkcmVzc2VzLlxuICAgKi9cbiAgYmVjaDMyOiAnYmMnLFxuICAvKipcbiAgICogVGhlIEJJUDMyIGtleSBwcmVmaXhlcyBmb3IgQml0Y29pbi5cbiAgICovXG4gIGJpcDMyOiB7XG4gICAgLyoqXG4gICAgICogVGhlIHB1YmxpYyBrZXkgcHJlZml4IGZvciBCSVAzMiBleHRlbmRlZCBwdWJsaWMga2V5cy5cbiAgICAgKi9cbiAgICBwdWJsaWM6IDB4MDQ4OGIyMWUsXG4gICAgLyoqXG4gICAgICogVGhlIHByaXZhdGUga2V5IHByZWZpeCBmb3IgQklQMzIgZXh0ZW5kZWQgcHJpdmF0ZSBrZXlzLlxuICAgICAqL1xuICAgIHByaXZhdGU6IDB4MDQ4OGFkZTQsXG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgcHJlZml4IGZvciBCaXRjb2luIHB1YmxpYyBrZXkgaGFzaGVzLlxuICAgKi9cbiAgcHViS2V5SGFzaDogMHgwMCxcbiAgLyoqXG4gICAqIFRoZSBwcmVmaXggZm9yIEJpdGNvaW4gc2NyaXB0IGhhc2hlcy5cbiAgICovXG4gIHNjcmlwdEhhc2g6IDB4MDUsXG4gIC8qKlxuICAgKiBUaGUgcHJlZml4IGZvciBCaXRjb2luIFdhbGxldCBJbXBvcnQgRm9ybWF0IChXSUYpIHByaXZhdGUga2V5cy5cbiAgICovXG4gIHdpZjogMHg4MCxcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHJlZ3Rlc3QgbmV0d29yayBjb25maWd1cmF0aW9uLlxuICovXG5leHBvcnRzLnJlZ3Rlc3QgPSB7XG4gIG1lc3NhZ2VQcmVmaXg6ICdcXHgxOEJpdGNvaW4gU2lnbmVkIE1lc3NhZ2U6XFxuJyxcbiAgYmVjaDMyOiAnYmNydCcsXG4gIGJpcDMyOiB7XG4gICAgcHVibGljOiAweDA0MzU4N2NmLFxuICAgIHByaXZhdGU6IDB4MDQzNTgzOTQsXG4gIH0sXG4gIHB1YktleUhhc2g6IDB4NmYsXG4gIHNjcmlwdEhhc2g6IDB4YzQsXG4gIHdpZjogMHhlZixcbn07XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHRlc3RuZXQgbmV0d29yayBjb25maWd1cmF0aW9uLlxuICovXG5leHBvcnRzLnRlc3RuZXQgPSB7XG4gIG1lc3NhZ2VQcmVmaXg6ICdcXHgxOEJpdGNvaW4gU2lnbmVkIE1lc3NhZ2U6XFxuJyxcbiAgYmVjaDMyOiAndGInLFxuICBiaXAzMjoge1xuICAgIHB1YmxpYzogMHgwNDM1ODdjZixcbiAgICBwcml2YXRlOiAweDA0MzU4Mzk0LFxuICB9LFxuICBwdWJLZXlIYXNoOiAweDZmLFxuICBzY3JpcHRIYXNoOiAweGM0LFxuICB3aWY6IDB4ZWYsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/networks.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/ops.js":
/*!***********************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/ops.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.REVERSE_OPS = exports.OPS = void 0;\nconst OPS = {\n  OP_FALSE: 0,\n  OP_0: 0,\n  OP_PUSHDATA1: 76,\n  OP_PUSHDATA2: 77,\n  OP_PUSHDATA4: 78,\n  OP_1NEGATE: 79,\n  OP_RESERVED: 80,\n  OP_TRUE: 81,\n  OP_1: 81,\n  OP_2: 82,\n  OP_3: 83,\n  OP_4: 84,\n  OP_5: 85,\n  OP_6: 86,\n  OP_7: 87,\n  OP_8: 88,\n  OP_9: 89,\n  OP_10: 90,\n  OP_11: 91,\n  OP_12: 92,\n  OP_13: 93,\n  OP_14: 94,\n  OP_15: 95,\n  OP_16: 96,\n  OP_NOP: 97,\n  OP_VER: 98,\n  OP_IF: 99,\n  OP_NOTIF: 100,\n  OP_VERIF: 101,\n  OP_VERNOTIF: 102,\n  OP_ELSE: 103,\n  OP_ENDIF: 104,\n  OP_VERIFY: 105,\n  OP_RETURN: 106,\n  OP_TOALTSTACK: 107,\n  OP_FROMALTSTACK: 108,\n  OP_2DROP: 109,\n  OP_2DUP: 110,\n  OP_3DUP: 111,\n  OP_2OVER: 112,\n  OP_2ROT: 113,\n  OP_2SWAP: 114,\n  OP_IFDUP: 115,\n  OP_DEPTH: 116,\n  OP_DROP: 117,\n  OP_DUP: 118,\n  OP_NIP: 119,\n  OP_OVER: 120,\n  OP_PICK: 121,\n  OP_ROLL: 122,\n  OP_ROT: 123,\n  OP_SWAP: 124,\n  OP_TUCK: 125,\n  OP_CAT: 126,\n  OP_SUBSTR: 127,\n  OP_LEFT: 128,\n  OP_RIGHT: 129,\n  OP_SIZE: 130,\n  OP_INVERT: 131,\n  OP_AND: 132,\n  OP_OR: 133,\n  OP_XOR: 134,\n  OP_EQUAL: 135,\n  OP_EQUALVERIFY: 136,\n  OP_RESERVED1: 137,\n  OP_RESERVED2: 138,\n  OP_1ADD: 139,\n  OP_1SUB: 140,\n  OP_2MUL: 141,\n  OP_2DIV: 142,\n  OP_NEGATE: 143,\n  OP_ABS: 144,\n  OP_NOT: 145,\n  OP_0NOTEQUAL: 146,\n  OP_ADD: 147,\n  OP_SUB: 148,\n  OP_MUL: 149,\n  OP_DIV: 150,\n  OP_MOD: 151,\n  OP_LSHIFT: 152,\n  OP_RSHIFT: 153,\n  OP_BOOLAND: 154,\n  OP_BOOLOR: 155,\n  OP_NUMEQUAL: 156,\n  OP_NUMEQUALVERIFY: 157,\n  OP_NUMNOTEQUAL: 158,\n  OP_LESSTHAN: 159,\n  OP_GREATERTHAN: 160,\n  OP_LESSTHANOREQUAL: 161,\n  OP_GREATERTHANOREQUAL: 162,\n  OP_MIN: 163,\n  OP_MAX: 164,\n  OP_WITHIN: 165,\n  OP_RIPEMD160: 166,\n  OP_SHA1: 167,\n  OP_SHA256: 168,\n  OP_HASH160: 169,\n  OP_HASH256: 170,\n  OP_CODESEPARATOR: 171,\n  OP_CHECKSIG: 172,\n  OP_CHECKSIGVERIFY: 173,\n  OP_CHECKMULTISIG: 174,\n  OP_CHECKMULTISIGVERIFY: 175,\n  OP_NOP1: 176,\n  OP_NOP2: 177,\n  OP_CHECKLOCKTIMEVERIFY: 177,\n  OP_NOP3: 178,\n  OP_CHECKSEQUENCEVERIFY: 178,\n  OP_NOP4: 179,\n  OP_NOP5: 180,\n  OP_NOP6: 181,\n  OP_NOP7: 182,\n  OP_NOP8: 183,\n  OP_NOP9: 184,\n  OP_NOP10: 185,\n  OP_CHECKSIGADD: 186,\n  OP_PUBKEYHASH: 253,\n  OP_PUBKEY: 254,\n  OP_INVALIDOPCODE: 255,\n};\nexports.OPS = OPS;\nconst REVERSE_OPS = {};\nexports.REVERSE_OPS = REVERSE_OPS;\nfor (const op of Object.keys(OPS)) {\n  const code = OPS[op];\n  REVERSE_OPS[code] = op;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvb3BzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvb3BzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJFVkVSU0VfT1BTID0gZXhwb3J0cy5PUFMgPSB2b2lkIDA7XG5jb25zdCBPUFMgPSB7XG4gIE9QX0ZBTFNFOiAwLFxuICBPUF8wOiAwLFxuICBPUF9QVVNIREFUQTE6IDc2LFxuICBPUF9QVVNIREFUQTI6IDc3LFxuICBPUF9QVVNIREFUQTQ6IDc4LFxuICBPUF8xTkVHQVRFOiA3OSxcbiAgT1BfUkVTRVJWRUQ6IDgwLFxuICBPUF9UUlVFOiA4MSxcbiAgT1BfMTogODEsXG4gIE9QXzI6IDgyLFxuICBPUF8zOiA4MyxcbiAgT1BfNDogODQsXG4gIE9QXzU6IDg1LFxuICBPUF82OiA4NixcbiAgT1BfNzogODcsXG4gIE9QXzg6IDg4LFxuICBPUF85OiA4OSxcbiAgT1BfMTA6IDkwLFxuICBPUF8xMTogOTEsXG4gIE9QXzEyOiA5MixcbiAgT1BfMTM6IDkzLFxuICBPUF8xNDogOTQsXG4gIE9QXzE1OiA5NSxcbiAgT1BfMTY6IDk2LFxuICBPUF9OT1A6IDk3LFxuICBPUF9WRVI6IDk4LFxuICBPUF9JRjogOTksXG4gIE9QX05PVElGOiAxMDAsXG4gIE9QX1ZFUklGOiAxMDEsXG4gIE9QX1ZFUk5PVElGOiAxMDIsXG4gIE9QX0VMU0U6IDEwMyxcbiAgT1BfRU5ESUY6IDEwNCxcbiAgT1BfVkVSSUZZOiAxMDUsXG4gIE9QX1JFVFVSTjogMTA2LFxuICBPUF9UT0FMVFNUQUNLOiAxMDcsXG4gIE9QX0ZST01BTFRTVEFDSzogMTA4LFxuICBPUF8yRFJPUDogMTA5LFxuICBPUF8yRFVQOiAxMTAsXG4gIE9QXzNEVVA6IDExMSxcbiAgT1BfMk9WRVI6IDExMixcbiAgT1BfMlJPVDogMTEzLFxuICBPUF8yU1dBUDogMTE0LFxuICBPUF9JRkRVUDogMTE1LFxuICBPUF9ERVBUSDogMTE2LFxuICBPUF9EUk9QOiAxMTcsXG4gIE9QX0RVUDogMTE4LFxuICBPUF9OSVA6IDExOSxcbiAgT1BfT1ZFUjogMTIwLFxuICBPUF9QSUNLOiAxMjEsXG4gIE9QX1JPTEw6IDEyMixcbiAgT1BfUk9UOiAxMjMsXG4gIE9QX1NXQVA6IDEyNCxcbiAgT1BfVFVDSzogMTI1LFxuICBPUF9DQVQ6IDEyNixcbiAgT1BfU1VCU1RSOiAxMjcsXG4gIE9QX0xFRlQ6IDEyOCxcbiAgT1BfUklHSFQ6IDEyOSxcbiAgT1BfU0laRTogMTMwLFxuICBPUF9JTlZFUlQ6IDEzMSxcbiAgT1BfQU5EOiAxMzIsXG4gIE9QX09SOiAxMzMsXG4gIE9QX1hPUjogMTM0LFxuICBPUF9FUVVBTDogMTM1LFxuICBPUF9FUVVBTFZFUklGWTogMTM2LFxuICBPUF9SRVNFUlZFRDE6IDEzNyxcbiAgT1BfUkVTRVJWRUQyOiAxMzgsXG4gIE9QXzFBREQ6IDEzOSxcbiAgT1BfMVNVQjogMTQwLFxuICBPUF8yTVVMOiAxNDEsXG4gIE9QXzJESVY6IDE0MixcbiAgT1BfTkVHQVRFOiAxNDMsXG4gIE9QX0FCUzogMTQ0LFxuICBPUF9OT1Q6IDE0NSxcbiAgT1BfME5PVEVRVUFMOiAxNDYsXG4gIE9QX0FERDogMTQ3LFxuICBPUF9TVUI6IDE0OCxcbiAgT1BfTVVMOiAxNDksXG4gIE9QX0RJVjogMTUwLFxuICBPUF9NT0Q6IDE1MSxcbiAgT1BfTFNISUZUOiAxNTIsXG4gIE9QX1JTSElGVDogMTUzLFxuICBPUF9CT09MQU5EOiAxNTQsXG4gIE9QX0JPT0xPUjogMTU1LFxuICBPUF9OVU1FUVVBTDogMTU2LFxuICBPUF9OVU1FUVVBTFZFUklGWTogMTU3LFxuICBPUF9OVU1OT1RFUVVBTDogMTU4LFxuICBPUF9MRVNTVEhBTjogMTU5LFxuICBPUF9HUkVBVEVSVEhBTjogMTYwLFxuICBPUF9MRVNTVEhBTk9SRVFVQUw6IDE2MSxcbiAgT1BfR1JFQVRFUlRIQU5PUkVRVUFMOiAxNjIsXG4gIE9QX01JTjogMTYzLFxuICBPUF9NQVg6IDE2NCxcbiAgT1BfV0lUSElOOiAxNjUsXG4gIE9QX1JJUEVNRDE2MDogMTY2LFxuICBPUF9TSEExOiAxNjcsXG4gIE9QX1NIQTI1NjogMTY4LFxuICBPUF9IQVNIMTYwOiAxNjksXG4gIE9QX0hBU0gyNTY6IDE3MCxcbiAgT1BfQ09ERVNFUEFSQVRPUjogMTcxLFxuICBPUF9DSEVDS1NJRzogMTcyLFxuICBPUF9DSEVDS1NJR1ZFUklGWTogMTczLFxuICBPUF9DSEVDS01VTFRJU0lHOiAxNzQsXG4gIE9QX0NIRUNLTVVMVElTSUdWRVJJRlk6IDE3NSxcbiAgT1BfTk9QMTogMTc2LFxuICBPUF9OT1AyOiAxNzcsXG4gIE9QX0NIRUNLTE9DS1RJTUVWRVJJRlk6IDE3NyxcbiAgT1BfTk9QMzogMTc4LFxuICBPUF9DSEVDS1NFUVVFTkNFVkVSSUZZOiAxNzgsXG4gIE9QX05PUDQ6IDE3OSxcbiAgT1BfTk9QNTogMTgwLFxuICBPUF9OT1A2OiAxODEsXG4gIE9QX05PUDc6IDE4MixcbiAgT1BfTk9QODogMTgzLFxuICBPUF9OT1A5OiAxODQsXG4gIE9QX05PUDEwOiAxODUsXG4gIE9QX0NIRUNLU0lHQUREOiAxODYsXG4gIE9QX1BVQktFWUhBU0g6IDI1MyxcbiAgT1BfUFVCS0VZOiAyNTQsXG4gIE9QX0lOVkFMSURPUENPREU6IDI1NSxcbn07XG5leHBvcnRzLk9QUyA9IE9QUztcbmNvbnN0IFJFVkVSU0VfT1BTID0ge307XG5leHBvcnRzLlJFVkVSU0VfT1BTID0gUkVWRVJTRV9PUFM7XG5mb3IgKGNvbnN0IG9wIG9mIE9iamVjdC5rZXlzKE9QUykpIHtcbiAgY29uc3QgY29kZSA9IE9QU1tvcF07XG4gIFJFVkVSU0VfT1BTW2NvZGVdID0gb3A7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/ops.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/bip341.js":
/*!***********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/bip341.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.tweakKey =\n  exports.tapTweakHash =\n  exports.tapleafHash =\n  exports.findScriptPath =\n  exports.toHashTree =\n  exports.rootHashFromPath =\n  exports.MAX_TAPTREE_DEPTH =\n  exports.LEAF_VERSION_TAPSCRIPT =\n    void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\");\nconst ecc_lib_1 = __webpack_require__(/*! ../ecc_lib */ \"./node_modules/bitcoinjs-lib/src/ecc_lib.js\");\nconst bcrypto = __webpack_require__(/*! ../crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\");\nconst bufferutils_1 = __webpack_require__(/*! ../bufferutils */ \"./node_modules/bitcoinjs-lib/src/bufferutils.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nexports.LEAF_VERSION_TAPSCRIPT = 0xc0;\nexports.MAX_TAPTREE_DEPTH = 128;\nconst isHashBranch = ht => 'left' in ht && 'right' in ht;\n/**\n * Calculates the root hash from a given control block and leaf hash.\n * @param controlBlock - The control block buffer.\n * @param leafHash - The leaf hash buffer.\n * @returns The root hash buffer.\n * @throws {TypeError} If the control block length is less than 33.\n */\nfunction rootHashFromPath(controlBlock, leafHash) {\n  if (controlBlock.length < 33)\n    throw new TypeError(\n      `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n    );\n  const m = (controlBlock.length - 33) / 32;\n  let kj = leafHash;\n  for (let j = 0; j < m; j++) {\n    const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);\n    if (kj.compare(ej) < 0) {\n      kj = tapBranchHash(kj, ej);\n    } else {\n      kj = tapBranchHash(ej, kj);\n    }\n  }\n  return kj;\n}\nexports.rootHashFromPath = rootHashFromPath;\n/**\n * Build a hash tree of merkle nodes from the scripts binary tree.\n * @param scriptTree - the tree of scripts to pairwise hash.\n */\nfunction toHashTree(scriptTree) {\n  if ((0, types_1.isTapleaf)(scriptTree))\n    return { hash: tapleafHash(scriptTree) };\n  const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];\n  hashes.sort((a, b) => a.hash.compare(b.hash));\n  const [left, right] = hashes;\n  return {\n    hash: tapBranchHash(left.hash, right.hash),\n    left,\n    right,\n  };\n}\nexports.toHashTree = toHashTree;\n/**\n * Given a HashTree, finds the path from a particular hash to the root.\n * @param node - the root of the tree\n * @param hash - the hash to search for\n * @returns - array of sibling hashes, from leaf (inclusive) to root\n * (exclusive) needed to prove inclusion of the specified hash. undefined if no\n * path is found\n */\nfunction findScriptPath(node, hash) {\n  if (isHashBranch(node)) {\n    const leftPath = findScriptPath(node.left, hash);\n    if (leftPath !== undefined) return [...leftPath, node.right.hash];\n    const rightPath = findScriptPath(node.right, hash);\n    if (rightPath !== undefined) return [...rightPath, node.left.hash];\n  } else if (node.hash.equals(hash)) {\n    return [];\n  }\n  return undefined;\n}\nexports.findScriptPath = findScriptPath;\nfunction tapleafHash(leaf) {\n  const version = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;\n  return bcrypto.taggedHash(\n    'TapLeaf',\n    buffer_1.Buffer.concat([\n      buffer_1.Buffer.from([version]),\n      serializeScript(leaf.output),\n    ]),\n  );\n}\nexports.tapleafHash = tapleafHash;\nfunction tapTweakHash(pubKey, h) {\n  return bcrypto.taggedHash(\n    'TapTweak',\n    buffer_1.Buffer.concat(h ? [pubKey, h] : [pubKey]),\n  );\n}\nexports.tapTweakHash = tapTweakHash;\nfunction tweakKey(pubKey, h) {\n  if (!buffer_1.Buffer.isBuffer(pubKey)) return null;\n  if (pubKey.length !== 32) return null;\n  if (h && h.length !== 32) return null;\n  const tweakHash = tapTweakHash(pubKey, h);\n  const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);\n  if (!res || res.xOnlyPubkey === null) return null;\n  return {\n    parity: res.parity,\n    x: buffer_1.Buffer.from(res.xOnlyPubkey),\n  };\n}\nexports.tweakKey = tweakKey;\nfunction tapBranchHash(a, b) {\n  return bcrypto.taggedHash('TapBranch', buffer_1.Buffer.concat([a, b]));\n}\nfunction serializeScript(s) {\n  const varintLen = bufferutils_1.varuint.encodingLength(s.length);\n  const buffer = buffer_1.Buffer.allocUnsafe(varintLen); // better\n  bufferutils_1.varuint.encode(s.length, buffer);\n  return buffer_1.Buffer.concat([buffer, s]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvYmlwMzQxLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixFQUFFLG9CQUFvQjtBQUN0QixFQUFFLG1CQUFtQjtBQUNyQixFQUFFLHNCQUFzQjtBQUN4QixFQUFFLGtCQUFrQjtBQUNwQixFQUFFLHdCQUF3QjtBQUMxQixFQUFFLHlCQUF5QjtBQUMzQixFQUFFLDhCQUE4QjtBQUNoQztBQUNBLGlCQUFpQixtQkFBTyxDQUFDLGlFQUFRO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLCtEQUFZO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFXO0FBQ25DLHNCQUFzQixtQkFBTyxDQUFDLHVFQUFnQjtBQUM5QyxnQkFBZ0IsbUJBQU8sQ0FBQywyREFBVTtBQUNsQyw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxvQkFBb0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvYmlwMzQxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnR3ZWFrS2V5ID1cbiAgZXhwb3J0cy50YXBUd2Vha0hhc2ggPVxuICBleHBvcnRzLnRhcGxlYWZIYXNoID1cbiAgZXhwb3J0cy5maW5kU2NyaXB0UGF0aCA9XG4gIGV4cG9ydHMudG9IYXNoVHJlZSA9XG4gIGV4cG9ydHMucm9vdEhhc2hGcm9tUGF0aCA9XG4gIGV4cG9ydHMuTUFYX1RBUFRSRUVfREVQVEggPVxuICBleHBvcnRzLkxFQUZfVkVSU0lPTl9UQVBTQ1JJUFQgPVxuICAgIHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZSgnYnVmZmVyJyk7XG5jb25zdCBlY2NfbGliXzEgPSByZXF1aXJlKCcuLi9lY2NfbGliJyk7XG5jb25zdCBiY3J5cHRvID0gcmVxdWlyZSgnLi4vY3J5cHRvJyk7XG5jb25zdCBidWZmZXJ1dGlsc18xID0gcmVxdWlyZSgnLi4vYnVmZmVydXRpbHMnKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKCcuLi90eXBlcycpO1xuZXhwb3J0cy5MRUFGX1ZFUlNJT05fVEFQU0NSSVBUID0gMHhjMDtcbmV4cG9ydHMuTUFYX1RBUFRSRUVfREVQVEggPSAxMjg7XG5jb25zdCBpc0hhc2hCcmFuY2ggPSBodCA9PiAnbGVmdCcgaW4gaHQgJiYgJ3JpZ2h0JyBpbiBodDtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgcm9vdCBoYXNoIGZyb20gYSBnaXZlbiBjb250cm9sIGJsb2NrIGFuZCBsZWFmIGhhc2guXG4gKiBAcGFyYW0gY29udHJvbEJsb2NrIC0gVGhlIGNvbnRyb2wgYmxvY2sgYnVmZmVyLlxuICogQHBhcmFtIGxlYWZIYXNoIC0gVGhlIGxlYWYgaGFzaCBidWZmZXIuXG4gKiBAcmV0dXJucyBUaGUgcm9vdCBoYXNoIGJ1ZmZlci5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIGNvbnRyb2wgYmxvY2sgbGVuZ3RoIGlzIGxlc3MgdGhhbiAzMy5cbiAqL1xuZnVuY3Rpb24gcm9vdEhhc2hGcm9tUGF0aChjb250cm9sQmxvY2ssIGxlYWZIYXNoKSB7XG4gIGlmIChjb250cm9sQmxvY2subGVuZ3RoIDwgMzMpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBUaGUgY29udHJvbC1ibG9jayBsZW5ndGggaXMgdG9vIHNtYWxsLiBHb3QgJHtjb250cm9sQmxvY2subGVuZ3RofSwgZXhwZWN0ZWQgbWluIDMzLmAsXG4gICAgKTtcbiAgY29uc3QgbSA9IChjb250cm9sQmxvY2subGVuZ3RoIC0gMzMpIC8gMzI7XG4gIGxldCBraiA9IGxlYWZIYXNoO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgIGNvbnN0IGVqID0gY29udHJvbEJsb2NrLnNsaWNlKDMzICsgMzIgKiBqLCA2NSArIDMyICogaik7XG4gICAgaWYgKGtqLmNvbXBhcmUoZWopIDwgMCkge1xuICAgICAga2ogPSB0YXBCcmFuY2hIYXNoKGtqLCBlaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtqID0gdGFwQnJhbmNoSGFzaChlaiwga2opO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2o7XG59XG5leHBvcnRzLnJvb3RIYXNoRnJvbVBhdGggPSByb290SGFzaEZyb21QYXRoO1xuLyoqXG4gKiBCdWlsZCBhIGhhc2ggdHJlZSBvZiBtZXJrbGUgbm9kZXMgZnJvbSB0aGUgc2NyaXB0cyBiaW5hcnkgdHJlZS5cbiAqIEBwYXJhbSBzY3JpcHRUcmVlIC0gdGhlIHRyZWUgb2Ygc2NyaXB0cyB0byBwYWlyd2lzZSBoYXNoLlxuICovXG5mdW5jdGlvbiB0b0hhc2hUcmVlKHNjcmlwdFRyZWUpIHtcbiAgaWYgKCgwLCB0eXBlc18xLmlzVGFwbGVhZikoc2NyaXB0VHJlZSkpXG4gICAgcmV0dXJuIHsgaGFzaDogdGFwbGVhZkhhc2goc2NyaXB0VHJlZSkgfTtcbiAgY29uc3QgaGFzaGVzID0gW3RvSGFzaFRyZWUoc2NyaXB0VHJlZVswXSksIHRvSGFzaFRyZWUoc2NyaXB0VHJlZVsxXSldO1xuICBoYXNoZXMuc29ydCgoYSwgYikgPT4gYS5oYXNoLmNvbXBhcmUoYi5oYXNoKSk7XG4gIGNvbnN0IFtsZWZ0LCByaWdodF0gPSBoYXNoZXM7XG4gIHJldHVybiB7XG4gICAgaGFzaDogdGFwQnJhbmNoSGFzaChsZWZ0Lmhhc2gsIHJpZ2h0Lmhhc2gpLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gIH07XG59XG5leHBvcnRzLnRvSGFzaFRyZWUgPSB0b0hhc2hUcmVlO1xuLyoqXG4gKiBHaXZlbiBhIEhhc2hUcmVlLCBmaW5kcyB0aGUgcGF0aCBmcm9tIGEgcGFydGljdWxhciBoYXNoIHRvIHRoZSByb290LlxuICogQHBhcmFtIG5vZGUgLSB0aGUgcm9vdCBvZiB0aGUgdHJlZVxuICogQHBhcmFtIGhhc2ggLSB0aGUgaGFzaCB0byBzZWFyY2ggZm9yXG4gKiBAcmV0dXJucyAtIGFycmF5IG9mIHNpYmxpbmcgaGFzaGVzLCBmcm9tIGxlYWYgKGluY2x1c2l2ZSkgdG8gcm9vdFxuICogKGV4Y2x1c2l2ZSkgbmVlZGVkIHRvIHByb3ZlIGluY2x1c2lvbiBvZiB0aGUgc3BlY2lmaWVkIGhhc2guIHVuZGVmaW5lZCBpZiBub1xuICogcGF0aCBpcyBmb3VuZFxuICovXG5mdW5jdGlvbiBmaW5kU2NyaXB0UGF0aChub2RlLCBoYXNoKSB7XG4gIGlmIChpc0hhc2hCcmFuY2gobm9kZSkpIHtcbiAgICBjb25zdCBsZWZ0UGF0aCA9IGZpbmRTY3JpcHRQYXRoKG5vZGUubGVmdCwgaGFzaCk7XG4gICAgaWYgKGxlZnRQYXRoICE9PSB1bmRlZmluZWQpIHJldHVybiBbLi4ubGVmdFBhdGgsIG5vZGUucmlnaHQuaGFzaF07XG4gICAgY29uc3QgcmlnaHRQYXRoID0gZmluZFNjcmlwdFBhdGgobm9kZS5yaWdodCwgaGFzaCk7XG4gICAgaWYgKHJpZ2h0UGF0aCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gWy4uLnJpZ2h0UGF0aCwgbm9kZS5sZWZ0Lmhhc2hdO1xuICB9IGVsc2UgaWYgKG5vZGUuaGFzaC5lcXVhbHMoaGFzaCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuZmluZFNjcmlwdFBhdGggPSBmaW5kU2NyaXB0UGF0aDtcbmZ1bmN0aW9uIHRhcGxlYWZIYXNoKGxlYWYpIHtcbiAgY29uc3QgdmVyc2lvbiA9IGxlYWYudmVyc2lvbiB8fCBleHBvcnRzLkxFQUZfVkVSU0lPTl9UQVBTQ1JJUFQ7XG4gIHJldHVybiBiY3J5cHRvLnRhZ2dlZEhhc2goXG4gICAgJ1RhcExlYWYnLFxuICAgIGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoW1xuICAgICAgYnVmZmVyXzEuQnVmZmVyLmZyb20oW3ZlcnNpb25dKSxcbiAgICAgIHNlcmlhbGl6ZVNjcmlwdChsZWFmLm91dHB1dCksXG4gICAgXSksXG4gICk7XG59XG5leHBvcnRzLnRhcGxlYWZIYXNoID0gdGFwbGVhZkhhc2g7XG5mdW5jdGlvbiB0YXBUd2Vha0hhc2gocHViS2V5LCBoKSB7XG4gIHJldHVybiBiY3J5cHRvLnRhZ2dlZEhhc2goXG4gICAgJ1RhcFR3ZWFrJyxcbiAgICBidWZmZXJfMS5CdWZmZXIuY29uY2F0KGggPyBbcHViS2V5LCBoXSA6IFtwdWJLZXldKSxcbiAgKTtcbn1cbmV4cG9ydHMudGFwVHdlYWtIYXNoID0gdGFwVHdlYWtIYXNoO1xuZnVuY3Rpb24gdHdlYWtLZXkocHViS2V5LCBoKSB7XG4gIGlmICghYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKHB1YktleSkpIHJldHVybiBudWxsO1xuICBpZiAocHViS2V5Lmxlbmd0aCAhPT0gMzIpIHJldHVybiBudWxsO1xuICBpZiAoaCAmJiBoLmxlbmd0aCAhPT0gMzIpIHJldHVybiBudWxsO1xuICBjb25zdCB0d2Vha0hhc2ggPSB0YXBUd2Vha0hhc2gocHViS2V5LCBoKTtcbiAgY29uc3QgcmVzID0gKDAsIGVjY19saWJfMS5nZXRFY2NMaWIpKCkueE9ubHlQb2ludEFkZFR3ZWFrKHB1YktleSwgdHdlYWtIYXNoKTtcbiAgaWYgKCFyZXMgfHwgcmVzLnhPbmx5UHVia2V5ID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBwYXJpdHk6IHJlcy5wYXJpdHksXG4gICAgeDogYnVmZmVyXzEuQnVmZmVyLmZyb20ocmVzLnhPbmx5UHVia2V5KSxcbiAgfTtcbn1cbmV4cG9ydHMudHdlYWtLZXkgPSB0d2Vha0tleTtcbmZ1bmN0aW9uIHRhcEJyYW5jaEhhc2goYSwgYikge1xuICByZXR1cm4gYmNyeXB0by50YWdnZWRIYXNoKCdUYXBCcmFuY2gnLCBidWZmZXJfMS5CdWZmZXIuY29uY2F0KFthLCBiXSkpO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplU2NyaXB0KHMpIHtcbiAgY29uc3QgdmFyaW50TGVuID0gYnVmZmVydXRpbHNfMS52YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHMubGVuZ3RoKTtcbiAgY29uc3QgYnVmZmVyID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jVW5zYWZlKHZhcmludExlbik7IC8vIGJldHRlclxuICBidWZmZXJ1dGlsc18xLnZhcnVpbnQuZW5jb2RlKHMubGVuZ3RoLCBidWZmZXIpO1xuICByZXR1cm4gYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBzXSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/payments/bip341.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/embed.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/embed.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2data = void 0;\nconst networks_1 = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst OPS = bscript.OPS;\n// output: OP_RETURN ...\n/**\n * Embeds data in a Bitcoin payment.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The modified payment object.\n * @throws {TypeError} If there is not enough data or if the output is invalid.\n */\nfunction p2data(a, opts) {\n  if (!a.data && !a.output) throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      data: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'embed', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.data) return;\n    return bscript.compile([OPS.OP_RETURN].concat(a.data));\n  });\n  lazy.prop(o, 'data', () => {\n    if (!a.output) return;\n    return bscript.decompile(a.output).slice(1);\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      const chunks = bscript.decompile(a.output);\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');\n      if (!chunks.slice(1).every(types_1.typeforce.Buffer))\n        throw new TypeError('Output is invalid');\n      if (a.data && !(0, types_1.stacksEqual)(a.data, o.data))\n        throw new TypeError('Data mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2data = p2data;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvZW1iZWQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLG1CQUFtQixtQkFBTyxDQUFDLGlFQUFhO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFXO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLDJEQUFVO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxpRUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3BheW1lbnRzL2VtYmVkLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnAyZGF0YSA9IHZvaWQgMDtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKCcuLi9uZXR3b3JrcycpO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoJy4uL3R5cGVzJyk7XG5jb25zdCBsYXp5ID0gcmVxdWlyZSgnLi9sYXp5Jyk7XG5jb25zdCBPUFMgPSBic2NyaXB0Lk9QUztcbi8vIG91dHB1dDogT1BfUkVUVVJOIC4uLlxuLyoqXG4gKiBFbWJlZHMgZGF0YSBpbiBhIEJpdGNvaW4gcGF5bWVudC5cbiAqIEBwYXJhbSBhIC0gVGhlIHBheW1lbnQgb2JqZWN0LlxuICogQHBhcmFtIG9wdHMgLSBPcHRpb25hbCBwYXltZW50IG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgbW9kaWZpZWQgcGF5bWVudCBvYmplY3QuXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZXJlIGlzIG5vdCBlbm91Z2ggZGF0YSBvciBpZiB0aGUgb3V0cHV0IGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHAyZGF0YShhLCBvcHRzKSB7XG4gIGlmICghYS5kYXRhICYmICFhLm91dHB1dCkgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gICgwLCB0eXBlc18xLnR5cGVmb3JjZSkoXG4gICAge1xuICAgICAgbmV0d29yazogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuT2JqZWN0KSxcbiAgICAgIG91dHB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgIGRhdGE6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKFxuICAgICAgICB0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICApLFxuICAgIH0sXG4gICAgYSxcbiAgKTtcbiAgY29uc3QgbmV0d29yayA9IGEubmV0d29yayB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gIGNvbnN0IG8gPSB7IG5hbWU6ICdlbWJlZCcsIG5ldHdvcmsgfTtcbiAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFhLmRhdGEpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtPUFMuT1BfUkVUVVJOXS5jb25jYXQoYS5kYXRhKSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2RhdGEnLCAoKSA9PiB7XG4gICAgaWYgKCFhLm91dHB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmRlY29tcGlsZShhLm91dHB1dCkuc2xpY2UoMSk7XG4gIH0pO1xuICAvLyBleHRlbmRlZCB2YWxpZGF0aW9uXG4gIGlmIChvcHRzLnZhbGlkYXRlKSB7XG4gICAgaWYgKGEub3V0cHV0KSB7XG4gICAgICBjb25zdCBjaHVua3MgPSBic2NyaXB0LmRlY29tcGlsZShhLm91dHB1dCk7XG4gICAgICBpZiAoY2h1bmtzWzBdICE9PSBPUFMuT1BfUkVUVVJOKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKCFjaHVua3Muc2xpY2UoMSkuZXZlcnkodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChhLmRhdGEgJiYgISgwLCB0eXBlc18xLnN0YWNrc0VxdWFsKShhLmRhdGEsIG8uZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGEgbWlzbWF0Y2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obywgYSk7XG59XG5leHBvcnRzLnAyZGF0YSA9IHAyZGF0YTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/payments/embed.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2tr =\n  exports.p2wsh =\n  exports.p2wpkh =\n  exports.p2sh =\n  exports.p2pkh =\n  exports.p2pk =\n  exports.p2ms =\n  exports.embed =\n    void 0;\nconst embed_1 = __webpack_require__(/*! ./embed */ \"./node_modules/bitcoinjs-lib/src/payments/embed.js\");\nObject.defineProperty(exports, \"embed\", ({\n  enumerable: true,\n  get: function () {\n    return embed_1.p2data;\n  },\n}));\nconst p2ms_1 = __webpack_require__(/*! ./p2ms */ \"./node_modules/bitcoinjs-lib/src/payments/p2ms.js\");\nObject.defineProperty(exports, \"p2ms\", ({\n  enumerable: true,\n  get: function () {\n    return p2ms_1.p2ms;\n  },\n}));\nconst p2pk_1 = __webpack_require__(/*! ./p2pk */ \"./node_modules/bitcoinjs-lib/src/payments/p2pk.js\");\nObject.defineProperty(exports, \"p2pk\", ({\n  enumerable: true,\n  get: function () {\n    return p2pk_1.p2pk;\n  },\n}));\nconst p2pkh_1 = __webpack_require__(/*! ./p2pkh */ \"./node_modules/bitcoinjs-lib/src/payments/p2pkh.js\");\nObject.defineProperty(exports, \"p2pkh\", ({\n  enumerable: true,\n  get: function () {\n    return p2pkh_1.p2pkh;\n  },\n}));\nconst p2sh_1 = __webpack_require__(/*! ./p2sh */ \"./node_modules/bitcoinjs-lib/src/payments/p2sh.js\");\nObject.defineProperty(exports, \"p2sh\", ({\n  enumerable: true,\n  get: function () {\n    return p2sh_1.p2sh;\n  },\n}));\nconst p2wpkh_1 = __webpack_require__(/*! ./p2wpkh */ \"./node_modules/bitcoinjs-lib/src/payments/p2wpkh.js\");\nObject.defineProperty(exports, \"p2wpkh\", ({\n  enumerable: true,\n  get: function () {\n    return p2wpkh_1.p2wpkh;\n  },\n}));\nconst p2wsh_1 = __webpack_require__(/*! ./p2wsh */ \"./node_modules/bitcoinjs-lib/src/payments/p2wsh.js\");\nObject.defineProperty(exports, \"p2wsh\", ({\n  enumerable: true,\n  get: function () {\n    return p2wsh_1.p2wsh;\n  },\n}));\nconst p2tr_1 = __webpack_require__(/*! ./p2tr */ \"./node_modules/bitcoinjs-lib/src/payments/p2tr.js\");\nObject.defineProperty(exports, \"p2tr\", ({\n  enumerable: true,\n  get: function () {\n    return p2tr_1.p2tr;\n  },\n}));\n// TODO\n// witness commitment\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLEVBQUUsYUFBYTtBQUNmLEVBQUUsY0FBYztBQUNoQixFQUFFLFlBQVk7QUFDZCxFQUFFLGFBQWE7QUFDZixFQUFFLFlBQVk7QUFDZCxFQUFFLFlBQVk7QUFDZCxFQUFFLGFBQWE7QUFDZjtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFTO0FBQ2pDLHlDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFQUFDO0FBQ0YsZUFBZSxtQkFBTyxDQUFDLGlFQUFRO0FBQy9CLHdDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFQUFDO0FBQ0YsZUFBZSxtQkFBTyxDQUFDLGlFQUFRO0FBQy9CLHdDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFQUFDO0FBQ0YsZ0JBQWdCLG1CQUFPLENBQUMsbUVBQVM7QUFDakMseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLEVBQUM7QUFDRixlQUFlLG1CQUFPLENBQUMsaUVBQVE7QUFDL0Isd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLEVBQUM7QUFDRixpQkFBaUIsbUJBQU8sQ0FBQyxxRUFBVTtBQUNuQywwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsRUFBQztBQUNGLGdCQUFnQixtQkFBTyxDQUFDLG1FQUFTO0FBQ2pDLHlDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFQUFDO0FBQ0YsZUFBZSxtQkFBTyxDQUFDLGlFQUFRO0FBQy9CLHdDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFQUFDO0FBQ0Y7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wMnRyID1cbiAgZXhwb3J0cy5wMndzaCA9XG4gIGV4cG9ydHMucDJ3cGtoID1cbiAgZXhwb3J0cy5wMnNoID1cbiAgZXhwb3J0cy5wMnBraCA9XG4gIGV4cG9ydHMucDJwayA9XG4gIGV4cG9ydHMucDJtcyA9XG4gIGV4cG9ydHMuZW1iZWQgPVxuICAgIHZvaWQgMDtcbmNvbnN0IGVtYmVkXzEgPSByZXF1aXJlKCcuL2VtYmVkJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2VtYmVkJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZW1iZWRfMS5wMmRhdGE7XG4gIH0sXG59KTtcbmNvbnN0IHAybXNfMSA9IHJlcXVpcmUoJy4vcDJtcycpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdwMm1zJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcDJtc18xLnAybXM7XG4gIH0sXG59KTtcbmNvbnN0IHAycGtfMSA9IHJlcXVpcmUoJy4vcDJwaycpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdwMnBrJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcDJwa18xLnAycGs7XG4gIH0sXG59KTtcbmNvbnN0IHAycGtoXzEgPSByZXF1aXJlKCcuL3AycGtoJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3AycGtoJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcDJwa2hfMS5wMnBraDtcbiAgfSxcbn0pO1xuY29uc3QgcDJzaF8xID0gcmVxdWlyZSgnLi9wMnNoJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3Ayc2gnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwMnNoXzEucDJzaDtcbiAgfSxcbn0pO1xuY29uc3QgcDJ3cGtoXzEgPSByZXF1aXJlKCcuL3Ayd3BraCcpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdwMndwa2gnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwMndwa2hfMS5wMndwa2g7XG4gIH0sXG59KTtcbmNvbnN0IHAyd3NoXzEgPSByZXF1aXJlKCcuL3Ayd3NoJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3Ayd3NoJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcDJ3c2hfMS5wMndzaDtcbiAgfSxcbn0pO1xuY29uc3QgcDJ0cl8xID0gcmVxdWlyZSgnLi9wMnRyJyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ3AydHInLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwMnRyXzEucDJ0cjtcbiAgfSxcbn0pO1xuLy8gVE9ET1xuLy8gd2l0bmVzcyBjb21taXRtZW50XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/payments/index.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/lazy.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/lazy.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.value = exports.prop = void 0;\nfunction prop(object, name, f) {\n  Object.defineProperty(object, name, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      const _value = f.call(this);\n      this[name] = _value;\n      return _value;\n    },\n    set(_value) {\n      Object.defineProperty(this, name, {\n        configurable: true,\n        enumerable: true,\n        value: _value,\n        writable: true,\n      });\n    },\n  });\n}\nexports.prop = prop;\nfunction value(f) {\n  let _value;\n  return () => {\n    if (_value !== undefined) return _value;\n    _value = f();\n    return _value;\n  };\n}\nexports.value = value;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvbGF6eS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3BheW1lbnRzL2xhenkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsdWUgPSBleHBvcnRzLnByb3AgPSB2b2lkIDA7XG5mdW5jdGlvbiBwcm9wKG9iamVjdCwgbmFtZSwgZikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgY29uc3QgX3ZhbHVlID0gZi5jYWxsKHRoaXMpO1xuICAgICAgdGhpc1tuYW1lXSA9IF92YWx1ZTtcbiAgICAgIHJldHVybiBfdmFsdWU7XG4gICAgfSxcbiAgICBzZXQoX3ZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBfdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfSxcbiAgfSk7XG59XG5leHBvcnRzLnByb3AgPSBwcm9wO1xuZnVuY3Rpb24gdmFsdWUoZikge1xuICBsZXQgX3ZhbHVlO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChfdmFsdWUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIF92YWx1ZTtcbiAgICBfdmFsdWUgPSBmKCk7XG4gICAgcmV0dXJuIF92YWx1ZTtcbiAgfTtcbn1cbmV4cG9ydHMudmFsdWUgPSB2YWx1ZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/payments/lazy.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2ms.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2ms.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2ms = void 0;\nconst networks_1 = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst OPS = bscript.OPS;\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\n// input: OP_0 [signatures ...]\n// output: m [pubKeys ...] n OP_CHECKMULTISIG\n/**\n * Represents a function that creates a Pay-to-Multisig (P2MS) payment object.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The created payment object.\n * @throws {TypeError} If the provided data is not valid.\n */\nfunction p2ms(a, opts) {\n  if (\n    !a.input &&\n    !a.output &&\n    !(a.pubkeys && a.m !== undefined) &&\n    !a.signatures\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  function isAcceptableSignature(x) {\n    return (\n      bscript.isCanonicalScriptSignature(x) ||\n      (opts.allowIncomplete && x === OPS.OP_0) !== undefined\n    );\n  }\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      m: types_1.typeforce.maybe(types_1.typeforce.Number),\n      n: types_1.typeforce.maybe(types_1.typeforce.Number),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      pubkeys: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.isPoint),\n      ),\n      signatures: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(isAcceptableSignature),\n      ),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { network };\n  let chunks = [];\n  let decoded = false;\n  function decode(output) {\n    if (decoded) return;\n    decoded = true;\n    chunks = bscript.decompile(output);\n    o.m = chunks[0] - OP_INT_BASE;\n    o.n = chunks[chunks.length - 2] - OP_INT_BASE;\n    o.pubkeys = chunks.slice(1, -2);\n  }\n  lazy.prop(o, 'output', () => {\n    if (!a.m) return;\n    if (!o.n) return;\n    if (!a.pubkeys) return;\n    return bscript.compile(\n      [].concat(\n        OP_INT_BASE + a.m,\n        a.pubkeys,\n        OP_INT_BASE + o.n,\n        OPS.OP_CHECKMULTISIG,\n      ),\n    );\n  });\n  lazy.prop(o, 'm', () => {\n    if (!o.output) return;\n    decode(o.output);\n    return o.m;\n  });\n  lazy.prop(o, 'n', () => {\n    if (!o.pubkeys) return;\n    return o.pubkeys.length;\n  });\n  lazy.prop(o, 'pubkeys', () => {\n    if (!a.output) return;\n    decode(a.output);\n    return o.pubkeys;\n  });\n  lazy.prop(o, 'signatures', () => {\n    if (!a.input) return;\n    return bscript.decompile(a.input).slice(1);\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signatures) return;\n    return bscript.compile([OPS.OP_0].concat(a.signatures));\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  lazy.prop(o, 'name', () => {\n    if (!o.m || !o.n) return;\n    return `p2ms(${o.m} of ${o.n})`;\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      decode(a.output);\n      if (!types_1.typeforce.Number(chunks[0]))\n        throw new TypeError('Output is invalid');\n      if (!types_1.typeforce.Number(chunks[chunks.length - 2]))\n        throw new TypeError('Output is invalid');\n      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)\n        throw new TypeError('Output is invalid');\n      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)\n        throw new TypeError('Output is invalid');\n      if (!o.pubkeys.every(x => (0, types_1.isPoint)(x)))\n        throw new TypeError('Output is invalid');\n      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');\n      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');\n      if (a.pubkeys && !(0, types_1.stacksEqual)(a.pubkeys, o.pubkeys))\n        throw new TypeError('Pubkeys mismatch');\n    }\n    if (a.pubkeys) {\n      if (a.n !== undefined && a.n !== a.pubkeys.length)\n        throw new TypeError('Pubkey count mismatch');\n      o.n = a.pubkeys.length;\n      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');\n    }\n    if (a.signatures) {\n      if (a.signatures.length < o.m)\n        throw new TypeError('Not enough signatures provided');\n      if (a.signatures.length > o.m)\n        throw new TypeError('Too many signatures provided');\n    }\n    if (a.input) {\n      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');\n      if (\n        o.signatures.length === 0 ||\n        !o.signatures.every(isAcceptableSignature)\n      )\n        throw new TypeError('Input has invalid signature(s)');\n      if (a.signatures && !(0, types_1.stacksEqual)(a.signatures, o.signatures))\n        throw new TypeError('Signature mismatch');\n      if (a.m !== undefined && a.m !== a.signatures.length)\n        throw new TypeError('Signature count mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2ms = p2ms;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osbUJBQW1CLG1CQUFPLENBQUMsaUVBQWE7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLGlFQUFRO0FBQzdCO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0IsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSyxLQUFLLElBQUk7QUFDakMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9wMm1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnAybXMgPSB2b2lkIDA7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZSgnLi4vbmV0d29ya3MnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKCcuLi90eXBlcycpO1xuY29uc3QgbGF6eSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuY29uc3QgT1BTID0gYnNjcmlwdC5PUFM7XG5jb25zdCBPUF9JTlRfQkFTRSA9IE9QUy5PUF9SRVNFUlZFRDsgLy8gT1BfMSAtIDFcbi8vIGlucHV0OiBPUF8wIFtzaWduYXR1cmVzIC4uLl1cbi8vIG91dHB1dDogbSBbcHViS2V5cyAuLi5dIG4gT1BfQ0hFQ0tNVUxUSVNJR1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgUGF5LXRvLU11bHRpc2lnIChQMk1TKSBwYXltZW50IG9iamVjdC5cbiAqIEBwYXJhbSBhIC0gVGhlIHBheW1lbnQgb2JqZWN0LlxuICogQHBhcmFtIG9wdHMgLSBPcHRpb25hbCBwYXltZW50IG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBwYXltZW50IG9iamVjdC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIHByb3ZpZGVkIGRhdGEgaXMgbm90IHZhbGlkLlxuICovXG5mdW5jdGlvbiBwMm1zKGEsIG9wdHMpIHtcbiAgaWYgKFxuICAgICFhLmlucHV0ICYmXG4gICAgIWEub3V0cHV0ICYmXG4gICAgIShhLnB1YmtleXMgJiYgYS5tICE9PSB1bmRlZmluZWQpICYmXG4gICAgIWEuc2lnbmF0dXJlc1xuICApXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gIGZ1bmN0aW9uIGlzQWNjZXB0YWJsZVNpZ25hdHVyZSh4KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUoeCkgfHxcbiAgICAgIChvcHRzLmFsbG93SW5jb21wbGV0ZSAmJiB4ID09PSBPUFMuT1BfMCkgIT09IHVuZGVmaW5lZFxuICAgICk7XG4gIH1cbiAgKDAsIHR5cGVzXzEudHlwZWZvcmNlKShcbiAgICB7XG4gICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgbTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuTnVtYmVyKSxcbiAgICAgIG46IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk51bWJlciksXG4gICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICBwdWJrZXlzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZShcbiAgICAgICAgdHlwZXNfMS50eXBlZm9yY2UuYXJyYXlPZih0eXBlc18xLmlzUG9pbnQpLFxuICAgICAgKSxcbiAgICAgIHNpZ25hdHVyZXM6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKFxuICAgICAgICB0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKGlzQWNjZXB0YWJsZVNpZ25hdHVyZSksXG4gICAgICApLFxuICAgICAgaW5wdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgfSxcbiAgICBhLFxuICApO1xuICBjb25zdCBuZXR3b3JrID0gYS5uZXR3b3JrIHx8IG5ldHdvcmtzXzEuYml0Y29pbjtcbiAgY29uc3QgbyA9IHsgbmV0d29yayB9O1xuICBsZXQgY2h1bmtzID0gW107XG4gIGxldCBkZWNvZGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlY29kZShvdXRwdXQpIHtcbiAgICBpZiAoZGVjb2RlZCkgcmV0dXJuO1xuICAgIGRlY29kZWQgPSB0cnVlO1xuICAgIGNodW5rcyA9IGJzY3JpcHQuZGVjb21waWxlKG91dHB1dCk7XG4gICAgby5tID0gY2h1bmtzWzBdIC0gT1BfSU5UX0JBU0U7XG4gICAgby5uID0gY2h1bmtzW2NodW5rcy5sZW5ndGggLSAyXSAtIE9QX0lOVF9CQVNFO1xuICAgIG8ucHVia2V5cyA9IGNodW5rcy5zbGljZSgxLCAtMik7XG4gIH1cbiAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFhLm0pIHJldHVybjtcbiAgICBpZiAoIW8ubikgcmV0dXJuO1xuICAgIGlmICghYS5wdWJrZXlzKSByZXR1cm47XG4gICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShcbiAgICAgIFtdLmNvbmNhdChcbiAgICAgICAgT1BfSU5UX0JBU0UgKyBhLm0sXG4gICAgICAgIGEucHVia2V5cyxcbiAgICAgICAgT1BfSU5UX0JBU0UgKyBvLm4sXG4gICAgICAgIE9QUy5PUF9DSEVDS01VTFRJU0lHLFxuICAgICAgKSxcbiAgICApO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdtJywgKCkgPT4ge1xuICAgIGlmICghby5vdXRwdXQpIHJldHVybjtcbiAgICBkZWNvZGUoby5vdXRwdXQpO1xuICAgIHJldHVybiBvLm07XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ24nLCAoKSA9PiB7XG4gICAgaWYgKCFvLnB1YmtleXMpIHJldHVybjtcbiAgICByZXR1cm4gby5wdWJrZXlzLmxlbmd0aDtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAncHVia2V5cycsICgpID0+IHtcbiAgICBpZiAoIWEub3V0cHV0KSByZXR1cm47XG4gICAgZGVjb2RlKGEub3V0cHV0KTtcbiAgICByZXR1cm4gby5wdWJrZXlzO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdzaWduYXR1cmVzJywgKCkgPT4ge1xuICAgIGlmICghYS5pbnB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmRlY29tcGlsZShhLmlucHV0KS5zbGljZSgxKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFhLnNpZ25hdHVyZXMpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtPUFMuT1BfMF0uY29uY2F0KGEuc2lnbmF0dXJlcykpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICd3aXRuZXNzJywgKCkgPT4ge1xuICAgIGlmICghby5pbnB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBbXTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnbmFtZScsICgpID0+IHtcbiAgICBpZiAoIW8ubSB8fCAhby5uKSByZXR1cm47XG4gICAgcmV0dXJuIGBwMm1zKCR7by5tfSBvZiAke28ubn0pYDtcbiAgfSk7XG4gIC8vIGV4dGVuZGVkIHZhbGlkYXRpb25cbiAgaWYgKG9wdHMudmFsaWRhdGUpIHtcbiAgICBpZiAoYS5vdXRwdXQpIHtcbiAgICAgIGRlY29kZShhLm91dHB1dCk7XG4gICAgICBpZiAoIXR5cGVzXzEudHlwZWZvcmNlLk51bWJlcihjaHVua3NbMF0pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKCF0eXBlc18xLnR5cGVmb3JjZS5OdW1iZXIoY2h1bmtzW2NodW5rcy5sZW5ndGggLSAyXSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXSAhPT0gT1BTLk9QX0NIRUNLTVVMVElTSUcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoby5tIDw9IDAgfHwgby5uID4gMTYgfHwgby5tID4gby5uIHx8IG8ubiAhPT0gY2h1bmtzLmxlbmd0aCAtIDMpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoIW8ucHVia2V5cy5ldmVyeSh4ID0+ICgwLCB0eXBlc18xLmlzUG9pbnQpKHgpKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChhLm0gIT09IHVuZGVmaW5lZCAmJiBhLm0gIT09IG8ubSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbSBtaXNtYXRjaCcpO1xuICAgICAgaWYgKGEubiAhPT0gdW5kZWZpbmVkICYmIGEubiAhPT0gby5uKSB0aHJvdyBuZXcgVHlwZUVycm9yKCduIG1pc21hdGNoJyk7XG4gICAgICBpZiAoYS5wdWJrZXlzICYmICEoMCwgdHlwZXNfMS5zdGFja3NFcXVhbCkoYS5wdWJrZXlzLCBvLnB1YmtleXMpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXlzIG1pc21hdGNoJyk7XG4gICAgfVxuICAgIGlmIChhLnB1YmtleXMpIHtcbiAgICAgIGlmIChhLm4gIT09IHVuZGVmaW5lZCAmJiBhLm4gIT09IGEucHVia2V5cy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1B1YmtleSBjb3VudCBtaXNtYXRjaCcpO1xuICAgICAgby5uID0gYS5wdWJrZXlzLmxlbmd0aDtcbiAgICAgIGlmIChvLm4gPCBvLm0pIHRocm93IG5ldyBUeXBlRXJyb3IoJ1B1YmtleSBjb3VudCBjYW5ub3QgYmUgbGVzcyB0aGFuIG0nKTtcbiAgICB9XG4gICAgaWYgKGEuc2lnbmF0dXJlcykge1xuICAgICAgaWYgKGEuc2lnbmF0dXJlcy5sZW5ndGggPCBvLm0pXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggc2lnbmF0dXJlcyBwcm92aWRlZCcpO1xuICAgICAgaWYgKGEuc2lnbmF0dXJlcy5sZW5ndGggPiBvLm0pXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RvbyBtYW55IHNpZ25hdHVyZXMgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgaWYgKGEuaW5wdXQpIHtcbiAgICAgIGlmIChhLmlucHV0WzBdICE9PSBPUFMuT1BfMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKFxuICAgICAgICBvLnNpZ25hdHVyZXMubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICFvLnNpZ25hdHVyZXMuZXZlcnkoaXNBY2NlcHRhYmxlU2lnbmF0dXJlKVxuICAgICAgKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBoYXMgaW52YWxpZCBzaWduYXR1cmUocyknKTtcbiAgICAgIGlmIChhLnNpZ25hdHVyZXMgJiYgISgwLCB0eXBlc18xLnN0YWNrc0VxdWFsKShhLnNpZ25hdHVyZXMsIG8uc2lnbmF0dXJlcykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NpZ25hdHVyZSBtaXNtYXRjaCcpO1xuICAgICAgaWYgKGEubSAhPT0gdW5kZWZpbmVkICYmIGEubSAhPT0gYS5zaWduYXR1cmVzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2lnbmF0dXJlIGNvdW50IG1pc21hdGNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG8sIGEpO1xufVxuZXhwb3J0cy5wMm1zID0gcDJtcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/payments/p2ms.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2pk.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2pk.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2pk = void 0;\nconst networks_1 = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst OPS = bscript.OPS;\n// input: {signature}\n// output: {pubKey} OP_CHECKSIG\n/**\n * Creates a pay-to-public-key (P2PK) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PK payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2pk(a, opts) {\n  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pk', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.pubkey) return;\n    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.output) return;\n    return a.output.slice(1, -1);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signature) return;\n    return bscript.compile([a.signature]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)\n        throw new TypeError('Output is invalid');\n      if (!(0, types_1.isPoint)(o.pubkey))\n        throw new TypeError('Output pubkey is invalid');\n      if (a.pubkey && !a.pubkey.equals(o.pubkey))\n        throw new TypeError('Pubkey mismatch');\n    }\n    if (a.signature) {\n      if (a.input && !a.input.equals(o.input))\n        throw new TypeError('Signature mismatch');\n    }\n    if (a.input) {\n      if (_chunks().length !== 1) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(o.signature))\n        throw new TypeError('Input has invalid signature');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pk = p2pk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJway5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osbUJBQW1CLG1CQUFPLENBQUMsaUVBQWE7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLGlFQUFRO0FBQzdCO0FBQ0EsV0FBVztBQUNYLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJway5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wMnBrID0gdm9pZCAwO1xuY29uc3QgbmV0d29ya3NfMSA9IHJlcXVpcmUoJy4uL25ldHdvcmtzJyk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi4vc2NyaXB0Jyk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbmNvbnN0IGxhenkgPSByZXF1aXJlKCcuL2xhenknKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuLy8gaW5wdXQ6IHtzaWduYXR1cmV9XG4vLyBvdXRwdXQ6IHtwdWJLZXl9IE9QX0NIRUNLU0lHXG4vKipcbiAqIENyZWF0ZXMgYSBwYXktdG8tcHVibGljLWtleSAoUDJQSykgcGF5bWVudCBvYmplY3QuXG4gKlxuICogQHBhcmFtIGEgLSBUaGUgcGF5bWVudCBvYmplY3QgY29udGFpbmluZyB0aGUgbmVjZXNzYXJ5IGRhdGEuXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIHBheW1lbnQgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBQMlBLIHBheW1lbnQgb2JqZWN0LlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgcmVxdWlyZWQgZGF0YSBpcyBub3QgcHJvdmlkZWQgb3IgaWYgdGhlIGRhdGEgaXMgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gcDJwayhhLCBvcHRzKSB7XG4gIGlmICghYS5pbnB1dCAmJiAhYS5vdXRwdXQgJiYgIWEucHVia2V5ICYmICFhLmlucHV0ICYmICFhLnNpZ25hdHVyZSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGRhdGEnKTtcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyB2YWxpZGF0ZTogdHJ1ZSB9LCBvcHRzIHx8IHt9KTtcbiAgKDAsIHR5cGVzXzEudHlwZWZvcmNlKShcbiAgICB7XG4gICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgb3V0cHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgcHVia2V5OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLmlzUG9pbnQpLFxuICAgICAgc2lnbmF0dXJlOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZShic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKSxcbiAgICAgIGlucHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgIH0sXG4gICAgYSxcbiAgKTtcbiAgY29uc3QgX2NodW5rcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIHJldHVybiBic2NyaXB0LmRlY29tcGlsZShhLmlucHV0KTtcbiAgfSk7XG4gIGNvbnN0IG5ldHdvcmsgPSBhLm5ldHdvcmsgfHwgbmV0d29ya3NfMS5iaXRjb2luO1xuICBjb25zdCBvID0geyBuYW1lOiAncDJwaycsIG5ldHdvcmsgfTtcbiAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFhLnB1YmtleSkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW2EucHVia2V5LCBPUFMuT1BfQ0hFQ0tTSUddKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAncHVia2V5JywgKCkgPT4ge1xuICAgIGlmICghYS5vdXRwdXQpIHJldHVybjtcbiAgICByZXR1cm4gYS5vdXRwdXQuc2xpY2UoMSwgLTEpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdzaWduYXR1cmUnLCAoKSA9PiB7XG4gICAgaWYgKCFhLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIF9jaHVua3MoKVswXTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFhLnNpZ25hdHVyZSkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoW2Euc2lnbmF0dXJlXSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3dpdG5lc3MnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIFtdO1xuICB9KTtcbiAgLy8gZXh0ZW5kZWQgdmFsaWRhdGlvblxuICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgIGlmIChhLm91dHB1dCkge1xuICAgICAgaWYgKGEub3V0cHV0W2Eub3V0cHV0Lmxlbmd0aCAtIDFdICE9PSBPUFMuT1BfQ0hFQ0tTSUcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoISgwLCB0eXBlc18xLmlzUG9pbnQpKG8ucHVia2V5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IHB1YmtleSBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoYS5wdWJrZXkgJiYgIWEucHVia2V5LmVxdWFscyhvLnB1YmtleSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1B1YmtleSBtaXNtYXRjaCcpO1xuICAgIH1cbiAgICBpZiAoYS5zaWduYXR1cmUpIHtcbiAgICAgIGlmIChhLmlucHV0ICYmICFhLmlucHV0LmVxdWFscyhvLmlucHV0KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2lnbmF0dXJlIG1pc21hdGNoJyk7XG4gICAgfVxuICAgIGlmIChhLmlucHV0KSB7XG4gICAgICBpZiAoX2NodW5rcygpLmxlbmd0aCAhPT0gMSkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKCFic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKG8uc2lnbmF0dXJlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgaGFzIGludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG8sIGEpO1xufVxuZXhwb3J0cy5wMnBrID0gcDJwaztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/payments/p2pk.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2pkh.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2pkh.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2pkh = void 0;\nconst bcrypto = __webpack_require__(/*! ../crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\");\nconst networks_1 = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst bs58check = __webpack_require__(/*! bs58check */ \"./node_modules/bs58check/index.js\");\nconst OPS = bscript.OPS;\n// input: {signature} {pubkey}\n// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG\n/**\n * Creates a Pay-to-Public-Key-Hash (P2PKH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PKH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2pkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const payload = Buffer.from(bs58check.decode(a.address));\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(network.pubKeyHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(3, 23);\n    if (a.address) return _address().hash;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      o.hash,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_CHECKSIG,\n    ]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.input) return;\n    return _chunks()[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return bscript.compile([a.signature, a.pubkey]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.pubKeyHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 25 ||\n        a.output[0] !== OPS.OP_DUP ||\n        a.output[1] !== OPS.OP_HASH160 ||\n        a.output[2] !== 0x14 ||\n        a.output[23] !== OPS.OP_EQUALVERIFY ||\n        a.output[24] !== OPS.OP_CHECKSIG\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(3, 23);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n    }\n    if (a.input) {\n      const chunks = _chunks();\n      if (chunks.length !== 2) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(chunks[0]))\n        throw new TypeError('Input has invalid signature');\n      if (!(0, types_1.isPoint)(chunks[1]))\n        throw new TypeError('Input has invalid pubkey');\n      if (a.signature && !a.signature.equals(chunks[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(chunks[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(chunks[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pkh = p2pkh;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJwa2guanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBVztBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyxpRUFBYTtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBVztBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQywyREFBVTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsaUVBQVE7QUFDN0Isa0JBQWtCLG1CQUFPLENBQUMsb0RBQVc7QUFDckM7QUFDQSxXQUFXLFlBQVk7QUFDdkIsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9wMnBraC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wMnBraCA9IHZvaWQgMDtcbmNvbnN0IGJjcnlwdG8gPSByZXF1aXJlKCcuLi9jcnlwdG8nKTtcbmNvbnN0IG5ldHdvcmtzXzEgPSByZXF1aXJlKCcuLi9uZXR3b3JrcycpO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4uL3NjcmlwdCcpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoJy4uL3R5cGVzJyk7XG5jb25zdCBsYXp5ID0gcmVxdWlyZSgnLi9sYXp5Jyk7XG5jb25zdCBiczU4Y2hlY2sgPSByZXF1aXJlKCdiczU4Y2hlY2snKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuLy8gaW5wdXQ6IHtzaWduYXR1cmV9IHtwdWJrZXl9XG4vLyBvdXRwdXQ6IE9QX0RVUCBPUF9IQVNIMTYwIHtoYXNoMTYwKHB1YmtleSl9IE9QX0VRVUFMVkVSSUZZIE9QX0NIRUNLU0lHXG4vKipcbiAqIENyZWF0ZXMgYSBQYXktdG8tUHVibGljLUtleS1IYXNoIChQMlBLSCkgcGF5bWVudCBvYmplY3QuXG4gKlxuICogQHBhcmFtIGEgLSBUaGUgcGF5bWVudCBvYmplY3QgY29udGFpbmluZyB0aGUgbmVjZXNzYXJ5IGRhdGEuXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIHBheW1lbnQgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBQMlBLSCBwYXltZW50IG9iamVjdC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIHJlcXVpcmVkIGRhdGEgaXMgbm90IHByb3ZpZGVkIG9yIGlmIHRoZSBkYXRhIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHAycGtoKGEsIG9wdHMpIHtcbiAgaWYgKCFhLmFkZHJlc3MgJiYgIWEuaGFzaCAmJiAhYS5vdXRwdXQgJiYgIWEucHVia2V5ICYmICFhLmlucHV0KVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggZGF0YScpO1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdHMgfHwge30pO1xuICAoMCwgdHlwZXNfMS50eXBlZm9yY2UpKFxuICAgIHtcbiAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICBhZGRyZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5TdHJpbmcpLFxuICAgICAgaGFzaDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigyMCkpLFxuICAgICAgb3V0cHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDI1KSksXG4gICAgICBwdWJrZXk6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEuaXNQb2ludCksXG4gICAgICBzaWduYXR1cmU6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKGJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUpLFxuICAgICAgaW5wdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgfSxcbiAgICBhLFxuICApO1xuICBjb25zdCBfYWRkcmVzcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuZnJvbShiczU4Y2hlY2suZGVjb2RlKGEuYWRkcmVzcykpO1xuICAgIGNvbnN0IHZlcnNpb24gPSBwYXlsb2FkLnJlYWRVSW50OCgwKTtcbiAgICBjb25zdCBoYXNoID0gcGF5bG9hZC5zbGljZSgxKTtcbiAgICByZXR1cm4geyB2ZXJzaW9uLCBoYXNoIH07XG4gIH0pO1xuICBjb25zdCBfY2h1bmtzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgcmV0dXJuIGJzY3JpcHQuZGVjb21waWxlKGEuaW5wdXQpO1xuICB9KTtcbiAgY29uc3QgbmV0d29yayA9IGEubmV0d29yayB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gIGNvbnN0IG8gPSB7IG5hbWU6ICdwMnBraCcsIG5ldHdvcmsgfTtcbiAgbGF6eS5wcm9wKG8sICdhZGRyZXNzJywgKCkgPT4ge1xuICAgIGlmICghby5oYXNoKSByZXR1cm47XG4gICAgY29uc3QgcGF5bG9hZCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyMSk7XG4gICAgcGF5bG9hZC53cml0ZVVJbnQ4KG5ldHdvcmsucHViS2V5SGFzaCwgMCk7XG4gICAgby5oYXNoLmNvcHkocGF5bG9hZCwgMSk7XG4gICAgcmV0dXJuIGJzNThjaGVjay5lbmNvZGUocGF5bG9hZCk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2hhc2gnLCAoKSA9PiB7XG4gICAgaWYgKGEub3V0cHV0KSByZXR1cm4gYS5vdXRwdXQuc2xpY2UoMywgMjMpO1xuICAgIGlmIChhLmFkZHJlc3MpIHJldHVybiBfYWRkcmVzcygpLmhhc2g7XG4gICAgaWYgKGEucHVia2V5IHx8IG8ucHVia2V5KSByZXR1cm4gYmNyeXB0by5oYXNoMTYwKGEucHVia2V5IHx8IG8ucHVia2V5KTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnb3V0cHV0JywgKCkgPT4ge1xuICAgIGlmICghby5oYXNoKSByZXR1cm47XG4gICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbXG4gICAgICBPUFMuT1BfRFVQLFxuICAgICAgT1BTLk9QX0hBU0gxNjAsXG4gICAgICBvLmhhc2gsXG4gICAgICBPUFMuT1BfRVFVQUxWRVJJRlksXG4gICAgICBPUFMuT1BfQ0hFQ0tTSUcsXG4gICAgXSk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3B1YmtleScsICgpID0+IHtcbiAgICBpZiAoIWEuaW5wdXQpIHJldHVybjtcbiAgICByZXR1cm4gX2NodW5rcygpWzFdO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdzaWduYXR1cmUnLCAoKSA9PiB7XG4gICAgaWYgKCFhLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIF9jaHVua3MoKVswXTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFhLnB1YmtleSkgcmV0dXJuO1xuICAgIGlmICghYS5zaWduYXR1cmUpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFthLnNpZ25hdHVyZSwgYS5wdWJrZXldKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnd2l0bmVzcycsICgpID0+IHtcbiAgICBpZiAoIW8uaW5wdXQpIHJldHVybjtcbiAgICByZXR1cm4gW107XG4gIH0pO1xuICAvLyBleHRlbmRlZCB2YWxpZGF0aW9uXG4gIGlmIChvcHRzLnZhbGlkYXRlKSB7XG4gICAgbGV0IGhhc2ggPSBCdWZmZXIuZnJvbShbXSk7XG4gICAgaWYgKGEuYWRkcmVzcykge1xuICAgICAgaWYgKF9hZGRyZXNzKCkudmVyc2lvbiAhPT0gbmV0d29yay5wdWJLZXlIYXNoKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHZlcnNpb24gb3IgTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgaWYgKF9hZGRyZXNzKCkuaGFzaC5sZW5ndGggIT09IDIwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgICAgIGhhc2ggPSBfYWRkcmVzcygpLmhhc2g7XG4gICAgfVxuICAgIGlmIChhLmhhc2gpIHtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGEuaGFzaCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IGEuaGFzaDtcbiAgICB9XG4gICAgaWYgKGEub3V0cHV0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIGEub3V0cHV0Lmxlbmd0aCAhPT0gMjUgfHxcbiAgICAgICAgYS5vdXRwdXRbMF0gIT09IE9QUy5PUF9EVVAgfHxcbiAgICAgICAgYS5vdXRwdXRbMV0gIT09IE9QUy5PUF9IQVNIMTYwIHx8XG4gICAgICAgIGEub3V0cHV0WzJdICE9PSAweDE0IHx8XG4gICAgICAgIGEub3V0cHV0WzIzXSAhPT0gT1BTLk9QX0VRVUFMVkVSSUZZIHx8XG4gICAgICAgIGEub3V0cHV0WzI0XSAhPT0gT1BTLk9QX0NIRUNLU0lHXG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBjb25zdCBoYXNoMiA9IGEub3V0cHV0LnNsaWNlKDMsIDIzKTtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGhhc2gyKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgZWxzZSBoYXNoID0gaGFzaDI7XG4gICAgfVxuICAgIGlmIChhLnB1YmtleSkge1xuICAgICAgY29uc3QgcGtoID0gYmNyeXB0by5oYXNoMTYwKGEucHVia2V5KTtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKHBraCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IHBraDtcbiAgICB9XG4gICAgaWYgKGEuaW5wdXQpIHtcbiAgICAgIGNvbnN0IGNodW5rcyA9IF9jaHVua3MoKTtcbiAgICAgIGlmIChjaHVua3MubGVuZ3RoICE9PSAyKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAoIWJzY3JpcHQuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUoY2h1bmtzWzBdKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW5wdXQgaGFzIGludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgICBpZiAoISgwLCB0eXBlc18xLmlzUG9pbnQpKGNodW5rc1sxXSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGhhcyBpbnZhbGlkIHB1YmtleScpO1xuICAgICAgaWYgKGEuc2lnbmF0dXJlICYmICFhLnNpZ25hdHVyZS5lcXVhbHMoY2h1bmtzWzBdKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2lnbmF0dXJlIG1pc21hdGNoJyk7XG4gICAgICBpZiAoYS5wdWJrZXkgJiYgIWEucHVia2V5LmVxdWFscyhjaHVua3NbMV0pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2gnKTtcbiAgICAgIGNvbnN0IHBraCA9IGJjcnlwdG8uaGFzaDE2MChjaHVua3NbMV0pO1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMocGtoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihvLCBhKTtcbn1cbmV4cG9ydHMucDJwa2ggPSBwMnBraDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/payments/p2pkh.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2sh.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2sh.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2sh = void 0;\nconst bcrypto = __webpack_require__(/*! ../crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\");\nconst networks_1 = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst bs58check = __webpack_require__(/*! bs58check */ \"./node_modules/bs58check/index.js\");\nconst OPS = bscript.OPS;\n// input: [redeemScriptSig ...] {redeemScript}\n// witness: <?>\n// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL\n/**\n * Creates a Pay-to-Script-Hash (P2SH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2SH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2sh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),\n      redeem: types_1.typeforce.maybe({\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  const _address = lazy.value(() => {\n    const payload = Buffer.from(bs58check.decode(a.address));\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const _redeem = lazy.value(() => {\n    const chunks = _chunks();\n    const lastChunk = chunks[chunks.length - 1];\n    return {\n      network,\n      output: lastChunk === OPS.OP_FALSE ? Buffer.from([]) : lastChunk,\n      input: bscript.compile(chunks.slice(0, -1)),\n      witness: a.witness || [],\n    };\n  });\n  // output dependents\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(o.network.scriptHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    // in order of least effort\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().hash;\n    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);\n  });\n  // input dependents\n  lazy.prop(o, 'redeem', () => {\n    if (!a.input) return;\n    return _redeem();\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;\n    return bscript.compile(\n      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),\n    );\n  });\n  lazy.prop(o, 'witness', () => {\n    if (o.redeem && o.redeem.witness) return o.redeem.witness;\n    if (o.input) return [];\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2sh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.scriptHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 23 ||\n        a.output[0] !== OPS.OP_HASH160 ||\n        a.output[1] !== 0x14 ||\n        a.output[22] !== OPS.OP_EQUAL\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2, 22);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    // inlined to prevent 'no-inner-declarations' failing\n    const checkRedeem = redeem => {\n      // is the redeem output empty/invalid?\n      if (redeem.output) {\n        const decompile = bscript.decompile(redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output too short');\n        if (redeem.output.byteLength > 520)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 520 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = bcrypto.hash160(redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (redeem.input) {\n        const hasInput = redeem.input.length > 0;\n        const hasWitness = redeem.witness && redeem.witness.length > 0;\n        if (!hasInput && !hasWitness) throw new TypeError('Empty input');\n        if (hasInput && hasWitness)\n          throw new TypeError('Input and witness provided');\n        if (hasInput) {\n          const richunks = bscript.decompile(redeem.input);\n          if (!bscript.isPushOnly(richunks))\n            throw new TypeError('Non push-only scriptSig');\n        }\n      }\n    };\n    if (a.input) {\n      const chunks = _chunks();\n      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');\n      if (!Buffer.isBuffer(_redeem().output))\n        throw new TypeError('Input is invalid');\n      checkRedeem(_redeem());\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      if (a.input) {\n        const redeem = _redeem();\n        if (a.redeem.output && !a.redeem.output.equals(redeem.output))\n          throw new TypeError('Redeem.output mismatch');\n        if (a.redeem.input && !a.redeem.input.equals(redeem.input))\n          throw new TypeError('Redeem.input mismatch');\n      }\n      checkRedeem(a.redeem);\n    }\n    if (a.witness) {\n      if (\n        a.redeem &&\n        a.redeem.witness &&\n        !(0, types_1.stacksEqual)(a.redeem.witness, a.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2sh = p2sh;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJzaC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFXO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLGlFQUFhO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLDZEQUFXO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLDJEQUFVO0FBQ2xDLGFBQWEsbUJBQU8sQ0FBQyxpRUFBUTtBQUM3QixrQkFBa0IsbUJBQU8sQ0FBQyxvREFBVztBQUNyQztBQUNBLGlDQUFpQztBQUNqQztBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQixZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9wMnNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnAyc2ggPSB2b2lkIDA7XG5jb25zdCBiY3J5cHRvID0gcmVxdWlyZSgnLi4vY3J5cHRvJyk7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZSgnLi4vbmV0d29ya3MnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKCcuLi90eXBlcycpO1xuY29uc3QgbGF6eSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuY29uc3QgYnM1OGNoZWNrID0gcmVxdWlyZSgnYnM1OGNoZWNrJyk7XG5jb25zdCBPUFMgPSBic2NyaXB0Lk9QUztcbi8vIGlucHV0OiBbcmVkZWVtU2NyaXB0U2lnIC4uLl0ge3JlZGVlbVNjcmlwdH1cbi8vIHdpdG5lc3M6IDw/PlxuLy8gb3V0cHV0OiBPUF9IQVNIMTYwIHtoYXNoMTYwKHJlZGVlbVNjcmlwdCl9IE9QX0VRVUFMXG4vKipcbiAqIENyZWF0ZXMgYSBQYXktdG8tU2NyaXB0LUhhc2ggKFAyU0gpIHBheW1lbnQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBhIC0gVGhlIHBheW1lbnQgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG5lY2Vzc2FyeSBkYXRhLlxuICogQHBhcmFtIG9wdHMgLSBPcHRpb25hbCBwYXltZW50IG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgUDJTSCBwYXltZW50IG9iamVjdC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIHJlcXVpcmVkIGRhdGEgaXMgbm90IHByb3ZpZGVkIG9yIGlmIHRoZSBkYXRhIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHAyc2goYSwgb3B0cykge1xuICBpZiAoIWEuYWRkcmVzcyAmJiAhYS5oYXNoICYmICFhLm91dHB1dCAmJiAhYS5yZWRlZW0gJiYgIWEuaW5wdXQpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGVub3VnaCBkYXRhJyk7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgdmFsaWRhdGU6IHRydWUgfSwgb3B0cyB8fCB7fSk7XG4gICgwLCB0eXBlc18xLnR5cGVmb3JjZSkoXG4gICAge1xuICAgICAgbmV0d29yazogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuT2JqZWN0KSxcbiAgICAgIGFkZHJlc3M6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLlN0cmluZyksXG4gICAgICBoYXNoOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDIwKSksXG4gICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMjMpKSxcbiAgICAgIHJlZGVlbTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoe1xuICAgICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgIGlucHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgICB3aXRuZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZShcbiAgICAgICAgICB0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgICksXG4gICAgICB9KSxcbiAgICAgIGlucHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgd2l0bmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoXG4gICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLmFycmF5T2YodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgICksXG4gICAgfSxcbiAgICBhLFxuICApO1xuICBsZXQgbmV0d29yayA9IGEubmV0d29yaztcbiAgaWYgKCFuZXR3b3JrKSB7XG4gICAgbmV0d29yayA9IChhLnJlZGVlbSAmJiBhLnJlZGVlbS5uZXR3b3JrKSB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gIH1cbiAgY29uc3QgbyA9IHsgbmV0d29yayB9O1xuICBjb25zdCBfYWRkcmVzcyA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuZnJvbShiczU4Y2hlY2suZGVjb2RlKGEuYWRkcmVzcykpO1xuICAgIGNvbnN0IHZlcnNpb24gPSBwYXlsb2FkLnJlYWRVSW50OCgwKTtcbiAgICBjb25zdCBoYXNoID0gcGF5bG9hZC5zbGljZSgxKTtcbiAgICByZXR1cm4geyB2ZXJzaW9uLCBoYXNoIH07XG4gIH0pO1xuICBjb25zdCBfY2h1bmtzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgcmV0dXJuIGJzY3JpcHQuZGVjb21waWxlKGEuaW5wdXQpO1xuICB9KTtcbiAgY29uc3QgX3JlZGVlbSA9IGxhenkudmFsdWUoKCkgPT4ge1xuICAgIGNvbnN0IGNodW5rcyA9IF9jaHVua3MoKTtcbiAgICBjb25zdCBsYXN0Q2h1bmsgPSBjaHVua3NbY2h1bmtzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiB7XG4gICAgICBuZXR3b3JrLFxuICAgICAgb3V0cHV0OiBsYXN0Q2h1bmsgPT09IE9QUy5PUF9GQUxTRSA/IEJ1ZmZlci5mcm9tKFtdKSA6IGxhc3RDaHVuayxcbiAgICAgIGlucHV0OiBic2NyaXB0LmNvbXBpbGUoY2h1bmtzLnNsaWNlKDAsIC0xKSksXG4gICAgICB3aXRuZXNzOiBhLndpdG5lc3MgfHwgW10sXG4gICAgfTtcbiAgfSk7XG4gIC8vIG91dHB1dCBkZXBlbmRlbnRzXG4gIGxhenkucHJvcChvLCAnYWRkcmVzcycsICgpID0+IHtcbiAgICBpZiAoIW8uaGFzaCkgcmV0dXJuO1xuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjEpO1xuICAgIHBheWxvYWQud3JpdGVVSW50OChvLm5ldHdvcmsuc2NyaXB0SGFzaCwgMCk7XG4gICAgby5oYXNoLmNvcHkocGF5bG9hZCwgMSk7XG4gICAgcmV0dXJuIGJzNThjaGVjay5lbmNvZGUocGF5bG9hZCk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2hhc2gnLCAoKSA9PiB7XG4gICAgLy8gaW4gb3JkZXIgb2YgbGVhc3QgZWZmb3J0XG4gICAgaWYgKGEub3V0cHV0KSByZXR1cm4gYS5vdXRwdXQuc2xpY2UoMiwgMjIpO1xuICAgIGlmIChhLmFkZHJlc3MpIHJldHVybiBfYWRkcmVzcygpLmhhc2g7XG4gICAgaWYgKG8ucmVkZWVtICYmIG8ucmVkZWVtLm91dHB1dCkgcmV0dXJuIGJjcnlwdG8uaGFzaDE2MChvLnJlZGVlbS5vdXRwdXQpO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdvdXRwdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFvLmhhc2gpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtPUFMuT1BfSEFTSDE2MCwgby5oYXNoLCBPUFMuT1BfRVFVQUxdKTtcbiAgfSk7XG4gIC8vIGlucHV0IGRlcGVuZGVudHNcbiAgbGF6eS5wcm9wKG8sICdyZWRlZW0nLCAoKSA9PiB7XG4gICAgaWYgKCFhLmlucHV0KSByZXR1cm47XG4gICAgcmV0dXJuIF9yZWRlZW0oKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFhLnJlZGVlbSB8fCAhYS5yZWRlZW0uaW5wdXQgfHwgIWEucmVkZWVtLm91dHB1dCkgcmV0dXJuO1xuICAgIHJldHVybiBic2NyaXB0LmNvbXBpbGUoXG4gICAgICBbXS5jb25jYXQoYnNjcmlwdC5kZWNvbXBpbGUoYS5yZWRlZW0uaW5wdXQpLCBhLnJlZGVlbS5vdXRwdXQpLFxuICAgICk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3dpdG5lc3MnLCAoKSA9PiB7XG4gICAgaWYgKG8ucmVkZWVtICYmIG8ucmVkZWVtLndpdG5lc3MpIHJldHVybiBvLnJlZGVlbS53aXRuZXNzO1xuICAgIGlmIChvLmlucHV0KSByZXR1cm4gW107XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ25hbWUnLCAoKSA9PiB7XG4gICAgY29uc3QgbmFtZVBhcnRzID0gWydwMnNoJ107XG4gICAgaWYgKG8ucmVkZWVtICE9PSB1bmRlZmluZWQgJiYgby5yZWRlZW0ubmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgbmFtZVBhcnRzLnB1c2goby5yZWRlZW0ubmFtZSk7XG4gICAgcmV0dXJuIG5hbWVQYXJ0cy5qb2luKCctJyk7XG4gIH0pO1xuICBpZiAob3B0cy52YWxpZGF0ZSkge1xuICAgIGxldCBoYXNoID0gQnVmZmVyLmZyb20oW10pO1xuICAgIGlmIChhLmFkZHJlc3MpIHtcbiAgICAgIGlmIChfYWRkcmVzcygpLnZlcnNpb24gIT09IG5ldHdvcmsuc2NyaXB0SGFzaClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB2ZXJzaW9uIG9yIE5ldHdvcmsgbWlzbWF0Y2gnKTtcbiAgICAgIGlmIChfYWRkcmVzcygpLmhhc2gubGVuZ3RoICE9PSAyMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gICAgICBoYXNoID0gX2FkZHJlc3MoKS5oYXNoO1xuICAgIH1cbiAgICBpZiAoYS5oYXNoKSB7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhhLmhhc2gpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICBlbHNlIGhhc2ggPSBhLmhhc2g7XG4gICAgfVxuICAgIGlmIChhLm91dHB1dCkge1xuICAgICAgaWYgKFxuICAgICAgICBhLm91dHB1dC5sZW5ndGggIT09IDIzIHx8XG4gICAgICAgIGEub3V0cHV0WzBdICE9PSBPUFMuT1BfSEFTSDE2MCB8fFxuICAgICAgICBhLm91dHB1dFsxXSAhPT0gMHgxNCB8fFxuICAgICAgICBhLm91dHB1dFsyMl0gIT09IE9QUy5PUF9FUVVBTFxuICAgICAgKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgY29uc3QgaGFzaDIgPSBhLm91dHB1dC5zbGljZSgyLCAyMik7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhoYXNoMikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IGhhc2gyO1xuICAgIH1cbiAgICAvLyBpbmxpbmVkIHRvIHByZXZlbnQgJ25vLWlubmVyLWRlY2xhcmF0aW9ucycgZmFpbGluZ1xuICAgIGNvbnN0IGNoZWNrUmVkZWVtID0gcmVkZWVtID0+IHtcbiAgICAgIC8vIGlzIHRoZSByZWRlZW0gb3V0cHV0IGVtcHR5L2ludmFsaWQ/XG4gICAgICBpZiAocmVkZWVtLm91dHB1dCkge1xuICAgICAgICBjb25zdCBkZWNvbXBpbGUgPSBic2NyaXB0LmRlY29tcGlsZShyZWRlZW0ub3V0cHV0KTtcbiAgICAgICAgaWYgKCFkZWNvbXBpbGUgfHwgZGVjb21waWxlLmxlbmd0aCA8IDEpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkZWVtLm91dHB1dCB0b28gc2hvcnQnKTtcbiAgICAgICAgaWYgKHJlZGVlbS5vdXRwdXQuYnl0ZUxlbmd0aCA+IDUyMClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ1JlZGVlbS5vdXRwdXQgdW5zcGVuZGFibGUgaWYgbGFyZ2VyIHRoYW4gNTIwIGJ5dGVzJyxcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoYnNjcmlwdC5jb3VudE5vblB1c2hPbmx5T1BzKGRlY29tcGlsZSkgPiAyMDEpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdSZWRlZW0ub3V0cHV0IHVuc3BlbmRhYmxlIHdpdGggbW9yZSB0aGFuIDIwMSBub24tcHVzaCBvcHMnLFxuICAgICAgICAgICk7XG4gICAgICAgIC8vIG1hdGNoIGhhc2ggYWdhaW5zdCBvdGhlciBzb3VyY2VzXG4gICAgICAgIGNvbnN0IGhhc2gyID0gYmNyeXB0by5oYXNoMTYwKHJlZGVlbS5vdXRwdXQpO1xuICAgICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhoYXNoMikpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgICBlbHNlIGhhc2ggPSBoYXNoMjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWRlZW0uaW5wdXQpIHtcbiAgICAgICAgY29uc3QgaGFzSW5wdXQgPSByZWRlZW0uaW5wdXQubGVuZ3RoID4gMDtcbiAgICAgICAgY29uc3QgaGFzV2l0bmVzcyA9IHJlZGVlbS53aXRuZXNzICYmIHJlZGVlbS53aXRuZXNzLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmICghaGFzSW5wdXQgJiYgIWhhc1dpdG5lc3MpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0VtcHR5IGlucHV0Jyk7XG4gICAgICAgIGlmIChoYXNJbnB1dCAmJiBoYXNXaXRuZXNzKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGFuZCB3aXRuZXNzIHByb3ZpZGVkJyk7XG4gICAgICAgIGlmIChoYXNJbnB1dCkge1xuICAgICAgICAgIGNvbnN0IHJpY2h1bmtzID0gYnNjcmlwdC5kZWNvbXBpbGUocmVkZWVtLmlucHV0KTtcbiAgICAgICAgICBpZiAoIWJzY3JpcHQuaXNQdXNoT25seShyaWNodW5rcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb24gcHVzaC1vbmx5IHNjcmlwdFNpZycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoYS5pbnB1dCkge1xuICAgICAgY29uc3QgY2h1bmtzID0gX2NodW5rcygpO1xuICAgICAgaWYgKCFjaHVua3MgfHwgY2h1bmtzLmxlbmd0aCA8IDEpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IHRvbyBzaG9ydCcpO1xuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoX3JlZGVlbSgpLm91dHB1dCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGNoZWNrUmVkZWVtKF9yZWRlZW0oKSk7XG4gICAgfVxuICAgIGlmIChhLnJlZGVlbSkge1xuICAgICAgaWYgKGEucmVkZWVtLm5ldHdvcmsgJiYgYS5yZWRlZW0ubmV0d29yayAhPT0gbmV0d29yaylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgaWYgKGEuaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVkZWVtID0gX3JlZGVlbSgpO1xuICAgICAgICBpZiAoYS5yZWRlZW0ub3V0cHV0ICYmICFhLnJlZGVlbS5vdXRwdXQuZXF1YWxzKHJlZGVlbS5vdXRwdXQpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbS5vdXRwdXQgbWlzbWF0Y2gnKTtcbiAgICAgICAgaWYgKGEucmVkZWVtLmlucHV0ICYmICFhLnJlZGVlbS5pbnB1dC5lcXVhbHMocmVkZWVtLmlucHV0KSlcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWRlZW0uaW5wdXQgbWlzbWF0Y2gnKTtcbiAgICAgIH1cbiAgICAgIGNoZWNrUmVkZWVtKGEucmVkZWVtKTtcbiAgICB9XG4gICAgaWYgKGEud2l0bmVzcykge1xuICAgICAgaWYgKFxuICAgICAgICBhLnJlZGVlbSAmJlxuICAgICAgICBhLnJlZGVlbS53aXRuZXNzICYmXG4gICAgICAgICEoMCwgdHlwZXNfMS5zdGFja3NFcXVhbCkoYS5yZWRlZW0ud2l0bmVzcywgYS53aXRuZXNzKVxuICAgICAgKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXaXRuZXNzIGFuZCByZWRlZW0ud2l0bmVzcyBtaXNtYXRjaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbihvLCBhKTtcbn1cbmV4cG9ydHMucDJzaCA9IHAyc2g7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/payments/p2sh.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2tr.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2tr.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2tr = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\");\nconst networks_1 = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst ecc_lib_1 = __webpack_require__(/*! ../ecc_lib */ \"./node_modules/bitcoinjs-lib/src/ecc_lib.js\");\nconst bip341_1 = __webpack_require__(/*! ./bip341 */ \"./node_modules/bitcoinjs-lib/src/payments/bip341.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst bech32_1 = __webpack_require__(/*! bech32 */ \"./node_modules/bech32/dist/index.js\");\nconst address_1 = __webpack_require__(/*! ../address */ \"./node_modules/bitcoinjs-lib/src/address.js\");\nconst OPS = bscript.OPS;\nconst TAPROOT_WITNESS_VERSION = 0x01;\nconst ANNEX_PREFIX = 0x50;\n/**\n * Creates a Pay-to-Taproot (P2TR) payment object.\n *\n * @param a - The payment object containing the necessary data for P2TR.\n * @param opts - Optional payment options.\n * @returns The P2TR payment object.\n * @throws {TypeError} If the provided data is invalid or insufficient.\n */\nfunction p2tr(a, opts) {\n  if (\n    !a.address &&\n    !a.output &&\n    !a.pubkey &&\n    !a.internalPubkey &&\n    !(a.witness && a.witness.length > 1)\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),\n      internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      signature: types_1.typeforce.maybe(\n        types_1.typeforce.anyOf(\n          types_1.typeforce.BufferN(64),\n          types_1.typeforce.BufferN(65),\n        ),\n      ),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n      scriptTree: types_1.typeforce.maybe(types_1.isTaptree),\n      redeem: types_1.typeforce.maybe({\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    return (0, address_1.fromBech32)(a.address);\n  });\n  // remove annex if present, ignored by taproot\n  const _witness = lazy.value(() => {\n    if (!a.witness || !a.witness.length) return;\n    if (\n      a.witness.length >= 2 &&\n      a.witness[a.witness.length - 1][0] === ANNEX_PREFIX\n    ) {\n      return a.witness.slice(0, -1);\n    }\n    return a.witness.slice();\n  });\n  const _hashTree = lazy.value(() => {\n    if (a.scriptTree) return (0, bip341_1.toHashTree)(a.scriptTree);\n    if (a.hash) return { hash: a.hash };\n    return;\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2tr', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.pubkey) return;\n    const words = bech32_1.bech32m.toWords(o.pubkey);\n    words.unshift(TAPROOT_WITNESS_VERSION);\n    return bech32_1.bech32m.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    const hashTree = _hashTree();\n    if (hashTree) return hashTree.hash;\n    const w = _witness();\n    if (w && w.length > 1) {\n      const controlBlock = w[w.length - 1];\n      const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n      const script = w[w.length - 2];\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: script,\n        version: leafVersion,\n      });\n      return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n    }\n    return null;\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.pubkey) return;\n    return bscript.compile([OPS.OP_1, o.pubkey]);\n  });\n  lazy.prop(o, 'redeemVersion', () => {\n    if (a.redeemVersion) return a.redeemVersion;\n    if (\n      a.redeem &&\n      a.redeem.redeemVersion !== undefined &&\n      a.redeem.redeemVersion !== null\n    ) {\n      return a.redeem.redeemVersion;\n    }\n    return bip341_1.LEAF_VERSION_TAPSCRIPT;\n  });\n  lazy.prop(o, 'redeem', () => {\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length < 2) return;\n    return {\n      output: witness[witness.length - 2],\n      witness: witness.slice(0, -2),\n      redeemVersion:\n        witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK,\n    };\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.internalPubkey) {\n      const tweakedKey = (0, bip341_1.tweakKey)(o.internalPubkey, o.hash);\n      if (tweakedKey) return tweakedKey.x;\n    }\n  });\n  lazy.prop(o, 'internalPubkey', () => {\n    if (a.internalPubkey) return a.internalPubkey;\n    const witness = _witness();\n    if (witness && witness.length > 1)\n      return witness[witness.length - 1].slice(1, 33);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (a.signature) return a.signature;\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length !== 1) return;\n    return witness[0];\n  });\n  lazy.prop(o, 'witness', () => {\n    if (a.witness) return a.witness;\n    const hashTree = _hashTree();\n    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);\n      if (!path) return;\n      const outputKey = (0, bip341_1.tweakKey)(a.internalPubkey, hashTree.hash);\n      if (!outputKey) return;\n      const controlBock = buffer_1.Buffer.concat(\n        [\n          buffer_1.Buffer.from([o.redeemVersion | outputKey.parity]),\n          a.internalPubkey,\n        ].concat(path),\n      );\n      return [a.redeem.output, controlBock];\n    }\n    if (a.signature) return [a.signature];\n  });\n  // extended validation\n  if (opts.validate) {\n    let pubkey = buffer_1.Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== TAPROOT_WITNESS_VERSION)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      pubkey = _address().data;\n    }\n    if (a.pubkey) {\n      if (pubkey.length > 0 && !pubkey.equals(a.pubkey))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.pubkey;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_1 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2)))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.output.slice(2);\n    }\n    if (a.internalPubkey) {\n      const tweakedKey = (0, bip341_1.tweakKey)(a.internalPubkey, o.hash);\n      if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = tweakedKey.x;\n    }\n    if (pubkey && pubkey.length) {\n      if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))\n        throw new TypeError('Invalid pubkey for p2tr');\n    }\n    const hashTree = _hashTree();\n    if (a.hash && hashTree) {\n      if (!a.hash.equals(hashTree.hash)) throw new TypeError('Hash mismatch');\n    }\n    if (a.redeem && a.redeem.output && hashTree) {\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))\n        throw new TypeError('Redeem script not in tree');\n    }\n    const witness = _witness();\n    // compare the provided redeem data with the one computed from witness\n    if (a.redeem && o.redeem) {\n      if (a.redeem.redeemVersion) {\n        if (a.redeem.redeemVersion !== o.redeem.redeemVersion)\n          throw new TypeError('Redeem.redeemVersion and witness mismatch');\n      }\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0)\n          throw new TypeError('Redeem.output is invalid');\n        // output redeem is constructed from the witness\n        if (o.redeem.output && !a.redeem.output.equals(o.redeem.output))\n          throw new TypeError('Redeem.output and witness mismatch');\n      }\n      if (a.redeem.witness) {\n        if (\n          o.redeem.witness &&\n          !(0, types_1.stacksEqual)(a.redeem.witness, o.redeem.witness)\n        )\n          throw new TypeError('Redeem.witness and witness mismatch');\n      }\n    }\n    if (witness && witness.length) {\n      if (witness.length === 1) {\n        // key spending\n        if (a.signature && !a.signature.equals(witness[0]))\n          throw new TypeError('Signature mismatch');\n      } else {\n        // script path spending\n        const controlBlock = witness[witness.length - 1];\n        if (controlBlock.length < 33)\n          throw new TypeError(\n            `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n          );\n        if ((controlBlock.length - 33) % 32 !== 0)\n          throw new TypeError(\n            `The control-block length of ${controlBlock.length} is incorrect!`,\n          );\n        const m = (controlBlock.length - 33) / 32;\n        if (m > 128)\n          throw new TypeError(\n            `The script path is too long. Got ${m}, expected max 128.`,\n          );\n        const internalPubkey = controlBlock.slice(1, 33);\n        if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey))\n          throw new TypeError('Internal pubkey mismatch');\n        if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey))\n          throw new TypeError('Invalid internalPubkey for p2tr witness');\n        const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n        const script = witness[witness.length - 2];\n        const leafHash = (0, bip341_1.tapleafHash)({\n          output: script,\n          version: leafVersion,\n        });\n        const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n        const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);\n        if (!outputKey)\n          // todo: needs test data\n          throw new TypeError('Invalid outputKey for p2tr witness');\n        if (pubkey.length && !pubkey.equals(outputKey.x))\n          throw new TypeError('Pubkey mismatch for p2tr witness');\n        if (outputKey.parity !== (controlBlock[0] & 1))\n          throw new Error('Incorrect parity');\n      }\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2tr = p2tr;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJ0ci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZO0FBQ1osaUJBQWlCLG1CQUFPLENBQUMsaUVBQVE7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsaUVBQWE7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVU7QUFDbEMsa0JBQWtCLG1CQUFPLENBQUMsK0RBQVk7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMscUVBQVU7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLGlFQUFRO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLG1EQUFRO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLCtEQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0IsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG9CQUFvQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMscUJBQXFCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9wMnRyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnAydHIgPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuY29uc3QgbmV0d29ya3NfMSA9IHJlcXVpcmUoJy4uL25ldHdvcmtzJyk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi4vc2NyaXB0Jyk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbmNvbnN0IGVjY19saWJfMSA9IHJlcXVpcmUoJy4uL2VjY19saWInKTtcbmNvbnN0IGJpcDM0MV8xID0gcmVxdWlyZSgnLi9iaXAzNDEnKTtcbmNvbnN0IGxhenkgPSByZXF1aXJlKCcuL2xhenknKTtcbmNvbnN0IGJlY2gzMl8xID0gcmVxdWlyZSgnYmVjaDMyJyk7XG5jb25zdCBhZGRyZXNzXzEgPSByZXF1aXJlKCcuLi9hZGRyZXNzJyk7XG5jb25zdCBPUFMgPSBic2NyaXB0Lk9QUztcbmNvbnN0IFRBUFJPT1RfV0lUTkVTU19WRVJTSU9OID0gMHgwMTtcbmNvbnN0IEFOTkVYX1BSRUZJWCA9IDB4NTA7XG4vKipcbiAqIENyZWF0ZXMgYSBQYXktdG8tVGFwcm9vdCAoUDJUUikgcGF5bWVudCBvYmplY3QuXG4gKlxuICogQHBhcmFtIGEgLSBUaGUgcGF5bWVudCBvYmplY3QgY29udGFpbmluZyB0aGUgbmVjZXNzYXJ5IGRhdGEgZm9yIFAyVFIuXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIHBheW1lbnQgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBQMlRSIHBheW1lbnQgb2JqZWN0LlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgcHJvdmlkZWQgZGF0YSBpcyBpbnZhbGlkIG9yIGluc3VmZmljaWVudC5cbiAqL1xuZnVuY3Rpb24gcDJ0cihhLCBvcHRzKSB7XG4gIGlmIChcbiAgICAhYS5hZGRyZXNzICYmXG4gICAgIWEub3V0cHV0ICYmXG4gICAgIWEucHVia2V5ICYmXG4gICAgIWEuaW50ZXJuYWxQdWJrZXkgJiZcbiAgICAhKGEud2l0bmVzcyAmJiBhLndpdG5lc3MubGVuZ3RoID4gMSlcbiAgKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggZGF0YScpO1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdHMgfHwge30pO1xuICAoMCwgdHlwZXNfMS50eXBlZm9yY2UpKFxuICAgIHtcbiAgICAgIGFkZHJlc3M6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLlN0cmluZyksXG4gICAgICBpbnB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigwKSksXG4gICAgICBuZXR3b3JrOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5PYmplY3QpLFxuICAgICAgb3V0cHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDM0KSksXG4gICAgICBpbnRlcm5hbFB1YmtleTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigzMikpLFxuICAgICAgaGFzaDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigzMikpLFxuICAgICAgcHVia2V5OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDMyKSksXG4gICAgICBzaWduYXR1cmU6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKFxuICAgICAgICB0eXBlc18xLnR5cGVmb3JjZS5hbnlPZihcbiAgICAgICAgICB0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDY0KSxcbiAgICAgICAgICB0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDY1KSxcbiAgICAgICAgKSxcbiAgICAgICksXG4gICAgICB3aXRuZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZShcbiAgICAgICAgdHlwZXNfMS50eXBlZm9yY2UuYXJyYXlPZih0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgKSxcbiAgICAgIHNjcmlwdFRyZWU6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEuaXNUYXB0cmVlKSxcbiAgICAgIHJlZGVlbTogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoe1xuICAgICAgICBvdXRwdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgIHJlZGVlbVZlcnNpb246IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk51bWJlciksXG4gICAgICAgIHdpdG5lc3M6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKFxuICAgICAgICAgIHR5cGVzXzEudHlwZWZvcmNlLmFycmF5T2YodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgICAgKSxcbiAgICAgIH0pLFxuICAgICAgcmVkZWVtVmVyc2lvbjogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuTnVtYmVyKSxcbiAgICB9LFxuICAgIGEsXG4gICk7XG4gIGNvbnN0IF9hZGRyZXNzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgcmV0dXJuICgwLCBhZGRyZXNzXzEuZnJvbUJlY2gzMikoYS5hZGRyZXNzKTtcbiAgfSk7XG4gIC8vIHJlbW92ZSBhbm5leCBpZiBwcmVzZW50LCBpZ25vcmVkIGJ5IHRhcHJvb3RcbiAgY29uc3QgX3dpdG5lc3MgPSBsYXp5LnZhbHVlKCgpID0+IHtcbiAgICBpZiAoIWEud2l0bmVzcyB8fCAhYS53aXRuZXNzLmxlbmd0aCkgcmV0dXJuO1xuICAgIGlmIChcbiAgICAgIGEud2l0bmVzcy5sZW5ndGggPj0gMiAmJlxuICAgICAgYS53aXRuZXNzW2Eud2l0bmVzcy5sZW5ndGggLSAxXVswXSA9PT0gQU5ORVhfUFJFRklYXG4gICAgKSB7XG4gICAgICByZXR1cm4gYS53aXRuZXNzLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIGEud2l0bmVzcy5zbGljZSgpO1xuICB9KTtcbiAgY29uc3QgX2hhc2hUcmVlID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgaWYgKGEuc2NyaXB0VHJlZSkgcmV0dXJuICgwLCBiaXAzNDFfMS50b0hhc2hUcmVlKShhLnNjcmlwdFRyZWUpO1xuICAgIGlmIChhLmhhc2gpIHJldHVybiB7IGhhc2g6IGEuaGFzaCB9O1xuICAgIHJldHVybjtcbiAgfSk7XG4gIGNvbnN0IG5ldHdvcmsgPSBhLm5ldHdvcmsgfHwgbmV0d29ya3NfMS5iaXRjb2luO1xuICBjb25zdCBvID0geyBuYW1lOiAncDJ0cicsIG5ldHdvcmsgfTtcbiAgbGF6eS5wcm9wKG8sICdhZGRyZXNzJywgKCkgPT4ge1xuICAgIGlmICghby5wdWJrZXkpIHJldHVybjtcbiAgICBjb25zdCB3b3JkcyA9IGJlY2gzMl8xLmJlY2gzMm0udG9Xb3JkcyhvLnB1YmtleSk7XG4gICAgd29yZHMudW5zaGlmdChUQVBST09UX1dJVE5FU1NfVkVSU0lPTik7XG4gICAgcmV0dXJuIGJlY2gzMl8xLmJlY2gzMm0uZW5jb2RlKG5ldHdvcmsuYmVjaDMyLCB3b3Jkcyk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2hhc2gnLCAoKSA9PiB7XG4gICAgY29uc3QgaGFzaFRyZWUgPSBfaGFzaFRyZWUoKTtcbiAgICBpZiAoaGFzaFRyZWUpIHJldHVybiBoYXNoVHJlZS5oYXNoO1xuICAgIGNvbnN0IHcgPSBfd2l0bmVzcygpO1xuICAgIGlmICh3ICYmIHcubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgY29udHJvbEJsb2NrID0gd1t3Lmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgbGVhZlZlcnNpb24gPSBjb250cm9sQmxvY2tbMF0gJiB0eXBlc18xLlRBUExFQUZfVkVSU0lPTl9NQVNLO1xuICAgICAgY29uc3Qgc2NyaXB0ID0gd1t3Lmxlbmd0aCAtIDJdO1xuICAgICAgY29uc3QgbGVhZkhhc2ggPSAoMCwgYmlwMzQxXzEudGFwbGVhZkhhc2gpKHtcbiAgICAgICAgb3V0cHV0OiBzY3JpcHQsXG4gICAgICAgIHZlcnNpb246IGxlYWZWZXJzaW9uLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKDAsIGJpcDM0MV8xLnJvb3RIYXNoRnJvbVBhdGgpKGNvbnRyb2xCbG9jaywgbGVhZkhhc2gpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnb3V0cHV0JywgKCkgPT4ge1xuICAgIGlmICghby5wdWJrZXkpIHJldHVybjtcbiAgICByZXR1cm4gYnNjcmlwdC5jb21waWxlKFtPUFMuT1BfMSwgby5wdWJrZXldKTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAncmVkZWVtVmVyc2lvbicsICgpID0+IHtcbiAgICBpZiAoYS5yZWRlZW1WZXJzaW9uKSByZXR1cm4gYS5yZWRlZW1WZXJzaW9uO1xuICAgIGlmIChcbiAgICAgIGEucmVkZWVtICYmXG4gICAgICBhLnJlZGVlbS5yZWRlZW1WZXJzaW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGEucmVkZWVtLnJlZGVlbVZlcnNpb24gIT09IG51bGxcbiAgICApIHtcbiAgICAgIHJldHVybiBhLnJlZGVlbS5yZWRlZW1WZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gYmlwMzQxXzEuTEVBRl9WRVJTSU9OX1RBUFNDUklQVDtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAncmVkZWVtJywgKCkgPT4ge1xuICAgIGNvbnN0IHdpdG5lc3MgPSBfd2l0bmVzcygpOyAvLyB3aXRuZXNzIHdpdGhvdXQgYW5uZXhcbiAgICBpZiAoIXdpdG5lc3MgfHwgd2l0bmVzcy5sZW5ndGggPCAyKSByZXR1cm47XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dHB1dDogd2l0bmVzc1t3aXRuZXNzLmxlbmd0aCAtIDJdLFxuICAgICAgd2l0bmVzczogd2l0bmVzcy5zbGljZSgwLCAtMiksXG4gICAgICByZWRlZW1WZXJzaW9uOlxuICAgICAgICB3aXRuZXNzW3dpdG5lc3MubGVuZ3RoIC0gMV1bMF0gJiB0eXBlc18xLlRBUExFQUZfVkVSU0lPTl9NQVNLLFxuICAgIH07XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3B1YmtleScsICgpID0+IHtcbiAgICBpZiAoYS5wdWJrZXkpIHJldHVybiBhLnB1YmtleTtcbiAgICBpZiAoYS5vdXRwdXQpIHJldHVybiBhLm91dHB1dC5zbGljZSgyKTtcbiAgICBpZiAoYS5hZGRyZXNzKSByZXR1cm4gX2FkZHJlc3MoKS5kYXRhO1xuICAgIGlmIChvLmludGVybmFsUHVia2V5KSB7XG4gICAgICBjb25zdCB0d2Vha2VkS2V5ID0gKDAsIGJpcDM0MV8xLnR3ZWFrS2V5KShvLmludGVybmFsUHVia2V5LCBvLmhhc2gpO1xuICAgICAgaWYgKHR3ZWFrZWRLZXkpIHJldHVybiB0d2Vha2VkS2V5Lng7XG4gICAgfVxuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdpbnRlcm5hbFB1YmtleScsICgpID0+IHtcbiAgICBpZiAoYS5pbnRlcm5hbFB1YmtleSkgcmV0dXJuIGEuaW50ZXJuYWxQdWJrZXk7XG4gICAgY29uc3Qgd2l0bmVzcyA9IF93aXRuZXNzKCk7XG4gICAgaWYgKHdpdG5lc3MgJiYgd2l0bmVzcy5sZW5ndGggPiAxKVxuICAgICAgcmV0dXJuIHdpdG5lc3Nbd2l0bmVzcy5sZW5ndGggLSAxXS5zbGljZSgxLCAzMyk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3NpZ25hdHVyZScsICgpID0+IHtcbiAgICBpZiAoYS5zaWduYXR1cmUpIHJldHVybiBhLnNpZ25hdHVyZTtcbiAgICBjb25zdCB3aXRuZXNzID0gX3dpdG5lc3MoKTsgLy8gd2l0bmVzcyB3aXRob3V0IGFubmV4XG4gICAgaWYgKCF3aXRuZXNzIHx8IHdpdG5lc3MubGVuZ3RoICE9PSAxKSByZXR1cm47XG4gICAgcmV0dXJuIHdpdG5lc3NbMF07XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3dpdG5lc3MnLCAoKSA9PiB7XG4gICAgaWYgKGEud2l0bmVzcykgcmV0dXJuIGEud2l0bmVzcztcbiAgICBjb25zdCBoYXNoVHJlZSA9IF9oYXNoVHJlZSgpO1xuICAgIGlmIChoYXNoVHJlZSAmJiBhLnJlZGVlbSAmJiBhLnJlZGVlbS5vdXRwdXQgJiYgYS5pbnRlcm5hbFB1YmtleSkge1xuICAgICAgY29uc3QgbGVhZkhhc2ggPSAoMCwgYmlwMzQxXzEudGFwbGVhZkhhc2gpKHtcbiAgICAgICAgb3V0cHV0OiBhLnJlZGVlbS5vdXRwdXQsXG4gICAgICAgIHZlcnNpb246IG8ucmVkZWVtVmVyc2lvbixcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGF0aCA9ICgwLCBiaXAzNDFfMS5maW5kU2NyaXB0UGF0aCkoaGFzaFRyZWUsIGxlYWZIYXNoKTtcbiAgICAgIGlmICghcGF0aCkgcmV0dXJuO1xuICAgICAgY29uc3Qgb3V0cHV0S2V5ID0gKDAsIGJpcDM0MV8xLnR3ZWFrS2V5KShhLmludGVybmFsUHVia2V5LCBoYXNoVHJlZS5oYXNoKTtcbiAgICAgIGlmICghb3V0cHV0S2V5KSByZXR1cm47XG4gICAgICBjb25zdCBjb250cm9sQm9jayA9IGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoXG4gICAgICAgIFtcbiAgICAgICAgICBidWZmZXJfMS5CdWZmZXIuZnJvbShbby5yZWRlZW1WZXJzaW9uIHwgb3V0cHV0S2V5LnBhcml0eV0pLFxuICAgICAgICAgIGEuaW50ZXJuYWxQdWJrZXksXG4gICAgICAgIF0uY29uY2F0KHBhdGgpLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBbYS5yZWRlZW0ub3V0cHV0LCBjb250cm9sQm9ja107XG4gICAgfVxuICAgIGlmIChhLnNpZ25hdHVyZSkgcmV0dXJuIFthLnNpZ25hdHVyZV07XG4gIH0pO1xuICAvLyBleHRlbmRlZCB2YWxpZGF0aW9uXG4gIGlmIChvcHRzLnZhbGlkYXRlKSB7XG4gICAgbGV0IHB1YmtleSA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFtdKTtcbiAgICBpZiAoYS5hZGRyZXNzKSB7XG4gICAgICBpZiAobmV0d29yayAmJiBuZXR3b3JrLmJlY2gzMiAhPT0gX2FkZHJlc3MoKS5wcmVmaXgpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcHJlZml4IG9yIE5ldHdvcmsgbWlzbWF0Y2gnKTtcbiAgICAgIGlmIChfYWRkcmVzcygpLnZlcnNpb24gIT09IFRBUFJPT1RfV0lUTkVTU19WRVJTSU9OKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MgdmVyc2lvbicpO1xuICAgICAgaWYgKF9hZGRyZXNzKCkuZGF0YS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MgZGF0YScpO1xuICAgICAgcHVia2V5ID0gX2FkZHJlc3MoKS5kYXRhO1xuICAgIH1cbiAgICBpZiAoYS5wdWJrZXkpIHtcbiAgICAgIGlmIChwdWJrZXkubGVuZ3RoID4gMCAmJiAhcHVia2V5LmVxdWFscyhhLnB1YmtleSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1B1YmtleSBtaXNtYXRjaCcpO1xuICAgICAgZWxzZSBwdWJrZXkgPSBhLnB1YmtleTtcbiAgICB9XG4gICAgaWYgKGEub3V0cHV0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIGEub3V0cHV0Lmxlbmd0aCAhPT0gMzQgfHxcbiAgICAgICAgYS5vdXRwdXRbMF0gIT09IE9QUy5PUF8xIHx8XG4gICAgICAgIGEub3V0cHV0WzFdICE9PSAweDIwXG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBpZiAocHVia2V5Lmxlbmd0aCA+IDAgJiYgIXB1YmtleS5lcXVhbHMoYS5vdXRwdXQuc2xpY2UoMikpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQdWJrZXkgbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgcHVia2V5ID0gYS5vdXRwdXQuc2xpY2UoMik7XG4gICAgfVxuICAgIGlmIChhLmludGVybmFsUHVia2V5KSB7XG4gICAgICBjb25zdCB0d2Vha2VkS2V5ID0gKDAsIGJpcDM0MV8xLnR3ZWFrS2V5KShhLmludGVybmFsUHVia2V5LCBvLmhhc2gpO1xuICAgICAgaWYgKHB1YmtleS5sZW5ndGggPiAwICYmICFwdWJrZXkuZXF1YWxzKHR3ZWFrZWRLZXkueCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1B1YmtleSBtaXNtYXRjaCcpO1xuICAgICAgZWxzZSBwdWJrZXkgPSB0d2Vha2VkS2V5Lng7XG4gICAgfVxuICAgIGlmIChwdWJrZXkgJiYgcHVia2V5Lmxlbmd0aCkge1xuICAgICAgaWYgKCEoMCwgZWNjX2xpYl8xLmdldEVjY0xpYikoKS5pc1hPbmx5UG9pbnQocHVia2V5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwdWJrZXkgZm9yIHAydHInKTtcbiAgICB9XG4gICAgY29uc3QgaGFzaFRyZWUgPSBfaGFzaFRyZWUoKTtcbiAgICBpZiAoYS5oYXNoICYmIGhhc2hUcmVlKSB7XG4gICAgICBpZiAoIWEuaGFzaC5lcXVhbHMoaGFzaFRyZWUuaGFzaCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICB9XG4gICAgaWYgKGEucmVkZWVtICYmIGEucmVkZWVtLm91dHB1dCAmJiBoYXNoVHJlZSkge1xuICAgICAgY29uc3QgbGVhZkhhc2ggPSAoMCwgYmlwMzQxXzEudGFwbGVhZkhhc2gpKHtcbiAgICAgICAgb3V0cHV0OiBhLnJlZGVlbS5vdXRwdXQsXG4gICAgICAgIHZlcnNpb246IG8ucmVkZWVtVmVyc2lvbixcbiAgICAgIH0pO1xuICAgICAgaWYgKCEoMCwgYmlwMzQxXzEuZmluZFNjcmlwdFBhdGgpKGhhc2hUcmVlLCBsZWFmSGFzaCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbSBzY3JpcHQgbm90IGluIHRyZWUnKTtcbiAgICB9XG4gICAgY29uc3Qgd2l0bmVzcyA9IF93aXRuZXNzKCk7XG4gICAgLy8gY29tcGFyZSB0aGUgcHJvdmlkZWQgcmVkZWVtIGRhdGEgd2l0aCB0aGUgb25lIGNvbXB1dGVkIGZyb20gd2l0bmVzc1xuICAgIGlmIChhLnJlZGVlbSAmJiBvLnJlZGVlbSkge1xuICAgICAgaWYgKGEucmVkZWVtLnJlZGVlbVZlcnNpb24pIHtcbiAgICAgICAgaWYgKGEucmVkZWVtLnJlZGVlbVZlcnNpb24gIT09IG8ucmVkZWVtLnJlZGVlbVZlcnNpb24pXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkZWVtLnJlZGVlbVZlcnNpb24gYW5kIHdpdG5lc3MgbWlzbWF0Y2gnKTtcbiAgICAgIH1cbiAgICAgIGlmIChhLnJlZGVlbS5vdXRwdXQpIHtcbiAgICAgICAgaWYgKGJzY3JpcHQuZGVjb21waWxlKGEucmVkZWVtLm91dHB1dCkubGVuZ3RoID09PSAwKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbS5vdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgICAvLyBvdXRwdXQgcmVkZWVtIGlzIGNvbnN0cnVjdGVkIGZyb20gdGhlIHdpdG5lc3NcbiAgICAgICAgaWYgKG8ucmVkZWVtLm91dHB1dCAmJiAhYS5yZWRlZW0ub3V0cHV0LmVxdWFscyhvLnJlZGVlbS5vdXRwdXQpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbS5vdXRwdXQgYW5kIHdpdG5lc3MgbWlzbWF0Y2gnKTtcbiAgICAgIH1cbiAgICAgIGlmIChhLnJlZGVlbS53aXRuZXNzKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBvLnJlZGVlbS53aXRuZXNzICYmXG4gICAgICAgICAgISgwLCB0eXBlc18xLnN0YWNrc0VxdWFsKShhLnJlZGVlbS53aXRuZXNzLCBvLnJlZGVlbS53aXRuZXNzKVxuICAgICAgICApXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkZWVtLndpdG5lc3MgYW5kIHdpdG5lc3MgbWlzbWF0Y2gnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdpdG5lc3MgJiYgd2l0bmVzcy5sZW5ndGgpIHtcbiAgICAgIGlmICh3aXRuZXNzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyBrZXkgc3BlbmRpbmdcbiAgICAgICAgaWYgKGEuc2lnbmF0dXJlICYmICFhLnNpZ25hdHVyZS5lcXVhbHMod2l0bmVzc1swXSkpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2lnbmF0dXJlIG1pc21hdGNoJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzY3JpcHQgcGF0aCBzcGVuZGluZ1xuICAgICAgICBjb25zdCBjb250cm9sQmxvY2sgPSB3aXRuZXNzW3dpdG5lc3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChjb250cm9sQmxvY2subGVuZ3RoIDwgMzMpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBUaGUgY29udHJvbC1ibG9jayBsZW5ndGggaXMgdG9vIHNtYWxsLiBHb3QgJHtjb250cm9sQmxvY2subGVuZ3RofSwgZXhwZWN0ZWQgbWluIDMzLmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKChjb250cm9sQmxvY2subGVuZ3RoIC0gMzMpICUgMzIgIT09IDApXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBUaGUgY29udHJvbC1ibG9jayBsZW5ndGggb2YgJHtjb250cm9sQmxvY2subGVuZ3RofSBpcyBpbmNvcnJlY3QhYCxcbiAgICAgICAgICApO1xuICAgICAgICBjb25zdCBtID0gKGNvbnRyb2xCbG9jay5sZW5ndGggLSAzMykgLyAzMjtcbiAgICAgICAgaWYgKG0gPiAxMjgpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgIGBUaGUgc2NyaXB0IHBhdGggaXMgdG9vIGxvbmcuIEdvdCAke219LCBleHBlY3RlZCBtYXggMTI4LmAsXG4gICAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxQdWJrZXkgPSBjb250cm9sQmxvY2suc2xpY2UoMSwgMzMpO1xuICAgICAgICBpZiAoYS5pbnRlcm5hbFB1YmtleSAmJiAhYS5pbnRlcm5hbFB1YmtleS5lcXVhbHMoaW50ZXJuYWxQdWJrZXkpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludGVybmFsIHB1YmtleSBtaXNtYXRjaCcpO1xuICAgICAgICBpZiAoISgwLCBlY2NfbGliXzEuZ2V0RWNjTGliKSgpLmlzWE9ubHlQb2ludChpbnRlcm5hbFB1YmtleSkpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBpbnRlcm5hbFB1YmtleSBmb3IgcDJ0ciB3aXRuZXNzJyk7XG4gICAgICAgIGNvbnN0IGxlYWZWZXJzaW9uID0gY29udHJvbEJsb2NrWzBdICYgdHlwZXNfMS5UQVBMRUFGX1ZFUlNJT05fTUFTSztcbiAgICAgICAgY29uc3Qgc2NyaXB0ID0gd2l0bmVzc1t3aXRuZXNzLmxlbmd0aCAtIDJdO1xuICAgICAgICBjb25zdCBsZWFmSGFzaCA9ICgwLCBiaXAzNDFfMS50YXBsZWFmSGFzaCkoe1xuICAgICAgICAgIG91dHB1dDogc2NyaXB0LFxuICAgICAgICAgIHZlcnNpb246IGxlYWZWZXJzaW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFzaCA9ICgwLCBiaXAzNDFfMS5yb290SGFzaEZyb21QYXRoKShjb250cm9sQmxvY2ssIGxlYWZIYXNoKTtcbiAgICAgICAgY29uc3Qgb3V0cHV0S2V5ID0gKDAsIGJpcDM0MV8xLnR3ZWFrS2V5KShpbnRlcm5hbFB1YmtleSwgaGFzaCk7XG4gICAgICAgIGlmICghb3V0cHV0S2V5KVxuICAgICAgICAgIC8vIHRvZG86IG5lZWRzIHRlc3QgZGF0YVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb3V0cHV0S2V5IGZvciBwMnRyIHdpdG5lc3MnKTtcbiAgICAgICAgaWYgKHB1YmtleS5sZW5ndGggJiYgIXB1YmtleS5lcXVhbHMob3V0cHV0S2V5LngpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1B1YmtleSBtaXNtYXRjaCBmb3IgcDJ0ciB3aXRuZXNzJyk7XG4gICAgICAgIGlmIChvdXRwdXRLZXkucGFyaXR5ICE9PSAoY29udHJvbEJsb2NrWzBdICYgMSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgcGFyaXR5Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG8sIGEpO1xufVxuZXhwb3J0cy5wMnRyID0gcDJ0cjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/payments/p2tr.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2wpkh.js":
/*!***********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2wpkh.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2wpkh = void 0;\nconst bcrypto = __webpack_require__(/*! ../crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\");\nconst networks_1 = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst bech32_1 = __webpack_require__(/*! bech32 */ \"./node_modules/bech32/dist/index.js\");\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = Buffer.alloc(0);\n// witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\n/**\n * Creates a pay-to-witness-public-key-hash (p2wpkh) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The p2wpkh payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nfunction p2wpkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32_1.bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32_1.bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2wpkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32_1.bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32_1.bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().data;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (!a.witness) return;\n    return a.witness[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.witness) return;\n    return a.witness[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return [a.signature, a.pubkey];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 20)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 22 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x14\n      )\n        throw new TypeError('Output is invalid');\n      if (hash.length > 0 && !hash.equals(a.output.slice(2)))\n        throw new TypeError('Hash mismatch');\n      else hash = a.output.slice(2);\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n      if (!(0, types_1.isPoint)(a.pubkey) || a.pubkey.length !== 33)\n        throw new TypeError('Invalid pubkey for p2wpkh');\n    }\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');\n      if (!bscript.isCanonicalScriptSignature(a.witness[0]))\n        throw new TypeError('Witness has invalid signature');\n      if (!(0, types_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33)\n        throw new TypeError('Witness has invalid pubkey');\n      if (a.signature && !a.signature.equals(a.witness[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(a.witness[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(a.witness[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wpkh = p2wpkh;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJ3cGtoLmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQVc7QUFDbkMsbUJBQW1CLG1CQUFPLENBQUMsaUVBQWE7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsMkRBQVU7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLGlFQUFRO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLG1EQUFRO0FBQ2pDO0FBQ0EscUJBQXFCLE1BQU07QUFDM0IsYUFBYSxZQUFZO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0IsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wYXltZW50cy9wMndwa2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucDJ3cGtoID0gdm9pZCAwO1xuY29uc3QgYmNyeXB0byA9IHJlcXVpcmUoJy4uL2NyeXB0bycpO1xuY29uc3QgbmV0d29ya3NfMSA9IHJlcXVpcmUoJy4uL25ldHdvcmtzJyk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi4vc2NyaXB0Jyk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbmNvbnN0IGxhenkgPSByZXF1aXJlKCcuL2xhenknKTtcbmNvbnN0IGJlY2gzMl8xID0gcmVxdWlyZSgnYmVjaDMyJyk7XG5jb25zdCBPUFMgPSBic2NyaXB0Lk9QUztcbmNvbnN0IEVNUFRZX0JVRkZFUiA9IEJ1ZmZlci5hbGxvYygwKTtcbi8vIHdpdG5lc3M6IHtzaWduYXR1cmV9IHtwdWJLZXl9XG4vLyBpbnB1dDogPD5cbi8vIG91dHB1dDogT1BfMCB7cHViS2V5SGFzaH1cbi8qKlxuICogQ3JlYXRlcyBhIHBheS10by13aXRuZXNzLXB1YmxpYy1rZXktaGFzaCAocDJ3cGtoKSBwYXltZW50IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gYSAtIFRoZSBwYXltZW50IG9iamVjdCBjb250YWluaW5nIHRoZSBuZWNlc3NhcnkgZGF0YS5cbiAqIEBwYXJhbSBvcHRzIC0gT3B0aW9uYWwgcGF5bWVudCBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIHAyd3BraCBwYXltZW50IG9iamVjdC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIHJlcXVpcmVkIGRhdGEgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiBwMndwa2goYSwgb3B0cykge1xuICBpZiAoIWEuYWRkcmVzcyAmJiAhYS5oYXNoICYmICFhLm91dHB1dCAmJiAhYS5wdWJrZXkgJiYgIWEud2l0bmVzcylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGRhdGEnKTtcbiAgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyB2YWxpZGF0ZTogdHJ1ZSB9LCBvcHRzIHx8IHt9KTtcbiAgKDAsIHR5cGVzXzEudHlwZWZvcmNlKShcbiAgICB7XG4gICAgICBhZGRyZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5TdHJpbmcpLFxuICAgICAgaGFzaDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigyMCkpLFxuICAgICAgaW5wdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlck4oMCkpLFxuICAgICAgbmV0d29yazogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuT2JqZWN0KSxcbiAgICAgIG91dHB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigyMikpLFxuICAgICAgcHVia2V5OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLmlzUG9pbnQpLFxuICAgICAgc2lnbmF0dXJlOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZShic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKSxcbiAgICAgIHdpdG5lc3M6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKFxuICAgICAgICB0eXBlc18xLnR5cGVmb3JjZS5hcnJheU9mKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICApLFxuICAgIH0sXG4gICAgYSxcbiAgKTtcbiAgY29uc3QgX2FkZHJlc3MgPSBsYXp5LnZhbHVlKCgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBiZWNoMzJfMS5iZWNoMzIuZGVjb2RlKGEuYWRkcmVzcyk7XG4gICAgY29uc3QgdmVyc2lvbiA9IHJlc3VsdC53b3Jkcy5zaGlmdCgpO1xuICAgIGNvbnN0IGRhdGEgPSBiZWNoMzJfMS5iZWNoMzIuZnJvbVdvcmRzKHJlc3VsdC53b3Jkcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZlcnNpb24sXG4gICAgICBwcmVmaXg6IHJlc3VsdC5wcmVmaXgsXG4gICAgICBkYXRhOiBCdWZmZXIuZnJvbShkYXRhKSxcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgbmV0d29yayA9IGEubmV0d29yayB8fCBuZXR3b3Jrc18xLmJpdGNvaW47XG4gIGNvbnN0IG8gPSB7IG5hbWU6ICdwMndwa2gnLCBuZXR3b3JrIH07XG4gIGxhenkucHJvcChvLCAnYWRkcmVzcycsICgpID0+IHtcbiAgICBpZiAoIW8uaGFzaCkgcmV0dXJuO1xuICAgIGNvbnN0IHdvcmRzID0gYmVjaDMyXzEuYmVjaDMyLnRvV29yZHMoby5oYXNoKTtcbiAgICB3b3Jkcy51bnNoaWZ0KDB4MDApO1xuICAgIHJldHVybiBiZWNoMzJfMS5iZWNoMzIuZW5jb2RlKG5ldHdvcmsuYmVjaDMyLCB3b3Jkcyk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2hhc2gnLCAoKSA9PiB7XG4gICAgaWYgKGEub3V0cHV0KSByZXR1cm4gYS5vdXRwdXQuc2xpY2UoMiwgMjIpO1xuICAgIGlmIChhLmFkZHJlc3MpIHJldHVybiBfYWRkcmVzcygpLmRhdGE7XG4gICAgaWYgKGEucHVia2V5IHx8IG8ucHVia2V5KSByZXR1cm4gYmNyeXB0by5oYXNoMTYwKGEucHVia2V5IHx8IG8ucHVia2V5KTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnb3V0cHV0JywgKCkgPT4ge1xuICAgIGlmICghby5oYXNoKSByZXR1cm47XG4gICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbT1BTLk9QXzAsIG8uaGFzaF0pO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdwdWJrZXknLCAoKSA9PiB7XG4gICAgaWYgKGEucHVia2V5KSByZXR1cm4gYS5wdWJrZXk7XG4gICAgaWYgKCFhLndpdG5lc3MpIHJldHVybjtcbiAgICByZXR1cm4gYS53aXRuZXNzWzFdO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdzaWduYXR1cmUnLCAoKSA9PiB7XG4gICAgaWYgKCFhLndpdG5lc3MpIHJldHVybjtcbiAgICByZXR1cm4gYS53aXRuZXNzWzBdO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdpbnB1dCcsICgpID0+IHtcbiAgICBpZiAoIW8ud2l0bmVzcykgcmV0dXJuO1xuICAgIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ3dpdG5lc3MnLCAoKSA9PiB7XG4gICAgaWYgKCFhLnB1YmtleSkgcmV0dXJuO1xuICAgIGlmICghYS5zaWduYXR1cmUpIHJldHVybjtcbiAgICByZXR1cm4gW2Euc2lnbmF0dXJlLCBhLnB1YmtleV07XG4gIH0pO1xuICAvLyBleHRlbmRlZCB2YWxpZGF0aW9uXG4gIGlmIChvcHRzLnZhbGlkYXRlKSB7XG4gICAgbGV0IGhhc2ggPSBCdWZmZXIuZnJvbShbXSk7XG4gICAgaWYgKGEuYWRkcmVzcykge1xuICAgICAgaWYgKG5ldHdvcmsgJiYgbmV0d29yay5iZWNoMzIgIT09IF9hZGRyZXNzKCkucHJlZml4KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHByZWZpeCBvciBOZXR3b3JrIG1pc21hdGNoJyk7XG4gICAgICBpZiAoX2FkZHJlc3MoKS52ZXJzaW9uICE9PSAweDAwKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MgdmVyc2lvbicpO1xuICAgICAgaWYgKF9hZGRyZXNzKCkuZGF0YS5sZW5ndGggIT09IDIwKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGFkZHJlc3MgZGF0YScpO1xuICAgICAgaGFzaCA9IF9hZGRyZXNzKCkuZGF0YTtcbiAgICB9XG4gICAgaWYgKGEuaGFzaCkge1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMoYS5oYXNoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgZWxzZSBoYXNoID0gYS5oYXNoO1xuICAgIH1cbiAgICBpZiAoYS5vdXRwdXQpIHtcbiAgICAgIGlmIChcbiAgICAgICAgYS5vdXRwdXQubGVuZ3RoICE9PSAyMiB8fFxuICAgICAgICBhLm91dHB1dFswXSAhPT0gT1BTLk9QXzAgfHxcbiAgICAgICAgYS5vdXRwdXRbMV0gIT09IDB4MTRcbiAgICAgIClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignT3V0cHV0IGlzIGludmFsaWQnKTtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGEub3V0cHV0LnNsaWNlKDIpKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGFzaCBtaXNtYXRjaCcpO1xuICAgICAgZWxzZSBoYXNoID0gYS5vdXRwdXQuc2xpY2UoMik7XG4gICAgfVxuICAgIGlmIChhLnB1YmtleSkge1xuICAgICAgY29uc3QgcGtoID0gYmNyeXB0by5oYXNoMTYwKGEucHVia2V5KTtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKHBraCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IHBraDtcbiAgICAgIGlmICghKDAsIHR5cGVzXzEuaXNQb2ludCkoYS5wdWJrZXkpIHx8IGEucHVia2V5Lmxlbmd0aCAhPT0gMzMpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcHVia2V5IGZvciBwMndwa2gnKTtcbiAgICB9XG4gICAgaWYgKGEud2l0bmVzcykge1xuICAgICAgaWYgKGEud2l0bmVzcy5sZW5ndGggIT09IDIpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgaXMgaW52YWxpZCcpO1xuICAgICAgaWYgKCFic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKGEud2l0bmVzc1swXSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgaGFzIGludmFsaWQgc2lnbmF0dXJlJyk7XG4gICAgICBpZiAoISgwLCB0eXBlc18xLmlzUG9pbnQpKGEud2l0bmVzc1sxXSkgfHwgYS53aXRuZXNzWzFdLmxlbmd0aCAhPT0gMzMpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgaGFzIGludmFsaWQgcHVia2V5Jyk7XG4gICAgICBpZiAoYS5zaWduYXR1cmUgJiYgIWEuc2lnbmF0dXJlLmVxdWFscyhhLndpdG5lc3NbMF0pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTaWduYXR1cmUgbWlzbWF0Y2gnKTtcbiAgICAgIGlmIChhLnB1YmtleSAmJiAhYS5wdWJrZXkuZXF1YWxzKGEud2l0bmVzc1sxXSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1B1YmtleSBtaXNtYXRjaCcpO1xuICAgICAgY29uc3QgcGtoID0gYmNyeXB0by5oYXNoMTYwKGEud2l0bmVzc1sxXSk7XG4gICAgICBpZiAoaGFzaC5sZW5ndGggPiAwICYmICFoYXNoLmVxdWFscyhwa2gpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG8sIGEpO1xufVxuZXhwb3J0cy5wMndwa2ggPSBwMndwa2g7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/payments/p2wpkh.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/payments/p2wsh.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/payments/p2wsh.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.p2wsh = void 0;\nconst bcrypto = __webpack_require__(/*! ../crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\");\nconst networks_1 = __webpack_require__(/*! ../networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst lazy = __webpack_require__(/*! ./lazy */ \"./node_modules/bitcoinjs-lib/src/payments/lazy.js\");\nconst bech32_1 = __webpack_require__(/*! bech32 */ \"./node_modules/bech32/dist/index.js\");\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = Buffer.alloc(0);\nfunction chunkHasUncompressedPubkey(chunk) {\n  if (\n    Buffer.isBuffer(chunk) &&\n    chunk.length === 65 &&\n    chunk[0] === 0x04 &&\n    (0, types_1.isPoint)(chunk)\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n// input: <>\n// witness: [redeemScriptSig ...] {redeemScript}\n// output: OP_0 {sha256(redeemScript)}\n/**\n * Creates a Pay-to-Witness-Script-Hash (P2WSH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2WSH payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nfunction p2wsh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),\n      redeem: types_1.typeforce.maybe({\n        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32_1.bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32_1.bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const _rchunks = lazy.value(() => {\n    return bscript.decompile(a.redeem.input);\n  });\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32_1.bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32_1.bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'redeem', () => {\n    if (!a.witness) return;\n    return {\n      output: a.witness[a.witness.length - 1],\n      input: EMPTY_BUFFER,\n      witness: a.witness.slice(0, -1),\n    };\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    // transform redeem input to witness stack?\n    if (\n      a.redeem &&\n      a.redeem.input &&\n      a.redeem.input.length > 0 &&\n      a.redeem.output &&\n      a.redeem.output.length > 0\n    ) {\n      const stack = bscript.toStack(_rchunks());\n      // assign, and blank the existing input\n      o.redeem = Object.assign({ witness: stack }, a.redeem);\n      o.redeem.input = EMPTY_BUFFER;\n      return [].concat(stack, a.redeem.output);\n    }\n    if (!a.redeem) return;\n    if (!a.redeem.output) return;\n    if (!a.redeem.witness) return;\n    return [].concat(a.redeem.witness, a.redeem.output);\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2wsh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().prefix !== network.bech32)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      // is there two redeem sources?\n      if (\n        a.redeem.input &&\n        a.redeem.input.length > 0 &&\n        a.redeem.witness &&\n        a.redeem.witness.length > 0\n      )\n        throw new TypeError('Ambiguous witness source');\n      // is the redeem output non-empty/valid?\n      if (a.redeem.output) {\n        const decompile = bscript.decompile(a.redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output is invalid');\n        if (a.redeem.output.byteLength > 3600)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 3600 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = bcrypto.sha256(a.redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))\n        throw new TypeError('Non push-only scriptSig');\n      if (\n        a.witness &&\n        a.redeem.witness &&\n        !(0, types_1.stacksEqual)(a.witness, a.redeem.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n      if (\n        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||\n        (a.redeem.output &&\n          (bscript.decompile(a.redeem.output) || []).some(\n            chunkHasUncompressedPubkey,\n          ))\n      ) {\n        throw new TypeError(\n          'redeem.input or redeem.output contains uncompressed pubkey',\n        );\n      }\n    }\n    if (a.witness && a.witness.length > 0) {\n      const wScript = a.witness[a.witness.length - 1];\n      if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))\n        throw new TypeError('Witness and redeem.output mismatch');\n      if (\n        a.witness.some(chunkHasUncompressedPubkey) ||\n        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)\n      )\n        throw new TypeError('Witness contains uncompressed pubkey');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wsh = p2wsh;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJ3c2guanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBVztBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyxpRUFBYTtBQUN4QyxnQkFBZ0IsbUJBQU8sQ0FBQyw2REFBVztBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQywyREFBVTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsaUVBQVE7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsbURBQVE7QUFDakM7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0EsSUFBSSxNQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQixZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdCQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcGF5bWVudHMvcDJ3c2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucDJ3c2ggPSB2b2lkIDA7XG5jb25zdCBiY3J5cHRvID0gcmVxdWlyZSgnLi4vY3J5cHRvJyk7XG5jb25zdCBuZXR3b3Jrc18xID0gcmVxdWlyZSgnLi4vbmV0d29ya3MnKTtcbmNvbnN0IGJzY3JpcHQgPSByZXF1aXJlKCcuLi9zY3JpcHQnKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKCcuLi90eXBlcycpO1xuY29uc3QgbGF6eSA9IHJlcXVpcmUoJy4vbGF6eScpO1xuY29uc3QgYmVjaDMyXzEgPSByZXF1aXJlKCdiZWNoMzInKTtcbmNvbnN0IE9QUyA9IGJzY3JpcHQuT1BTO1xuY29uc3QgRU1QVFlfQlVGRkVSID0gQnVmZmVyLmFsbG9jKDApO1xuZnVuY3Rpb24gY2h1bmtIYXNVbmNvbXByZXNzZWRQdWJrZXkoY2h1bmspIHtcbiAgaWYgKFxuICAgIEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICBjaHVuay5sZW5ndGggPT09IDY1ICYmXG4gICAgY2h1bmtbMF0gPT09IDB4MDQgJiZcbiAgICAoMCwgdHlwZXNfMS5pc1BvaW50KShjaHVuaylcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4vLyBpbnB1dDogPD5cbi8vIHdpdG5lc3M6IFtyZWRlZW1TY3JpcHRTaWcgLi4uXSB7cmVkZWVtU2NyaXB0fVxuLy8gb3V0cHV0OiBPUF8wIHtzaGEyNTYocmVkZWVtU2NyaXB0KX1cbi8qKlxuICogQ3JlYXRlcyBhIFBheS10by1XaXRuZXNzLVNjcmlwdC1IYXNoIChQMldTSCkgcGF5bWVudCBvYmplY3QuXG4gKlxuICogQHBhcmFtIGEgLSBUaGUgcGF5bWVudCBvYmplY3QgY29udGFpbmluZyB0aGUgbmVjZXNzYXJ5IGRhdGEuXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIHBheW1lbnQgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBQMldTSCBwYXltZW50IG9iamVjdC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIHJlcXVpcmVkIGRhdGEgaXMgbWlzc2luZyBvciBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiBwMndzaChhLCBvcHRzKSB7XG4gIGlmICghYS5hZGRyZXNzICYmICFhLmhhc2ggJiYgIWEub3V0cHV0ICYmICFhLnJlZGVlbSAmJiAhYS53aXRuZXNzKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggZGF0YScpO1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbih7IHZhbGlkYXRlOiB0cnVlIH0sIG9wdHMgfHwge30pO1xuICAoMCwgdHlwZXNfMS50eXBlZm9yY2UpKFxuICAgIHtcbiAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICBhZGRyZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5TdHJpbmcpLFxuICAgICAgaGFzaDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigzMikpLFxuICAgICAgb3V0cHV0OiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZSh0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXJOKDM0KSksXG4gICAgICByZWRlZW06IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHtcbiAgICAgICAgaW5wdXQ6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLkJ1ZmZlciksXG4gICAgICAgIG5ldHdvcms6IHR5cGVzXzEudHlwZWZvcmNlLm1heWJlKHR5cGVzXzEudHlwZWZvcmNlLk9iamVjdCksXG4gICAgICAgIG91dHB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyKSxcbiAgICAgICAgd2l0bmVzczogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUoXG4gICAgICAgICAgdHlwZXNfMS50eXBlZm9yY2UuYXJyYXlPZih0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgICApLFxuICAgICAgfSksXG4gICAgICBpbnB1dDogdHlwZXNfMS50eXBlZm9yY2UubWF5YmUodHlwZXNfMS50eXBlZm9yY2UuQnVmZmVyTigwKSksXG4gICAgICB3aXRuZXNzOiB0eXBlc18xLnR5cGVmb3JjZS5tYXliZShcbiAgICAgICAgdHlwZXNfMS50eXBlZm9yY2UuYXJyYXlPZih0eXBlc18xLnR5cGVmb3JjZS5CdWZmZXIpLFxuICAgICAgKSxcbiAgICB9LFxuICAgIGEsXG4gICk7XG4gIGNvbnN0IF9hZGRyZXNzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYmVjaDMyXzEuYmVjaDMyLmRlY29kZShhLmFkZHJlc3MpO1xuICAgIGNvbnN0IHZlcnNpb24gPSByZXN1bHQud29yZHMuc2hpZnQoKTtcbiAgICBjb25zdCBkYXRhID0gYmVjaDMyXzEuYmVjaDMyLmZyb21Xb3JkcyhyZXN1bHQud29yZHMpO1xuICAgIHJldHVybiB7XG4gICAgICB2ZXJzaW9uLFxuICAgICAgcHJlZml4OiByZXN1bHQucHJlZml4LFxuICAgICAgZGF0YTogQnVmZmVyLmZyb20oZGF0YSksXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IF9yY2h1bmtzID0gbGF6eS52YWx1ZSgoKSA9PiB7XG4gICAgcmV0dXJuIGJzY3JpcHQuZGVjb21waWxlKGEucmVkZWVtLmlucHV0KTtcbiAgfSk7XG4gIGxldCBuZXR3b3JrID0gYS5uZXR3b3JrO1xuICBpZiAoIW5ldHdvcmspIHtcbiAgICBuZXR3b3JrID0gKGEucmVkZWVtICYmIGEucmVkZWVtLm5ldHdvcmspIHx8IG5ldHdvcmtzXzEuYml0Y29pbjtcbiAgfVxuICBjb25zdCBvID0geyBuZXR3b3JrIH07XG4gIGxhenkucHJvcChvLCAnYWRkcmVzcycsICgpID0+IHtcbiAgICBpZiAoIW8uaGFzaCkgcmV0dXJuO1xuICAgIGNvbnN0IHdvcmRzID0gYmVjaDMyXzEuYmVjaDMyLnRvV29yZHMoby5oYXNoKTtcbiAgICB3b3Jkcy51bnNoaWZ0KDB4MDApO1xuICAgIHJldHVybiBiZWNoMzJfMS5iZWNoMzIuZW5jb2RlKG5ldHdvcmsuYmVjaDMyLCB3b3Jkcyk7XG4gIH0pO1xuICBsYXp5LnByb3AobywgJ2hhc2gnLCAoKSA9PiB7XG4gICAgaWYgKGEub3V0cHV0KSByZXR1cm4gYS5vdXRwdXQuc2xpY2UoMik7XG4gICAgaWYgKGEuYWRkcmVzcykgcmV0dXJuIF9hZGRyZXNzKCkuZGF0YTtcbiAgICBpZiAoby5yZWRlZW0gJiYgby5yZWRlZW0ub3V0cHV0KSByZXR1cm4gYmNyeXB0by5zaGEyNTYoby5yZWRlZW0ub3V0cHV0KTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnb3V0cHV0JywgKCkgPT4ge1xuICAgIGlmICghby5oYXNoKSByZXR1cm47XG4gICAgcmV0dXJuIGJzY3JpcHQuY29tcGlsZShbT1BTLk9QXzAsIG8uaGFzaF0pO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICdyZWRlZW0nLCAoKSA9PiB7XG4gICAgaWYgKCFhLndpdG5lc3MpIHJldHVybjtcbiAgICByZXR1cm4ge1xuICAgICAgb3V0cHV0OiBhLndpdG5lc3NbYS53aXRuZXNzLmxlbmd0aCAtIDFdLFxuICAgICAgaW5wdXQ6IEVNUFRZX0JVRkZFUixcbiAgICAgIHdpdG5lc3M6IGEud2l0bmVzcy5zbGljZSgwLCAtMSksXG4gICAgfTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnaW5wdXQnLCAoKSA9PiB7XG4gICAgaWYgKCFvLndpdG5lc3MpIHJldHVybjtcbiAgICByZXR1cm4gRU1QVFlfQlVGRkVSO1xuICB9KTtcbiAgbGF6eS5wcm9wKG8sICd3aXRuZXNzJywgKCkgPT4ge1xuICAgIC8vIHRyYW5zZm9ybSByZWRlZW0gaW5wdXQgdG8gd2l0bmVzcyBzdGFjaz9cbiAgICBpZiAoXG4gICAgICBhLnJlZGVlbSAmJlxuICAgICAgYS5yZWRlZW0uaW5wdXQgJiZcbiAgICAgIGEucmVkZWVtLmlucHV0Lmxlbmd0aCA+IDAgJiZcbiAgICAgIGEucmVkZWVtLm91dHB1dCAmJlxuICAgICAgYS5yZWRlZW0ub3V0cHV0Lmxlbmd0aCA+IDBcbiAgICApIHtcbiAgICAgIGNvbnN0IHN0YWNrID0gYnNjcmlwdC50b1N0YWNrKF9yY2h1bmtzKCkpO1xuICAgICAgLy8gYXNzaWduLCBhbmQgYmxhbmsgdGhlIGV4aXN0aW5nIGlucHV0XG4gICAgICBvLnJlZGVlbSA9IE9iamVjdC5hc3NpZ24oeyB3aXRuZXNzOiBzdGFjayB9LCBhLnJlZGVlbSk7XG4gICAgICBvLnJlZGVlbS5pbnB1dCA9IEVNUFRZX0JVRkZFUjtcbiAgICAgIHJldHVybiBbXS5jb25jYXQoc3RhY2ssIGEucmVkZWVtLm91dHB1dCk7XG4gICAgfVxuICAgIGlmICghYS5yZWRlZW0pIHJldHVybjtcbiAgICBpZiAoIWEucmVkZWVtLm91dHB1dCkgcmV0dXJuO1xuICAgIGlmICghYS5yZWRlZW0ud2l0bmVzcykgcmV0dXJuO1xuICAgIHJldHVybiBbXS5jb25jYXQoYS5yZWRlZW0ud2l0bmVzcywgYS5yZWRlZW0ub3V0cHV0KTtcbiAgfSk7XG4gIGxhenkucHJvcChvLCAnbmFtZScsICgpID0+IHtcbiAgICBjb25zdCBuYW1lUGFydHMgPSBbJ3Ayd3NoJ107XG4gICAgaWYgKG8ucmVkZWVtICE9PSB1bmRlZmluZWQgJiYgby5yZWRlZW0ubmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgbmFtZVBhcnRzLnB1c2goby5yZWRlZW0ubmFtZSk7XG4gICAgcmV0dXJuIG5hbWVQYXJ0cy5qb2luKCctJyk7XG4gIH0pO1xuICAvLyBleHRlbmRlZCB2YWxpZGF0aW9uXG4gIGlmIChvcHRzLnZhbGlkYXRlKSB7XG4gICAgbGV0IGhhc2ggPSBCdWZmZXIuZnJvbShbXSk7XG4gICAgaWYgKGEuYWRkcmVzcykge1xuICAgICAgaWYgKF9hZGRyZXNzKCkucHJlZml4ICE9PSBuZXR3b3JrLmJlY2gzMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBwcmVmaXggb3IgTmV0d29yayBtaXNtYXRjaCcpO1xuICAgICAgaWYgKF9hZGRyZXNzKCkudmVyc2lvbiAhPT0gMHgwMClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzIHZlcnNpb24nKTtcbiAgICAgIGlmIChfYWRkcmVzcygpLmRhdGEubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhZGRyZXNzIGRhdGEnKTtcbiAgICAgIGhhc2ggPSBfYWRkcmVzcygpLmRhdGE7XG4gICAgfVxuICAgIGlmIChhLmhhc2gpIHtcbiAgICAgIGlmIChoYXNoLmxlbmd0aCA+IDAgJiYgIWhhc2guZXF1YWxzKGEuaGFzaCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgIGVsc2UgaGFzaCA9IGEuaGFzaDtcbiAgICB9XG4gICAgaWYgKGEub3V0cHV0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIGEub3V0cHV0Lmxlbmd0aCAhPT0gMzQgfHxcbiAgICAgICAgYS5vdXRwdXRbMF0gIT09IE9QUy5PUF8wIHx8XG4gICAgICAgIGEub3V0cHV0WzFdICE9PSAweDIwXG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ091dHB1dCBpcyBpbnZhbGlkJyk7XG4gICAgICBjb25zdCBoYXNoMiA9IGEub3V0cHV0LnNsaWNlKDIpO1xuICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMoaGFzaDIpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdIYXNoIG1pc21hdGNoJyk7XG4gICAgICBlbHNlIGhhc2ggPSBoYXNoMjtcbiAgICB9XG4gICAgaWYgKGEucmVkZWVtKSB7XG4gICAgICBpZiAoYS5yZWRlZW0ubmV0d29yayAmJiBhLnJlZGVlbS5uZXR3b3JrICE9PSBuZXR3b3JrKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdOZXR3b3JrIG1pc21hdGNoJyk7XG4gICAgICAvLyBpcyB0aGVyZSB0d28gcmVkZWVtIHNvdXJjZXM/XG4gICAgICBpZiAoXG4gICAgICAgIGEucmVkZWVtLmlucHV0ICYmXG4gICAgICAgIGEucmVkZWVtLmlucHV0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgYS5yZWRlZW0ud2l0bmVzcyAmJlxuICAgICAgICBhLnJlZGVlbS53aXRuZXNzLmxlbmd0aCA+IDBcbiAgICAgIClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQW1iaWd1b3VzIHdpdG5lc3Mgc291cmNlJyk7XG4gICAgICAvLyBpcyB0aGUgcmVkZWVtIG91dHB1dCBub24tZW1wdHkvdmFsaWQ/XG4gICAgICBpZiAoYS5yZWRlZW0ub3V0cHV0KSB7XG4gICAgICAgIGNvbnN0IGRlY29tcGlsZSA9IGJzY3JpcHQuZGVjb21waWxlKGEucmVkZWVtLm91dHB1dCk7XG4gICAgICAgIGlmICghZGVjb21waWxlIHx8IGRlY29tcGlsZS5sZW5ndGggPCAxKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZGVlbS5vdXRwdXQgaXMgaW52YWxpZCcpO1xuICAgICAgICBpZiAoYS5yZWRlZW0ub3V0cHV0LmJ5dGVMZW5ndGggPiAzNjAwKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAnUmVkZWVtLm91dHB1dCB1bnNwZW5kYWJsZSBpZiBsYXJnZXIgdGhhbiAzNjAwIGJ5dGVzJyxcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoYnNjcmlwdC5jb3VudE5vblB1c2hPbmx5T1BzKGRlY29tcGlsZSkgPiAyMDEpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdSZWRlZW0ub3V0cHV0IHVuc3BlbmRhYmxlIHdpdGggbW9yZSB0aGFuIDIwMSBub24tcHVzaCBvcHMnLFxuICAgICAgICAgICk7XG4gICAgICAgIC8vIG1hdGNoIGhhc2ggYWdhaW5zdCBvdGhlciBzb3VyY2VzXG4gICAgICAgIGNvbnN0IGhhc2gyID0gYmNyeXB0by5zaGEyNTYoYS5yZWRlZW0ub3V0cHV0KTtcbiAgICAgICAgaWYgKGhhc2gubGVuZ3RoID4gMCAmJiAhaGFzaC5lcXVhbHMoaGFzaDIpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0hhc2ggbWlzbWF0Y2gnKTtcbiAgICAgICAgZWxzZSBoYXNoID0gaGFzaDI7XG4gICAgICB9XG4gICAgICBpZiAoYS5yZWRlZW0uaW5wdXQgJiYgIWJzY3JpcHQuaXNQdXNoT25seShfcmNodW5rcygpKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm9uIHB1c2gtb25seSBzY3JpcHRTaWcnKTtcbiAgICAgIGlmIChcbiAgICAgICAgYS53aXRuZXNzICYmXG4gICAgICAgIGEucmVkZWVtLndpdG5lc3MgJiZcbiAgICAgICAgISgwLCB0eXBlc18xLnN0YWNrc0VxdWFsKShhLndpdG5lc3MsIGEucmVkZWVtLndpdG5lc3MpXG4gICAgICApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgYW5kIHJlZGVlbS53aXRuZXNzIG1pc21hdGNoJyk7XG4gICAgICBpZiAoXG4gICAgICAgIChhLnJlZGVlbS5pbnB1dCAmJiBfcmNodW5rcygpLnNvbWUoY2h1bmtIYXNVbmNvbXByZXNzZWRQdWJrZXkpKSB8fFxuICAgICAgICAoYS5yZWRlZW0ub3V0cHV0ICYmXG4gICAgICAgICAgKGJzY3JpcHQuZGVjb21waWxlKGEucmVkZWVtLm91dHB1dCkgfHwgW10pLnNvbWUoXG4gICAgICAgICAgICBjaHVua0hhc1VuY29tcHJlc3NlZFB1YmtleSxcbiAgICAgICAgICApKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ3JlZGVlbS5pbnB1dCBvciByZWRlZW0ub3V0cHV0IGNvbnRhaW5zIHVuY29tcHJlc3NlZCBwdWJrZXknLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYS53aXRuZXNzICYmIGEud2l0bmVzcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB3U2NyaXB0ID0gYS53aXRuZXNzW2Eud2l0bmVzcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChhLnJlZGVlbSAmJiBhLnJlZGVlbS5vdXRwdXQgJiYgIWEucmVkZWVtLm91dHB1dC5lcXVhbHMod1NjcmlwdCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dpdG5lc3MgYW5kIHJlZGVlbS5vdXRwdXQgbWlzbWF0Y2gnKTtcbiAgICAgIGlmIChcbiAgICAgICAgYS53aXRuZXNzLnNvbWUoY2h1bmtIYXNVbmNvbXByZXNzZWRQdWJrZXkpIHx8XG4gICAgICAgIChic2NyaXB0LmRlY29tcGlsZSh3U2NyaXB0KSB8fCBbXSkuc29tZShjaHVua0hhc1VuY29tcHJlc3NlZFB1YmtleSlcbiAgICAgIClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV2l0bmVzcyBjb250YWlucyB1bmNvbXByZXNzZWQgcHVia2V5Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG8sIGEpO1xufVxuZXhwb3J0cy5wMndzaCA9IHAyd3NoO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/payments/p2wsh.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/psbt.js":
/*!************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/psbt.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Psbt = void 0;\nconst bip174_1 = __webpack_require__(/*! bip174 */ \"./node_modules/bip174/src/lib/psbt.js\");\nconst varuint = __webpack_require__(/*! bip174/src/lib/converter/varint */ \"./node_modules/bip174/src/lib/converter/varint.js\");\nconst utils_1 = __webpack_require__(/*! bip174/src/lib/utils */ \"./node_modules/bip174/src/lib/utils.js\");\nconst address_1 = __webpack_require__(/*! ./address */ \"./node_modules/bitcoinjs-lib/src/address.js\");\nconst bufferutils_1 = __webpack_require__(/*! ./bufferutils */ \"./node_modules/bitcoinjs-lib/src/bufferutils.js\");\nconst networks_1 = __webpack_require__(/*! ./networks */ \"./node_modules/bitcoinjs-lib/src/networks.js\");\nconst payments = __webpack_require__(/*! ./payments */ \"./node_modules/bitcoinjs-lib/src/payments/index.js\");\nconst bip341_1 = __webpack_require__(/*! ./payments/bip341 */ \"./node_modules/bitcoinjs-lib/src/payments/bip341.js\");\nconst bscript = __webpack_require__(/*! ./script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"./node_modules/bitcoinjs-lib/src/transaction.js\");\nconst bip371_1 = __webpack_require__(/*! ./psbt/bip371 */ \"./node_modules/bitcoinjs-lib/src/psbt/bip371.js\");\nconst psbtutils_1 = __webpack_require__(/*! ./psbt/psbtutils */ \"./node_modules/bitcoinjs-lib/src/psbt/psbtutils.js\");\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000, // satoshi per byte\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n *\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n *\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n *\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n *\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n *\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nclass Psbt {\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Psbt's predecessor (TransactionBuilder - now removed) behavior\n      // was to not confirm input values  before signing.\n      // Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: (0, bufferutils_1.cloneBuffer)(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = (0, address_1.fromOutputScript)(\n          output.script,\n          this.opts.network,\n        );\n      } catch (_) {}\n      return {\n        script: (0, bufferutils_1.cloneBuffer)(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    (0, bip371_1.checkTaprootInputFields)(inputData, inputData, 'addInput');\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = (0, address_1.toOutputScript)(address, network);\n      outputData = Object.assign({}, outputData, { script });\n    }\n    (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, 'addOutput');\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        undefined,\n        finalScriptsFunc,\n      );\n    return this._finalizeInput(inputIndex, input, finalScriptsFunc);\n  }\n  finalizeTaprootInput(\n    inputIndex,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = bip371_1.tapScriptFinalizer,\n  ) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n        finalScriptsFunc,\n      );\n    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);\n  }\n  _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  _finalizeTaprootInput(\n    inputIndex,\n    input,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = bip371_1.tapScriptFinalizer,\n  ) {\n    if (!input.witnessUtxo)\n      throw new Error(\n        `Cannot finalize input #${inputIndex}. Missing withness utxo.`,\n      );\n    // Check key spend first. Increased privacy and reduced block space.\n    if (input.tapKeySig) {\n      const payment = payments.p2tr({\n        output: input.witnessUtxo.script,\n        signature: input.tapKeySig,\n      });\n      const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        payment.witness,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    } else {\n      const { finalScriptWitness } = finalScriptsFunc(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    }\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(\n      script,\n      inputIndex,\n      'input',\n      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),\n      input.witnessScript ||\n        redeemFromFinalWitnessScript(input.finalScriptWitness),\n    );\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  validateSignaturesOfAllInputs(validator) {\n    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx, validator),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this.validateSignaturesOfTaprootInput(\n        inputIndex,\n        validator,\n        pubkey,\n      );\n    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);\n  }\n  _validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n              true,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      results.push(validator(pSig.pubkey, hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const tapKeySig = (input || {}).tapKeySig;\n    const tapScriptSig = (input || {}).tapScriptSig;\n    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);\n    const allHashses = pubkey\n      ? getTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          pubkey,\n          this.__CACHE,\n        )\n      : getAllTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          this.__CACHE,\n        );\n    if (!allHashses.length) throw new Error('No signatures for this pubkey');\n    const tapKeyHash = allHashses.find(h => !h.leafHash);\n    let validationResultCount = 0;\n    if (tapKeySig && tapKeyHash) {\n      const isValidTapkeySig = validator(\n        tapKeyHash.pubkey,\n        tapKeyHash.hash,\n        trimTaprootSig(tapKeySig),\n      );\n      if (!isValidTapkeySig) return false;\n      validationResultCount++;\n    }\n    if (tapScriptSig) {\n      for (const tapSig of tapScriptSig) {\n        const tapSigHash = allHashses.find(h => tapSig.pubkey.equals(h.pubkey));\n        if (tapSigHash) {\n          const isValidTapScriptSig = validator(\n            tapSig.pubkey,\n            tapSigHash.hash,\n            trimTaprootSig(tapSig.signature),\n          );\n          if (!isValidTapScriptSig) return false;\n          validationResultCount++;\n        }\n      }\n    }\n    return validationResultCount > 0;\n  }\n  signAllInputsHD(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(keyPair, sighashTypes) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(inputIndex, keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input)) {\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        undefined,\n        sighashTypes,\n      );\n    }\n    return this._signInput(inputIndex, keyPair, sighashTypes);\n  }\n  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        tapLeafHashToSign,\n        sighashTypes,\n      );\n    throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n  }\n  _signInput(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  _signTaprootInput(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    const tapKeySig = hashesForSig\n      .filter(h => !h.leafHash)\n      .map(h =>\n        (0, bip371_1.serializeTaprootSignature)(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n      )[0];\n    const tapScriptSig = hashesForSig\n      .filter(h => !!h.leafHash)\n      .map(h => ({\n        pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n        signature: (0, bip371_1.serializeTaprootSignature)(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n        leafHash: h.leafHash,\n      }));\n    if (tapKeySig) {\n      this.data.updateInput(inputIndex, { tapKeySig });\n    }\n    if (tapScriptSig.length) {\n      this.data.updateInput(inputIndex, { tapScriptSig });\n    }\n    return this;\n  }\n  signInputAsync(inputIndex, keyPair, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n      if ((0, bip371_1.isTaprootInput)(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          undefined,\n          sighashTypes,\n        );\n      return this._signInputAsync(inputIndex, keyPair, sighashTypes);\n    });\n  }\n  signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n      if ((0, bip371_1.isTaprootInput)(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          tapLeafHash,\n          sighashTypes,\n        );\n      throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n    });\n  }\n  _signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    return Promise.resolve(keyPair.sign(hash)).then(signature => {\n      const partialSig = [\n        {\n          pubkey: keyPair.publicKey,\n          signature: bscript.signature.encode(signature, sighashType),\n        },\n      ];\n      this.data.updateInput(inputIndex, { partialSig });\n    });\n  }\n  async _signTaprootInputAsync(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHash,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHash,\n      sighashTypes,\n    );\n    const signaturePromises = [];\n    const tapKeyHash = hashesForSig.filter(h => !h.leafHash)[0];\n    if (tapKeyHash) {\n      const tapKeySigPromise = Promise.resolve(\n        keyPair.signSchnorr(tapKeyHash.hash),\n      ).then(sig => {\n        return {\n          tapKeySig: (0, bip371_1.serializeTaprootSignature)(\n            sig,\n            input.sighashType,\n          ),\n        };\n      });\n      signaturePromises.push(tapKeySigPromise);\n    }\n    const tapScriptHashes = hashesForSig.filter(h => !!h.leafHash);\n    if (tapScriptHashes.length) {\n      const tapScriptSigPromises = tapScriptHashes.map(tsh => {\n        return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(\n          signature => {\n            const tapScriptSig = [\n              {\n                pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n                signature: (0, bip371_1.serializeTaprootSignature)(\n                  signature,\n                  input.sighashType,\n                ),\n                leafHash: tsh.leafHash,\n              },\n            ];\n            return { tapScriptSig };\n          },\n        );\n      });\n      signaturePromises.push(...tapScriptSigPromises);\n    }\n    return Promise.all(signaturePromises).then(results => {\n      results.forEach(v => this.data.updateInput(inputIndex, v));\n    });\n  }\n  checkTaprootHashesForSig(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes,\n  ) {\n    if (typeof keyPair.signSchnorr !== 'function')\n      throw new Error(\n        `Need Schnorr Signer to sign taproot input #${inputIndex}.`,\n      );\n    const hashesForSig = getTaprootHashesForSig(\n      inputIndex,\n      input,\n      this.data.inputs,\n      keyPair.publicKey,\n      this.__CACHE,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    if (!hashesForSig || !hashesForSig.length)\n      throw new Error(\n        `Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString(\n          'hex',\n        )}`,\n      );\n    return hashesForSig;\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    (0, bip371_1.checkTaprootInputFields)(\n      this.data.inputs[inputIndex],\n      updateData,\n      'updateInput',\n    );\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const outputData = this.data.outputs[outputIndex];\n    (0, bip371_1.checkTaprootOutputFields)(\n      outputData,\n      updateData,\n      'updateOutput',\n    );\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, 'hex'))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !Buffer.isBuffer(output.script) ||\n      typeof output.value !== 'number'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = compressPubkey(pkey);\n        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (!d.masterFingerprint.equals(root.fingerprint)) return false;\n    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    const throws = (0, bip371_1.isTaprootInput)(input)\n      ? (0, bip371_1.checkTaprootInputForSigs)(input, action)\n      : (0, psbtutils_1.checkInputForSig)(input, action);\n    if (throws)\n      throw new Error('Can not modify transaction, signatures exist.');\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString('hex') +\n    ':' +\n    input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        p2wsh.witness,\n      );\n    } else {\n      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        payment.witness,\n      );\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    false,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n  checkSighashTypeAllowed(sighashType, sighashTypes);\n  let hash;\n  let prevout;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const { meaningfulScript, type } = getMeaningfulScript(\n    prevout.script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      meaningfulScript,\n      prevout.value,\n      sighashType,\n    );\n  } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({\n      hash: meaningfulScript.slice(2),\n    }).output;\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      signingScript,\n      prevout.value,\n      sighashType,\n    );\n  } else {\n    // non-segwit\n    if (\n      input.nonWitnessUtxo === undefined &&\n      cache.__UNSAFE_SIGN_NONSEGWIT === false\n    )\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${meaningfulScript.toString('hex')}`,\n      );\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n      console.warn(\n        'Warning: Signing non-segwit inputs without the full parent transaction ' +\n          'means there is a chance that a miner could feed you incorrect information ' +\n          \"to trick you into paying large fees. This behavior is the same as Psbt's predecessor \" +\n          '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +\n          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n          'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n          '*********************',\n      );\n    hash = unsignedTx.hashForSignature(\n      inputIndex,\n      meaningfulScript,\n      sighashType,\n    );\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash,\n  };\n}\nfunction getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {\n  const allPublicKeys = [];\n  if (input.tapInternalKey) {\n    const key = getPrevoutTaprootKey(inputIndex, input, cache);\n    if (key) {\n      allPublicKeys.push(key);\n    }\n  }\n  if (input.tapScriptSig) {\n    const tapScriptPubkeys = input.tapScriptSig.map(tss => tss.pubkey);\n    allPublicKeys.push(...tapScriptPubkeys);\n  }\n  const allHashes = allPublicKeys.map(pubicKey =>\n    getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache),\n  );\n  return allHashes.flat();\n}\nfunction getPrevoutTaprootKey(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;\n}\nfunction trimTaprootSig(signature) {\n  return signature.length === 64 ? signature : signature.subarray(0, 64);\n}\nfunction getTaprootHashesForSig(\n  inputIndex,\n  input,\n  inputs,\n  pubkey,\n  cache,\n  tapLeafHashToSign,\n  allowedSighashTypes,\n) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;\n  checkSighashTypeAllowed(sighashType, allowedSighashTypes);\n  const prevOuts = inputs.map((i, index) =>\n    getScriptAndAmountFromUtxo(index, i, cache),\n  );\n  const signingScripts = prevOuts.map(o => o.script);\n  const values = prevOuts.map(o => o.value);\n  const hashes = [];\n  if (input.tapInternalKey && !tapLeafHashToSign) {\n    const outputKey =\n      getPrevoutTaprootKey(inputIndex, input, cache) || Buffer.from([]);\n    if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {\n      const tapKeyHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n      );\n      hashes.push({ pubkey, hash: tapKeyHash });\n    }\n  }\n  const tapLeafHashes = (input.tapLeafScript || [])\n    .filter(tapLeaf => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script))\n    .map(tapLeaf => {\n      const hash = (0, bip341_1.tapleafHash)({\n        output: tapLeaf.script,\n        version: tapLeaf.leafVersion,\n      });\n      return Object.assign({ hash }, tapLeaf);\n    })\n    .filter(\n      tapLeaf => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash),\n    )\n    .map(tapLeaf => {\n      const tapScriptHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n        tapLeaf.hash,\n      );\n      return {\n        pubkey,\n        hash: tapScriptHash,\n        leafHash: tapLeaf.hash,\n      };\n    });\n  return hashes.concat(tapLeafHashes);\n}\nfunction checkSighashTypeAllowed(sighashType, sighashTypes) {\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return ps.pubkey.equals(pk);\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return script;\n}\nfunction getScriptAndAmountFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return {\n      script: input.witnessUtxo.script,\n      value: input.witnessUtxo.value,\n    };\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];\n    return { script: o.script, value: o.value };\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    outputIndex,\n    'output',\n    output.redeemScript,\n    output.witnessScript,\n  );\n  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (\n    !Buffer.isBuffer(lastItem) ||\n    isPubkeyLike(lastItem) ||\n    isSigLike(lastItem)\n  )\n    return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction compressPubkey(pubkey) {\n  if (pubkey.length === 65) {\n    const parity = pubkey[64] & 1;\n    const newKey = pubkey.slice(0, 33);\n    newKey[0] = 2 | parity;\n    return newKey;\n  }\n  return pubkey.slice();\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(\n  script,\n  index,\n  ioType,\n  redeemScript,\n  witnessScript,\n) {\n  const isP2SH = (0, psbtutils_1.isP2SHScript)(script);\n  const isP2SHP2WSH =\n    isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);\n  const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);\n  if (isP2SH && redeemScript === undefined)\n    throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n    throw new Error(\n      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',\n    );\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH\n      ? 'p2sh-p2wsh'\n      : isP2SH\n      ? 'p2sh'\n      : isP2WSH\n      ? 'p2wsh'\n      : 'raw',\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if (\n    (0, psbtutils_1.isP2WPKH)(script) ||\n    (0, psbtutils_1.isP2SHScript)(script)\n  ) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction classifyScript(script) {\n  if ((0, psbtutils_1.isP2WPKH)(script)) return 'witnesspubkeyhash';\n  if ((0, psbtutils_1.isP2PKH)(script)) return 'pubkeyhash';\n  if ((0, psbtutils_1.isP2MS)(script)) return 'multisig';\n  if ((0, psbtutils_1.isP2PK)(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcHNidC5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWTtBQUNaLGlCQUFpQixtQkFBTyxDQUFDLHFEQUFRO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLDBGQUFpQztBQUN6RCxnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBc0I7QUFDOUMsa0JBQWtCLG1CQUFPLENBQUMsOERBQVc7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsc0VBQWU7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsZ0VBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsc0VBQVk7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsOEVBQW1CO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLDREQUFVO0FBQ2xDLHNCQUFzQixtQkFBTyxDQUFDLHNFQUFlO0FBQzdDLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFlO0FBQ3hDLG9CQUFvQixtQkFBTyxDQUFDLDRFQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1CQUFtQjtBQUNqRTtBQUNBLHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBLG1DQUFtQyxn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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixNQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsTUFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxNQUFNO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLE1BQU07QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wc2J0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBzYnQgPSB2b2lkIDA7XG5jb25zdCBiaXAxNzRfMSA9IHJlcXVpcmUoJ2JpcDE3NCcpO1xuY29uc3QgdmFydWludCA9IHJlcXVpcmUoJ2JpcDE3NC9zcmMvbGliL2NvbnZlcnRlci92YXJpbnQnKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKCdiaXAxNzQvc3JjL2xpYi91dGlscycpO1xuY29uc3QgYWRkcmVzc18xID0gcmVxdWlyZSgnLi9hZGRyZXNzJyk7XG5jb25zdCBidWZmZXJ1dGlsc18xID0gcmVxdWlyZSgnLi9idWZmZXJ1dGlscycpO1xuY29uc3QgbmV0d29ya3NfMSA9IHJlcXVpcmUoJy4vbmV0d29ya3MnKTtcbmNvbnN0IHBheW1lbnRzID0gcmVxdWlyZSgnLi9wYXltZW50cycpO1xuY29uc3QgYmlwMzQxXzEgPSByZXF1aXJlKCcuL3BheW1lbnRzL2JpcDM0MScpO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZSgnLi90cmFuc2FjdGlvbicpO1xuY29uc3QgYmlwMzcxXzEgPSByZXF1aXJlKCcuL3BzYnQvYmlwMzcxJyk7XG5jb25zdCBwc2J0dXRpbHNfMSA9IHJlcXVpcmUoJy4vcHNidC9wc2J0dXRpbHMnKTtcbi8qKlxuICogVGhlc2UgYXJlIHRoZSBkZWZhdWx0IGFyZ3VtZW50cyBmb3IgYSBQc2J0IGluc3RhbmNlLlxuICovXG5jb25zdCBERUZBVUxUX09QVFMgPSB7XG4gIC8qKlxuICAgKiBBIGJpdGNvaW5qcyBOZXR3b3JrIG9iamVjdC4gVGhpcyBpcyBvbmx5IHVzZWQgaWYgeW91IHBhc3MgYW4gYGFkZHJlc3NgXG4gICAqIHBhcmFtZXRlciB0byBhZGRPdXRwdXQuIE90aGVyd2lzZSBpdCBpcyBub3QgbmVlZGVkIGFuZCBjYW4gYmUgbGVmdCBkZWZhdWx0LlxuICAgKi9cbiAgbmV0d29yazogbmV0d29ya3NfMS5iaXRjb2luLFxuICAvKipcbiAgICogV2hlbiBleHRyYWN0VHJhbnNhY3Rpb24gaXMgY2FsbGVkLCB0aGUgZmVlIHJhdGUgaXMgY2hlY2tlZC5cbiAgICogVEhJUyBJUyBOT1QgVE8gQkUgUkVMSUVEIE9OLlxuICAgKiBJdCBpcyBvbmx5IGhlcmUgYXMgYSBsYXN0IGRpdGNoIGVmZm9ydCB0byBwcmV2ZW50IHNlbmRpbmcgYSA1MDAgQlRDIGZlZSBldGMuXG4gICAqL1xuICBtYXhpbXVtRmVlUmF0ZTogNTAwMCwgLy8gc2F0b3NoaSBwZXIgYnl0ZVxufTtcbi8qKlxuICogUHNidCBjbGFzcyBjYW4gcGFyc2UgYW5kIGdlbmVyYXRlIGEgUFNCVCBiaW5hcnkgYmFzZWQgb2ZmIG9mIHRoZSBCSVAxNzQuXG4gKiBUaGVyZSBhcmUgNiByb2xlcyB0aGF0IHRoaXMgY2xhc3MgZnVsZmlsbHMuIChFeHBsYWluZWQgaW4gQklQMTc0KVxuICpcbiAqIENyZWF0b3I6IFRoaXMgY2FuIGJlIGRvbmUgd2l0aCBgbmV3IFBzYnQoKWBcbiAqXG4gKiBVcGRhdGVyOiBUaGlzIGNhbiBiZSBkb25lIHdpdGggYHBzYnQuYWRkSW5wdXQoaW5wdXQpYCwgYHBzYnQuYWRkSW5wdXRzKGlucHV0cylgLFxuICogICBgcHNidC5hZGRPdXRwdXQob3V0cHV0KWAsIGBwc2J0LmFkZE91dHB1dHMob3V0cHV0cylgIHdoZW4geW91IGFyZSBsb29raW5nIHRvXG4gKiAgIGFkZCBuZXcgaW5wdXRzIGFuZCBvdXRwdXRzIHRvIHRoZSBQU0JULCBhbmQgYHBzYnQudXBkYXRlR2xvYmFsKGl0ZW1PYmplY3QpYCxcbiAqICAgYHBzYnQudXBkYXRlSW5wdXQoaXRlbU9iamVjdClgLCBgcHNidC51cGRhdGVPdXRwdXQoaXRlbU9iamVjdClgXG4gKiAgIGFkZElucHV0IHJlcXVpcmVzIGhhc2g6IEJ1ZmZlciB8IHN0cmluZzsgYW5kIGluZGV4OiBudW1iZXI7IGFzIGF0dHJpYnV0ZXNcbiAqICAgYW5kIGNhbiBhbHNvIGluY2x1ZGUgYW55IGF0dHJpYnV0ZXMgdGhhdCBhcmUgdXNlZCBpbiB1cGRhdGVJbnB1dCBtZXRob2QuXG4gKiAgIGFkZE91dHB1dCByZXF1aXJlcyBzY3JpcHQ6IEJ1ZmZlcjsgYW5kIHZhbHVlOiBudW1iZXI7IGFuZCBsaWtld2lzZSBjYW4gaW5jbHVkZVxuICogICBkYXRhIGZvciB1cGRhdGVPdXRwdXQuXG4gKiAgIEZvciBhIGxpc3Qgb2Ygd2hhdCBhdHRyaWJ1dGVzIHNob3VsZCBiZSB3aGF0IHR5cGVzLiBDaGVjayB0aGUgYmlwMTc0IGxpYnJhcnkuXG4gKiAgIEFsc28sIGNoZWNrIHRoZSBpbnRlZ3JhdGlvbiB0ZXN0cyBmb3Igc29tZSBleGFtcGxlcyBvZiB1c2FnZS5cbiAqXG4gKiBTaWduZXI6IFRoZXJlIGFyZSBhIGZldyBtZXRob2RzLiBzaWduQWxsSW5wdXRzIGFuZCBzaWduQWxsSW5wdXRzQXN5bmMsIHdoaWNoIHdpbGwgc2VhcmNoIGFsbCBpbnB1dFxuICogICBpbmZvcm1hdGlvbiBmb3IgeW91ciBwdWJrZXkgb3IgcHVia2V5aGFzaCwgYW5kIG9ubHkgc2lnbiBpbnB1dHMgd2hlcmUgaXQgZmluZHNcbiAqICAgeW91ciBpbmZvLiBPciB5b3UgY2FuIGV4cGxpY2l0bHkgc2lnbiBhIHNwZWNpZmljIGlucHV0IHdpdGggc2lnbklucHV0IGFuZFxuICogICBzaWduSW5wdXRBc3luYy4gRm9yIHRoZSBhc3luYyBtZXRob2RzIHlvdSBjYW4gY3JlYXRlIGEgU2lnbmVyQXN5bmMgb2JqZWN0XG4gKiAgIGFuZCB1c2Ugc29tZXRoaW5nIGxpa2UgYSBoYXJkd2FyZSB3YWxsZXQgdG8gc2lnbiB3aXRoLiAoWW91IG11c3QgaW1wbGVtZW50IHRoaXMpXG4gKlxuICogQ29tYmluZXI6IHBzYnRzIGNhbiBiZSBjb21iaW5lZCBlYXNpbHkgd2l0aCBgcHNidC5jb21iaW5lKHBzYnQyLCBwc2J0MywgcHNidDQgLi4uKWBcbiAqICAgdGhlIHBzYnQgY2FsbGluZyBjb21iaW5lIHdpbGwgYWx3YXlzIGhhdmUgcHJlY2VkZW5jZSB3aGVuIGEgY29uZmxpY3Qgb2NjdXJzLlxuICogICBDb21iaW5lIGNoZWNrcyBpZiB0aGUgaW50ZXJuYWwgYml0Y29pbiB0cmFuc2FjdGlvbiBpcyB0aGUgc2FtZSwgc28gYmUgc3VyZSB0aGF0XG4gKiAgIGFsbCBzZXF1ZW5jZXMsIHZlcnNpb24sIGxvY2t0aW1lLCBldGMuIGFyZSB0aGUgc2FtZSBiZWZvcmUgY29tYmluaW5nLlxuICpcbiAqIElucHV0IEZpbmFsaXplcjogVGhpcyByb2xlIGlzIGZhaXJseSBpbXBvcnRhbnQuIE5vdCBvbmx5IGRvZXMgaXQgbmVlZCB0byBjb25zdHJ1Y3RcbiAqICAgdGhlIGlucHV0IHNjcmlwdFNpZ3MgYW5kIHdpdG5lc3NlcywgYnV0IGl0IFNIT1VMRCB2ZXJpZnkgdGhlIHNpZ25hdHVyZXMgZXRjLlxuICogICBCZWZvcmUgcnVubmluZyBgcHNidC5maW5hbGl6ZUFsbElucHV0cygpYCBwbGVhc2UgcnVuIGBwc2J0LnZhbGlkYXRlU2lnbmF0dXJlc09mQWxsSW5wdXRzKClgXG4gKiAgIFJ1bm5pbmcgYW55IGZpbmFsaXplIG1ldGhvZCB3aWxsIGRlbGV0ZSBhbnkgZGF0YSBpbiB0aGUgaW5wdXQocykgdGhhdCBhcmUgbm8gbG9uZ2VyXG4gKiAgIG5lZWRlZCBkdWUgdG8gdGhlIGZpbmFsaXplZCBzY3JpcHRzIGNvbnRhaW5pbmcgdGhlIGluZm9ybWF0aW9uLlxuICpcbiAqIFRyYW5zYWN0aW9uIEV4dHJhY3RvcjogVGhpcyByb2xlIHdpbGwgcGVyZm9ybSBzb21lIGNoZWNrcyBiZWZvcmUgcmV0dXJuaW5nIGFcbiAqICAgVHJhbnNhY3Rpb24gb2JqZWN0LiBTdWNoIGFzIGZlZSByYXRlIG5vdCBiZWluZyBsYXJnZXIgdGhhbiBtYXhpbXVtRmVlUmF0ZSBldGMuXG4gKi9cbmNsYXNzIFBzYnQge1xuICBzdGF0aWMgZnJvbUJhc2U2NChkYXRhLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShkYXRhLCAnYmFzZTY0Jyk7XG4gICAgcmV0dXJuIHRoaXMuZnJvbUJ1ZmZlcihidWZmZXIsIG9wdHMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSGV4KGRhdGEsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGRhdGEsICdoZXgnKTtcbiAgICByZXR1cm4gdGhpcy5mcm9tQnVmZmVyKGJ1ZmZlciwgb3B0cyk7XG4gIH1cbiAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBwc2J0QmFzZSA9IGJpcDE3NF8xLlBzYnQuZnJvbUJ1ZmZlcihidWZmZXIsIHRyYW5zYWN0aW9uRnJvbUJ1ZmZlcik7XG4gICAgY29uc3QgcHNidCA9IG5ldyBQc2J0KG9wdHMsIHBzYnRCYXNlKTtcbiAgICBjaGVja1R4Rm9yRHVwZUlucyhwc2J0Ll9fQ0FDSEUuX19UWCwgcHNidC5fX0NBQ0hFKTtcbiAgICByZXR1cm4gcHNidDtcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRzID0ge30sIGRhdGEgPSBuZXcgYmlwMTc0XzEuUHNidChuZXcgUHNidFRyYW5zYWN0aW9uKCkpKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAvLyBzZXQgZGVmYXVsdHNcbiAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVFMsIG9wdHMpO1xuICAgIHRoaXMuX19DQUNIRSA9IHtcbiAgICAgIF9fTk9OX1dJVE5FU1NfVVRYT19UWF9DQUNIRTogW10sXG4gICAgICBfX05PTl9XSVRORVNTX1VUWE9fQlVGX0NBQ0hFOiBbXSxcbiAgICAgIF9fVFhfSU5fQ0FDSEU6IHt9LFxuICAgICAgX19UWDogdGhpcy5kYXRhLmdsb2JhbE1hcC51bnNpZ25lZFR4LnR4LFxuICAgICAgLy8gUHNidCdzIHByZWRlY2Vzc29yIChUcmFuc2FjdGlvbkJ1aWxkZXIgLSBub3cgcmVtb3ZlZCkgYmVoYXZpb3JcbiAgICAgIC8vIHdhcyB0byBub3QgY29uZmlybSBpbnB1dCB2YWx1ZXMgIGJlZm9yZSBzaWduaW5nLlxuICAgICAgLy8gRXZlbiB0aG91Z2ggd2UgaGlnaGx5IGVuY291cmFnZSBwZW9wbGUgdG8gZ2V0XG4gICAgICAvLyB0aGUgZnVsbCBwYXJlbnQgdHJhbnNhY3Rpb24gdG8gdmVyaWZ5IHZhbHVlcywgdGhlIGFiaWxpdHkgdG9cbiAgICAgIC8vIHNpZ24gbm9uLXNlZ3dpdCBpbnB1dHMgd2l0aG91dCB0aGUgZnVsbCB0cmFuc2FjdGlvbiB3YXMgb2Z0ZW5cbiAgICAgIC8vIHJlcXVlc3RlZC4gU28gdGhlIG9ubHkgd2F5IHRvIGFjdGl2YXRlIGlzIHRvIHVzZSBAdHMtaWdub3JlLlxuICAgICAgLy8gV2Ugd2lsbCBkaXNhYmxlIGV4cG9ydGluZyB0aGUgUHNidCB3aGVuIHVuc2FmZSBzaWduIGlzIGFjdGl2ZS5cbiAgICAgIC8vIGJlY2F1c2UgaXQgaXMgbm90IEJJUDE3NCBjb21wbGlhbnQuXG4gICAgICBfX1VOU0FGRV9TSUdOX05PTlNFR1dJVDogZmFsc2UsXG4gICAgfTtcbiAgICBpZiAodGhpcy5kYXRhLmlucHV0cy5sZW5ndGggPT09IDApIHRoaXMuc2V0VmVyc2lvbigyKTtcbiAgICAvLyBNYWtlIGRhdGEgaGlkZGVuIHdoZW4gZW51bWVyYXRpbmdcbiAgICBjb25zdCBkcGV3ID0gKG9iaiwgYXR0ciwgZW51bWVyYWJsZSwgd3JpdGFibGUpID0+XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBhdHRyLCB7XG4gICAgICAgIGVudW1lcmFibGUsXG4gICAgICAgIHdyaXRhYmxlLFxuICAgICAgfSk7XG4gICAgZHBldyh0aGlzLCAnX19DQUNIRScsIGZhbHNlLCB0cnVlKTtcbiAgICBkcGV3KHRoaXMsICdvcHRzJywgZmFsc2UsIHRydWUpO1xuICB9XG4gIGdldCBpbnB1dENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuaW5wdXRzLmxlbmd0aDtcbiAgfVxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fX0NBQ0hFLl9fVFgudmVyc2lvbjtcbiAgfVxuICBzZXQgdmVyc2lvbih2ZXJzaW9uKSB7XG4gICAgdGhpcy5zZXRWZXJzaW9uKHZlcnNpb24pO1xuICB9XG4gIGdldCBsb2NrdGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX0NBQ0hFLl9fVFgubG9ja3RpbWU7XG4gIH1cbiAgc2V0IGxvY2t0aW1lKGxvY2t0aW1lKSB7XG4gICAgdGhpcy5zZXRMb2NrdGltZShsb2NrdGltZSk7XG4gIH1cbiAgZ2V0IHR4SW5wdXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9fQ0FDSEUuX19UWC5pbnMubWFwKGlucHV0ID0+ICh7XG4gICAgICBoYXNoOiAoMCwgYnVmZmVydXRpbHNfMS5jbG9uZUJ1ZmZlcikoaW5wdXQuaGFzaCksXG4gICAgICBpbmRleDogaW5wdXQuaW5kZXgsXG4gICAgICBzZXF1ZW5jZTogaW5wdXQuc2VxdWVuY2UsXG4gICAgfSkpO1xuICB9XG4gIGdldCB0eE91dHB1dHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19DQUNIRS5fX1RYLm91dHMubWFwKG91dHB1dCA9PiB7XG4gICAgICBsZXQgYWRkcmVzcztcbiAgICAgIHRyeSB7XG4gICAgICAgIGFkZHJlc3MgPSAoMCwgYWRkcmVzc18xLmZyb21PdXRwdXRTY3JpcHQpKFxuICAgICAgICAgIG91dHB1dC5zY3JpcHQsXG4gICAgICAgICAgdGhpcy5vcHRzLm5ldHdvcmssXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NyaXB0OiAoMCwgYnVmZmVydXRpbHNfMS5jbG9uZUJ1ZmZlcikob3V0cHV0LnNjcmlwdCksXG4gICAgICAgIHZhbHVlOiBvdXRwdXQudmFsdWUsXG4gICAgICAgIGFkZHJlc3MsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGNvbWJpbmUoLi4udGhvc2UpIHtcbiAgICB0aGlzLmRhdGEuY29tYmluZSguLi50aG9zZS5tYXAobyA9PiBvLmRhdGEpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICAvLyBUT0RPOiBtb3JlIGVmZmljaWVudCBjbG9uaW5nXG4gICAgY29uc3QgcmVzID0gUHNidC5mcm9tQnVmZmVyKHRoaXMuZGF0YS50b0J1ZmZlcigpKTtcbiAgICByZXMub3B0cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vcHRzKSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBzZXRNYXhpbXVtRmVlUmF0ZShzYXRvc2hpUGVyQnl0ZSkge1xuICAgIGNoZWNrMzJCaXQoc2F0b3NoaVBlckJ5dGUpOyAvLyA0Mi45IEJUQyBwZXIgYnl0ZSBJUyBleGNlc3NpdmUuLi4gc28gdGhyb3dcbiAgICB0aGlzLm9wdHMubWF4aW11bUZlZVJhdGUgPSBzYXRvc2hpUGVyQnl0ZTtcbiAgfVxuICBzZXRWZXJzaW9uKHZlcnNpb24pIHtcbiAgICBjaGVjazMyQml0KHZlcnNpb24pO1xuICAgIGNoZWNrSW5wdXRzRm9yUGFydGlhbFNpZyh0aGlzLmRhdGEuaW5wdXRzLCAnc2V0VmVyc2lvbicpO1xuICAgIGNvbnN0IGMgPSB0aGlzLl9fQ0FDSEU7XG4gICAgYy5fX1RYLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGMuX19FWFRSQUNURURfVFggPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0TG9ja3RpbWUobG9ja3RpbWUpIHtcbiAgICBjaGVjazMyQml0KGxvY2t0aW1lKTtcbiAgICBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcodGhpcy5kYXRhLmlucHV0cywgJ3NldExvY2t0aW1lJyk7XG4gICAgY29uc3QgYyA9IHRoaXMuX19DQUNIRTtcbiAgICBjLl9fVFgubG9ja3RpbWUgPSBsb2NrdGltZTtcbiAgICBjLl9fRVhUUkFDVEVEX1RYID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldElucHV0U2VxdWVuY2UoaW5wdXRJbmRleCwgc2VxdWVuY2UpIHtcbiAgICBjaGVjazMyQml0KHNlcXVlbmNlKTtcbiAgICBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcodGhpcy5kYXRhLmlucHV0cywgJ3NldElucHV0U2VxdWVuY2UnKTtcbiAgICBjb25zdCBjID0gdGhpcy5fX0NBQ0hFO1xuICAgIGlmIChjLl9fVFguaW5zLmxlbmd0aCA8PSBpbnB1dEluZGV4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGluZGV4IHRvbyBoaWdoJyk7XG4gICAgfVxuICAgIGMuX19UWC5pbnNbaW5wdXRJbmRleF0uc2VxdWVuY2UgPSBzZXF1ZW5jZTtcbiAgICBjLl9fRVhUUkFDVEVEX1RYID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZElucHV0cyhpbnB1dERhdGFzKSB7XG4gICAgaW5wdXREYXRhcy5mb3JFYWNoKGlucHV0RGF0YSA9PiB0aGlzLmFkZElucHV0KGlucHV0RGF0YSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZElucHV0KGlucHV0RGF0YSkge1xuICAgIGlmIChcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxIHx8XG4gICAgICAhaW5wdXREYXRhIHx8XG4gICAgICBpbnB1dERhdGEuaGFzaCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBpbnB1dERhdGEuaW5kZXggPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBhcmd1bWVudHMgZm9yIFBzYnQuYWRkSW5wdXQuIGAgK1xuICAgICAgICAgIGBSZXF1aXJlcyBzaW5nbGUgb2JqZWN0IHdpdGggYXQgbGVhc3QgW2hhc2hdIGFuZCBbaW5kZXhdYCxcbiAgICAgICk7XG4gICAgfVxuICAgICgwLCBiaXAzNzFfMS5jaGVja1RhcHJvb3RJbnB1dEZpZWxkcykoaW5wdXREYXRhLCBpbnB1dERhdGEsICdhZGRJbnB1dCcpO1xuICAgIGNoZWNrSW5wdXRzRm9yUGFydGlhbFNpZyh0aGlzLmRhdGEuaW5wdXRzLCAnYWRkSW5wdXQnKTtcbiAgICBpZiAoaW5wdXREYXRhLndpdG5lc3NTY3JpcHQpIGNoZWNrSW52YWxpZFAyV1NIKGlucHV0RGF0YS53aXRuZXNzU2NyaXB0KTtcbiAgICBjb25zdCBjID0gdGhpcy5fX0NBQ0hFO1xuICAgIHRoaXMuZGF0YS5hZGRJbnB1dChpbnB1dERhdGEpO1xuICAgIGNvbnN0IHR4SW4gPSBjLl9fVFguaW5zW2MuX19UWC5pbnMubGVuZ3RoIC0gMV07XG4gICAgY2hlY2tUeElucHV0Q2FjaGUoYywgdHhJbik7XG4gICAgY29uc3QgaW5wdXRJbmRleCA9IHRoaXMuZGF0YS5pbnB1dHMubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF07XG4gICAgaWYgKGlucHV0Lm5vbldpdG5lc3NVdHhvKSB7XG4gICAgICBhZGROb25XaXRuZXNzVHhDYWNoZSh0aGlzLl9fQ0FDSEUsIGlucHV0LCBpbnB1dEluZGV4KTtcbiAgICB9XG4gICAgYy5fX0ZFRSA9IHVuZGVmaW5lZDtcbiAgICBjLl9fRkVFX1JBVEUgPSB1bmRlZmluZWQ7XG4gICAgYy5fX0VYVFJBQ1RFRF9UWCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRPdXRwdXRzKG91dHB1dERhdGFzKSB7XG4gICAgb3V0cHV0RGF0YXMuZm9yRWFjaChvdXRwdXREYXRhID0+IHRoaXMuYWRkT3V0cHV0KG91dHB1dERhdGEpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRPdXRwdXQob3V0cHV0RGF0YSkge1xuICAgIGlmIChcbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxIHx8XG4gICAgICAhb3V0cHV0RGF0YSB8fFxuICAgICAgb3V0cHV0RGF0YS52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAob3V0cHV0RGF0YS5hZGRyZXNzID09PSB1bmRlZmluZWQgJiYgb3V0cHV0RGF0YS5zY3JpcHQgPT09IHVuZGVmaW5lZClcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgYXJndW1lbnRzIGZvciBQc2J0LmFkZE91dHB1dC4gYCArXG4gICAgICAgICAgYFJlcXVpcmVzIHNpbmdsZSBvYmplY3Qgd2l0aCBhdCBsZWFzdCBbc2NyaXB0IG9yIGFkZHJlc3NdIGFuZCBbdmFsdWVdYCxcbiAgICAgICk7XG4gICAgfVxuICAgIGNoZWNrSW5wdXRzRm9yUGFydGlhbFNpZyh0aGlzLmRhdGEuaW5wdXRzLCAnYWRkT3V0cHV0Jyk7XG4gICAgY29uc3QgeyBhZGRyZXNzIH0gPSBvdXRwdXREYXRhO1xuICAgIGlmICh0eXBlb2YgYWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IHsgbmV0d29yayB9ID0gdGhpcy5vcHRzO1xuICAgICAgY29uc3Qgc2NyaXB0ID0gKDAsIGFkZHJlc3NfMS50b091dHB1dFNjcmlwdCkoYWRkcmVzcywgbmV0d29yayk7XG4gICAgICBvdXRwdXREYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgb3V0cHV0RGF0YSwgeyBzY3JpcHQgfSk7XG4gICAgfVxuICAgICgwLCBiaXAzNzFfMS5jaGVja1RhcHJvb3RPdXRwdXRGaWVsZHMpKG91dHB1dERhdGEsIG91dHB1dERhdGEsICdhZGRPdXRwdXQnKTtcbiAgICBjb25zdCBjID0gdGhpcy5fX0NBQ0hFO1xuICAgIHRoaXMuZGF0YS5hZGRPdXRwdXQob3V0cHV0RGF0YSk7XG4gICAgYy5fX0ZFRSA9IHVuZGVmaW5lZDtcbiAgICBjLl9fRkVFX1JBVEUgPSB1bmRlZmluZWQ7XG4gICAgYy5fX0VYVFJBQ1RFRF9UWCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBleHRyYWN0VHJhbnNhY3Rpb24oZGlzYWJsZUZlZUNoZWNrKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEuaW5wdXRzLmV2ZXJ5KGlzRmluYWxpemVkKSkgdGhyb3cgbmV3IEVycm9yKCdOb3QgZmluYWxpemVkJyk7XG4gICAgY29uc3QgYyA9IHRoaXMuX19DQUNIRTtcbiAgICBpZiAoIWRpc2FibGVGZWVDaGVjaykge1xuICAgICAgY2hlY2tGZWVzKHRoaXMsIGMsIHRoaXMub3B0cyk7XG4gICAgfVxuICAgIGlmIChjLl9fRVhUUkFDVEVEX1RYKSByZXR1cm4gYy5fX0VYVFJBQ1RFRF9UWDtcbiAgICBjb25zdCB0eCA9IGMuX19UWC5jbG9uZSgpO1xuICAgIGlucHV0RmluYWxpemVHZXRBbXRzKHRoaXMuZGF0YS5pbnB1dHMsIHR4LCBjLCB0cnVlKTtcbiAgICByZXR1cm4gdHg7XG4gIH1cbiAgZ2V0RmVlUmF0ZSgpIHtcbiAgICByZXR1cm4gZ2V0VHhDYWNoZVZhbHVlKFxuICAgICAgJ19fRkVFX1JBVEUnLFxuICAgICAgJ2ZlZSByYXRlJyxcbiAgICAgIHRoaXMuZGF0YS5pbnB1dHMsXG4gICAgICB0aGlzLl9fQ0FDSEUsXG4gICAgKTtcbiAgfVxuICBnZXRGZWUoKSB7XG4gICAgcmV0dXJuIGdldFR4Q2FjaGVWYWx1ZSgnX19GRUUnLCAnZmVlJywgdGhpcy5kYXRhLmlucHV0cywgdGhpcy5fX0NBQ0hFKTtcbiAgfVxuICBmaW5hbGl6ZUFsbElucHV0cygpIHtcbiAgICAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCAwKTsgLy8gbWFraW5nIHN1cmUgd2UgaGF2ZSBhdCBsZWFzdCBvbmVcbiAgICByYW5nZSh0aGlzLmRhdGEuaW5wdXRzLmxlbmd0aCkuZm9yRWFjaChpZHggPT4gdGhpcy5maW5hbGl6ZUlucHV0KGlkeCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZpbmFsaXplSW5wdXQoaW5wdXRJbmRleCwgZmluYWxTY3JpcHRzRnVuYykge1xuICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgaWYgKCgwLCBiaXAzNzFfMS5pc1RhcHJvb3RJbnB1dCkoaW5wdXQpKVxuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmFsaXplVGFwcm9vdElucHV0KFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBmaW5hbFNjcmlwdHNGdW5jLFxuICAgICAgKTtcbiAgICByZXR1cm4gdGhpcy5fZmluYWxpemVJbnB1dChpbnB1dEluZGV4LCBpbnB1dCwgZmluYWxTY3JpcHRzRnVuYyk7XG4gIH1cbiAgZmluYWxpemVUYXByb290SW5wdXQoXG4gICAgaW5wdXRJbmRleCxcbiAgICB0YXBMZWFmSGFzaFRvRmluYWxpemUsXG4gICAgZmluYWxTY3JpcHRzRnVuYyA9IGJpcDM3MV8xLnRhcFNjcmlwdEZpbmFsaXplcixcbiAgKSB7XG4gICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICBpZiAoKDAsIGJpcDM3MV8xLmlzVGFwcm9vdElucHV0KShpbnB1dCkpXG4gICAgICByZXR1cm4gdGhpcy5fZmluYWxpemVUYXByb290SW5wdXQoXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgIGlucHV0LFxuICAgICAgICB0YXBMZWFmSGFzaFRvRmluYWxpemUsXG4gICAgICAgIGZpbmFsU2NyaXB0c0Z1bmMsXG4gICAgICApO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGZpbmFsaXplIGlucHV0ICMke2lucHV0SW5kZXh9LiBOb3QgVGFwcm9vdC5gKTtcbiAgfVxuICBfZmluYWxpemVJbnB1dChpbnB1dEluZGV4LCBpbnB1dCwgZmluYWxTY3JpcHRzRnVuYyA9IGdldEZpbmFsU2NyaXB0cykge1xuICAgIGNvbnN0IHsgc2NyaXB0LCBpc1AyU0gsIGlzUDJXU0gsIGlzU2Vnd2l0IH0gPSBnZXRTY3JpcHRGcm9tSW5wdXQoXG4gICAgICBpbnB1dEluZGV4LFxuICAgICAgaW5wdXQsXG4gICAgICB0aGlzLl9fQ0FDSEUsXG4gICAgKTtcbiAgICBpZiAoIXNjcmlwdCkgdGhyb3cgbmV3IEVycm9yKGBObyBzY3JpcHQgZm91bmQgZm9yIGlucHV0ICMke2lucHV0SW5kZXh9YCk7XG4gICAgY2hlY2tQYXJ0aWFsU2lnU2lnaGFzaGVzKGlucHV0KTtcbiAgICBjb25zdCB7IGZpbmFsU2NyaXB0U2lnLCBmaW5hbFNjcmlwdFdpdG5lc3MgfSA9IGZpbmFsU2NyaXB0c0Z1bmMoXG4gICAgICBpbnB1dEluZGV4LFxuICAgICAgaW5wdXQsXG4gICAgICBzY3JpcHQsXG4gICAgICBpc1NlZ3dpdCxcbiAgICAgIGlzUDJTSCxcbiAgICAgIGlzUDJXU0gsXG4gICAgKTtcbiAgICBpZiAoZmluYWxTY3JpcHRTaWcpIHRoaXMuZGF0YS51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IGZpbmFsU2NyaXB0U2lnIH0pO1xuICAgIGlmIChmaW5hbFNjcmlwdFdpdG5lc3MpXG4gICAgICB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgeyBmaW5hbFNjcmlwdFdpdG5lc3MgfSk7XG4gICAgaWYgKCFmaW5hbFNjcmlwdFNpZyAmJiAhZmluYWxTY3JpcHRXaXRuZXNzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGVycm9yIGZpbmFsaXppbmcgaW5wdXQgIyR7aW5wdXRJbmRleH1gKTtcbiAgICB0aGlzLmRhdGEuY2xlYXJGaW5hbGl6ZWRJbnB1dChpbnB1dEluZGV4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfZmluYWxpemVUYXByb290SW5wdXQoXG4gICAgaW5wdXRJbmRleCxcbiAgICBpbnB1dCxcbiAgICB0YXBMZWFmSGFzaFRvRmluYWxpemUsXG4gICAgZmluYWxTY3JpcHRzRnVuYyA9IGJpcDM3MV8xLnRhcFNjcmlwdEZpbmFsaXplcixcbiAgKSB7XG4gICAgaWYgKCFpbnB1dC53aXRuZXNzVXR4bylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENhbm5vdCBmaW5hbGl6ZSBpbnB1dCAjJHtpbnB1dEluZGV4fS4gTWlzc2luZyB3aXRobmVzcyB1dHhvLmAsXG4gICAgICApO1xuICAgIC8vIENoZWNrIGtleSBzcGVuZCBmaXJzdC4gSW5jcmVhc2VkIHByaXZhY3kgYW5kIHJlZHVjZWQgYmxvY2sgc3BhY2UuXG4gICAgaWYgKGlucHV0LnRhcEtleVNpZykge1xuICAgICAgY29uc3QgcGF5bWVudCA9IHBheW1lbnRzLnAydHIoe1xuICAgICAgICBvdXRwdXQ6IGlucHV0LndpdG5lc3NVdHhvLnNjcmlwdCxcbiAgICAgICAgc2lnbmF0dXJlOiBpbnB1dC50YXBLZXlTaWcsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGZpbmFsU2NyaXB0V2l0bmVzcyA9ICgwLCBwc2J0dXRpbHNfMS53aXRuZXNzU3RhY2tUb1NjcmlwdFdpdG5lc3MpKFxuICAgICAgICBwYXltZW50LndpdG5lc3MsXG4gICAgICApO1xuICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgZmluYWxTY3JpcHRXaXRuZXNzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IGZpbmFsU2NyaXB0V2l0bmVzcyB9ID0gZmluYWxTY3JpcHRzRnVuYyhcbiAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHRhcExlYWZIYXNoVG9GaW5hbGl6ZSxcbiAgICAgICk7XG4gICAgICB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgeyBmaW5hbFNjcmlwdFdpdG5lc3MgfSk7XG4gICAgfVxuICAgIHRoaXMuZGF0YS5jbGVhckZpbmFsaXplZElucHV0KGlucHV0SW5kZXgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldElucHV0VHlwZShpbnB1dEluZGV4KSB7XG4gICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICBjb25zdCBzY3JpcHQgPSBnZXRTY3JpcHRGcm9tVXR4byhpbnB1dEluZGV4LCBpbnB1dCwgdGhpcy5fX0NBQ0hFKTtcbiAgICBjb25zdCByZXN1bHQgPSBnZXRNZWFuaW5nZnVsU2NyaXB0KFxuICAgICAgc2NyaXB0LFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgICdpbnB1dCcsXG4gICAgICBpbnB1dC5yZWRlZW1TY3JpcHQgfHwgcmVkZWVtRnJvbUZpbmFsU2NyaXB0U2lnKGlucHV0LmZpbmFsU2NyaXB0U2lnKSxcbiAgICAgIGlucHV0LndpdG5lc3NTY3JpcHQgfHxcbiAgICAgICAgcmVkZWVtRnJvbUZpbmFsV2l0bmVzc1NjcmlwdChpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3MpLFxuICAgICk7XG4gICAgY29uc3QgdHlwZSA9IHJlc3VsdC50eXBlID09PSAncmF3JyA/ICcnIDogcmVzdWx0LnR5cGUgKyAnLSc7XG4gICAgY29uc3QgbWFpblR5cGUgPSBjbGFzc2lmeVNjcmlwdChyZXN1bHQubWVhbmluZ2Z1bFNjcmlwdCk7XG4gICAgcmV0dXJuIHR5cGUgKyBtYWluVHlwZTtcbiAgfVxuICBpbnB1dEhhc1B1YmtleShpbnB1dEluZGV4LCBwdWJrZXkpIHtcbiAgICBjb25zdCBpbnB1dCA9ICgwLCB1dGlsc18xLmNoZWNrRm9ySW5wdXQpKHRoaXMuZGF0YS5pbnB1dHMsIGlucHV0SW5kZXgpO1xuICAgIHJldHVybiBwdWJrZXlJbklucHV0KHB1YmtleSwgaW5wdXQsIGlucHV0SW5kZXgsIHRoaXMuX19DQUNIRSk7XG4gIH1cbiAgaW5wdXRIYXNIREtleShpbnB1dEluZGV4LCByb290KSB7XG4gICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICBjb25zdCBkZXJpdmF0aW9uSXNNaW5lID0gYmlwMzJEZXJpdmF0aW9uSXNNaW5lKHJvb3QpO1xuICAgIHJldHVybiAoXG4gICAgICAhIWlucHV0LmJpcDMyRGVyaXZhdGlvbiAmJiBpbnB1dC5iaXAzMkRlcml2YXRpb24uc29tZShkZXJpdmF0aW9uSXNNaW5lKVxuICAgICk7XG4gIH1cbiAgb3V0cHV0SGFzUHVia2V5KG91dHB1dEluZGV4LCBwdWJrZXkpIHtcbiAgICBjb25zdCBvdXRwdXQgPSAoMCwgdXRpbHNfMS5jaGVja0Zvck91dHB1dCkodGhpcy5kYXRhLm91dHB1dHMsIG91dHB1dEluZGV4KTtcbiAgICByZXR1cm4gcHVia2V5SW5PdXRwdXQocHVia2V5LCBvdXRwdXQsIG91dHB1dEluZGV4LCB0aGlzLl9fQ0FDSEUpO1xuICB9XG4gIG91dHB1dEhhc0hES2V5KG91dHB1dEluZGV4LCByb290KSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JPdXRwdXQpKHRoaXMuZGF0YS5vdXRwdXRzLCBvdXRwdXRJbmRleCk7XG4gICAgY29uc3QgZGVyaXZhdGlvbklzTWluZSA9IGJpcDMyRGVyaXZhdGlvbklzTWluZShyb290KTtcbiAgICByZXR1cm4gKFxuICAgICAgISFvdXRwdXQuYmlwMzJEZXJpdmF0aW9uICYmIG91dHB1dC5iaXAzMkRlcml2YXRpb24uc29tZShkZXJpdmF0aW9uSXNNaW5lKVxuICAgICk7XG4gIH1cbiAgdmFsaWRhdGVTaWduYXR1cmVzT2ZBbGxJbnB1dHModmFsaWRhdG9yKSB7XG4gICAgKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgMCk7IC8vIG1ha2luZyBzdXJlIHdlIGhhdmUgYXQgbGVhc3Qgb25lXG4gICAgY29uc3QgcmVzdWx0cyA9IHJhbmdlKHRoaXMuZGF0YS5pbnB1dHMubGVuZ3RoKS5tYXAoaWR4ID0+XG4gICAgICB0aGlzLnZhbGlkYXRlU2lnbmF0dXJlc09mSW5wdXQoaWR4LCB2YWxpZGF0b3IpLFxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKChmaW5hbCwgcmVzKSA9PiByZXMgPT09IHRydWUgJiYgZmluYWwsIHRydWUpO1xuICB9XG4gIHZhbGlkYXRlU2lnbmF0dXJlc09mSW5wdXQoaW5wdXRJbmRleCwgdmFsaWRhdG9yLCBwdWJrZXkpIHtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF07XG4gICAgaWYgKCgwLCBiaXAzNzFfMS5pc1RhcHJvb3RJbnB1dCkoaW5wdXQpKVxuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVTaWduYXR1cmVzT2ZUYXByb290SW5wdXQoXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgIHZhbGlkYXRvcixcbiAgICAgICAgcHVia2V5LFxuICAgICAgKTtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGVTaWduYXR1cmVzT2ZJbnB1dChpbnB1dEluZGV4LCB2YWxpZGF0b3IsIHB1YmtleSk7XG4gIH1cbiAgX3ZhbGlkYXRlU2lnbmF0dXJlc09mSW5wdXQoaW5wdXRJbmRleCwgdmFsaWRhdG9yLCBwdWJrZXkpIHtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuZGF0YS5pbnB1dHNbaW5wdXRJbmRleF07XG4gICAgY29uc3QgcGFydGlhbFNpZyA9IChpbnB1dCB8fCB7fSkucGFydGlhbFNpZztcbiAgICBpZiAoIWlucHV0IHx8ICFwYXJ0aWFsU2lnIHx8IHBhcnRpYWxTaWcubGVuZ3RoIDwgMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmF0dXJlcyB0byB2YWxpZGF0ZScpO1xuICAgIGlmICh0eXBlb2YgdmFsaWRhdG9yICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIHZhbGlkYXRvciBmdW5jdGlvbiB0byB2YWxpZGF0ZSBzaWduYXR1cmVzJyk7XG4gICAgY29uc3QgbXlTaWdzID0gcHVia2V5XG4gICAgICA/IHBhcnRpYWxTaWcuZmlsdGVyKHNpZyA9PiBzaWcucHVia2V5LmVxdWFscyhwdWJrZXkpKVxuICAgICAgOiBwYXJ0aWFsU2lnO1xuICAgIGlmIChteVNpZ3MubGVuZ3RoIDwgMSkgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduYXR1cmVzIGZvciB0aGlzIHB1YmtleScpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgaGFzaENhY2hlO1xuICAgIGxldCBzY3JpcHRDYWNoZTtcbiAgICBsZXQgc2lnaGFzaENhY2hlO1xuICAgIGZvciAoY29uc3QgcFNpZyBvZiBteVNpZ3MpIHtcbiAgICAgIGNvbnN0IHNpZyA9IGJzY3JpcHQuc2lnbmF0dXJlLmRlY29kZShwU2lnLnNpZ25hdHVyZSk7XG4gICAgICBjb25zdCB7IGhhc2gsIHNjcmlwdCB9ID1cbiAgICAgICAgc2lnaGFzaENhY2hlICE9PSBzaWcuaGFzaFR5cGVcbiAgICAgICAgICA/IGdldEhhc2hGb3JTaWcoXG4gICAgICAgICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGlucHV0LCB7IHNpZ2hhc2hUeXBlOiBzaWcuaGFzaFR5cGUgfSksXG4gICAgICAgICAgICAgIHRoaXMuX19DQUNIRSxcbiAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IHsgaGFzaDogaGFzaENhY2hlLCBzY3JpcHQ6IHNjcmlwdENhY2hlIH07XG4gICAgICBzaWdoYXNoQ2FjaGUgPSBzaWcuaGFzaFR5cGU7XG4gICAgICBoYXNoQ2FjaGUgPSBoYXNoO1xuICAgICAgc2NyaXB0Q2FjaGUgPSBzY3JpcHQ7XG4gICAgICBjaGVja1NjcmlwdEZvclB1YmtleShwU2lnLnB1YmtleSwgc2NyaXB0LCAndmVyaWZ5Jyk7XG4gICAgICByZXN1bHRzLnB1c2godmFsaWRhdG9yKHBTaWcucHVia2V5LCBoYXNoLCBzaWcuc2lnbmF0dXJlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzLmV2ZXJ5KHJlcyA9PiByZXMgPT09IHRydWUpO1xuICB9XG4gIHZhbGlkYXRlU2lnbmF0dXJlc09mVGFwcm9vdElucHV0KGlucHV0SW5kZXgsIHZhbGlkYXRvciwgcHVia2V5KSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmRhdGEuaW5wdXRzW2lucHV0SW5kZXhdO1xuICAgIGNvbnN0IHRhcEtleVNpZyA9IChpbnB1dCB8fCB7fSkudGFwS2V5U2lnO1xuICAgIGNvbnN0IHRhcFNjcmlwdFNpZyA9IChpbnB1dCB8fCB7fSkudGFwU2NyaXB0U2lnO1xuICAgIGlmICghaW5wdXQgJiYgIXRhcEtleVNpZyAmJiAhKHRhcFNjcmlwdFNpZyAmJiAhdGFwU2NyaXB0U2lnLmxlbmd0aCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25hdHVyZXMgdG8gdmFsaWRhdGUnKTtcbiAgICBpZiAodHlwZW9mIHZhbGlkYXRvciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCB2YWxpZGF0b3IgZnVuY3Rpb24gdG8gdmFsaWRhdGUgc2lnbmF0dXJlcycpO1xuICAgIHB1YmtleSA9IHB1YmtleSAmJiAoMCwgYmlwMzcxXzEudG9YT25seSkocHVia2V5KTtcbiAgICBjb25zdCBhbGxIYXNoc2VzID0gcHVia2V5XG4gICAgICA/IGdldFRhcHJvb3RIYXNoZXNGb3JTaWcoXG4gICAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICB0aGlzLmRhdGEuaW5wdXRzLFxuICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICB0aGlzLl9fQ0FDSEUsXG4gICAgICAgIClcbiAgICAgIDogZ2V0QWxsVGFwcm9vdEhhc2hlc0ZvclNpZyhcbiAgICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHRoaXMuZGF0YS5pbnB1dHMsXG4gICAgICAgICAgdGhpcy5fX0NBQ0hFLFxuICAgICAgICApO1xuICAgIGlmICghYWxsSGFzaHNlcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmF0dXJlcyBmb3IgdGhpcyBwdWJrZXknKTtcbiAgICBjb25zdCB0YXBLZXlIYXNoID0gYWxsSGFzaHNlcy5maW5kKGggPT4gIWgubGVhZkhhc2gpO1xuICAgIGxldCB2YWxpZGF0aW9uUmVzdWx0Q291bnQgPSAwO1xuICAgIGlmICh0YXBLZXlTaWcgJiYgdGFwS2V5SGFzaCkge1xuICAgICAgY29uc3QgaXNWYWxpZFRhcGtleVNpZyA9IHZhbGlkYXRvcihcbiAgICAgICAgdGFwS2V5SGFzaC5wdWJrZXksXG4gICAgICAgIHRhcEtleUhhc2guaGFzaCxcbiAgICAgICAgdHJpbVRhcHJvb3RTaWcodGFwS2V5U2lnKSxcbiAgICAgICk7XG4gICAgICBpZiAoIWlzVmFsaWRUYXBrZXlTaWcpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhbGlkYXRpb25SZXN1bHRDb3VudCsrO1xuICAgIH1cbiAgICBpZiAodGFwU2NyaXB0U2lnKSB7XG4gICAgICBmb3IgKGNvbnN0IHRhcFNpZyBvZiB0YXBTY3JpcHRTaWcpIHtcbiAgICAgICAgY29uc3QgdGFwU2lnSGFzaCA9IGFsbEhhc2hzZXMuZmluZChoID0+IHRhcFNpZy5wdWJrZXkuZXF1YWxzKGgucHVia2V5KSk7XG4gICAgICAgIGlmICh0YXBTaWdIYXNoKSB7XG4gICAgICAgICAgY29uc3QgaXNWYWxpZFRhcFNjcmlwdFNpZyA9IHZhbGlkYXRvcihcbiAgICAgICAgICAgIHRhcFNpZy5wdWJrZXksXG4gICAgICAgICAgICB0YXBTaWdIYXNoLmhhc2gsXG4gICAgICAgICAgICB0cmltVGFwcm9vdFNpZyh0YXBTaWcuc2lnbmF0dXJlKSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghaXNWYWxpZFRhcFNjcmlwdFNpZykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHRDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWxpZGF0aW9uUmVzdWx0Q291bnQgPiAwO1xuICB9XG4gIHNpZ25BbGxJbnB1dHNIRChcbiAgICBoZEtleVBhaXIsXG4gICAgc2lnaGFzaFR5cGVzID0gW3RyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExdLFxuICApIHtcbiAgICBpZiAoIWhkS2V5UGFpciB8fCAhaGRLZXlQYWlyLnB1YmxpY0tleSB8fCAhaGRLZXlQYWlyLmZpbmdlcnByaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgSERTaWduZXIgdG8gc2lnbiBpbnB1dCcpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgZm9yIChjb25zdCBpIG9mIHJhbmdlKHRoaXMuZGF0YS5pbnB1dHMubGVuZ3RoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zaWduSW5wdXRIRChpLCBoZEtleVBhaXIsIHNpZ2hhc2hUeXBlcyk7XG4gICAgICAgIHJlc3VsdHMucHVzaCh0cnVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXN1bHRzLnB1c2goZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0cy5ldmVyeSh2ID0+IHYgPT09IGZhbHNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnB1dHMgd2VyZSBzaWduZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2lnbkFsbElucHV0c0hEQXN5bmMoXG4gICAgaGRLZXlQYWlyLFxuICAgIHNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXSxcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghaGRLZXlQYWlyIHx8ICFoZEtleVBhaXIucHVibGljS2V5IHx8ICFoZEtleVBhaXIuZmluZ2VycHJpbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05lZWQgSERTaWduZXIgdG8gc2lnbiBpbnB1dCcpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGkgb2YgcmFuZ2UodGhpcy5kYXRhLmlucHV0cy5sZW5ndGgpKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgdGhpcy5zaWduSW5wdXRIREFzeW5jKGksIGhkS2V5UGFpciwgc2lnaGFzaFR5cGVzKS50aGVuKFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdHMuZXZlcnkodiA9PiB2ID09PSBmYWxzZSkpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTm8gaW5wdXRzIHdlcmUgc2lnbmVkJykpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHNpZ25JbnB1dEhEKFxuICAgIGlucHV0SW5kZXgsXG4gICAgaGRLZXlQYWlyLFxuICAgIHNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXSxcbiAgKSB7XG4gICAgaWYgKCFoZEtleVBhaXIgfHwgIWhkS2V5UGFpci5wdWJsaWNLZXkgfHwgIWhkS2V5UGFpci5maW5nZXJwcmludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIEhEU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVycyA9IGdldFNpZ25lcnNGcm9tSEQoaW5wdXRJbmRleCwgdGhpcy5kYXRhLmlucHV0cywgaGRLZXlQYWlyKTtcbiAgICBzaWduZXJzLmZvckVhY2goc2lnbmVyID0+IHRoaXMuc2lnbklucHV0KGlucHV0SW5kZXgsIHNpZ25lciwgc2lnaGFzaFR5cGVzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2lnbklucHV0SERBc3luYyhcbiAgICBpbnB1dEluZGV4LFxuICAgIGhkS2V5UGFpcixcbiAgICBzaWdoYXNoVHlwZXMgPSBbdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTF0sXG4gICkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIWhkS2V5UGFpciB8fCAhaGRLZXlQYWlyLnB1YmxpY0tleSB8fCAhaGRLZXlQYWlyLmZpbmdlcnByaW50KSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdOZWVkIEhEU2lnbmVyIHRvIHNpZ24gaW5wdXQnKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzaWduZXJzID0gZ2V0U2lnbmVyc0Zyb21IRChpbnB1dEluZGV4LCB0aGlzLmRhdGEuaW5wdXRzLCBoZEtleVBhaXIpO1xuICAgICAgY29uc3QgcHJvbWlzZXMgPSBzaWduZXJzLm1hcChzaWduZXIgPT5cbiAgICAgICAgdGhpcy5zaWduSW5wdXRBc3luYyhpbnB1dEluZGV4LCBzaWduZXIsIHNpZ2hhc2hUeXBlcyksXG4gICAgICApO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2gocmVqZWN0KTtcbiAgICB9KTtcbiAgfVxuICBzaWduQWxsSW5wdXRzKGtleVBhaXIsIHNpZ2hhc2hUeXBlcykge1xuICAgIGlmICgha2V5UGFpciB8fCAha2V5UGFpci5wdWJsaWNLZXkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICAvLyBUT0RPOiBBZGQgYSBwdWJrZXkvcHVia2V5aGFzaCBjYWNoZSB0byBlYWNoIGlucHV0XG4gICAgLy8gYXMgaW5wdXQgaW5mb3JtYXRpb24gaXMgYWRkZWQsIHRoZW4gZXZlbnR1YWxseVxuICAgIC8vIG9wdGltaXplIHRoaXMgbWV0aG9kLlxuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgcmFuZ2UodGhpcy5kYXRhLmlucHV0cy5sZW5ndGgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNpZ25JbnB1dChpLCBrZXlQYWlyLCBzaWdoYXNoVHlwZXMpO1xuICAgICAgICByZXN1bHRzLnB1c2godHJ1ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3VsdHMuZXZlcnkodiA9PiB2ID09PSBmYWxzZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXRzIHdlcmUgc2lnbmVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNpZ25BbGxJbnB1dHNBc3luYyhrZXlQYWlyLCBzaWdoYXNoVHlwZXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCFrZXlQYWlyIHx8ICFrZXlQYWlyLnB1YmxpY0tleSlcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ05lZWQgU2lnbmVyIHRvIHNpZ24gaW5wdXQnKSk7XG4gICAgICAvLyBUT0RPOiBBZGQgYSBwdWJrZXkvcHVia2V5aGFzaCBjYWNoZSB0byBlYWNoIGlucHV0XG4gICAgICAvLyBhcyBpbnB1dCBpbmZvcm1hdGlvbiBpcyBhZGRlZCwgdGhlbiBldmVudHVhbGx5XG4gICAgICAvLyBvcHRpbWl6ZSB0aGlzIG1ldGhvZC5cbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBmb3IgKGNvbnN0IFtpXSBvZiB0aGlzLmRhdGEuaW5wdXRzLmVudHJpZXMoKSkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgIHRoaXMuc2lnbklucHV0QXN5bmMoaSwga2V5UGFpciwgc2lnaGFzaFR5cGVzKS50aGVuKFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2godHJ1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdHMuZXZlcnkodiA9PiB2ID09PSBmYWxzZSkpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcignTm8gaW5wdXRzIHdlcmUgc2lnbmVkJykpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHNpZ25JbnB1dChpbnB1dEluZGV4LCBrZXlQYWlyLCBzaWdoYXNoVHlwZXMpIHtcbiAgICBpZiAoIWtleVBhaXIgfHwgIWtleVBhaXIucHVibGljS2V5KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWVkIFNpZ25lciB0byBzaWduIGlucHV0Jyk7XG4gICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICBpZiAoKDAsIGJpcDM3MV8xLmlzVGFwcm9vdElucHV0KShpbnB1dCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaWduVGFwcm9vdElucHV0KFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICBpbnB1dCxcbiAgICAgICAga2V5UGFpcixcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBzaWdoYXNoVHlwZXMsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2lnbklucHV0KGlucHV0SW5kZXgsIGtleVBhaXIsIHNpZ2hhc2hUeXBlcyk7XG4gIH1cbiAgc2lnblRhcHJvb3RJbnB1dChpbnB1dEluZGV4LCBrZXlQYWlyLCB0YXBMZWFmSGFzaFRvU2lnbiwgc2lnaGFzaFR5cGVzKSB7XG4gICAgaWYgKCFrZXlQYWlyIHx8ICFrZXlQYWlyLnB1YmxpY0tleSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBTaWduZXIgdG8gc2lnbiBpbnB1dCcpO1xuICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgaWYgKCgwLCBiaXAzNzFfMS5pc1RhcHJvb3RJbnB1dCkoaW5wdXQpKVxuICAgICAgcmV0dXJuIHRoaXMuX3NpZ25UYXByb290SW5wdXQoXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBrZXlQYWlyLFxuICAgICAgICB0YXBMZWFmSGFzaFRvU2lnbixcbiAgICAgICAgc2lnaGFzaFR5cGVzLFxuICAgICAgKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICMke2lucHV0SW5kZXh9IGlzIG5vdCBvZiB0eXBlIFRhcHJvb3QuYCk7XG4gIH1cbiAgX3NpZ25JbnB1dChcbiAgICBpbnB1dEluZGV4LFxuICAgIGtleVBhaXIsXG4gICAgc2lnaGFzaFR5cGVzID0gW3RyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExdLFxuICApIHtcbiAgICBjb25zdCB7IGhhc2gsIHNpZ2hhc2hUeXBlIH0gPSBnZXRIYXNoQW5kU2lnaGFzaFR5cGUoXG4gICAgICB0aGlzLmRhdGEuaW5wdXRzLFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgIGtleVBhaXIucHVibGljS2V5LFxuICAgICAgdGhpcy5fX0NBQ0hFLFxuICAgICAgc2lnaGFzaFR5cGVzLFxuICAgICk7XG4gICAgY29uc3QgcGFydGlhbFNpZyA9IFtcbiAgICAgIHtcbiAgICAgICAgcHVia2V5OiBrZXlQYWlyLnB1YmxpY0tleSxcbiAgICAgICAgc2lnbmF0dXJlOiBic2NyaXB0LnNpZ25hdHVyZS5lbmNvZGUoa2V5UGFpci5zaWduKGhhc2gpLCBzaWdoYXNoVHlwZSksXG4gICAgICB9LFxuICAgIF07XG4gICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgcGFydGlhbFNpZyB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfc2lnblRhcHJvb3RJbnB1dChcbiAgICBpbnB1dEluZGV4LFxuICAgIGlucHV0LFxuICAgIGtleVBhaXIsXG4gICAgdGFwTGVhZkhhc2hUb1NpZ24sXG4gICAgYWxsb3dlZFNpZ2hhc2hUeXBlcyA9IFt0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVF0sXG4gICkge1xuICAgIGNvbnN0IGhhc2hlc0ZvclNpZyA9IHRoaXMuY2hlY2tUYXByb290SGFzaGVzRm9yU2lnKFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgIGlucHV0LFxuICAgICAga2V5UGFpcixcbiAgICAgIHRhcExlYWZIYXNoVG9TaWduLFxuICAgICAgYWxsb3dlZFNpZ2hhc2hUeXBlcyxcbiAgICApO1xuICAgIGNvbnN0IHRhcEtleVNpZyA9IGhhc2hlc0ZvclNpZ1xuICAgICAgLmZpbHRlcihoID0+ICFoLmxlYWZIYXNoKVxuICAgICAgLm1hcChoID0+XG4gICAgICAgICgwLCBiaXAzNzFfMS5zZXJpYWxpemVUYXByb290U2lnbmF0dXJlKShcbiAgICAgICAgICBrZXlQYWlyLnNpZ25TY2hub3JyKGguaGFzaCksXG4gICAgICAgICAgaW5wdXQuc2lnaGFzaFR5cGUsXG4gICAgICAgICksXG4gICAgICApWzBdO1xuICAgIGNvbnN0IHRhcFNjcmlwdFNpZyA9IGhhc2hlc0ZvclNpZ1xuICAgICAgLmZpbHRlcihoID0+ICEhaC5sZWFmSGFzaClcbiAgICAgIC5tYXAoaCA9PiAoe1xuICAgICAgICBwdWJrZXk6ICgwLCBiaXAzNzFfMS50b1hPbmx5KShrZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgIHNpZ25hdHVyZTogKDAsIGJpcDM3MV8xLnNlcmlhbGl6ZVRhcHJvb3RTaWduYXR1cmUpKFxuICAgICAgICAgIGtleVBhaXIuc2lnblNjaG5vcnIoaC5oYXNoKSxcbiAgICAgICAgICBpbnB1dC5zaWdoYXNoVHlwZSxcbiAgICAgICAgKSxcbiAgICAgICAgbGVhZkhhc2g6IGgubGVhZkhhc2gsXG4gICAgICB9KSk7XG4gICAgaWYgKHRhcEtleVNpZykge1xuICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgdGFwS2V5U2lnIH0pO1xuICAgIH1cbiAgICBpZiAodGFwU2NyaXB0U2lnLmxlbmd0aCkge1xuICAgICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHsgdGFwU2NyaXB0U2lnIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzaWduSW5wdXRBc3luYyhpbnB1dEluZGV4LCBrZXlQYWlyLCBzaWdoYXNoVHlwZXMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIWtleVBhaXIgfHwgIWtleVBhaXIucHVibGljS2V5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgU2lnbmVyIHRvIHNpZ24gaW5wdXQnKTtcbiAgICAgIGNvbnN0IGlucHV0ID0gKDAsIHV0aWxzXzEuY2hlY2tGb3JJbnB1dCkodGhpcy5kYXRhLmlucHV0cywgaW5wdXRJbmRleCk7XG4gICAgICBpZiAoKDAsIGJpcDM3MV8xLmlzVGFwcm9vdElucHV0KShpbnB1dCkpXG4gICAgICAgIHJldHVybiB0aGlzLl9zaWduVGFwcm9vdElucHV0QXN5bmMoXG4gICAgICAgICAgaW5wdXRJbmRleCxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBrZXlQYWlyLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBzaWdoYXNoVHlwZXMsXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gdGhpcy5fc2lnbklucHV0QXN5bmMoaW5wdXRJbmRleCwga2V5UGFpciwgc2lnaGFzaFR5cGVzKTtcbiAgICB9KTtcbiAgfVxuICBzaWduVGFwcm9vdElucHV0QXN5bmMoaW5wdXRJbmRleCwga2V5UGFpciwgdGFwTGVhZkhhc2gsIHNpZ2hhc2hUeXBlcykge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIGlmICgha2V5UGFpciB8fCAha2V5UGFpci5wdWJsaWNLZXkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVlZCBTaWduZXIgdG8gc2lnbiBpbnB1dCcpO1xuICAgICAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KSh0aGlzLmRhdGEuaW5wdXRzLCBpbnB1dEluZGV4KTtcbiAgICAgIGlmICgoMCwgYmlwMzcxXzEuaXNUYXByb290SW5wdXQpKGlucHV0KSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZ25UYXByb290SW5wdXRBc3luYyhcbiAgICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIGtleVBhaXIsXG4gICAgICAgICAgdGFwTGVhZkhhc2gsXG4gICAgICAgICAgc2lnaGFzaFR5cGVzLFxuICAgICAgICApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAjJHtpbnB1dEluZGV4fSBpcyBub3Qgb2YgdHlwZSBUYXByb290LmApO1xuICAgIH0pO1xuICB9XG4gIF9zaWduSW5wdXRBc3luYyhcbiAgICBpbnB1dEluZGV4LFxuICAgIGtleVBhaXIsXG4gICAgc2lnaGFzaFR5cGVzID0gW3RyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTExdLFxuICApIHtcbiAgICBjb25zdCB7IGhhc2gsIHNpZ2hhc2hUeXBlIH0gPSBnZXRIYXNoQW5kU2lnaGFzaFR5cGUoXG4gICAgICB0aGlzLmRhdGEuaW5wdXRzLFxuICAgICAgaW5wdXRJbmRleCxcbiAgICAgIGtleVBhaXIucHVibGljS2V5LFxuICAgICAgdGhpcy5fX0NBQ0hFLFxuICAgICAgc2lnaGFzaFR5cGVzLFxuICAgICk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXlQYWlyLnNpZ24oaGFzaCkpLnRoZW4oc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpYWxTaWcgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXk6IGtleVBhaXIucHVibGljS2V5LFxuICAgICAgICAgIHNpZ25hdHVyZTogYnNjcmlwdC5zaWduYXR1cmUuZW5jb2RlKHNpZ25hdHVyZSwgc2lnaGFzaFR5cGUpLFxuICAgICAgICB9LFxuICAgICAgXTtcbiAgICAgIHRoaXMuZGF0YS51cGRhdGVJbnB1dChpbnB1dEluZGV4LCB7IHBhcnRpYWxTaWcgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX3NpZ25UYXByb290SW5wdXRBc3luYyhcbiAgICBpbnB1dEluZGV4LFxuICAgIGlucHV0LFxuICAgIGtleVBhaXIsXG4gICAgdGFwTGVhZkhhc2gsXG4gICAgc2lnaGFzaFR5cGVzID0gW3RyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxUXSxcbiAgKSB7XG4gICAgY29uc3QgaGFzaGVzRm9yU2lnID0gdGhpcy5jaGVja1RhcHJvb3RIYXNoZXNGb3JTaWcoXG4gICAgICBpbnB1dEluZGV4LFxuICAgICAgaW5wdXQsXG4gICAgICBrZXlQYWlyLFxuICAgICAgdGFwTGVhZkhhc2gsXG4gICAgICBzaWdoYXNoVHlwZXMsXG4gICAgKTtcbiAgICBjb25zdCBzaWduYXR1cmVQcm9taXNlcyA9IFtdO1xuICAgIGNvbnN0IHRhcEtleUhhc2ggPSBoYXNoZXNGb3JTaWcuZmlsdGVyKGggPT4gIWgubGVhZkhhc2gpWzBdO1xuICAgIGlmICh0YXBLZXlIYXNoKSB7XG4gICAgICBjb25zdCB0YXBLZXlTaWdQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICBrZXlQYWlyLnNpZ25TY2hub3JyKHRhcEtleUhhc2guaGFzaCksXG4gICAgICApLnRoZW4oc2lnID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YXBLZXlTaWc6ICgwLCBiaXAzNzFfMS5zZXJpYWxpemVUYXByb290U2lnbmF0dXJlKShcbiAgICAgICAgICAgIHNpZyxcbiAgICAgICAgICAgIGlucHV0LnNpZ2hhc2hUeXBlLFxuICAgICAgICAgICksXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHNpZ25hdHVyZVByb21pc2VzLnB1c2godGFwS2V5U2lnUHJvbWlzZSk7XG4gICAgfVxuICAgIGNvbnN0IHRhcFNjcmlwdEhhc2hlcyA9IGhhc2hlc0ZvclNpZy5maWx0ZXIoaCA9PiAhIWgubGVhZkhhc2gpO1xuICAgIGlmICh0YXBTY3JpcHRIYXNoZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0YXBTY3JpcHRTaWdQcm9taXNlcyA9IHRhcFNjcmlwdEhhc2hlcy5tYXAodHNoID0+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXlQYWlyLnNpZ25TY2hub3JyKHRzaC5oYXNoKSkudGhlbihcbiAgICAgICAgICBzaWduYXR1cmUgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFwU2NyaXB0U2lnID0gW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHVia2V5OiAoMCwgYmlwMzcxXzEudG9YT25seSkoa2V5UGFpci5wdWJsaWNLZXkpLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogKDAsIGJpcDM3MV8xLnNlcmlhbGl6ZVRhcHJvb3RTaWduYXR1cmUpKFxuICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICAgaW5wdXQuc2lnaGFzaFR5cGUsXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBsZWFmSGFzaDogdHNoLmxlYWZIYXNoLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiB7IHRhcFNjcmlwdFNpZyB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIHNpZ25hdHVyZVByb21pc2VzLnB1c2goLi4udGFwU2NyaXB0U2lnUHJvbWlzZXMpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoc2lnbmF0dXJlUHJvbWlzZXMpLnRoZW4ocmVzdWx0cyA9PiB7XG4gICAgICByZXN1bHRzLmZvckVhY2godiA9PiB0aGlzLmRhdGEudXBkYXRlSW5wdXQoaW5wdXRJbmRleCwgdikpO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrVGFwcm9vdEhhc2hlc0ZvclNpZyhcbiAgICBpbnB1dEluZGV4LFxuICAgIGlucHV0LFxuICAgIGtleVBhaXIsXG4gICAgdGFwTGVhZkhhc2hUb1NpZ24sXG4gICAgYWxsb3dlZFNpZ2hhc2hUeXBlcyxcbiAgKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlQYWlyLnNpZ25TY2hub3JyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTmVlZCBTY2hub3JyIFNpZ25lciB0byBzaWduIHRhcHJvb3QgaW5wdXQgIyR7aW5wdXRJbmRleH0uYCxcbiAgICAgICk7XG4gICAgY29uc3QgaGFzaGVzRm9yU2lnID0gZ2V0VGFwcm9vdEhhc2hlc0ZvclNpZyhcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgICBpbnB1dCxcbiAgICAgIHRoaXMuZGF0YS5pbnB1dHMsXG4gICAgICBrZXlQYWlyLnB1YmxpY0tleSxcbiAgICAgIHRoaXMuX19DQUNIRSxcbiAgICAgIHRhcExlYWZIYXNoVG9TaWduLFxuICAgICAgYWxsb3dlZFNpZ2hhc2hUeXBlcyxcbiAgICApO1xuICAgIGlmICghaGFzaGVzRm9yU2lnIHx8ICFoYXNoZXNGb3JTaWcubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2FuIG5vdCBzaWduIGZvciBpbnB1dCAjJHtpbnB1dEluZGV4fSB3aXRoIHRoZSBrZXkgJHtrZXlQYWlyLnB1YmxpY0tleS50b1N0cmluZyhcbiAgICAgICAgICAnaGV4JyxcbiAgICAgICAgKX1gLFxuICAgICAgKTtcbiAgICByZXR1cm4gaGFzaGVzRm9yU2lnO1xuICB9XG4gIHRvQnVmZmVyKCkge1xuICAgIGNoZWNrQ2FjaGUodGhpcy5fX0NBQ0hFKTtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnRvQnVmZmVyKCk7XG4gIH1cbiAgdG9IZXgoKSB7XG4gICAgY2hlY2tDYWNoZSh0aGlzLl9fQ0FDSEUpO1xuICAgIHJldHVybiB0aGlzLmRhdGEudG9IZXgoKTtcbiAgfVxuICB0b0Jhc2U2NCgpIHtcbiAgICBjaGVja0NhY2hlKHRoaXMuX19DQUNIRSk7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS50b0Jhc2U2NCgpO1xuICB9XG4gIHVwZGF0ZUdsb2JhbCh1cGRhdGVEYXRhKSB7XG4gICAgdGhpcy5kYXRhLnVwZGF0ZUdsb2JhbCh1cGRhdGVEYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB1cGRhdGVJbnB1dChpbnB1dEluZGV4LCB1cGRhdGVEYXRhKSB7XG4gICAgaWYgKHVwZGF0ZURhdGEud2l0bmVzc1NjcmlwdCkgY2hlY2tJbnZhbGlkUDJXU0godXBkYXRlRGF0YS53aXRuZXNzU2NyaXB0KTtcbiAgICAoMCwgYmlwMzcxXzEuY2hlY2tUYXByb290SW5wdXRGaWVsZHMpKFxuICAgICAgdGhpcy5kYXRhLmlucHV0c1tpbnB1dEluZGV4XSxcbiAgICAgIHVwZGF0ZURhdGEsXG4gICAgICAndXBkYXRlSW5wdXQnLFxuICAgICk7XG4gICAgdGhpcy5kYXRhLnVwZGF0ZUlucHV0KGlucHV0SW5kZXgsIHVwZGF0ZURhdGEpO1xuICAgIGlmICh1cGRhdGVEYXRhLm5vbldpdG5lc3NVdHhvKSB7XG4gICAgICBhZGROb25XaXRuZXNzVHhDYWNoZShcbiAgICAgICAgdGhpcy5fX0NBQ0hFLFxuICAgICAgICB0aGlzLmRhdGEuaW5wdXRzW2lucHV0SW5kZXhdLFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdXBkYXRlT3V0cHV0KG91dHB1dEluZGV4LCB1cGRhdGVEYXRhKSB7XG4gICAgY29uc3Qgb3V0cHV0RGF0YSA9IHRoaXMuZGF0YS5vdXRwdXRzW291dHB1dEluZGV4XTtcbiAgICAoMCwgYmlwMzcxXzEuY2hlY2tUYXByb290T3V0cHV0RmllbGRzKShcbiAgICAgIG91dHB1dERhdGEsXG4gICAgICB1cGRhdGVEYXRhLFxuICAgICAgJ3VwZGF0ZU91dHB1dCcsXG4gICAgKTtcbiAgICB0aGlzLmRhdGEudXBkYXRlT3V0cHV0KG91dHB1dEluZGV4LCB1cGRhdGVEYXRhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhZGRVbmtub3duS2V5VmFsVG9HbG9iYWwoa2V5VmFsKSB7XG4gICAgdGhpcy5kYXRhLmFkZFVua25vd25LZXlWYWxUb0dsb2JhbChrZXlWYWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZFVua25vd25LZXlWYWxUb0lucHV0KGlucHV0SW5kZXgsIGtleVZhbCkge1xuICAgIHRoaXMuZGF0YS5hZGRVbmtub3duS2V5VmFsVG9JbnB1dChpbnB1dEluZGV4LCBrZXlWYWwpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGFkZFVua25vd25LZXlWYWxUb091dHB1dChvdXRwdXRJbmRleCwga2V5VmFsKSB7XG4gICAgdGhpcy5kYXRhLmFkZFVua25vd25LZXlWYWxUb091dHB1dChvdXRwdXRJbmRleCwga2V5VmFsKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhckZpbmFsaXplZElucHV0KGlucHV0SW5kZXgpIHtcbiAgICB0aGlzLmRhdGEuY2xlYXJGaW5hbGl6ZWRJbnB1dChpbnB1dEluZGV4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuZXhwb3J0cy5Qc2J0ID0gUHNidDtcbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBuZWVkZWQgdG8gcGFzcyB0byB0aGUgYmlwMTc0IGJhc2UgY2xhc3MncyBmcm9tQnVmZmVyLlxuICogSXQgdGFrZXMgdGhlIFwidHJhbnNhY3Rpb24gYnVmZmVyXCIgcG9ydGlvbiBvZiB0aGUgcHNidCBidWZmZXIgYW5kIHJldHVybnMgYVxuICogVHJhbnNhY3Rpb24gKEZyb20gdGhlIGJpcDE3NCBsaWJyYXJ5KSBpbnRlcmZhY2UuXG4gKi9cbmNvbnN0IHRyYW5zYWN0aW9uRnJvbUJ1ZmZlciA9IGJ1ZmZlciA9PiBuZXcgUHNidFRyYW5zYWN0aW9uKGJ1ZmZlcik7XG4vKipcbiAqIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB0aGUgVHJhbnNhY3Rpb24gaW50ZXJmYWNlIGZyb20gYmlwMTc0IGxpYnJhcnkuXG4gKiBJdCBjb250YWlucyBhIGJpdGNvaW5qcy1saWIgVHJhbnNhY3Rpb24gb2JqZWN0LlxuICovXG5jbGFzcyBQc2J0VHJhbnNhY3Rpb24ge1xuICBjb25zdHJ1Y3RvcihidWZmZXIgPSBCdWZmZXIuZnJvbShbMiwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pKSB7XG4gICAgdGhpcy50eCA9IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbUJ1ZmZlcihidWZmZXIpO1xuICAgIGNoZWNrVHhFbXB0eSh0aGlzLnR4KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R4Jywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxuICBnZXRJbnB1dE91dHB1dENvdW50cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW5wdXRDb3VudDogdGhpcy50eC5pbnMubGVuZ3RoLFxuICAgICAgb3V0cHV0Q291bnQ6IHRoaXMudHgub3V0cy5sZW5ndGgsXG4gICAgfTtcbiAgfVxuICBhZGRJbnB1dChpbnB1dCkge1xuICAgIGlmIChcbiAgICAgIGlucHV0Lmhhc2ggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgaW5wdXQuaW5kZXggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgKCFCdWZmZXIuaXNCdWZmZXIoaW5wdXQuaGFzaCkgJiYgdHlwZW9mIGlucHV0Lmhhc2ggIT09ICdzdHJpbmcnKSB8fFxuICAgICAgdHlwZW9mIGlucHV0LmluZGV4ICE9PSAnbnVtYmVyJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZGRpbmcgaW5wdXQuJyk7XG4gICAgfVxuICAgIGNvbnN0IGhhc2ggPVxuICAgICAgdHlwZW9mIGlucHV0Lmhhc2ggPT09ICdzdHJpbmcnXG4gICAgICAgID8gKDAsIGJ1ZmZlcnV0aWxzXzEucmV2ZXJzZUJ1ZmZlcikoQnVmZmVyLmZyb20oaW5wdXQuaGFzaCwgJ2hleCcpKVxuICAgICAgICA6IGlucHV0Lmhhc2g7XG4gICAgdGhpcy50eC5hZGRJbnB1dChoYXNoLCBpbnB1dC5pbmRleCwgaW5wdXQuc2VxdWVuY2UpO1xuICB9XG4gIGFkZE91dHB1dChvdXRwdXQpIHtcbiAgICBpZiAoXG4gICAgICBvdXRwdXQuc2NyaXB0ID09PSB1bmRlZmluZWQgfHxcbiAgICAgIG91dHB1dC52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAhQnVmZmVyLmlzQnVmZmVyKG91dHB1dC5zY3JpcHQpIHx8XG4gICAgICB0eXBlb2Ygb3V0cHV0LnZhbHVlICE9PSAnbnVtYmVyJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZGRpbmcgb3V0cHV0LicpO1xuICAgIH1cbiAgICB0aGlzLnR4LmFkZE91dHB1dChvdXRwdXQuc2NyaXB0LCBvdXRwdXQudmFsdWUpO1xuICB9XG4gIHRvQnVmZmVyKCkge1xuICAgIHJldHVybiB0aGlzLnR4LnRvQnVmZmVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbkZpbmFsaXplKGlucHV0LCBzY3JpcHQsIHNjcmlwdFR5cGUpIHtcbiAgc3dpdGNoIChzY3JpcHRUeXBlKSB7XG4gICAgY2FzZSAncHVia2V5JzpcbiAgICBjYXNlICdwdWJrZXloYXNoJzpcbiAgICBjYXNlICd3aXRuZXNzcHVia2V5aGFzaCc6XG4gICAgICByZXR1cm4gaGFzU2lncygxLCBpbnB1dC5wYXJ0aWFsU2lnKTtcbiAgICBjYXNlICdtdWx0aXNpZyc6XG4gICAgICBjb25zdCBwMm1zID0gcGF5bWVudHMucDJtcyh7IG91dHB1dDogc2NyaXB0IH0pO1xuICAgICAgcmV0dXJuIGhhc1NpZ3MocDJtcy5tLCBpbnB1dC5wYXJ0aWFsU2lnLCBwMm1zLnB1YmtleXMpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQ2FjaGUoY2FjaGUpIHtcbiAgaWYgKGNhY2hlLl9fVU5TQUZFX1NJR05fTk9OU0VHV0lUICE9PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IEJJUDE3NCBjb21wbGlhbnQsIGNhbiBub3QgZXhwb3J0Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc1NpZ3MobmVlZGVkU2lncywgcGFydGlhbFNpZywgcHVia2V5cykge1xuICBpZiAoIXBhcnRpYWxTaWcpIHJldHVybiBmYWxzZTtcbiAgbGV0IHNpZ3M7XG4gIGlmIChwdWJrZXlzKSB7XG4gICAgc2lncyA9IHB1YmtleXNcbiAgICAgIC5tYXAocGtleSA9PiB7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IGNvbXByZXNzUHVia2V5KHBrZXkpO1xuICAgICAgICByZXR1cm4gcGFydGlhbFNpZy5maW5kKHBTaWcgPT4gcFNpZy5wdWJrZXkuZXF1YWxzKHB1YmtleSkpO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIodiA9PiAhIXYpO1xuICB9IGVsc2Uge1xuICAgIHNpZ3MgPSBwYXJ0aWFsU2lnO1xuICB9XG4gIGlmIChzaWdzLmxlbmd0aCA+IG5lZWRlZFNpZ3MpIHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgc2lnbmF0dXJlcycpO1xuICByZXR1cm4gc2lncy5sZW5ndGggPT09IG5lZWRlZFNpZ3M7XG59XG5mdW5jdGlvbiBpc0ZpbmFsaXplZChpbnB1dCkge1xuICByZXR1cm4gISFpbnB1dC5maW5hbFNjcmlwdFNpZyB8fCAhIWlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcztcbn1cbmZ1bmN0aW9uIGJpcDMyRGVyaXZhdGlvbklzTWluZShyb290KSB7XG4gIHJldHVybiBkID0+IHtcbiAgICBpZiAoIWQubWFzdGVyRmluZ2VycHJpbnQuZXF1YWxzKHJvb3QuZmluZ2VycHJpbnQpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFyb290LmRlcml2ZVBhdGgoZC5wYXRoKS5wdWJsaWNLZXkuZXF1YWxzKGQucHVia2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gY2hlY2szMkJpdChudW0pIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBudW0gIT09ICdudW1iZXInIHx8XG4gICAgbnVtICE9PSBNYXRoLmZsb29yKG51bSkgfHxcbiAgICBudW0gPiAweGZmZmZmZmZmIHx8XG4gICAgbnVtIDwgMFxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgMzIgYml0IGludGVnZXInKTtcbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tGZWVzKHBzYnQsIGNhY2hlLCBvcHRzKSB7XG4gIGNvbnN0IGZlZVJhdGUgPSBjYWNoZS5fX0ZFRV9SQVRFIHx8IHBzYnQuZ2V0RmVlUmF0ZSgpO1xuICBjb25zdCB2c2l6ZSA9IGNhY2hlLl9fRVhUUkFDVEVEX1RYLnZpcnR1YWxTaXplKCk7XG4gIGNvbnN0IHNhdG9zaGlzID0gZmVlUmF0ZSAqIHZzaXplO1xuICBpZiAoZmVlUmF0ZSA+PSBvcHRzLm1heGltdW1GZWVSYXRlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFdhcm5pbmc6IFlvdSBhcmUgcGF5aW5nIGFyb3VuZCAkeyhzYXRvc2hpcyAvIDFlOCkudG9GaXhlZCg4KX0gaW4gYCArXG4gICAgICAgIGBmZWVzLCB3aGljaCBpcyAke2ZlZVJhdGV9IHNhdG9zaGkgcGVyIGJ5dGUgZm9yIGEgdHJhbnNhY3Rpb24gYCArXG4gICAgICAgIGB3aXRoIGEgVlNpemUgb2YgJHt2c2l6ZX0gYnl0ZXMgKHNlZ3dpdCBjb3VudGVkIGFzIDAuMjUgYnl0ZSBwZXIgYCArXG4gICAgICAgIGBieXRlKS4gVXNlIHNldE1heGltdW1GZWVSYXRlIG1ldGhvZCB0byByYWlzZSB5b3VyIHRocmVzaG9sZCwgb3IgYCArXG4gICAgICAgIGBwYXNzIHRydWUgdG8gdGhlIGZpcnN0IGFyZyBvZiBleHRyYWN0VHJhbnNhY3Rpb24uYCxcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja0lucHV0c0ZvclBhcnRpYWxTaWcoaW5wdXRzLCBhY3Rpb24pIHtcbiAgaW5wdXRzLmZvckVhY2goaW5wdXQgPT4ge1xuICAgIGNvbnN0IHRocm93cyA9ICgwLCBiaXAzNzFfMS5pc1RhcHJvb3RJbnB1dCkoaW5wdXQpXG4gICAgICA/ICgwLCBiaXAzNzFfMS5jaGVja1RhcHJvb3RJbnB1dEZvclNpZ3MpKGlucHV0LCBhY3Rpb24pXG4gICAgICA6ICgwLCBwc2J0dXRpbHNfMS5jaGVja0lucHV0Rm9yU2lnKShpbnB1dCwgYWN0aW9uKTtcbiAgICBpZiAodGhyb3dzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IG1vZGlmeSB0cmFuc2FjdGlvbiwgc2lnbmF0dXJlcyBleGlzdC4nKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjaGVja1BhcnRpYWxTaWdTaWdoYXNoZXMoaW5wdXQpIHtcbiAgaWYgKCFpbnB1dC5zaWdoYXNoVHlwZSB8fCAhaW5wdXQucGFydGlhbFNpZykgcmV0dXJuO1xuICBjb25zdCB7IHBhcnRpYWxTaWcsIHNpZ2hhc2hUeXBlIH0gPSBpbnB1dDtcbiAgcGFydGlhbFNpZy5mb3JFYWNoKHBTaWcgPT4ge1xuICAgIGNvbnN0IHsgaGFzaFR5cGUgfSA9IGJzY3JpcHQuc2lnbmF0dXJlLmRlY29kZShwU2lnLnNpZ25hdHVyZSk7XG4gICAgaWYgKHNpZ2hhc2hUeXBlICE9PSBoYXNoVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaWduYXR1cmUgc2lnaGFzaCBkb2VzIG5vdCBtYXRjaCBpbnB1dCBzaWdoYXNoIHR5cGUnKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tTY3JpcHRGb3JQdWJrZXkocHVia2V5LCBzY3JpcHQsIGFjdGlvbikge1xuICBpZiAoISgwLCBwc2J0dXRpbHNfMS5wdWJrZXlJblNjcmlwdCkocHVia2V5LCBzY3JpcHQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbiBub3QgJHthY3Rpb259IGZvciB0aGlzIGlucHV0IHdpdGggdGhlIGtleSAke3B1YmtleS50b1N0cmluZygnaGV4Jyl9YCxcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja1R4RW1wdHkodHgpIHtcbiAgY29uc3QgaXNFbXB0eSA9IHR4Lmlucy5ldmVyeShcbiAgICBpbnB1dCA9PlxuICAgICAgaW5wdXQuc2NyaXB0ICYmXG4gICAgICBpbnB1dC5zY3JpcHQubGVuZ3RoID09PSAwICYmXG4gICAgICBpbnB1dC53aXRuZXNzICYmXG4gICAgICBpbnB1dC53aXRuZXNzLmxlbmd0aCA9PT0gMCxcbiAgKTtcbiAgaWYgKCFpc0VtcHR5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3JtYXQgRXJyb3I6IFRyYW5zYWN0aW9uIFNjcmlwdFNpZ3MgYXJlIG5vdCBlbXB0eScpO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja1R4Rm9yRHVwZUlucyh0eCwgY2FjaGUpIHtcbiAgdHguaW5zLmZvckVhY2goaW5wdXQgPT4ge1xuICAgIGNoZWNrVHhJbnB1dENhY2hlKGNhY2hlLCBpbnB1dCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tUeElucHV0Q2FjaGUoY2FjaGUsIGlucHV0KSB7XG4gIGNvbnN0IGtleSA9XG4gICAgKDAsIGJ1ZmZlcnV0aWxzXzEucmV2ZXJzZUJ1ZmZlcikoQnVmZmVyLmZyb20oaW5wdXQuaGFzaCkpLnRvU3RyaW5nKCdoZXgnKSArXG4gICAgJzonICtcbiAgICBpbnB1dC5pbmRleDtcbiAgaWYgKGNhY2hlLl9fVFhfSU5fQ0FDSEVba2V5XSkgdGhyb3cgbmV3IEVycm9yKCdEdXBsaWNhdGUgaW5wdXQgZGV0ZWN0ZWQuJyk7XG4gIGNhY2hlLl9fVFhfSU5fQ0FDSEVba2V5XSA9IDE7XG59XG5mdW5jdGlvbiBzY3JpcHRDaGVja2VyRmFjdG9yeShwYXltZW50LCBwYXltZW50U2NyaXB0TmFtZSkge1xuICByZXR1cm4gKGlucHV0SW5kZXgsIHNjcmlwdFB1YktleSwgcmVkZWVtU2NyaXB0LCBpb1R5cGUpID0+IHtcbiAgICBjb25zdCByZWRlZW1TY3JpcHRPdXRwdXQgPSBwYXltZW50KHtcbiAgICAgIHJlZGVlbTogeyBvdXRwdXQ6IHJlZGVlbVNjcmlwdCB9LFxuICAgIH0pLm91dHB1dDtcbiAgICBpZiAoIXNjcmlwdFB1YktleS5lcXVhbHMocmVkZWVtU2NyaXB0T3V0cHV0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtwYXltZW50U2NyaXB0TmFtZX0gZm9yICR7aW9UeXBlfSAjJHtpbnB1dEluZGV4fSBkb2Vzbid0IG1hdGNoIHRoZSBzY3JpcHRQdWJLZXkgaW4gdGhlIHByZXZvdXRgLFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBjaGVja1JlZGVlbVNjcmlwdCA9IHNjcmlwdENoZWNrZXJGYWN0b3J5KHBheW1lbnRzLnAyc2gsICdSZWRlZW0gc2NyaXB0Jyk7XG5jb25zdCBjaGVja1dpdG5lc3NTY3JpcHQgPSBzY3JpcHRDaGVja2VyRmFjdG9yeShcbiAgcGF5bWVudHMucDJ3c2gsXG4gICdXaXRuZXNzIHNjcmlwdCcsXG4pO1xuZnVuY3Rpb24gZ2V0VHhDYWNoZVZhbHVlKGtleSwgbmFtZSwgaW5wdXRzLCBjKSB7XG4gIGlmICghaW5wdXRzLmV2ZXJ5KGlzRmluYWxpemVkKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFBTQlQgbXVzdCBiZSBmaW5hbGl6ZWQgdG8gY2FsY3VsYXRlICR7bmFtZX1gKTtcbiAgaWYgKGtleSA9PT0gJ19fRkVFX1JBVEUnICYmIGMuX19GRUVfUkFURSkgcmV0dXJuIGMuX19GRUVfUkFURTtcbiAgaWYgKGtleSA9PT0gJ19fRkVFJyAmJiBjLl9fRkVFKSByZXR1cm4gYy5fX0ZFRTtcbiAgbGV0IHR4O1xuICBsZXQgbXVzdEZpbmFsaXplID0gdHJ1ZTtcbiAgaWYgKGMuX19FWFRSQUNURURfVFgpIHtcbiAgICB0eCA9IGMuX19FWFRSQUNURURfVFg7XG4gICAgbXVzdEZpbmFsaXplID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdHggPSBjLl9fVFguY2xvbmUoKTtcbiAgfVxuICBpbnB1dEZpbmFsaXplR2V0QW10cyhpbnB1dHMsIHR4LCBjLCBtdXN0RmluYWxpemUpO1xuICBpZiAoa2V5ID09PSAnX19GRUVfUkFURScpIHJldHVybiBjLl9fRkVFX1JBVEU7XG4gIGVsc2UgaWYgKGtleSA9PT0gJ19fRkVFJykgcmV0dXJuIGMuX19GRUU7XG59XG5mdW5jdGlvbiBnZXRGaW5hbFNjcmlwdHMoaW5wdXRJbmRleCwgaW5wdXQsIHNjcmlwdCwgaXNTZWd3aXQsIGlzUDJTSCwgaXNQMldTSCkge1xuICBjb25zdCBzY3JpcHRUeXBlID0gY2xhc3NpZnlTY3JpcHQoc2NyaXB0KTtcbiAgaWYgKCFjYW5GaW5hbGl6ZShpbnB1dCwgc2NyaXB0LCBzY3JpcHRUeXBlKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbiBub3QgZmluYWxpemUgaW5wdXQgIyR7aW5wdXRJbmRleH1gKTtcbiAgcmV0dXJuIHByZXBhcmVGaW5hbFNjcmlwdHMoXG4gICAgc2NyaXB0LFxuICAgIHNjcmlwdFR5cGUsXG4gICAgaW5wdXQucGFydGlhbFNpZyxcbiAgICBpc1NlZ3dpdCxcbiAgICBpc1AyU0gsXG4gICAgaXNQMldTSCxcbiAgKTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVGaW5hbFNjcmlwdHMoXG4gIHNjcmlwdCxcbiAgc2NyaXB0VHlwZSxcbiAgcGFydGlhbFNpZyxcbiAgaXNTZWd3aXQsXG4gIGlzUDJTSCxcbiAgaXNQMldTSCxcbikge1xuICBsZXQgZmluYWxTY3JpcHRTaWc7XG4gIGxldCBmaW5hbFNjcmlwdFdpdG5lc3M7XG4gIC8vIFdvdywgdGhlIHBheW1lbnRzIEFQSSBpcyB2ZXJ5IGhhbmR5XG4gIGNvbnN0IHBheW1lbnQgPSBnZXRQYXltZW50KHNjcmlwdCwgc2NyaXB0VHlwZSwgcGFydGlhbFNpZyk7XG4gIGNvbnN0IHAyd3NoID0gIWlzUDJXU0ggPyBudWxsIDogcGF5bWVudHMucDJ3c2goeyByZWRlZW06IHBheW1lbnQgfSk7XG4gIGNvbnN0IHAyc2ggPSAhaXNQMlNIID8gbnVsbCA6IHBheW1lbnRzLnAyc2goeyByZWRlZW06IHAyd3NoIHx8IHBheW1lbnQgfSk7XG4gIGlmIChpc1NlZ3dpdCkge1xuICAgIGlmIChwMndzaCkge1xuICAgICAgZmluYWxTY3JpcHRXaXRuZXNzID0gKDAsIHBzYnR1dGlsc18xLndpdG5lc3NTdGFja1RvU2NyaXB0V2l0bmVzcykoXG4gICAgICAgIHAyd3NoLndpdG5lc3MsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5hbFNjcmlwdFdpdG5lc3MgPSAoMCwgcHNidHV0aWxzXzEud2l0bmVzc1N0YWNrVG9TY3JpcHRXaXRuZXNzKShcbiAgICAgICAgcGF5bWVudC53aXRuZXNzLFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHAyc2gpIHtcbiAgICAgIGZpbmFsU2NyaXB0U2lnID0gcDJzaC5pbnB1dDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHAyc2gpIHtcbiAgICAgIGZpbmFsU2NyaXB0U2lnID0gcDJzaC5pbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluYWxTY3JpcHRTaWcgPSBwYXltZW50LmlucHV0O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGZpbmFsU2NyaXB0U2lnLFxuICAgIGZpbmFsU2NyaXB0V2l0bmVzcyxcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEhhc2hBbmRTaWdoYXNoVHlwZShcbiAgaW5wdXRzLFxuICBpbnB1dEluZGV4LFxuICBwdWJrZXksXG4gIGNhY2hlLFxuICBzaWdoYXNoVHlwZXMsXG4pIHtcbiAgY29uc3QgaW5wdXQgPSAoMCwgdXRpbHNfMS5jaGVja0ZvcklucHV0KShpbnB1dHMsIGlucHV0SW5kZXgpO1xuICBjb25zdCB7IGhhc2gsIHNpZ2hhc2hUeXBlLCBzY3JpcHQgfSA9IGdldEhhc2hGb3JTaWcoXG4gICAgaW5wdXRJbmRleCxcbiAgICBpbnB1dCxcbiAgICBjYWNoZSxcbiAgICBmYWxzZSxcbiAgICBzaWdoYXNoVHlwZXMsXG4gICk7XG4gIGNoZWNrU2NyaXB0Rm9yUHVia2V5KHB1YmtleSwgc2NyaXB0LCAnc2lnbicpO1xuICByZXR1cm4ge1xuICAgIGhhc2gsXG4gICAgc2lnaGFzaFR5cGUsXG4gIH07XG59XG5mdW5jdGlvbiBnZXRIYXNoRm9yU2lnKGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSwgZm9yVmFsaWRhdGUsIHNpZ2hhc2hUeXBlcykge1xuICBjb25zdCB1bnNpZ25lZFR4ID0gY2FjaGUuX19UWDtcbiAgY29uc3Qgc2lnaGFzaFR5cGUgPVxuICAgIGlucHV0LnNpZ2hhc2hUeXBlIHx8IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTEw7XG4gIGNoZWNrU2lnaGFzaFR5cGVBbGxvd2VkKHNpZ2hhc2hUeXBlLCBzaWdoYXNoVHlwZXMpO1xuICBsZXQgaGFzaDtcbiAgbGV0IHByZXZvdXQ7XG4gIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4bykge1xuICAgIGNvbnN0IG5vbldpdG5lc3NVdHhvVHggPSBub25XaXRuZXNzVXR4b1R4RnJvbUNhY2hlKFxuICAgICAgY2FjaGUsXG4gICAgICBpbnB1dCxcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgKTtcbiAgICBjb25zdCBwcmV2b3V0SGFzaCA9IHVuc2lnbmVkVHguaW5zW2lucHV0SW5kZXhdLmhhc2g7XG4gICAgY29uc3QgdXR4b0hhc2ggPSBub25XaXRuZXNzVXR4b1R4LmdldEhhc2goKTtcbiAgICAvLyBJZiBhIG5vbi13aXRuZXNzIFVUWE8gaXMgcHJvdmlkZWQsIGl0cyBoYXNoIG11c3QgbWF0Y2ggdGhlIGhhc2ggc3BlY2lmaWVkIGluIHRoZSBwcmV2b3V0XG4gICAgaWYgKCFwcmV2b3V0SGFzaC5lcXVhbHModXR4b0hhc2gpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBOb24td2l0bmVzcyBVVFhPIGhhc2ggZm9yIGlucHV0ICMke2lucHV0SW5kZXh9IGRvZXNuJ3QgbWF0Y2ggdGhlIGhhc2ggc3BlY2lmaWVkIGluIHRoZSBwcmV2b3V0YCxcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHByZXZvdXRJbmRleCA9IHVuc2lnbmVkVHguaW5zW2lucHV0SW5kZXhdLmluZGV4O1xuICAgIHByZXZvdXQgPSBub25XaXRuZXNzVXR4b1R4Lm91dHNbcHJldm91dEluZGV4XTtcbiAgfSBlbHNlIGlmIChpbnB1dC53aXRuZXNzVXR4bykge1xuICAgIHByZXZvdXQgPSBpbnB1dC53aXRuZXNzVXR4bztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgYSBVdHhvIGlucHV0IGl0ZW0gZm9yIHNpZ25pbmcnKTtcbiAgfVxuICBjb25zdCB7IG1lYW5pbmdmdWxTY3JpcHQsIHR5cGUgfSA9IGdldE1lYW5pbmdmdWxTY3JpcHQoXG4gICAgcHJldm91dC5zY3JpcHQsXG4gICAgaW5wdXRJbmRleCxcbiAgICAnaW5wdXQnLFxuICAgIGlucHV0LnJlZGVlbVNjcmlwdCxcbiAgICBpbnB1dC53aXRuZXNzU2NyaXB0LFxuICApO1xuICBpZiAoWydwMnNoLXAyd3NoJywgJ3Ayd3NoJ10uaW5kZXhPZih0eXBlKSA+PSAwKSB7XG4gICAgaGFzaCA9IHVuc2lnbmVkVHguaGFzaEZvcldpdG5lc3NWMChcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgICBtZWFuaW5nZnVsU2NyaXB0LFxuICAgICAgcHJldm91dC52YWx1ZSxcbiAgICAgIHNpZ2hhc2hUeXBlLFxuICAgICk7XG4gIH0gZWxzZSBpZiAoKDAsIHBzYnR1dGlsc18xLmlzUDJXUEtIKShtZWFuaW5nZnVsU2NyaXB0KSkge1xuICAgIC8vIFAyV1BLSCB1c2VzIHRoZSBQMlBLSCB0ZW1wbGF0ZSBmb3IgcHJldm91dFNjcmlwdCB3aGVuIHNpZ25pbmdcbiAgICBjb25zdCBzaWduaW5nU2NyaXB0ID0gcGF5bWVudHMucDJwa2goe1xuICAgICAgaGFzaDogbWVhbmluZ2Z1bFNjcmlwdC5zbGljZSgyKSxcbiAgICB9KS5vdXRwdXQ7XG4gICAgaGFzaCA9IHVuc2lnbmVkVHguaGFzaEZvcldpdG5lc3NWMChcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgICBzaWduaW5nU2NyaXB0LFxuICAgICAgcHJldm91dC52YWx1ZSxcbiAgICAgIHNpZ2hhc2hUeXBlLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9uLXNlZ3dpdFxuICAgIGlmIChcbiAgICAgIGlucHV0Lm5vbldpdG5lc3NVdHhvID09PSB1bmRlZmluZWQgJiZcbiAgICAgIGNhY2hlLl9fVU5TQUZFX1NJR05fTk9OU0VHV0lUID09PSBmYWxzZVxuICAgIClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYElucHV0ICMke2lucHV0SW5kZXh9IGhhcyB3aXRuZXNzVXR4byBidXQgbm9uLXNlZ3dpdCBzY3JpcHQ6IGAgK1xuICAgICAgICAgIGAke21lYW5pbmdmdWxTY3JpcHQudG9TdHJpbmcoJ2hleCcpfWAsXG4gICAgICApO1xuICAgIGlmICghZm9yVmFsaWRhdGUgJiYgY2FjaGUuX19VTlNBRkVfU0lHTl9OT05TRUdXSVQgIT09IGZhbHNlKVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnV2FybmluZzogU2lnbmluZyBub24tc2Vnd2l0IGlucHV0cyB3aXRob3V0IHRoZSBmdWxsIHBhcmVudCB0cmFuc2FjdGlvbiAnICtcbiAgICAgICAgICAnbWVhbnMgdGhlcmUgaXMgYSBjaGFuY2UgdGhhdCBhIG1pbmVyIGNvdWxkIGZlZWQgeW91IGluY29ycmVjdCBpbmZvcm1hdGlvbiAnICtcbiAgICAgICAgICBcInRvIHRyaWNrIHlvdSBpbnRvIHBheWluZyBsYXJnZSBmZWVzLiBUaGlzIGJlaGF2aW9yIGlzIHRoZSBzYW1lIGFzIFBzYnQncyBwcmVkZWNlc3NvciBcIiArXG4gICAgICAgICAgJyhUcmFuc2FjdGlvbkJ1aWxkZXIgLSBub3cgcmVtb3ZlZCkgd2hlbiBzaWduaW5nIG5vbi1zZWd3aXQgc2NyaXB0cy4gWW91IGFyZSBub3QgJyArXG4gICAgICAgICAgJ2FibGUgdG8gZXhwb3J0IHRoaXMgUHNidCB3aXRoIHRvQnVmZmVyfHRvQmFzZTY0fHRvSGV4IHNpbmNlIGl0IGlzIG5vdCAnICtcbiAgICAgICAgICAnQklQMTc0IGNvbXBsaWFudC5cXG4qKioqKioqKioqKioqKioqKioqKipcXG5QUk9DRUVEIFdJVEggQ0FVVElPTiFcXG4nICtcbiAgICAgICAgICAnKioqKioqKioqKioqKioqKioqKioqJyxcbiAgICAgICk7XG4gICAgaGFzaCA9IHVuc2lnbmVkVHguaGFzaEZvclNpZ25hdHVyZShcbiAgICAgIGlucHV0SW5kZXgsXG4gICAgICBtZWFuaW5nZnVsU2NyaXB0LFxuICAgICAgc2lnaGFzaFR5cGUsXG4gICAgKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjcmlwdDogbWVhbmluZ2Z1bFNjcmlwdCxcbiAgICBzaWdoYXNoVHlwZSxcbiAgICBoYXNoLFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QWxsVGFwcm9vdEhhc2hlc0ZvclNpZyhpbnB1dEluZGV4LCBpbnB1dCwgaW5wdXRzLCBjYWNoZSkge1xuICBjb25zdCBhbGxQdWJsaWNLZXlzID0gW107XG4gIGlmIChpbnB1dC50YXBJbnRlcm5hbEtleSkge1xuICAgIGNvbnN0IGtleSA9IGdldFByZXZvdXRUYXByb290S2V5KGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSk7XG4gICAgaWYgKGtleSkge1xuICAgICAgYWxsUHVibGljS2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIGlmIChpbnB1dC50YXBTY3JpcHRTaWcpIHtcbiAgICBjb25zdCB0YXBTY3JpcHRQdWJrZXlzID0gaW5wdXQudGFwU2NyaXB0U2lnLm1hcCh0c3MgPT4gdHNzLnB1YmtleSk7XG4gICAgYWxsUHVibGljS2V5cy5wdXNoKC4uLnRhcFNjcmlwdFB1YmtleXMpO1xuICB9XG4gIGNvbnN0IGFsbEhhc2hlcyA9IGFsbFB1YmxpY0tleXMubWFwKHB1YmljS2V5ID0+XG4gICAgZ2V0VGFwcm9vdEhhc2hlc0ZvclNpZyhpbnB1dEluZGV4LCBpbnB1dCwgaW5wdXRzLCBwdWJpY0tleSwgY2FjaGUpLFxuICApO1xuICByZXR1cm4gYWxsSGFzaGVzLmZsYXQoKTtcbn1cbmZ1bmN0aW9uIGdldFByZXZvdXRUYXByb290S2V5KGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSkge1xuICBjb25zdCB7IHNjcmlwdCB9ID0gZ2V0U2NyaXB0QW5kQW1vdW50RnJvbVV0eG8oaW5wdXRJbmRleCwgaW5wdXQsIGNhY2hlKTtcbiAgcmV0dXJuICgwLCBwc2J0dXRpbHNfMS5pc1AyVFIpKHNjcmlwdCkgPyBzY3JpcHQuc3ViYXJyYXkoMiwgMzQpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIHRyaW1UYXByb290U2lnKHNpZ25hdHVyZSkge1xuICByZXR1cm4gc2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQgPyBzaWduYXR1cmUgOiBzaWduYXR1cmUuc3ViYXJyYXkoMCwgNjQpO1xufVxuZnVuY3Rpb24gZ2V0VGFwcm9vdEhhc2hlc0ZvclNpZyhcbiAgaW5wdXRJbmRleCxcbiAgaW5wdXQsXG4gIGlucHV0cyxcbiAgcHVia2V5LFxuICBjYWNoZSxcbiAgdGFwTGVhZkhhc2hUb1NpZ24sXG4gIGFsbG93ZWRTaWdoYXNoVHlwZXMsXG4pIHtcbiAgY29uc3QgdW5zaWduZWRUeCA9IGNhY2hlLl9fVFg7XG4gIGNvbnN0IHNpZ2hhc2hUeXBlID1cbiAgICBpbnB1dC5zaWdoYXNoVHlwZSB8fCB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVDtcbiAgY2hlY2tTaWdoYXNoVHlwZUFsbG93ZWQoc2lnaGFzaFR5cGUsIGFsbG93ZWRTaWdoYXNoVHlwZXMpO1xuICBjb25zdCBwcmV2T3V0cyA9IGlucHV0cy5tYXAoKGksIGluZGV4KSA9PlxuICAgIGdldFNjcmlwdEFuZEFtb3VudEZyb21VdHhvKGluZGV4LCBpLCBjYWNoZSksXG4gICk7XG4gIGNvbnN0IHNpZ25pbmdTY3JpcHRzID0gcHJldk91dHMubWFwKG8gPT4gby5zY3JpcHQpO1xuICBjb25zdCB2YWx1ZXMgPSBwcmV2T3V0cy5tYXAobyA9PiBvLnZhbHVlKTtcbiAgY29uc3QgaGFzaGVzID0gW107XG4gIGlmIChpbnB1dC50YXBJbnRlcm5hbEtleSAmJiAhdGFwTGVhZkhhc2hUb1NpZ24pIHtcbiAgICBjb25zdCBvdXRwdXRLZXkgPVxuICAgICAgZ2V0UHJldm91dFRhcHJvb3RLZXkoaW5wdXRJbmRleCwgaW5wdXQsIGNhY2hlKSB8fCBCdWZmZXIuZnJvbShbXSk7XG4gICAgaWYgKCgwLCBiaXAzNzFfMS50b1hPbmx5KShwdWJrZXkpLmVxdWFscyhvdXRwdXRLZXkpKSB7XG4gICAgICBjb25zdCB0YXBLZXlIYXNoID0gdW5zaWduZWRUeC5oYXNoRm9yV2l0bmVzc1YxKFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgICBzaWduaW5nU2NyaXB0cyxcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBzaWdoYXNoVHlwZSxcbiAgICAgICk7XG4gICAgICBoYXNoZXMucHVzaCh7IHB1YmtleSwgaGFzaDogdGFwS2V5SGFzaCB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgdGFwTGVhZkhhc2hlcyA9IChpbnB1dC50YXBMZWFmU2NyaXB0IHx8IFtdKVxuICAgIC5maWx0ZXIodGFwTGVhZiA9PiAoMCwgcHNidHV0aWxzXzEucHVia2V5SW5TY3JpcHQpKHB1YmtleSwgdGFwTGVhZi5zY3JpcHQpKVxuICAgIC5tYXAodGFwTGVhZiA9PiB7XG4gICAgICBjb25zdCBoYXNoID0gKDAsIGJpcDM0MV8xLnRhcGxlYWZIYXNoKSh7XG4gICAgICAgIG91dHB1dDogdGFwTGVhZi5zY3JpcHQsXG4gICAgICAgIHZlcnNpb246IHRhcExlYWYubGVhZlZlcnNpb24sXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgaGFzaCB9LCB0YXBMZWFmKTtcbiAgICB9KVxuICAgIC5maWx0ZXIoXG4gICAgICB0YXBMZWFmID0+ICF0YXBMZWFmSGFzaFRvU2lnbiB8fCB0YXBMZWFmSGFzaFRvU2lnbi5lcXVhbHModGFwTGVhZi5oYXNoKSxcbiAgICApXG4gICAgLm1hcCh0YXBMZWFmID0+IHtcbiAgICAgIGNvbnN0IHRhcFNjcmlwdEhhc2ggPSB1bnNpZ25lZFR4Lmhhc2hGb3JXaXRuZXNzVjEoXG4gICAgICAgIGlucHV0SW5kZXgsXG4gICAgICAgIHNpZ25pbmdTY3JpcHRzLFxuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIHNpZ2hhc2hUeXBlLFxuICAgICAgICB0YXBMZWFmLmhhc2gsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHVia2V5LFxuICAgICAgICBoYXNoOiB0YXBTY3JpcHRIYXNoLFxuICAgICAgICBsZWFmSGFzaDogdGFwTGVhZi5oYXNoLFxuICAgICAgfTtcbiAgICB9KTtcbiAgcmV0dXJuIGhhc2hlcy5jb25jYXQodGFwTGVhZkhhc2hlcyk7XG59XG5mdW5jdGlvbiBjaGVja1NpZ2hhc2hUeXBlQWxsb3dlZChzaWdoYXNoVHlwZSwgc2lnaGFzaFR5cGVzKSB7XG4gIGlmIChzaWdoYXNoVHlwZXMgJiYgc2lnaGFzaFR5cGVzLmluZGV4T2Yoc2lnaGFzaFR5cGUpIDwgMCkge1xuICAgIGNvbnN0IHN0ciA9IHNpZ2hhc2hUeXBlVG9TdHJpbmcoc2lnaGFzaFR5cGUpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBTaWdoYXNoIHR5cGUgaXMgbm90IGFsbG93ZWQuIFJldHJ5IHRoZSBzaWduIG1ldGhvZCBwYXNzaW5nIHRoZSBgICtcbiAgICAgICAgYHNpZ2hhc2hUeXBlcyBhcnJheSBvZiB3aGl0ZWxpc3RlZCB0eXBlcy4gU2lnaGFzaCB0eXBlOiAke3N0cn1gLFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFBheW1lbnQoc2NyaXB0LCBzY3JpcHRUeXBlLCBwYXJ0aWFsU2lnKSB7XG4gIGxldCBwYXltZW50O1xuICBzd2l0Y2ggKHNjcmlwdFR5cGUpIHtcbiAgICBjYXNlICdtdWx0aXNpZyc6XG4gICAgICBjb25zdCBzaWdzID0gZ2V0U29ydGVkU2lncyhzY3JpcHQsIHBhcnRpYWxTaWcpO1xuICAgICAgcGF5bWVudCA9IHBheW1lbnRzLnAybXMoe1xuICAgICAgICBvdXRwdXQ6IHNjcmlwdCxcbiAgICAgICAgc2lnbmF0dXJlczogc2lncyxcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHVia2V5JzpcbiAgICAgIHBheW1lbnQgPSBwYXltZW50cy5wMnBrKHtcbiAgICAgICAgb3V0cHV0OiBzY3JpcHQsXG4gICAgICAgIHNpZ25hdHVyZTogcGFydGlhbFNpZ1swXS5zaWduYXR1cmUsXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3B1YmtleWhhc2gnOlxuICAgICAgcGF5bWVudCA9IHBheW1lbnRzLnAycGtoKHtcbiAgICAgICAgb3V0cHV0OiBzY3JpcHQsXG4gICAgICAgIHB1YmtleTogcGFydGlhbFNpZ1swXS5wdWJrZXksXG4gICAgICAgIHNpZ25hdHVyZTogcGFydGlhbFNpZ1swXS5zaWduYXR1cmUsXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3dpdG5lc3NwdWJrZXloYXNoJzpcbiAgICAgIHBheW1lbnQgPSBwYXltZW50cy5wMndwa2goe1xuICAgICAgICBvdXRwdXQ6IHNjcmlwdCxcbiAgICAgICAgcHVia2V5OiBwYXJ0aWFsU2lnWzBdLnB1YmtleSxcbiAgICAgICAgc2lnbmF0dXJlOiBwYXJ0aWFsU2lnWzBdLnNpZ25hdHVyZSxcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHBheW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRTY3JpcHRGcm9tSW5wdXQoaW5wdXRJbmRleCwgaW5wdXQsIGNhY2hlKSB7XG4gIGNvbnN0IHVuc2lnbmVkVHggPSBjYWNoZS5fX1RYO1xuICBjb25zdCByZXMgPSB7XG4gICAgc2NyaXB0OiBudWxsLFxuICAgIGlzU2Vnd2l0OiBmYWxzZSxcbiAgICBpc1AyU0g6IGZhbHNlLFxuICAgIGlzUDJXU0g6IGZhbHNlLFxuICB9O1xuICByZXMuaXNQMlNIID0gISFpbnB1dC5yZWRlZW1TY3JpcHQ7XG4gIHJlcy5pc1AyV1NIID0gISFpbnB1dC53aXRuZXNzU2NyaXB0O1xuICBpZiAoaW5wdXQud2l0bmVzc1NjcmlwdCkge1xuICAgIHJlcy5zY3JpcHQgPSBpbnB1dC53aXRuZXNzU2NyaXB0O1xuICB9IGVsc2UgaWYgKGlucHV0LnJlZGVlbVNjcmlwdCkge1xuICAgIHJlcy5zY3JpcHQgPSBpbnB1dC5yZWRlZW1TY3JpcHQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlucHV0Lm5vbldpdG5lc3NVdHhvKSB7XG4gICAgICBjb25zdCBub25XaXRuZXNzVXR4b1R4ID0gbm9uV2l0bmVzc1V0eG9UeEZyb21DYWNoZShcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGlucHV0LFxuICAgICAgICBpbnB1dEluZGV4LFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHByZXZvdXRJbmRleCA9IHVuc2lnbmVkVHguaW5zW2lucHV0SW5kZXhdLmluZGV4O1xuICAgICAgcmVzLnNjcmlwdCA9IG5vbldpdG5lc3NVdHhvVHgub3V0c1twcmV2b3V0SW5kZXhdLnNjcmlwdDtcbiAgICB9IGVsc2UgaWYgKGlucHV0LndpdG5lc3NVdHhvKSB7XG4gICAgICByZXMuc2NyaXB0ID0gaW5wdXQud2l0bmVzc1V0eG8uc2NyaXB0O1xuICAgIH1cbiAgfVxuICBpZiAoaW5wdXQud2l0bmVzc1NjcmlwdCB8fCAoMCwgcHNidHV0aWxzXzEuaXNQMldQS0gpKHJlcy5zY3JpcHQpKSB7XG4gICAgcmVzLmlzU2Vnd2l0ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2V0U2lnbmVyc0Zyb21IRChpbnB1dEluZGV4LCBpbnB1dHMsIGhkS2V5UGFpcikge1xuICBjb25zdCBpbnB1dCA9ICgwLCB1dGlsc18xLmNoZWNrRm9ySW5wdXQpKGlucHV0cywgaW5wdXRJbmRleCk7XG4gIGlmICghaW5wdXQuYmlwMzJEZXJpdmF0aW9uIHx8IGlucHV0LmJpcDMyRGVyaXZhdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgYmlwMzJEZXJpdmF0aW9uIHRvIHNpZ24gd2l0aCBIRCcpO1xuICB9XG4gIGNvbnN0IG15RGVyaXZhdGlvbnMgPSBpbnB1dC5iaXAzMkRlcml2YXRpb25cbiAgICAubWFwKGJpcER2ID0+IHtcbiAgICAgIGlmIChiaXBEdi5tYXN0ZXJGaW5nZXJwcmludC5lcXVhbHMoaGRLZXlQYWlyLmZpbmdlcnByaW50KSkge1xuICAgICAgICByZXR1cm4gYmlwRHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSlcbiAgICAuZmlsdGVyKHYgPT4gISF2KTtcbiAgaWYgKG15RGVyaXZhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ05lZWQgb25lIGJpcDMyRGVyaXZhdGlvbiBtYXN0ZXJGaW5nZXJwcmludCB0byBtYXRjaCB0aGUgSERTaWduZXIgZmluZ2VycHJpbnQnLFxuICAgICk7XG4gIH1cbiAgY29uc3Qgc2lnbmVycyA9IG15RGVyaXZhdGlvbnMubWFwKGJpcER2ID0+IHtcbiAgICBjb25zdCBub2RlID0gaGRLZXlQYWlyLmRlcml2ZVBhdGgoYmlwRHYucGF0aCk7XG4gICAgaWYgKCFiaXBEdi5wdWJrZXkuZXF1YWxzKG5vZGUucHVibGljS2V5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwdWJrZXkgZGlkIG5vdCBtYXRjaCBiaXAzMkRlcml2YXRpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0pO1xuICByZXR1cm4gc2lnbmVycztcbn1cbmZ1bmN0aW9uIGdldFNvcnRlZFNpZ3Moc2NyaXB0LCBwYXJ0aWFsU2lnKSB7XG4gIGNvbnN0IHAybXMgPSBwYXltZW50cy5wMm1zKHsgb3V0cHV0OiBzY3JpcHQgfSk7XG4gIC8vIGZvciBlYWNoIHB1YmtleSBpbiBvcmRlciBvZiBwMm1zIHNjcmlwdFxuICByZXR1cm4gcDJtcy5wdWJrZXlzXG4gICAgLm1hcChwayA9PiB7XG4gICAgICAvLyBmaWx0ZXIgcGFydGlhbFNpZyBhcnJheSBieSBwdWJrZXkgYmVpbmcgZXF1YWxcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBhcnRpYWxTaWcuZmlsdGVyKHBzID0+IHtcbiAgICAgICAgICByZXR1cm4gcHMucHVia2V5LmVxdWFscyhwayk7XG4gICAgICAgIH0pWzBdIHx8IHt9XG4gICAgICApLnNpZ25hdHVyZTtcbiAgICAgIC8vIEFueSBwdWJrZXkgd2l0aG91dCBhIG1hdGNoIHdpbGwgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgLy8gdGhpcyBsYXN0IGZpbHRlciByZW1vdmVzIGFsbCB0aGUgdW5kZWZpbmVkIGl0ZW1zIGluIHRoZSBhcnJheS5cbiAgICB9KVxuICAgIC5maWx0ZXIodiA9PiAhIXYpO1xufVxuZnVuY3Rpb24gc2NyaXB0V2l0bmVzc1RvV2l0bmVzc1N0YWNrKGJ1ZmZlcikge1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZnVuY3Rpb24gcmVhZFNsaWNlKG4pIHtcbiAgICBvZmZzZXQgKz0gbjtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKG9mZnNldCAtIG4sIG9mZnNldCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZFZhckludCgpIHtcbiAgICBjb25zdCB2aSA9IHZhcnVpbnQuZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gdmFydWludC5kZWNvZGUuYnl0ZXM7XG4gICAgcmV0dXJuIHZpO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWRWYXJTbGljZSgpIHtcbiAgICByZXR1cm4gcmVhZFNsaWNlKHJlYWRWYXJJbnQoKSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVhZFZlY3RvcigpIHtcbiAgICBjb25zdCBjb3VudCA9IHJlYWRWYXJJbnQoKTtcbiAgICBjb25zdCB2ZWN0b3IgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHZlY3Rvci5wdXNoKHJlYWRWYXJTbGljZSgpKTtcbiAgICByZXR1cm4gdmVjdG9yO1xuICB9XG4gIHJldHVybiByZWFkVmVjdG9yKCk7XG59XG5mdW5jdGlvbiBzaWdoYXNoVHlwZVRvU3RyaW5nKHNpZ2hhc2hUeXBlKSB7XG4gIGxldCB0ZXh0ID1cbiAgICBzaWdoYXNoVHlwZSAmIHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTllPTkVDQU5QQVlcbiAgICAgID8gJ1NJR0hBU0hfQU5ZT05FQ0FOUEFZIHwgJ1xuICAgICAgOiAnJztcbiAgY29uc3Qgc2lnTW9kID0gc2lnaGFzaFR5cGUgJiAweDFmO1xuICBzd2l0Y2ggKHNpZ01vZCkge1xuICAgIGNhc2UgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTDpcbiAgICAgIHRleHQgKz0gJ1NJR0hBU0hfQUxMJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRTpcbiAgICAgIHRleHQgKz0gJ1NJR0hBU0hfU0lOR0xFJztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX05PTkU6XG4gICAgICB0ZXh0ICs9ICdTSUdIQVNIX05PTkUnO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiBhZGROb25XaXRuZXNzVHhDYWNoZShjYWNoZSwgaW5wdXQsIGlucHV0SW5kZXgpIHtcbiAgY2FjaGUuX19OT05fV0lUTkVTU19VVFhPX0JVRl9DQUNIRVtpbnB1dEluZGV4XSA9IGlucHV0Lm5vbldpdG5lc3NVdHhvO1xuICBjb25zdCB0eCA9IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uZnJvbUJ1ZmZlcihpbnB1dC5ub25XaXRuZXNzVXR4byk7XG4gIGNhY2hlLl9fTk9OX1dJVE5FU1NfVVRYT19UWF9DQUNIRVtpbnB1dEluZGV4XSA9IHR4O1xuICBjb25zdCBzZWxmID0gY2FjaGU7XG4gIGNvbnN0IHNlbGZJbmRleCA9IGlucHV0SW5kZXg7XG4gIGRlbGV0ZSBpbnB1dC5ub25XaXRuZXNzVXR4bztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGlucHV0LCAnbm9uV2l0bmVzc1V0eG8nLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBidWYgPSBzZWxmLl9fTk9OX1dJVE5FU1NfVVRYT19CVUZfQ0FDSEVbc2VsZkluZGV4XTtcbiAgICAgIGNvbnN0IHR4Q2FjaGUgPSBzZWxmLl9fTk9OX1dJVE5FU1NfVVRYT19UWF9DQUNIRVtzZWxmSW5kZXhdO1xuICAgICAgaWYgKGJ1ZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBuZXdCdWYgPSB0eENhY2hlLnRvQnVmZmVyKCk7XG4gICAgICAgIHNlbGYuX19OT05fV0lUTkVTU19VVFhPX0JVRl9DQUNIRVtzZWxmSW5kZXhdID0gbmV3QnVmO1xuICAgICAgICByZXR1cm4gbmV3QnVmO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0KGRhdGEpIHtcbiAgICAgIHNlbGYuX19OT05fV0lUTkVTU19VVFhPX0JVRl9DQUNIRVtzZWxmSW5kZXhdID0gZGF0YTtcbiAgICB9LFxuICB9KTtcbn1cbmZ1bmN0aW9uIGlucHV0RmluYWxpemVHZXRBbXRzKGlucHV0cywgdHgsIGNhY2hlLCBtdXN0RmluYWxpemUpIHtcbiAgbGV0IGlucHV0QW1vdW50ID0gMDtcbiAgaW5wdXRzLmZvckVhY2goKGlucHV0LCBpZHgpID0+IHtcbiAgICBpZiAobXVzdEZpbmFsaXplICYmIGlucHV0LmZpbmFsU2NyaXB0U2lnKVxuICAgICAgdHguaW5zW2lkeF0uc2NyaXB0ID0gaW5wdXQuZmluYWxTY3JpcHRTaWc7XG4gICAgaWYgKG11c3RGaW5hbGl6ZSAmJiBpbnB1dC5maW5hbFNjcmlwdFdpdG5lc3MpIHtcbiAgICAgIHR4Lmluc1tpZHhdLndpdG5lc3MgPSBzY3JpcHRXaXRuZXNzVG9XaXRuZXNzU3RhY2soXG4gICAgICAgIGlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcyxcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChpbnB1dC53aXRuZXNzVXR4bykge1xuICAgICAgaW5wdXRBbW91bnQgKz0gaW5wdXQud2l0bmVzc1V0eG8udmFsdWU7XG4gICAgfSBlbHNlIGlmIChpbnB1dC5ub25XaXRuZXNzVXR4bykge1xuICAgICAgY29uc3QgbndUeCA9IG5vbldpdG5lc3NVdHhvVHhGcm9tQ2FjaGUoY2FjaGUsIGlucHV0LCBpZHgpO1xuICAgICAgY29uc3Qgdm91dCA9IHR4Lmluc1tpZHhdLmluZGV4O1xuICAgICAgY29uc3Qgb3V0ID0gbndUeC5vdXRzW3ZvdXRdO1xuICAgICAgaW5wdXRBbW91bnQgKz0gb3V0LnZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG91dHB1dEFtb3VudCA9IHR4Lm91dHMucmVkdWNlKCh0b3RhbCwgbykgPT4gdG90YWwgKyBvLnZhbHVlLCAwKTtcbiAgY29uc3QgZmVlID0gaW5wdXRBbW91bnQgLSBvdXRwdXRBbW91bnQ7XG4gIGlmIChmZWUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPdXRwdXRzIGFyZSBzcGVuZGluZyBtb3JlIHRoYW4gSW5wdXRzJyk7XG4gIH1cbiAgY29uc3QgYnl0ZXMgPSB0eC52aXJ0dWFsU2l6ZSgpO1xuICBjYWNoZS5fX0ZFRSA9IGZlZTtcbiAgY2FjaGUuX19FWFRSQUNURURfVFggPSB0eDtcbiAgY2FjaGUuX19GRUVfUkFURSA9IE1hdGguZmxvb3IoZmVlIC8gYnl0ZXMpO1xufVxuZnVuY3Rpb24gbm9uV2l0bmVzc1V0eG9UeEZyb21DYWNoZShjYWNoZSwgaW5wdXQsIGlucHV0SW5kZXgpIHtcbiAgY29uc3QgYyA9IGNhY2hlLl9fTk9OX1dJVE5FU1NfVVRYT19UWF9DQUNIRTtcbiAgaWYgKCFjW2lucHV0SW5kZXhdKSB7XG4gICAgYWRkTm9uV2l0bmVzc1R4Q2FjaGUoY2FjaGUsIGlucHV0LCBpbnB1dEluZGV4KTtcbiAgfVxuICByZXR1cm4gY1tpbnB1dEluZGV4XTtcbn1cbmZ1bmN0aW9uIGdldFNjcmlwdEZyb21VdHhvKGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSkge1xuICBjb25zdCB7IHNjcmlwdCB9ID0gZ2V0U2NyaXB0QW5kQW1vdW50RnJvbVV0eG8oaW5wdXRJbmRleCwgaW5wdXQsIGNhY2hlKTtcbiAgcmV0dXJuIHNjcmlwdDtcbn1cbmZ1bmN0aW9uIGdldFNjcmlwdEFuZEFtb3VudEZyb21VdHhvKGlucHV0SW5kZXgsIGlucHV0LCBjYWNoZSkge1xuICBpZiAoaW5wdXQud2l0bmVzc1V0eG8gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7XG4gICAgICBzY3JpcHQ6IGlucHV0LndpdG5lc3NVdHhvLnNjcmlwdCxcbiAgICAgIHZhbHVlOiBpbnB1dC53aXRuZXNzVXR4by52YWx1ZSxcbiAgICB9O1xuICB9IGVsc2UgaWYgKGlucHV0Lm5vbldpdG5lc3NVdHhvICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBub25XaXRuZXNzVXR4b1R4ID0gbm9uV2l0bmVzc1V0eG9UeEZyb21DYWNoZShcbiAgICAgIGNhY2hlLFxuICAgICAgaW5wdXQsXG4gICAgICBpbnB1dEluZGV4LFxuICAgICk7XG4gICAgY29uc3QgbyA9IG5vbldpdG5lc3NVdHhvVHgub3V0c1tjYWNoZS5fX1RYLmluc1tpbnB1dEluZGV4XS5pbmRleF07XG4gICAgcmV0dXJuIHsgc2NyaXB0OiBvLnNjcmlwdCwgdmFsdWU6IG8udmFsdWUgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kIHB1YmtleSBpbiBpbnB1dCB3aXRob3V0IFV0eG8gZGF0YVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gcHVia2V5SW5JbnB1dChwdWJrZXksIGlucHV0LCBpbnB1dEluZGV4LCBjYWNoZSkge1xuICBjb25zdCBzY3JpcHQgPSBnZXRTY3JpcHRGcm9tVXR4byhpbnB1dEluZGV4LCBpbnB1dCwgY2FjaGUpO1xuICBjb25zdCB7IG1lYW5pbmdmdWxTY3JpcHQgfSA9IGdldE1lYW5pbmdmdWxTY3JpcHQoXG4gICAgc2NyaXB0LFxuICAgIGlucHV0SW5kZXgsXG4gICAgJ2lucHV0JyxcbiAgICBpbnB1dC5yZWRlZW1TY3JpcHQsXG4gICAgaW5wdXQud2l0bmVzc1NjcmlwdCxcbiAgKTtcbiAgcmV0dXJuICgwLCBwc2J0dXRpbHNfMS5wdWJrZXlJblNjcmlwdCkocHVia2V5LCBtZWFuaW5nZnVsU2NyaXB0KTtcbn1cbmZ1bmN0aW9uIHB1YmtleUluT3V0cHV0KHB1YmtleSwgb3V0cHV0LCBvdXRwdXRJbmRleCwgY2FjaGUpIHtcbiAgY29uc3Qgc2NyaXB0ID0gY2FjaGUuX19UWC5vdXRzW291dHB1dEluZGV4XS5zY3JpcHQ7XG4gIGNvbnN0IHsgbWVhbmluZ2Z1bFNjcmlwdCB9ID0gZ2V0TWVhbmluZ2Z1bFNjcmlwdChcbiAgICBzY3JpcHQsXG4gICAgb3V0cHV0SW5kZXgsXG4gICAgJ291dHB1dCcsXG4gICAgb3V0cHV0LnJlZGVlbVNjcmlwdCxcbiAgICBvdXRwdXQud2l0bmVzc1NjcmlwdCxcbiAgKTtcbiAgcmV0dXJuICgwLCBwc2J0dXRpbHNfMS5wdWJrZXlJblNjcmlwdCkocHVia2V5LCBtZWFuaW5nZnVsU2NyaXB0KTtcbn1cbmZ1bmN0aW9uIHJlZGVlbUZyb21GaW5hbFNjcmlwdFNpZyhmaW5hbFNjcmlwdCkge1xuICBpZiAoIWZpbmFsU2NyaXB0KSByZXR1cm47XG4gIGNvbnN0IGRlY29tcCA9IGJzY3JpcHQuZGVjb21waWxlKGZpbmFsU2NyaXB0KTtcbiAgaWYgKCFkZWNvbXApIHJldHVybjtcbiAgY29uc3QgbGFzdEl0ZW0gPSBkZWNvbXBbZGVjb21wLmxlbmd0aCAtIDFdO1xuICBpZiAoXG4gICAgIUJ1ZmZlci5pc0J1ZmZlcihsYXN0SXRlbSkgfHxcbiAgICBpc1B1YmtleUxpa2UobGFzdEl0ZW0pIHx8XG4gICAgaXNTaWdMaWtlKGxhc3RJdGVtKVxuICApXG4gICAgcmV0dXJuO1xuICBjb25zdCBzRGVjb21wID0gYnNjcmlwdC5kZWNvbXBpbGUobGFzdEl0ZW0pO1xuICBpZiAoIXNEZWNvbXApIHJldHVybjtcbiAgcmV0dXJuIGxhc3RJdGVtO1xufVxuZnVuY3Rpb24gcmVkZWVtRnJvbUZpbmFsV2l0bmVzc1NjcmlwdChmaW5hbFNjcmlwdCkge1xuICBpZiAoIWZpbmFsU2NyaXB0KSByZXR1cm47XG4gIGNvbnN0IGRlY29tcCA9IHNjcmlwdFdpdG5lc3NUb1dpdG5lc3NTdGFjayhmaW5hbFNjcmlwdCk7XG4gIGNvbnN0IGxhc3RJdGVtID0gZGVjb21wW2RlY29tcC5sZW5ndGggLSAxXTtcbiAgaWYgKGlzUHVia2V5TGlrZShsYXN0SXRlbSkpIHJldHVybjtcbiAgY29uc3Qgc0RlY29tcCA9IGJzY3JpcHQuZGVjb21waWxlKGxhc3RJdGVtKTtcbiAgaWYgKCFzRGVjb21wKSByZXR1cm47XG4gIHJldHVybiBsYXN0SXRlbTtcbn1cbmZ1bmN0aW9uIGNvbXByZXNzUHVia2V5KHB1YmtleSkge1xuICBpZiAocHVia2V5Lmxlbmd0aCA9PT0gNjUpIHtcbiAgICBjb25zdCBwYXJpdHkgPSBwdWJrZXlbNjRdICYgMTtcbiAgICBjb25zdCBuZXdLZXkgPSBwdWJrZXkuc2xpY2UoMCwgMzMpO1xuICAgIG5ld0tleVswXSA9IDIgfCBwYXJpdHk7XG4gICAgcmV0dXJuIG5ld0tleTtcbiAgfVxuICByZXR1cm4gcHVia2V5LnNsaWNlKCk7XG59XG5mdW5jdGlvbiBpc1B1YmtleUxpa2UoYnVmKSB7XG4gIHJldHVybiBidWYubGVuZ3RoID09PSAzMyAmJiBic2NyaXB0LmlzQ2Fub25pY2FsUHViS2V5KGJ1Zik7XG59XG5mdW5jdGlvbiBpc1NpZ0xpa2UoYnVmKSB7XG4gIHJldHVybiBic2NyaXB0LmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlKGJ1Zik7XG59XG5mdW5jdGlvbiBnZXRNZWFuaW5nZnVsU2NyaXB0KFxuICBzY3JpcHQsXG4gIGluZGV4LFxuICBpb1R5cGUsXG4gIHJlZGVlbVNjcmlwdCxcbiAgd2l0bmVzc1NjcmlwdCxcbikge1xuICBjb25zdCBpc1AyU0ggPSAoMCwgcHNidHV0aWxzXzEuaXNQMlNIU2NyaXB0KShzY3JpcHQpO1xuICBjb25zdCBpc1AyU0hQMldTSCA9XG4gICAgaXNQMlNIICYmIHJlZGVlbVNjcmlwdCAmJiAoMCwgcHNidHV0aWxzXzEuaXNQMldTSFNjcmlwdCkocmVkZWVtU2NyaXB0KTtcbiAgY29uc3QgaXNQMldTSCA9ICgwLCBwc2J0dXRpbHNfMS5pc1AyV1NIU2NyaXB0KShzY3JpcHQpO1xuICBpZiAoaXNQMlNIICYmIHJlZGVlbVNjcmlwdCA9PT0gdW5kZWZpbmVkKVxuICAgIHRocm93IG5ldyBFcnJvcignc2NyaXB0UHVia2V5IGlzIFAyU0ggYnV0IHJlZGVlbVNjcmlwdCBtaXNzaW5nJyk7XG4gIGlmICgoaXNQMldTSCB8fCBpc1AyU0hQMldTSCkgJiYgd2l0bmVzc1NjcmlwdCA9PT0gdW5kZWZpbmVkKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdzY3JpcHRQdWJrZXkgb3IgcmVkZWVtU2NyaXB0IGlzIFAyV1NIIGJ1dCB3aXRuZXNzU2NyaXB0IG1pc3NpbmcnLFxuICAgICk7XG4gIGxldCBtZWFuaW5nZnVsU2NyaXB0O1xuICBpZiAoaXNQMlNIUDJXU0gpIHtcbiAgICBtZWFuaW5nZnVsU2NyaXB0ID0gd2l0bmVzc1NjcmlwdDtcbiAgICBjaGVja1JlZGVlbVNjcmlwdChpbmRleCwgc2NyaXB0LCByZWRlZW1TY3JpcHQsIGlvVHlwZSk7XG4gICAgY2hlY2tXaXRuZXNzU2NyaXB0KGluZGV4LCByZWRlZW1TY3JpcHQsIHdpdG5lc3NTY3JpcHQsIGlvVHlwZSk7XG4gICAgY2hlY2tJbnZhbGlkUDJXU0gobWVhbmluZ2Z1bFNjcmlwdCk7XG4gIH0gZWxzZSBpZiAoaXNQMldTSCkge1xuICAgIG1lYW5pbmdmdWxTY3JpcHQgPSB3aXRuZXNzU2NyaXB0O1xuICAgIGNoZWNrV2l0bmVzc1NjcmlwdChpbmRleCwgc2NyaXB0LCB3aXRuZXNzU2NyaXB0LCBpb1R5cGUpO1xuICAgIGNoZWNrSW52YWxpZFAyV1NIKG1lYW5pbmdmdWxTY3JpcHQpO1xuICB9IGVsc2UgaWYgKGlzUDJTSCkge1xuICAgIG1lYW5pbmdmdWxTY3JpcHQgPSByZWRlZW1TY3JpcHQ7XG4gICAgY2hlY2tSZWRlZW1TY3JpcHQoaW5kZXgsIHNjcmlwdCwgcmVkZWVtU2NyaXB0LCBpb1R5cGUpO1xuICB9IGVsc2Uge1xuICAgIG1lYW5pbmdmdWxTY3JpcHQgPSBzY3JpcHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtZWFuaW5nZnVsU2NyaXB0LFxuICAgIHR5cGU6IGlzUDJTSFAyV1NIXG4gICAgICA/ICdwMnNoLXAyd3NoJ1xuICAgICAgOiBpc1AyU0hcbiAgICAgID8gJ3Ayc2gnXG4gICAgICA6IGlzUDJXU0hcbiAgICAgID8gJ3Ayd3NoJ1xuICAgICAgOiAncmF3JyxcbiAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrSW52YWxpZFAyV1NIKHNjcmlwdCkge1xuICBpZiAoXG4gICAgKDAsIHBzYnR1dGlsc18xLmlzUDJXUEtIKShzY3JpcHQpIHx8XG4gICAgKDAsIHBzYnR1dGlsc18xLmlzUDJTSFNjcmlwdCkoc2NyaXB0KVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1AyV1BLSCBvciBQMlNIIGNhbiBub3QgYmUgY29udGFpbmVkIHdpdGhpbiBQMldTSCcpO1xuICB9XG59XG5mdW5jdGlvbiBjbGFzc2lmeVNjcmlwdChzY3JpcHQpIHtcbiAgaWYgKCgwLCBwc2J0dXRpbHNfMS5pc1AyV1BLSCkoc2NyaXB0KSkgcmV0dXJuICd3aXRuZXNzcHVia2V5aGFzaCc7XG4gIGlmICgoMCwgcHNidHV0aWxzXzEuaXNQMlBLSCkoc2NyaXB0KSkgcmV0dXJuICdwdWJrZXloYXNoJztcbiAgaWYgKCgwLCBwc2J0dXRpbHNfMS5pc1AyTVMpKHNjcmlwdCkpIHJldHVybiAnbXVsdGlzaWcnO1xuICBpZiAoKDAsIHBzYnR1dGlsc18xLmlzUDJQSykoc2NyaXB0KSkgcmV0dXJuICdwdWJrZXknO1xuICByZXR1cm4gJ25vbnN0YW5kYXJkJztcbn1cbmZ1bmN0aW9uIHJhbmdlKG4pIHtcbiAgcmV0dXJuIFsuLi5BcnJheShuKS5rZXlzKCldO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/psbt.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/psbt/bip371.js":
/*!*******************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/psbt/bip371.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkTaprootInputForSigs =\n  exports.tapTreeFromList =\n  exports.tapTreeToList =\n  exports.tweakInternalPubKey =\n  exports.checkTaprootOutputFields =\n  exports.checkTaprootInputFields =\n  exports.isTaprootOutput =\n  exports.isTaprootInput =\n  exports.serializeTaprootSignature =\n  exports.tapScriptFinalizer =\n  exports.toXOnly =\n    void 0;\nconst types_1 = __webpack_require__(/*! ../types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst transaction_1 = __webpack_require__(/*! ../transaction */ \"./node_modules/bitcoinjs-lib/src/transaction.js\");\nconst psbtutils_1 = __webpack_require__(/*! ./psbtutils */ \"./node_modules/bitcoinjs-lib/src/psbt/psbtutils.js\");\nconst bip341_1 = __webpack_require__(/*! ../payments/bip341 */ \"./node_modules/bitcoinjs-lib/src/payments/bip341.js\");\nconst payments_1 = __webpack_require__(/*! ../payments */ \"./node_modules/bitcoinjs-lib/src/payments/index.js\");\nconst psbtutils_2 = __webpack_require__(/*! ./psbtutils */ \"./node_modules/bitcoinjs-lib/src/psbt/psbtutils.js\");\nconst toXOnly = pubKey => (pubKey.length === 32 ? pubKey : pubKey.slice(1, 33));\nexports.toXOnly = toXOnly;\n/**\n * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.\n * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.\n * @param inputIndex the position of the PSBT input.\n * @param input the PSBT input.\n * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash\n *                              and will try to build the finalScriptWitness.\n * @returns the finalScriptWitness or throws an exception if no tapleaf found.\n */\nfunction tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {\n  const tapLeaf = findTapLeafToFinalize(\n    input,\n    inputIndex,\n    tapLeafHashToFinalize,\n  );\n  try {\n    const sigs = sortSignatures(input, tapLeaf);\n    const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);\n    return {\n      finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness),\n    };\n  } catch (err) {\n    throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);\n  }\n}\nexports.tapScriptFinalizer = tapScriptFinalizer;\nfunction serializeTaprootSignature(sig, sighashType) {\n  const sighashTypeByte = sighashType\n    ? Buffer.from([sighashType])\n    : Buffer.from([]);\n  return Buffer.concat([sig, sighashTypeByte]);\n}\nexports.serializeTaprootSignature = serializeTaprootSignature;\nfunction isTaprootInput(input) {\n  return (\n    input &&\n    !!(\n      input.tapInternalKey ||\n      input.tapMerkleRoot ||\n      (input.tapLeafScript && input.tapLeafScript.length) ||\n      (input.tapBip32Derivation && input.tapBip32Derivation.length) ||\n      (input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script))\n    )\n  );\n}\nexports.isTaprootInput = isTaprootInput;\nfunction isTaprootOutput(output, script) {\n  return (\n    output &&\n    !!(\n      output.tapInternalKey ||\n      output.tapTree ||\n      (output.tapBip32Derivation && output.tapBip32Derivation.length) ||\n      (script && (0, psbtutils_1.isP2TR)(script))\n    )\n  );\n}\nexports.isTaprootOutput = isTaprootOutput;\nfunction checkTaprootInputFields(inputData, newInputData, action) {\n  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);\n  checkIfTapLeafInTree(inputData, newInputData, action);\n}\nexports.checkTaprootInputFields = checkTaprootInputFields;\nfunction checkTaprootOutputFields(outputData, newOutputData, action) {\n  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);\n  checkTaprootScriptPubkey(outputData, newOutputData);\n}\nexports.checkTaprootOutputFields = checkTaprootOutputFields;\nfunction checkTaprootScriptPubkey(outputData, newOutputData) {\n  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;\n  const tapInternalKey =\n    newOutputData.tapInternalKey || outputData.tapInternalKey;\n  const tapTree = newOutputData.tapTree || outputData.tapTree;\n  if (tapInternalKey) {\n    const { script: scriptPubkey } = outputData;\n    const script = getTaprootScripPubkey(tapInternalKey, tapTree);\n    if (scriptPubkey && !scriptPubkey.equals(script))\n      throw new Error('Error adding output. Script or address missmatch.');\n  }\n}\nfunction getTaprootScripPubkey(tapInternalKey, tapTree) {\n  const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);\n  const { output } = (0, payments_1.p2tr)({\n    internalPubkey: tapInternalKey,\n    scriptTree,\n  });\n  return output;\n}\nfunction tweakInternalPubKey(inputIndex, input) {\n  const tapInternalKey = input.tapInternalKey;\n  const outputKey =\n    tapInternalKey &&\n    (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);\n  if (!outputKey)\n    throw new Error(\n      `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${\n        tapInternalKey && tapInternalKey.toString('hex')\n      }`,\n    );\n  return outputKey.x;\n}\nexports.tweakInternalPubKey = tweakInternalPubKey;\n/**\n * Convert a binary tree to a BIP371 type list. Each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @param tree the binary tap tree\n * @returns a list of BIP 371 tapleaves\n */\nfunction tapTreeToList(tree) {\n  if (!(0, types_1.isTaptree)(tree))\n    throw new Error(\n      'Cannot convert taptree to tapleaf list. Expecting a tapree structure.',\n    );\n  return _tapTreeToList(tree);\n}\nexports.tapTreeToList = tapTreeToList;\n/**\n * Convert a BIP371 TapLeaf list to a TapTree (binary).\n * @param leaves a list of tapleaves where each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed\n */\nfunction tapTreeFromList(leaves = []) {\n  if (leaves.length === 1 && leaves[0].depth === 0)\n    return {\n      output: leaves[0].script,\n      version: leaves[0].leafVersion,\n    };\n  return instertLeavesInTree(leaves);\n}\nexports.tapTreeFromList = tapTreeFromList;\nfunction checkTaprootInputForSigs(input, action) {\n  const sigs = extractTaprootSigs(input);\n  return sigs.some(sig =>\n    (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action),\n  );\n}\nexports.checkTaprootInputForSigs = checkTaprootInputForSigs;\nfunction decodeSchnorrSignature(signature) {\n  return {\n    signature: signature.slice(0, 64),\n    hashType:\n      signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT,\n  };\n}\nfunction extractTaprootSigs(input) {\n  const sigs = [];\n  if (input.tapKeySig) sigs.push(input.tapKeySig);\n  if (input.tapScriptSig)\n    sigs.push(...input.tapScriptSig.map(s => s.signature));\n  if (!sigs.length) {\n    const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);\n    if (finalTapKeySig) sigs.push(finalTapKeySig);\n  }\n  return sigs;\n}\nfunction getTapKeySigFromWithness(finalScriptWitness) {\n  if (!finalScriptWitness) return;\n  const witness = finalScriptWitness.slice(2);\n  // todo: add schnorr signature validation\n  if (witness.length === 64 || witness.length === 65) return witness;\n}\nfunction _tapTreeToList(tree, leaves = [], depth = 0) {\n  if (depth > bip341_1.MAX_TAPTREE_DEPTH)\n    throw new Error('Max taptree depth exceeded.');\n  if (!tree) return [];\n  if ((0, types_1.isTapleaf)(tree)) {\n    leaves.push({\n      depth,\n      leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,\n      script: tree.output,\n    });\n    return leaves;\n  }\n  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);\n  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);\n  return leaves;\n}\nfunction instertLeavesInTree(leaves) {\n  let tree;\n  for (const leaf of leaves) {\n    tree = instertLeafInTree(leaf, tree);\n    if (!tree) throw new Error(`No room left to insert tapleaf in tree`);\n  }\n  return tree;\n}\nfunction instertLeafInTree(leaf, tree, depth = 0) {\n  if (depth > bip341_1.MAX_TAPTREE_DEPTH)\n    throw new Error('Max taptree depth exceeded.');\n  if (leaf.depth === depth) {\n    if (!tree)\n      return {\n        output: leaf.script,\n        version: leaf.leafVersion,\n      };\n    return;\n  }\n  if ((0, types_1.isTapleaf)(tree)) return;\n  const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);\n  if (leftSide) return [leftSide, tree && tree[1]];\n  const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);\n  if (rightSide) return [tree && tree[0], rightSide];\n}\nfunction checkMixedTaprootAndNonTaprootInputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootInput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootInput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootInput(newInputData) &&\n    hasNonTaprootFields(newInputData); // todo: bad? use !===\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\nfunction checkMixedTaprootAndNonTaprootOutputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootOutput(newInputData) &&\n    hasNonTaprootFields(newInputData);\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\n/**\n * Checks if the tap leaf is part of the tap tree for the given input data.\n * Throws an error if the tap leaf is not part of the tap tree.\n * @param inputData - The original PsbtInput data.\n * @param newInputData - The new PsbtInput data.\n * @param action - The action being performed.\n * @throws {Error} - If the tap leaf is not part of the tap tree.\n */\nfunction checkIfTapLeafInTree(inputData, newInputData, action) {\n  if (newInputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    const oldLeafsInTree = (inputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree || !oldLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  } else if (inputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, inputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  }\n}\n/**\n * Checks if a TapLeafScript is present in a Merkle tree.\n * @param tapLeaf The TapLeafScript to check.\n * @param merkleRoot The Merkle root of the tree. If not provided, the function assumes the TapLeafScript is present.\n * @returns A boolean indicating whether the TapLeafScript is present in the tree.\n */\nfunction isTapLeafInTree(tapLeaf, merkleRoot) {\n  if (!merkleRoot) return true;\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  const rootHash = (0, bip341_1.rootHashFromPath)(\n    tapLeaf.controlBlock,\n    leafHash,\n  );\n  return rootHash.equals(merkleRoot);\n}\n/**\n * Sorts the signatures in the input's tapScriptSig array based on their position in the tapLeaf script.\n *\n * @param input - The PsbtInput object.\n * @param tapLeaf - The TapLeafScript object.\n * @returns An array of sorted signatures as Buffers.\n */\nfunction sortSignatures(input, tapLeaf) {\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  return (input.tapScriptSig || [])\n    .filter(tss => tss.leafHash.equals(leafHash))\n    .map(tss => addPubkeyPositionInScript(tapLeaf.script, tss))\n    .sort((t1, t2) => t2.positionInScript - t1.positionInScript)\n    .map(t => t.signature);\n}\n/**\n * Adds the position of a public key in a script to a TapScriptSig object.\n * @param script The script in which to find the position of the public key.\n * @param tss The TapScriptSig object to add the position to.\n * @returns A TapScriptSigWitPosition object with the added position.\n */\nfunction addPubkeyPositionInScript(script, tss) {\n  return Object.assign(\n    {\n      positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(\n        tss.pubkey,\n        script,\n      ),\n    },\n    tss,\n  );\n}\n/**\n * Find tapleaf by hash, or get the signed tapleaf with the shortest path.\n */\nfunction findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {\n  if (!input.tapScriptSig || !input.tapScriptSig.length)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`,\n    );\n  const tapLeaf = (input.tapLeafScript || [])\n    .sort((a, b) => a.controlBlock.length - b.controlBlock.length)\n    .find(leaf =>\n      canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize),\n    );\n  if (!tapLeaf)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`,\n    );\n  return tapLeaf;\n}\n/**\n * Determines whether a TapLeafScript can be finalized.\n *\n * @param leaf - The TapLeafScript to check.\n * @param tapScriptSig - The array of TapScriptSig objects.\n * @param hash - The optional hash to compare with the leaf hash.\n * @returns A boolean indicating whether the TapLeafScript can be finalized.\n */\nfunction canFinalizeLeaf(leaf, tapScriptSig, hash) {\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: leaf.script,\n    version: leaf.leafVersion,\n  });\n  const whiteListedHash = !hash || hash.equals(leafHash);\n  return (\n    whiteListedHash &&\n    tapScriptSig.find(tss => tss.leafHash.equals(leafHash)) !== undefined\n  );\n}\n/**\n * Checks if the given PsbtInput or PsbtOutput has non-taproot fields.\n * Non-taproot fields include redeemScript, witnessScript, and bip32Derivation.\n * @param io The PsbtInput or PsbtOutput to check.\n * @returns A boolean indicating whether the given input or output has non-taproot fields.\n */\nfunction hasNonTaprootFields(io) {\n  return (\n    io &&\n    !!(\n      io.redeemScript ||\n      io.witnessScript ||\n      (io.bip32Derivation && io.bip32Derivation.length)\n    )\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcHNidC9iaXAzNzEuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQztBQUNoQyxFQUFFLHVCQUF1QjtBQUN6QixFQUFFLHFCQUFxQjtBQUN2QixFQUFFLDJCQUEyQjtBQUM3QixFQUFFLGdDQUFnQztBQUNsQyxFQUFFLCtCQUErQjtBQUNqQyxFQUFFLHVCQUF1QjtBQUN6QixFQUFFLHNCQUFzQjtBQUN4QixFQUFFLGlDQUFpQztBQUNuQyxFQUFFLDBCQUEwQjtBQUM1QixFQUFFLGVBQWU7QUFDakI7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywyREFBVTtBQUNsQyxzQkFBc0IsbUJBQU8sQ0FBQyx1RUFBZ0I7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsdUVBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsK0VBQW9CO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLHVFQUFhO0FBQ3hDLG9CQUFvQixtQkFBTyxDQUFDLHVFQUFhO0FBQ3pDO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix1REFBdUQsV0FBVyxJQUFJLElBQUk7QUFDMUU7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsTUFBTSxNQUFNO0FBQ1osTUFBTSxNQUFNO0FBQ1osU0FBUyxNQUFNO0FBQ2Y7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3BzYnQvYmlwMzcxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoZWNrVGFwcm9vdElucHV0Rm9yU2lncyA9XG4gIGV4cG9ydHMudGFwVHJlZUZyb21MaXN0ID1cbiAgZXhwb3J0cy50YXBUcmVlVG9MaXN0ID1cbiAgZXhwb3J0cy50d2Vha0ludGVybmFsUHViS2V5ID1cbiAgZXhwb3J0cy5jaGVja1RhcHJvb3RPdXRwdXRGaWVsZHMgPVxuICBleHBvcnRzLmNoZWNrVGFwcm9vdElucHV0RmllbGRzID1cbiAgZXhwb3J0cy5pc1RhcHJvb3RPdXRwdXQgPVxuICBleHBvcnRzLmlzVGFwcm9vdElucHV0ID1cbiAgZXhwb3J0cy5zZXJpYWxpemVUYXByb290U2lnbmF0dXJlID1cbiAgZXhwb3J0cy50YXBTY3JpcHRGaW5hbGl6ZXIgPVxuICBleHBvcnRzLnRvWE9ubHkgPVxuICAgIHZvaWQgMDtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKCcuLi90eXBlcycpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoJy4uL3RyYW5zYWN0aW9uJyk7XG5jb25zdCBwc2J0dXRpbHNfMSA9IHJlcXVpcmUoJy4vcHNidHV0aWxzJyk7XG5jb25zdCBiaXAzNDFfMSA9IHJlcXVpcmUoJy4uL3BheW1lbnRzL2JpcDM0MScpO1xuY29uc3QgcGF5bWVudHNfMSA9IHJlcXVpcmUoJy4uL3BheW1lbnRzJyk7XG5jb25zdCBwc2J0dXRpbHNfMiA9IHJlcXVpcmUoJy4vcHNidHV0aWxzJyk7XG5jb25zdCB0b1hPbmx5ID0gcHViS2V5ID0+IChwdWJLZXkubGVuZ3RoID09PSAzMiA/IHB1YktleSA6IHB1YktleS5zbGljZSgxLCAzMykpO1xuZXhwb3J0cy50b1hPbmx5ID0gdG9YT25seTtcbi8qKlxuICogRGVmYXVsdCB0YXBzY3JpcHQgZmluYWxpemVyLiBJdCBzZWFyY2hlcyBmb3IgdGhlIGB0YXBMZWFmSGFzaFRvRmluYWxpemVgIGlmIHByb3ZpZGVkLlxuICogT3RoZXJ3aXNlIGl0IHdpbGwgc2VhcmNoIGZvciB0aGUgdGFwbGVhZiB0aGF0IGhhcyBhdCBsZWFzdCBvbmUgc2lnbmF0dXJlIGFuZCBoYXMgdGhlIHNob3J0ZXN0IHBhdGguXG4gKiBAcGFyYW0gaW5wdXRJbmRleCB0aGUgcG9zaXRpb24gb2YgdGhlIFBTQlQgaW5wdXQuXG4gKiBAcGFyYW0gaW5wdXQgdGhlIFBTQlQgaW5wdXQuXG4gKiBAcGFyYW0gdGFwTGVhZkhhc2hUb0ZpbmFsaXplIG9wdGlvbmFsLCBpZiBwcm92aWRlZCB0aGUgZmluYWxpemVyIHdpbGwgc2VhcmNoIGZvciBhIHRhcGxlYWYgdGhhdCBoYXMgdGhpcyBoYXNoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCB3aWxsIHRyeSB0byBidWlsZCB0aGUgZmluYWxTY3JpcHRXaXRuZXNzLlxuICogQHJldHVybnMgdGhlIGZpbmFsU2NyaXB0V2l0bmVzcyBvciB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIG5vIHRhcGxlYWYgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHRhcFNjcmlwdEZpbmFsaXplcihpbnB1dEluZGV4LCBpbnB1dCwgdGFwTGVhZkhhc2hUb0ZpbmFsaXplKSB7XG4gIGNvbnN0IHRhcExlYWYgPSBmaW5kVGFwTGVhZlRvRmluYWxpemUoXG4gICAgaW5wdXQsXG4gICAgaW5wdXRJbmRleCxcbiAgICB0YXBMZWFmSGFzaFRvRmluYWxpemUsXG4gICk7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2lncyA9IHNvcnRTaWduYXR1cmVzKGlucHV0LCB0YXBMZWFmKTtcbiAgICBjb25zdCB3aXRuZXNzID0gc2lncy5jb25jYXQodGFwTGVhZi5zY3JpcHQpLmNvbmNhdCh0YXBMZWFmLmNvbnRyb2xCbG9jayk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbmFsU2NyaXB0V2l0bmVzczogKDAsIHBzYnR1dGlsc18xLndpdG5lc3NTdGFja1RvU2NyaXB0V2l0bmVzcykod2l0bmVzcyksXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW4gbm90IGZpbmFsaXplIHRhcHJvb3QgaW5wdXQgIyR7aW5wdXRJbmRleH06ICR7ZXJyfWApO1xuICB9XG59XG5leHBvcnRzLnRhcFNjcmlwdEZpbmFsaXplciA9IHRhcFNjcmlwdEZpbmFsaXplcjtcbmZ1bmN0aW9uIHNlcmlhbGl6ZVRhcHJvb3RTaWduYXR1cmUoc2lnLCBzaWdoYXNoVHlwZSkge1xuICBjb25zdCBzaWdoYXNoVHlwZUJ5dGUgPSBzaWdoYXNoVHlwZVxuICAgID8gQnVmZmVyLmZyb20oW3NpZ2hhc2hUeXBlXSlcbiAgICA6IEJ1ZmZlci5mcm9tKFtdKTtcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3NpZywgc2lnaGFzaFR5cGVCeXRlXSk7XG59XG5leHBvcnRzLnNlcmlhbGl6ZVRhcHJvb3RTaWduYXR1cmUgPSBzZXJpYWxpemVUYXByb290U2lnbmF0dXJlO1xuZnVuY3Rpb24gaXNUYXByb290SW5wdXQoaW5wdXQpIHtcbiAgcmV0dXJuIChcbiAgICBpbnB1dCAmJlxuICAgICEhKFxuICAgICAgaW5wdXQudGFwSW50ZXJuYWxLZXkgfHxcbiAgICAgIGlucHV0LnRhcE1lcmtsZVJvb3QgfHxcbiAgICAgIChpbnB1dC50YXBMZWFmU2NyaXB0ICYmIGlucHV0LnRhcExlYWZTY3JpcHQubGVuZ3RoKSB8fFxuICAgICAgKGlucHV0LnRhcEJpcDMyRGVyaXZhdGlvbiAmJiBpbnB1dC50YXBCaXAzMkRlcml2YXRpb24ubGVuZ3RoKSB8fFxuICAgICAgKGlucHV0LndpdG5lc3NVdHhvICYmICgwLCBwc2J0dXRpbHNfMS5pc1AyVFIpKGlucHV0LndpdG5lc3NVdHhvLnNjcmlwdCkpXG4gICAgKVxuICApO1xufVxuZXhwb3J0cy5pc1RhcHJvb3RJbnB1dCA9IGlzVGFwcm9vdElucHV0O1xuZnVuY3Rpb24gaXNUYXByb290T3V0cHV0KG91dHB1dCwgc2NyaXB0KSB7XG4gIHJldHVybiAoXG4gICAgb3V0cHV0ICYmXG4gICAgISEoXG4gICAgICBvdXRwdXQudGFwSW50ZXJuYWxLZXkgfHxcbiAgICAgIG91dHB1dC50YXBUcmVlIHx8XG4gICAgICAob3V0cHV0LnRhcEJpcDMyRGVyaXZhdGlvbiAmJiBvdXRwdXQudGFwQmlwMzJEZXJpdmF0aW9uLmxlbmd0aCkgfHxcbiAgICAgIChzY3JpcHQgJiYgKDAsIHBzYnR1dGlsc18xLmlzUDJUUikoc2NyaXB0KSlcbiAgICApXG4gICk7XG59XG5leHBvcnRzLmlzVGFwcm9vdE91dHB1dCA9IGlzVGFwcm9vdE91dHB1dDtcbmZ1bmN0aW9uIGNoZWNrVGFwcm9vdElucHV0RmllbGRzKGlucHV0RGF0YSwgbmV3SW5wdXREYXRhLCBhY3Rpb24pIHtcbiAgY2hlY2tNaXhlZFRhcHJvb3RBbmROb25UYXByb290SW5wdXRGaWVsZHMoaW5wdXREYXRhLCBuZXdJbnB1dERhdGEsIGFjdGlvbik7XG4gIGNoZWNrSWZUYXBMZWFmSW5UcmVlKGlucHV0RGF0YSwgbmV3SW5wdXREYXRhLCBhY3Rpb24pO1xufVxuZXhwb3J0cy5jaGVja1RhcHJvb3RJbnB1dEZpZWxkcyA9IGNoZWNrVGFwcm9vdElucHV0RmllbGRzO1xuZnVuY3Rpb24gY2hlY2tUYXByb290T3V0cHV0RmllbGRzKG91dHB1dERhdGEsIG5ld091dHB1dERhdGEsIGFjdGlvbikge1xuICBjaGVja01peGVkVGFwcm9vdEFuZE5vblRhcHJvb3RPdXRwdXRGaWVsZHMob3V0cHV0RGF0YSwgbmV3T3V0cHV0RGF0YSwgYWN0aW9uKTtcbiAgY2hlY2tUYXByb290U2NyaXB0UHVia2V5KG91dHB1dERhdGEsIG5ld091dHB1dERhdGEpO1xufVxuZXhwb3J0cy5jaGVja1RhcHJvb3RPdXRwdXRGaWVsZHMgPSBjaGVja1RhcHJvb3RPdXRwdXRGaWVsZHM7XG5mdW5jdGlvbiBjaGVja1RhcHJvb3RTY3JpcHRQdWJrZXkob3V0cHV0RGF0YSwgbmV3T3V0cHV0RGF0YSkge1xuICBpZiAoIW5ld091dHB1dERhdGEudGFwVHJlZSAmJiAhbmV3T3V0cHV0RGF0YS50YXBJbnRlcm5hbEtleSkgcmV0dXJuO1xuICBjb25zdCB0YXBJbnRlcm5hbEtleSA9XG4gICAgbmV3T3V0cHV0RGF0YS50YXBJbnRlcm5hbEtleSB8fCBvdXRwdXREYXRhLnRhcEludGVybmFsS2V5O1xuICBjb25zdCB0YXBUcmVlID0gbmV3T3V0cHV0RGF0YS50YXBUcmVlIHx8IG91dHB1dERhdGEudGFwVHJlZTtcbiAgaWYgKHRhcEludGVybmFsS2V5KSB7XG4gICAgY29uc3QgeyBzY3JpcHQ6IHNjcmlwdFB1YmtleSB9ID0gb3V0cHV0RGF0YTtcbiAgICBjb25zdCBzY3JpcHQgPSBnZXRUYXByb290U2NyaXBQdWJrZXkodGFwSW50ZXJuYWxLZXksIHRhcFRyZWUpO1xuICAgIGlmIChzY3JpcHRQdWJrZXkgJiYgIXNjcmlwdFB1YmtleS5lcXVhbHMoc2NyaXB0KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWRkaW5nIG91dHB1dC4gU2NyaXB0IG9yIGFkZHJlc3MgbWlzc21hdGNoLicpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUYXByb290U2NyaXBQdWJrZXkodGFwSW50ZXJuYWxLZXksIHRhcFRyZWUpIHtcbiAgY29uc3Qgc2NyaXB0VHJlZSA9IHRhcFRyZWUgJiYgdGFwVHJlZUZyb21MaXN0KHRhcFRyZWUubGVhdmVzKTtcbiAgY29uc3QgeyBvdXRwdXQgfSA9ICgwLCBwYXltZW50c18xLnAydHIpKHtcbiAgICBpbnRlcm5hbFB1YmtleTogdGFwSW50ZXJuYWxLZXksXG4gICAgc2NyaXB0VHJlZSxcbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiB0d2Vha0ludGVybmFsUHViS2V5KGlucHV0SW5kZXgsIGlucHV0KSB7XG4gIGNvbnN0IHRhcEludGVybmFsS2V5ID0gaW5wdXQudGFwSW50ZXJuYWxLZXk7XG4gIGNvbnN0IG91dHB1dEtleSA9XG4gICAgdGFwSW50ZXJuYWxLZXkgJiZcbiAgICAoMCwgYmlwMzQxXzEudHdlYWtLZXkpKHRhcEludGVybmFsS2V5LCBpbnB1dC50YXBNZXJrbGVSb290KTtcbiAgaWYgKCFvdXRwdXRLZXkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCB0d2VhayB0YXAgaW50ZXJuYWwga2V5IGZvciBpbnB1dCAjJHtpbnB1dEluZGV4fS4gUHVibGljIGtleTogJHtcbiAgICAgICAgdGFwSW50ZXJuYWxLZXkgJiYgdGFwSW50ZXJuYWxLZXkudG9TdHJpbmcoJ2hleCcpXG4gICAgICB9YCxcbiAgICApO1xuICByZXR1cm4gb3V0cHV0S2V5Lng7XG59XG5leHBvcnRzLnR3ZWFrSW50ZXJuYWxQdWJLZXkgPSB0d2Vha0ludGVybmFsUHViS2V5O1xuLyoqXG4gKiBDb252ZXJ0IGEgYmluYXJ5IHRyZWUgdG8gYSBCSVAzNzEgdHlwZSBsaXN0LiBFYWNoIGVsZW1lbnQgb2YgdGhlIGxpc3QgaXMgKGFjY29yZGluZyB0byBCSVAzNzEpOlxuICogT25lIG9yIG1vcmUgdHVwbGVzIHJlcHJlc2VudGluZyB0aGUgZGVwdGgsIGxlYWYgdmVyc2lvbiwgYW5kIHNjcmlwdCBmb3IgYSBsZWFmIGluIHRoZSBUYXByb290IHRyZWUsXG4gKiBhbGxvd2luZyB0aGUgZW50aXJlIHRyZWUgdG8gYmUgcmVjb25zdHJ1Y3RlZC4gVGhlIHR1cGxlcyBtdXN0IGJlIGluIGRlcHRoIGZpcnN0IHNlYXJjaCBvcmRlciBzbyB0aGF0XG4gKiB0aGUgdHJlZSBpcyBjb3JyZWN0bHkgcmVjb25zdHJ1Y3RlZC5cbiAqIEBwYXJhbSB0cmVlIHRoZSBiaW5hcnkgdGFwIHRyZWVcbiAqIEByZXR1cm5zIGEgbGlzdCBvZiBCSVAgMzcxIHRhcGxlYXZlc1xuICovXG5mdW5jdGlvbiB0YXBUcmVlVG9MaXN0KHRyZWUpIHtcbiAgaWYgKCEoMCwgdHlwZXNfMS5pc1RhcHRyZWUpKHRyZWUpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdDYW5ub3QgY29udmVydCB0YXB0cmVlIHRvIHRhcGxlYWYgbGlzdC4gRXhwZWN0aW5nIGEgdGFwcmVlIHN0cnVjdHVyZS4nLFxuICAgICk7XG4gIHJldHVybiBfdGFwVHJlZVRvTGlzdCh0cmVlKTtcbn1cbmV4cG9ydHMudGFwVHJlZVRvTGlzdCA9IHRhcFRyZWVUb0xpc3Q7XG4vKipcbiAqIENvbnZlcnQgYSBCSVAzNzEgVGFwTGVhZiBsaXN0IHRvIGEgVGFwVHJlZSAoYmluYXJ5KS5cbiAqIEBwYXJhbSBsZWF2ZXMgYSBsaXN0IG9mIHRhcGxlYXZlcyB3aGVyZSBlYWNoIGVsZW1lbnQgb2YgdGhlIGxpc3QgaXMgKGFjY29yZGluZyB0byBCSVAzNzEpOlxuICogT25lIG9yIG1vcmUgdHVwbGVzIHJlcHJlc2VudGluZyB0aGUgZGVwdGgsIGxlYWYgdmVyc2lvbiwgYW5kIHNjcmlwdCBmb3IgYSBsZWFmIGluIHRoZSBUYXByb290IHRyZWUsXG4gKiBhbGxvd2luZyB0aGUgZW50aXJlIHRyZWUgdG8gYmUgcmVjb25zdHJ1Y3RlZC4gVGhlIHR1cGxlcyBtdXN0IGJlIGluIGRlcHRoIGZpcnN0IHNlYXJjaCBvcmRlciBzbyB0aGF0XG4gKiB0aGUgdHJlZSBpcyBjb3JyZWN0bHkgcmVjb25zdHJ1Y3RlZC5cbiAqIEByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHRhcHRyZWUsIG9yIHRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIHRyZWUgY2Fubm90IGJlIHJlY29uc3RydWN0ZWRcbiAqL1xuZnVuY3Rpb24gdGFwVHJlZUZyb21MaXN0KGxlYXZlcyA9IFtdKSB7XG4gIGlmIChsZWF2ZXMubGVuZ3RoID09PSAxICYmIGxlYXZlc1swXS5kZXB0aCA9PT0gMClcbiAgICByZXR1cm4ge1xuICAgICAgb3V0cHV0OiBsZWF2ZXNbMF0uc2NyaXB0LFxuICAgICAgdmVyc2lvbjogbGVhdmVzWzBdLmxlYWZWZXJzaW9uLFxuICAgIH07XG4gIHJldHVybiBpbnN0ZXJ0TGVhdmVzSW5UcmVlKGxlYXZlcyk7XG59XG5leHBvcnRzLnRhcFRyZWVGcm9tTGlzdCA9IHRhcFRyZWVGcm9tTGlzdDtcbmZ1bmN0aW9uIGNoZWNrVGFwcm9vdElucHV0Rm9yU2lncyhpbnB1dCwgYWN0aW9uKSB7XG4gIGNvbnN0IHNpZ3MgPSBleHRyYWN0VGFwcm9vdFNpZ3MoaW5wdXQpO1xuICByZXR1cm4gc2lncy5zb21lKHNpZyA9PlxuICAgICgwLCBwc2J0dXRpbHNfMi5zaWduYXR1cmVCbG9ja3NBY3Rpb24pKHNpZywgZGVjb2RlU2Nobm9yclNpZ25hdHVyZSwgYWN0aW9uKSxcbiAgKTtcbn1cbmV4cG9ydHMuY2hlY2tUYXByb290SW5wdXRGb3JTaWdzID0gY2hlY2tUYXByb290SW5wdXRGb3JTaWdzO1xuZnVuY3Rpb24gZGVjb2RlU2Nobm9yclNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgcmV0dXJuIHtcbiAgICBzaWduYXR1cmU6IHNpZ25hdHVyZS5zbGljZSgwLCA2NCksXG4gICAgaGFzaFR5cGU6XG4gICAgICBzaWduYXR1cmUuc2xpY2UoNjQpWzBdIHx8IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24uU0lHSEFTSF9ERUZBVUxULFxuICB9O1xufVxuZnVuY3Rpb24gZXh0cmFjdFRhcHJvb3RTaWdzKGlucHV0KSB7XG4gIGNvbnN0IHNpZ3MgPSBbXTtcbiAgaWYgKGlucHV0LnRhcEtleVNpZykgc2lncy5wdXNoKGlucHV0LnRhcEtleVNpZyk7XG4gIGlmIChpbnB1dC50YXBTY3JpcHRTaWcpXG4gICAgc2lncy5wdXNoKC4uLmlucHV0LnRhcFNjcmlwdFNpZy5tYXAocyA9PiBzLnNpZ25hdHVyZSkpO1xuICBpZiAoIXNpZ3MubGVuZ3RoKSB7XG4gICAgY29uc3QgZmluYWxUYXBLZXlTaWcgPSBnZXRUYXBLZXlTaWdGcm9tV2l0aG5lc3MoaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzKTtcbiAgICBpZiAoZmluYWxUYXBLZXlTaWcpIHNpZ3MucHVzaChmaW5hbFRhcEtleVNpZyk7XG4gIH1cbiAgcmV0dXJuIHNpZ3M7XG59XG5mdW5jdGlvbiBnZXRUYXBLZXlTaWdGcm9tV2l0aG5lc3MoZmluYWxTY3JpcHRXaXRuZXNzKSB7XG4gIGlmICghZmluYWxTY3JpcHRXaXRuZXNzKSByZXR1cm47XG4gIGNvbnN0IHdpdG5lc3MgPSBmaW5hbFNjcmlwdFdpdG5lc3Muc2xpY2UoMik7XG4gIC8vIHRvZG86IGFkZCBzY2hub3JyIHNpZ25hdHVyZSB2YWxpZGF0aW9uXG4gIGlmICh3aXRuZXNzLmxlbmd0aCA9PT0gNjQgfHwgd2l0bmVzcy5sZW5ndGggPT09IDY1KSByZXR1cm4gd2l0bmVzcztcbn1cbmZ1bmN0aW9uIF90YXBUcmVlVG9MaXN0KHRyZWUsIGxlYXZlcyA9IFtdLCBkZXB0aCA9IDApIHtcbiAgaWYgKGRlcHRoID4gYmlwMzQxXzEuTUFYX1RBUFRSRUVfREVQVEgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNYXggdGFwdHJlZSBkZXB0aCBleGNlZWRlZC4nKTtcbiAgaWYgKCF0cmVlKSByZXR1cm4gW107XG4gIGlmICgoMCwgdHlwZXNfMS5pc1RhcGxlYWYpKHRyZWUpKSB7XG4gICAgbGVhdmVzLnB1c2goe1xuICAgICAgZGVwdGgsXG4gICAgICBsZWFmVmVyc2lvbjogdHJlZS52ZXJzaW9uIHx8IGJpcDM0MV8xLkxFQUZfVkVSU0lPTl9UQVBTQ1JJUFQsXG4gICAgICBzY3JpcHQ6IHRyZWUub3V0cHV0LFxuICAgIH0pO1xuICAgIHJldHVybiBsZWF2ZXM7XG4gIH1cbiAgaWYgKHRyZWVbMF0pIF90YXBUcmVlVG9MaXN0KHRyZWVbMF0sIGxlYXZlcywgZGVwdGggKyAxKTtcbiAgaWYgKHRyZWVbMV0pIF90YXBUcmVlVG9MaXN0KHRyZWVbMV0sIGxlYXZlcywgZGVwdGggKyAxKTtcbiAgcmV0dXJuIGxlYXZlcztcbn1cbmZ1bmN0aW9uIGluc3RlcnRMZWF2ZXNJblRyZWUobGVhdmVzKSB7XG4gIGxldCB0cmVlO1xuICBmb3IgKGNvbnN0IGxlYWYgb2YgbGVhdmVzKSB7XG4gICAgdHJlZSA9IGluc3RlcnRMZWFmSW5UcmVlKGxlYWYsIHRyZWUpO1xuICAgIGlmICghdHJlZSkgdGhyb3cgbmV3IEVycm9yKGBObyByb29tIGxlZnQgdG8gaW5zZXJ0IHRhcGxlYWYgaW4gdHJlZWApO1xuICB9XG4gIHJldHVybiB0cmVlO1xufVxuZnVuY3Rpb24gaW5zdGVydExlYWZJblRyZWUobGVhZiwgdHJlZSwgZGVwdGggPSAwKSB7XG4gIGlmIChkZXB0aCA+IGJpcDM0MV8xLk1BWF9UQVBUUkVFX0RFUFRIKVxuICAgIHRocm93IG5ldyBFcnJvcignTWF4IHRhcHRyZWUgZGVwdGggZXhjZWVkZWQuJyk7XG4gIGlmIChsZWFmLmRlcHRoID09PSBkZXB0aCkge1xuICAgIGlmICghdHJlZSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG91dHB1dDogbGVhZi5zY3JpcHQsXG4gICAgICAgIHZlcnNpb246IGxlYWYubGVhZlZlcnNpb24sXG4gICAgICB9O1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoKDAsIHR5cGVzXzEuaXNUYXBsZWFmKSh0cmVlKSkgcmV0dXJuO1xuICBjb25zdCBsZWZ0U2lkZSA9IGluc3RlcnRMZWFmSW5UcmVlKGxlYWYsIHRyZWUgJiYgdHJlZVswXSwgZGVwdGggKyAxKTtcbiAgaWYgKGxlZnRTaWRlKSByZXR1cm4gW2xlZnRTaWRlLCB0cmVlICYmIHRyZWVbMV1dO1xuICBjb25zdCByaWdodFNpZGUgPSBpbnN0ZXJ0TGVhZkluVHJlZShsZWFmLCB0cmVlICYmIHRyZWVbMV0sIGRlcHRoICsgMSk7XG4gIGlmIChyaWdodFNpZGUpIHJldHVybiBbdHJlZSAmJiB0cmVlWzBdLCByaWdodFNpZGVdO1xufVxuZnVuY3Rpb24gY2hlY2tNaXhlZFRhcHJvb3RBbmROb25UYXByb290SW5wdXRGaWVsZHMoXG4gIGlucHV0RGF0YSxcbiAgbmV3SW5wdXREYXRhLFxuICBhY3Rpb24sXG4pIHtcbiAgY29uc3QgaXNCYWRUYXByb290VXBkYXRlID1cbiAgICBpc1RhcHJvb3RJbnB1dChpbnB1dERhdGEpICYmIGhhc05vblRhcHJvb3RGaWVsZHMobmV3SW5wdXREYXRhKTtcbiAgY29uc3QgaXNCYWROb25UYXByb290VXBkYXRlID1cbiAgICBoYXNOb25UYXByb290RmllbGRzKGlucHV0RGF0YSkgJiYgaXNUYXByb290SW5wdXQobmV3SW5wdXREYXRhKTtcbiAgY29uc3QgaGFzTWl4ZWRGaWVsZHMgPVxuICAgIGlucHV0RGF0YSA9PT0gbmV3SW5wdXREYXRhICYmXG4gICAgaXNUYXByb290SW5wdXQobmV3SW5wdXREYXRhKSAmJlxuICAgIGhhc05vblRhcHJvb3RGaWVsZHMobmV3SW5wdXREYXRhKTsgLy8gdG9kbzogYmFkPyB1c2UgIT09PVxuICBpZiAoaXNCYWRUYXByb290VXBkYXRlIHx8IGlzQmFkTm9uVGFwcm9vdFVwZGF0ZSB8fCBoYXNNaXhlZEZpZWxkcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBhcmd1bWVudHMgZm9yIFBzYnQuJHthY3Rpb259LiBgICtcbiAgICAgICAgYENhbm5vdCB1c2UgYm90aCB0YXByb290IGFuZCBub24tdGFwcm9vdCBmaWVsZHMuYCxcbiAgICApO1xufVxuZnVuY3Rpb24gY2hlY2tNaXhlZFRhcHJvb3RBbmROb25UYXByb290T3V0cHV0RmllbGRzKFxuICBpbnB1dERhdGEsXG4gIG5ld0lucHV0RGF0YSxcbiAgYWN0aW9uLFxuKSB7XG4gIGNvbnN0IGlzQmFkVGFwcm9vdFVwZGF0ZSA9XG4gICAgaXNUYXByb290T3V0cHV0KGlucHV0RGF0YSkgJiYgaGFzTm9uVGFwcm9vdEZpZWxkcyhuZXdJbnB1dERhdGEpO1xuICBjb25zdCBpc0JhZE5vblRhcHJvb3RVcGRhdGUgPVxuICAgIGhhc05vblRhcHJvb3RGaWVsZHMoaW5wdXREYXRhKSAmJiBpc1RhcHJvb3RPdXRwdXQobmV3SW5wdXREYXRhKTtcbiAgY29uc3QgaGFzTWl4ZWRGaWVsZHMgPVxuICAgIGlucHV0RGF0YSA9PT0gbmV3SW5wdXREYXRhICYmXG4gICAgaXNUYXByb290T3V0cHV0KG5ld0lucHV0RGF0YSkgJiZcbiAgICBoYXNOb25UYXByb290RmllbGRzKG5ld0lucHV0RGF0YSk7XG4gIGlmIChpc0JhZFRhcHJvb3RVcGRhdGUgfHwgaXNCYWROb25UYXByb290VXBkYXRlIHx8IGhhc01peGVkRmllbGRzKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgUHNidC4ke2FjdGlvbn0uIGAgK1xuICAgICAgICBgQ2Fubm90IHVzZSBib3RoIHRhcHJvb3QgYW5kIG5vbi10YXByb290IGZpZWxkcy5gLFxuICAgICk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdGFwIGxlYWYgaXMgcGFydCBvZiB0aGUgdGFwIHRyZWUgZm9yIHRoZSBnaXZlbiBpbnB1dCBkYXRhLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB0YXAgbGVhZiBpcyBub3QgcGFydCBvZiB0aGUgdGFwIHRyZWUuXG4gKiBAcGFyYW0gaW5wdXREYXRhIC0gVGhlIG9yaWdpbmFsIFBzYnRJbnB1dCBkYXRhLlxuICogQHBhcmFtIG5ld0lucHV0RGF0YSAtIFRoZSBuZXcgUHNidElucHV0IGRhdGEuXG4gKiBAcGFyYW0gYWN0aW9uIC0gVGhlIGFjdGlvbiBiZWluZyBwZXJmb3JtZWQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiB0aGUgdGFwIGxlYWYgaXMgbm90IHBhcnQgb2YgdGhlIHRhcCB0cmVlLlxuICovXG5mdW5jdGlvbiBjaGVja0lmVGFwTGVhZkluVHJlZShpbnB1dERhdGEsIG5ld0lucHV0RGF0YSwgYWN0aW9uKSB7XG4gIGlmIChuZXdJbnB1dERhdGEudGFwTWVya2xlUm9vdCkge1xuICAgIGNvbnN0IG5ld0xlYWZzSW5UcmVlID0gKG5ld0lucHV0RGF0YS50YXBMZWFmU2NyaXB0IHx8IFtdKS5ldmVyeShsID0+XG4gICAgICBpc1RhcExlYWZJblRyZWUobCwgbmV3SW5wdXREYXRhLnRhcE1lcmtsZVJvb3QpLFxuICAgICk7XG4gICAgY29uc3Qgb2xkTGVhZnNJblRyZWUgPSAoaW5wdXREYXRhLnRhcExlYWZTY3JpcHQgfHwgW10pLmV2ZXJ5KGwgPT5cbiAgICAgIGlzVGFwTGVhZkluVHJlZShsLCBuZXdJbnB1dERhdGEudGFwTWVya2xlUm9vdCksXG4gICAgKTtcbiAgICBpZiAoIW5ld0xlYWZzSW5UcmVlIHx8ICFvbGRMZWFmc0luVHJlZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEludmFsaWQgYXJndW1lbnRzIGZvciBQc2J0LiR7YWN0aW9ufS4gVGFwbGVhZiBub3QgcGFydCBvZiB0YXB0cmVlLmAsXG4gICAgICApO1xuICB9IGVsc2UgaWYgKGlucHV0RGF0YS50YXBNZXJrbGVSb290KSB7XG4gICAgY29uc3QgbmV3TGVhZnNJblRyZWUgPSAobmV3SW5wdXREYXRhLnRhcExlYWZTY3JpcHQgfHwgW10pLmV2ZXJ5KGwgPT5cbiAgICAgIGlzVGFwTGVhZkluVHJlZShsLCBpbnB1dERhdGEudGFwTWVya2xlUm9vdCksXG4gICAgKTtcbiAgICBpZiAoIW5ld0xlYWZzSW5UcmVlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBhcmd1bWVudHMgZm9yIFBzYnQuJHthY3Rpb259LiBUYXBsZWFmIG5vdCBwYXJ0IG9mIHRhcHRyZWUuYCxcbiAgICAgICk7XG4gIH1cbn1cbi8qKlxuICogQ2hlY2tzIGlmIGEgVGFwTGVhZlNjcmlwdCBpcyBwcmVzZW50IGluIGEgTWVya2xlIHRyZWUuXG4gKiBAcGFyYW0gdGFwTGVhZiBUaGUgVGFwTGVhZlNjcmlwdCB0byBjaGVjay5cbiAqIEBwYXJhbSBtZXJrbGVSb290IFRoZSBNZXJrbGUgcm9vdCBvZiB0aGUgdHJlZS4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZnVuY3Rpb24gYXNzdW1lcyB0aGUgVGFwTGVhZlNjcmlwdCBpcyBwcmVzZW50LlxuICogQHJldHVybnMgQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgVGFwTGVhZlNjcmlwdCBpcyBwcmVzZW50IGluIHRoZSB0cmVlLlxuICovXG5mdW5jdGlvbiBpc1RhcExlYWZJblRyZWUodGFwTGVhZiwgbWVya2xlUm9vdCkge1xuICBpZiAoIW1lcmtsZVJvb3QpIHJldHVybiB0cnVlO1xuICBjb25zdCBsZWFmSGFzaCA9ICgwLCBiaXAzNDFfMS50YXBsZWFmSGFzaCkoe1xuICAgIG91dHB1dDogdGFwTGVhZi5zY3JpcHQsXG4gICAgdmVyc2lvbjogdGFwTGVhZi5sZWFmVmVyc2lvbixcbiAgfSk7XG4gIGNvbnN0IHJvb3RIYXNoID0gKDAsIGJpcDM0MV8xLnJvb3RIYXNoRnJvbVBhdGgpKFxuICAgIHRhcExlYWYuY29udHJvbEJsb2NrLFxuICAgIGxlYWZIYXNoLFxuICApO1xuICByZXR1cm4gcm9vdEhhc2guZXF1YWxzKG1lcmtsZVJvb3QpO1xufVxuLyoqXG4gKiBTb3J0cyB0aGUgc2lnbmF0dXJlcyBpbiB0aGUgaW5wdXQncyB0YXBTY3JpcHRTaWcgYXJyYXkgYmFzZWQgb24gdGhlaXIgcG9zaXRpb24gaW4gdGhlIHRhcExlYWYgc2NyaXB0LlxuICpcbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSBQc2J0SW5wdXQgb2JqZWN0LlxuICogQHBhcmFtIHRhcExlYWYgLSBUaGUgVGFwTGVhZlNjcmlwdCBvYmplY3QuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzb3J0ZWQgc2lnbmF0dXJlcyBhcyBCdWZmZXJzLlxuICovXG5mdW5jdGlvbiBzb3J0U2lnbmF0dXJlcyhpbnB1dCwgdGFwTGVhZikge1xuICBjb25zdCBsZWFmSGFzaCA9ICgwLCBiaXAzNDFfMS50YXBsZWFmSGFzaCkoe1xuICAgIG91dHB1dDogdGFwTGVhZi5zY3JpcHQsXG4gICAgdmVyc2lvbjogdGFwTGVhZi5sZWFmVmVyc2lvbixcbiAgfSk7XG4gIHJldHVybiAoaW5wdXQudGFwU2NyaXB0U2lnIHx8IFtdKVxuICAgIC5maWx0ZXIodHNzID0+IHRzcy5sZWFmSGFzaC5lcXVhbHMobGVhZkhhc2gpKVxuICAgIC5tYXAodHNzID0+IGFkZFB1YmtleVBvc2l0aW9uSW5TY3JpcHQodGFwTGVhZi5zY3JpcHQsIHRzcykpXG4gICAgLnNvcnQoKHQxLCB0MikgPT4gdDIucG9zaXRpb25JblNjcmlwdCAtIHQxLnBvc2l0aW9uSW5TY3JpcHQpXG4gICAgLm1hcCh0ID0+IHQuc2lnbmF0dXJlKTtcbn1cbi8qKlxuICogQWRkcyB0aGUgcG9zaXRpb24gb2YgYSBwdWJsaWMga2V5IGluIGEgc2NyaXB0IHRvIGEgVGFwU2NyaXB0U2lnIG9iamVjdC5cbiAqIEBwYXJhbSBzY3JpcHQgVGhlIHNjcmlwdCBpbiB3aGljaCB0byBmaW5kIHRoZSBwb3NpdGlvbiBvZiB0aGUgcHVibGljIGtleS5cbiAqIEBwYXJhbSB0c3MgVGhlIFRhcFNjcmlwdFNpZyBvYmplY3QgdG8gYWRkIHRoZSBwb3NpdGlvbiB0by5cbiAqIEByZXR1cm5zIEEgVGFwU2NyaXB0U2lnV2l0UG9zaXRpb24gb2JqZWN0IHdpdGggdGhlIGFkZGVkIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBhZGRQdWJrZXlQb3NpdGlvbkluU2NyaXB0KHNjcmlwdCwgdHNzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgIHtcbiAgICAgIHBvc2l0aW9uSW5TY3JpcHQ6ICgwLCBwc2J0dXRpbHNfMS5wdWJrZXlQb3NpdGlvbkluU2NyaXB0KShcbiAgICAgICAgdHNzLnB1YmtleSxcbiAgICAgICAgc2NyaXB0LFxuICAgICAgKSxcbiAgICB9LFxuICAgIHRzcyxcbiAgKTtcbn1cbi8qKlxuICogRmluZCB0YXBsZWFmIGJ5IGhhc2gsIG9yIGdldCB0aGUgc2lnbmVkIHRhcGxlYWYgd2l0aCB0aGUgc2hvcnRlc3QgcGF0aC5cbiAqL1xuZnVuY3Rpb24gZmluZFRhcExlYWZUb0ZpbmFsaXplKGlucHV0LCBpbnB1dEluZGV4LCBsZWFmSGFzaFRvRmluYWxpemUpIHtcbiAgaWYgKCFpbnB1dC50YXBTY3JpcHRTaWcgfHwgIWlucHV0LnRhcFNjcmlwdFNpZy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbiBub3QgZmluYWxpemUgdGFwcm9vdCBpbnB1dCAjJHtpbnB1dEluZGV4fS4gTm8gdGFwbGVhZiBzY3JpcHQgc2lnbmF0dXJlIHByb3ZpZGVkLmAsXG4gICAgKTtcbiAgY29uc3QgdGFwTGVhZiA9IChpbnB1dC50YXBMZWFmU2NyaXB0IHx8IFtdKVxuICAgIC5zb3J0KChhLCBiKSA9PiBhLmNvbnRyb2xCbG9jay5sZW5ndGggLSBiLmNvbnRyb2xCbG9jay5sZW5ndGgpXG4gICAgLmZpbmQobGVhZiA9PlxuICAgICAgY2FuRmluYWxpemVMZWFmKGxlYWYsIGlucHV0LnRhcFNjcmlwdFNpZywgbGVhZkhhc2hUb0ZpbmFsaXplKSxcbiAgICApO1xuICBpZiAoIXRhcExlYWYpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbiBub3QgZmluYWxpemUgdGFwcm9vdCBpbnB1dCAjJHtpbnB1dEluZGV4fS4gU2lnbmF0dXJlIGZvciB0YXBsZWFmIHNjcmlwdCBub3QgZm91bmQuYCxcbiAgICApO1xuICByZXR1cm4gdGFwTGVhZjtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgVGFwTGVhZlNjcmlwdCBjYW4gYmUgZmluYWxpemVkLlxuICpcbiAqIEBwYXJhbSBsZWFmIC0gVGhlIFRhcExlYWZTY3JpcHQgdG8gY2hlY2suXG4gKiBAcGFyYW0gdGFwU2NyaXB0U2lnIC0gVGhlIGFycmF5IG9mIFRhcFNjcmlwdFNpZyBvYmplY3RzLlxuICogQHBhcmFtIGhhc2ggLSBUaGUgb3B0aW9uYWwgaGFzaCB0byBjb21wYXJlIHdpdGggdGhlIGxlYWYgaGFzaC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIFRhcExlYWZTY3JpcHQgY2FuIGJlIGZpbmFsaXplZC5cbiAqL1xuZnVuY3Rpb24gY2FuRmluYWxpemVMZWFmKGxlYWYsIHRhcFNjcmlwdFNpZywgaGFzaCkge1xuICBjb25zdCBsZWFmSGFzaCA9ICgwLCBiaXAzNDFfMS50YXBsZWFmSGFzaCkoe1xuICAgIG91dHB1dDogbGVhZi5zY3JpcHQsXG4gICAgdmVyc2lvbjogbGVhZi5sZWFmVmVyc2lvbixcbiAgfSk7XG4gIGNvbnN0IHdoaXRlTGlzdGVkSGFzaCA9ICFoYXNoIHx8IGhhc2guZXF1YWxzKGxlYWZIYXNoKTtcbiAgcmV0dXJuIChcbiAgICB3aGl0ZUxpc3RlZEhhc2ggJiZcbiAgICB0YXBTY3JpcHRTaWcuZmluZCh0c3MgPT4gdHNzLmxlYWZIYXNoLmVxdWFscyhsZWFmSGFzaCkpICE9PSB1bmRlZmluZWRcbiAgKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBQc2J0SW5wdXQgb3IgUHNidE91dHB1dCBoYXMgbm9uLXRhcHJvb3QgZmllbGRzLlxuICogTm9uLXRhcHJvb3QgZmllbGRzIGluY2x1ZGUgcmVkZWVtU2NyaXB0LCB3aXRuZXNzU2NyaXB0LCBhbmQgYmlwMzJEZXJpdmF0aW9uLlxuICogQHBhcmFtIGlvIFRoZSBQc2J0SW5wdXQgb3IgUHNidE91dHB1dCB0byBjaGVjay5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGdpdmVuIGlucHV0IG9yIG91dHB1dCBoYXMgbm9uLXRhcHJvb3QgZmllbGRzLlxuICovXG5mdW5jdGlvbiBoYXNOb25UYXByb290RmllbGRzKGlvKSB7XG4gIHJldHVybiAoXG4gICAgaW8gJiZcbiAgICAhIShcbiAgICAgIGlvLnJlZGVlbVNjcmlwdCB8fFxuICAgICAgaW8ud2l0bmVzc1NjcmlwdCB8fFxuICAgICAgKGlvLmJpcDMyRGVyaXZhdGlvbiAmJiBpby5iaXAzMkRlcml2YXRpb24ubGVuZ3RoKVxuICAgIClcbiAgKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/psbt/bip371.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/psbt/psbtutils.js":
/*!**********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/psbt/psbtutils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.signatureBlocksAction =\n  exports.checkInputForSig =\n  exports.pubkeyInScript =\n  exports.pubkeyPositionInScript =\n  exports.witnessStackToScriptWitness =\n  exports.isP2TR =\n  exports.isP2SHScript =\n  exports.isP2WSHScript =\n  exports.isP2WPKH =\n  exports.isP2PKH =\n  exports.isP2PK =\n  exports.isP2MS =\n    void 0;\nconst varuint = __webpack_require__(/*! bip174/src/lib/converter/varint */ \"./node_modules/bip174/src/lib/converter/varint.js\");\nconst bscript = __webpack_require__(/*! ../script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nconst transaction_1 = __webpack_require__(/*! ../transaction */ \"./node_modules/bitcoinjs-lib/src/transaction.js\");\nconst crypto_1 = __webpack_require__(/*! ../crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\");\nconst payments = __webpack_require__(/*! ../payments */ \"./node_modules/bitcoinjs-lib/src/payments/index.js\");\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nexports.isP2MS = isPaymentFactory(payments.p2ms);\nexports.isP2PK = isPaymentFactory(payments.p2pk);\nexports.isP2PKH = isPaymentFactory(payments.p2pkh);\nexports.isP2WPKH = isPaymentFactory(payments.p2wpkh);\nexports.isP2WSHScript = isPaymentFactory(payments.p2wsh);\nexports.isP2SHScript = isPaymentFactory(payments.p2sh);\nexports.isP2TR = isPaymentFactory(payments.p2tr);\n/**\n * Converts a witness stack to a script witness.\n * @param witness The witness stack to convert.\n * @returns The script witness as a Buffer.\n */\n/**\n * Converts a witness stack to a script witness.\n * @param witness The witness stack to convert.\n * @returns The converted script witness.\n */\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\nexports.witnessStackToScriptWitness = witnessStackToScriptWitness;\n/**\n * Finds the position of a public key in a script.\n * @param pubkey The public key to search for.\n * @param script The script to search in.\n * @returns The index of the public key in the script, or -1 if not found.\n * @throws {Error} If there is an unknown script error.\n */\nfunction pubkeyPositionInScript(pubkey, script) {\n  const pubkeyHash = (0, crypto_1.hash160)(pubkey);\n  const pubkeyXOnly = pubkey.slice(1, 33); // slice before calling?\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  return decompiled.findIndex(element => {\n    if (typeof element === 'number') return false;\n    return (\n      element.equals(pubkey) ||\n      element.equals(pubkeyHash) ||\n      element.equals(pubkeyXOnly)\n    );\n  });\n}\nexports.pubkeyPositionInScript = pubkeyPositionInScript;\n/**\n * Checks if a public key is present in a script.\n * @param pubkey The public key to check.\n * @param script The script to search in.\n * @returns A boolean indicating whether the public key is present in the script.\n */\nfunction pubkeyInScript(pubkey, script) {\n  return pubkeyPositionInScript(pubkey, script) !== -1;\n}\nexports.pubkeyInScript = pubkeyInScript;\n/**\n * Checks if an input contains a signature for a specific action.\n * @param input - The input to check.\n * @param action - The action to check for.\n * @returns A boolean indicating whether the input contains a signature for the specified action.\n */\nfunction checkInputForSig(input, action) {\n  const pSigs = extractPartialSigs(input);\n  return pSigs.some(pSig =>\n    signatureBlocksAction(pSig, bscript.signature.decode, action),\n  );\n}\nexports.checkInputForSig = checkInputForSig;\n/**\n * Determines if a given action is allowed for a signature block.\n * @param signature - The signature block.\n * @param signatureDecodeFn - The function used to decode the signature.\n * @param action - The action to be checked.\n * @returns True if the action is allowed, false otherwise.\n */\nfunction signatureBlocksAction(signature, signatureDecodeFn, action) {\n  const { hashType } = signatureDecodeFn(signature);\n  const whitelist = [];\n  const isAnyoneCanPay =\n    hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n  if (isAnyoneCanPay) whitelist.push('addInput');\n  const hashMod = hashType & 0x1f;\n  switch (hashMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n    case transaction_1.Transaction.SIGHASH_NONE:\n      whitelist.push('addOutput');\n      whitelist.push('setInputSequence');\n      break;\n  }\n  if (whitelist.indexOf(action) === -1) {\n    return true;\n  }\n  return false;\n}\nexports.signatureBlocksAction = signatureBlocksAction;\n/**\n * Extracts the signatures from a PsbtInput object.\n * If the input has partial signatures, it returns an array of the signatures.\n * If the input does not have partial signatures, it checks if it has a finalScriptSig or finalScriptWitness.\n * If it does, it extracts the signatures from the final scripts and returns them.\n * If none of the above conditions are met, it returns an empty array.\n *\n * @param input - The PsbtInput object from which to extract the signatures.\n * @returns An array of signatures extracted from the PsbtInput object.\n */\nfunction extractPartialSigs(input) {\n  let pSigs = [];\n  if ((input.partialSig || []).length === 0) {\n    if (!input.finalScriptSig && !input.finalScriptWitness) return [];\n    pSigs = getPsigsFromInputFinalScripts(input);\n  } else {\n    pSigs = input.partialSig;\n  }\n  return pSigs.map(p => p.signature);\n}\n/**\n * Retrieves the partial signatures (Psigs) from the input's final scripts.\n * Psigs are extracted from both the final scriptSig and final scriptWitness of the input.\n * Only canonical script signatures are considered.\n *\n * @param input - The PsbtInput object representing the input.\n * @returns An array of PartialSig objects containing the extracted Psigs.\n */\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n    })\n    .map(sig => ({ signature: sig }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcHNidC9wc2J0dXRpbHMuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3QixFQUFFLHdCQUF3QjtBQUMxQixFQUFFLHNCQUFzQjtBQUN4QixFQUFFLDhCQUE4QjtBQUNoQyxFQUFFLG1DQUFtQztBQUNyQyxFQUFFLGNBQWM7QUFDaEIsRUFBRSxvQkFBb0I7QUFDdEIsRUFBRSxxQkFBcUI7QUFDdkIsRUFBRSxnQkFBZ0I7QUFDbEIsRUFBRSxlQUFlO0FBQ2pCLEVBQUUsY0FBYztBQUNoQixFQUFFLGNBQWM7QUFDaEI7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBaUM7QUFDekQsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQVc7QUFDbkMsc0JBQXNCLG1CQUFPLENBQUMsdUVBQWdCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLDZEQUFXO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLHVFQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBLGFBQWEsTUFBTSxpQkFBaUIsTUFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTSxpQkFBaUIsTUFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixLQUFLO0FBQ0wsbUJBQW1CLGdCQUFnQjtBQUNuQyIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9wc2J0L3BzYnR1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaWduYXR1cmVCbG9ja3NBY3Rpb24gPVxuICBleHBvcnRzLmNoZWNrSW5wdXRGb3JTaWcgPVxuICBleHBvcnRzLnB1YmtleUluU2NyaXB0ID1cbiAgZXhwb3J0cy5wdWJrZXlQb3NpdGlvbkluU2NyaXB0ID1cbiAgZXhwb3J0cy53aXRuZXNzU3RhY2tUb1NjcmlwdFdpdG5lc3MgPVxuICBleHBvcnRzLmlzUDJUUiA9XG4gIGV4cG9ydHMuaXNQMlNIU2NyaXB0ID1cbiAgZXhwb3J0cy5pc1AyV1NIU2NyaXB0ID1cbiAgZXhwb3J0cy5pc1AyV1BLSCA9XG4gIGV4cG9ydHMuaXNQMlBLSCA9XG4gIGV4cG9ydHMuaXNQMlBLID1cbiAgZXhwb3J0cy5pc1AyTVMgPVxuICAgIHZvaWQgMDtcbmNvbnN0IHZhcnVpbnQgPSByZXF1aXJlKCdiaXAxNzQvc3JjL2xpYi9jb252ZXJ0ZXIvdmFyaW50Jyk7XG5jb25zdCBic2NyaXB0ID0gcmVxdWlyZSgnLi4vc2NyaXB0Jyk7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZSgnLi4vdHJhbnNhY3Rpb24nKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZSgnLi4vY3J5cHRvJyk7XG5jb25zdCBwYXltZW50cyA9IHJlcXVpcmUoJy4uL3BheW1lbnRzJyk7XG5mdW5jdGlvbiBpc1BheW1lbnRGYWN0b3J5KHBheW1lbnQpIHtcbiAgcmV0dXJuIHNjcmlwdCA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHBheW1lbnQoeyBvdXRwdXQ6IHNjcmlwdCB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydHMuaXNQMk1TID0gaXNQYXltZW50RmFjdG9yeShwYXltZW50cy5wMm1zKTtcbmV4cG9ydHMuaXNQMlBLID0gaXNQYXltZW50RmFjdG9yeShwYXltZW50cy5wMnBrKTtcbmV4cG9ydHMuaXNQMlBLSCA9IGlzUGF5bWVudEZhY3RvcnkocGF5bWVudHMucDJwa2gpO1xuZXhwb3J0cy5pc1AyV1BLSCA9IGlzUGF5bWVudEZhY3RvcnkocGF5bWVudHMucDJ3cGtoKTtcbmV4cG9ydHMuaXNQMldTSFNjcmlwdCA9IGlzUGF5bWVudEZhY3RvcnkocGF5bWVudHMucDJ3c2gpO1xuZXhwb3J0cy5pc1AyU0hTY3JpcHQgPSBpc1BheW1lbnRGYWN0b3J5KHBheW1lbnRzLnAyc2gpO1xuZXhwb3J0cy5pc1AyVFIgPSBpc1BheW1lbnRGYWN0b3J5KHBheW1lbnRzLnAydHIpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIHdpdG5lc3Mgc3RhY2sgdG8gYSBzY3JpcHQgd2l0bmVzcy5cbiAqIEBwYXJhbSB3aXRuZXNzIFRoZSB3aXRuZXNzIHN0YWNrIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgc2NyaXB0IHdpdG5lc3MgYXMgYSBCdWZmZXIuXG4gKi9cbi8qKlxuICogQ29udmVydHMgYSB3aXRuZXNzIHN0YWNrIHRvIGEgc2NyaXB0IHdpdG5lc3MuXG4gKiBAcGFyYW0gd2l0bmVzcyBUaGUgd2l0bmVzcyBzdGFjayB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBzY3JpcHQgd2l0bmVzcy5cbiAqL1xuZnVuY3Rpb24gd2l0bmVzc1N0YWNrVG9TY3JpcHRXaXRuZXNzKHdpdG5lc3MpIHtcbiAgbGV0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgZnVuY3Rpb24gd3JpdGVTbGljZShzbGljZSkge1xuICAgIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgQnVmZmVyLmZyb20oc2xpY2UpXSk7XG4gIH1cbiAgZnVuY3Rpb24gd3JpdGVWYXJJbnQoaSkge1xuICAgIGNvbnN0IGN1cnJlbnRMZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgIGNvbnN0IHZhcmludExlbiA9IHZhcnVpbnQuZW5jb2RpbmdMZW5ndGgoaSk7XG4gICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBCdWZmZXIuYWxsb2NVbnNhZmUodmFyaW50TGVuKV0pO1xuICAgIHZhcnVpbnQuZW5jb2RlKGksIGJ1ZmZlciwgY3VycmVudExlbik7XG4gIH1cbiAgZnVuY3Rpb24gd3JpdGVWYXJTbGljZShzbGljZSkge1xuICAgIHdyaXRlVmFySW50KHNsaWNlLmxlbmd0aCk7XG4gICAgd3JpdGVTbGljZShzbGljZSk7XG4gIH1cbiAgZnVuY3Rpb24gd3JpdGVWZWN0b3IodmVjdG9yKSB7XG4gICAgd3JpdGVWYXJJbnQodmVjdG9yLmxlbmd0aCk7XG4gICAgdmVjdG9yLmZvckVhY2god3JpdGVWYXJTbGljZSk7XG4gIH1cbiAgd3JpdGVWZWN0b3Iod2l0bmVzcyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLndpdG5lc3NTdGFja1RvU2NyaXB0V2l0bmVzcyA9IHdpdG5lc3NTdGFja1RvU2NyaXB0V2l0bmVzcztcbi8qKlxuICogRmluZHMgdGhlIHBvc2l0aW9uIG9mIGEgcHVibGljIGtleSBpbiBhIHNjcmlwdC5cbiAqIEBwYXJhbSBwdWJrZXkgVGhlIHB1YmxpYyBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSBzY3JpcHQgVGhlIHNjcmlwdCB0byBzZWFyY2ggaW4uXG4gKiBAcmV0dXJucyBUaGUgaW5kZXggb2YgdGhlIHB1YmxpYyBrZXkgaW4gdGhlIHNjcmlwdCwgb3IgLTEgaWYgbm90IGZvdW5kLlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGFuIHVua25vd24gc2NyaXB0IGVycm9yLlxuICovXG5mdW5jdGlvbiBwdWJrZXlQb3NpdGlvbkluU2NyaXB0KHB1YmtleSwgc2NyaXB0KSB7XG4gIGNvbnN0IHB1YmtleUhhc2ggPSAoMCwgY3J5cHRvXzEuaGFzaDE2MCkocHVia2V5KTtcbiAgY29uc3QgcHVia2V5WE9ubHkgPSBwdWJrZXkuc2xpY2UoMSwgMzMpOyAvLyBzbGljZSBiZWZvcmUgY2FsbGluZz9cbiAgY29uc3QgZGVjb21waWxlZCA9IGJzY3JpcHQuZGVjb21waWxlKHNjcmlwdCk7XG4gIGlmIChkZWNvbXBpbGVkID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gc2NyaXB0IGVycm9yJyk7XG4gIHJldHVybiBkZWNvbXBpbGVkLmZpbmRJbmRleChlbGVtZW50ID0+IHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIChcbiAgICAgIGVsZW1lbnQuZXF1YWxzKHB1YmtleSkgfHxcbiAgICAgIGVsZW1lbnQuZXF1YWxzKHB1YmtleUhhc2gpIHx8XG4gICAgICBlbGVtZW50LmVxdWFscyhwdWJrZXlYT25seSlcbiAgICApO1xuICB9KTtcbn1cbmV4cG9ydHMucHVia2V5UG9zaXRpb25JblNjcmlwdCA9IHB1YmtleVBvc2l0aW9uSW5TY3JpcHQ7XG4vKipcbiAqIENoZWNrcyBpZiBhIHB1YmxpYyBrZXkgaXMgcHJlc2VudCBpbiBhIHNjcmlwdC5cbiAqIEBwYXJhbSBwdWJrZXkgVGhlIHB1YmxpYyBrZXkgdG8gY2hlY2suXG4gKiBAcGFyYW0gc2NyaXB0IFRoZSBzY3JpcHQgdG8gc2VhcmNoIGluLlxuICogQHJldHVybnMgQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcHVibGljIGtleSBpcyBwcmVzZW50IGluIHRoZSBzY3JpcHQuXG4gKi9cbmZ1bmN0aW9uIHB1YmtleUluU2NyaXB0KHB1YmtleSwgc2NyaXB0KSB7XG4gIHJldHVybiBwdWJrZXlQb3NpdGlvbkluU2NyaXB0KHB1YmtleSwgc2NyaXB0KSAhPT0gLTE7XG59XG5leHBvcnRzLnB1YmtleUluU2NyaXB0ID0gcHVia2V5SW5TY3JpcHQ7XG4vKipcbiAqIENoZWNrcyBpZiBhbiBpbnB1dCBjb250YWlucyBhIHNpZ25hdHVyZSBmb3IgYSBzcGVjaWZpYyBhY3Rpb24uXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgaW5wdXQgdG8gY2hlY2suXG4gKiBAcGFyYW0gYWN0aW9uIC0gVGhlIGFjdGlvbiB0byBjaGVjayBmb3IuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBpbnB1dCBjb250YWlucyBhIHNpZ25hdHVyZSBmb3IgdGhlIHNwZWNpZmllZCBhY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNoZWNrSW5wdXRGb3JTaWcoaW5wdXQsIGFjdGlvbikge1xuICBjb25zdCBwU2lncyA9IGV4dHJhY3RQYXJ0aWFsU2lncyhpbnB1dCk7XG4gIHJldHVybiBwU2lncy5zb21lKHBTaWcgPT5cbiAgICBzaWduYXR1cmVCbG9ja3NBY3Rpb24ocFNpZywgYnNjcmlwdC5zaWduYXR1cmUuZGVjb2RlLCBhY3Rpb24pLFxuICApO1xufVxuZXhwb3J0cy5jaGVja0lucHV0Rm9yU2lnID0gY2hlY2tJbnB1dEZvclNpZztcbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGFjdGlvbiBpcyBhbGxvd2VkIGZvciBhIHNpZ25hdHVyZSBibG9jay5cbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIGJsb2NrLlxuICogQHBhcmFtIHNpZ25hdHVyZURlY29kZUZuIC0gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZGVjb2RlIHRoZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gYWN0aW9uIC0gVGhlIGFjdGlvbiB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgYWN0aW9uIGlzIGFsbG93ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gc2lnbmF0dXJlQmxvY2tzQWN0aW9uKHNpZ25hdHVyZSwgc2lnbmF0dXJlRGVjb2RlRm4sIGFjdGlvbikge1xuICBjb25zdCB7IGhhc2hUeXBlIH0gPSBzaWduYXR1cmVEZWNvZGVGbihzaWduYXR1cmUpO1xuICBjb25zdCB3aGl0ZWxpc3QgPSBbXTtcbiAgY29uc3QgaXNBbnlvbmVDYW5QYXkgPVxuICAgIGhhc2hUeXBlICYgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWTtcbiAgaWYgKGlzQW55b25lQ2FuUGF5KSB3aGl0ZWxpc3QucHVzaCgnYWRkSW5wdXQnKTtcbiAgY29uc3QgaGFzaE1vZCA9IGhhc2hUeXBlICYgMHgxZjtcbiAgc3dpdGNoIChoYXNoTW9kKSB7XG4gICAgY2FzZSB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uLlNJR0hBU0hfU0lOR0xFOlxuICAgIGNhc2UgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbi5TSUdIQVNIX05PTkU6XG4gICAgICB3aGl0ZWxpc3QucHVzaCgnYWRkT3V0cHV0Jyk7XG4gICAgICB3aGl0ZWxpc3QucHVzaCgnc2V0SW5wdXRTZXF1ZW5jZScpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgaWYgKHdoaXRlbGlzdC5pbmRleE9mKGFjdGlvbikgPT09IC0xKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5zaWduYXR1cmVCbG9ja3NBY3Rpb24gPSBzaWduYXR1cmVCbG9ja3NBY3Rpb247XG4vKipcbiAqIEV4dHJhY3RzIHRoZSBzaWduYXR1cmVzIGZyb20gYSBQc2J0SW5wdXQgb2JqZWN0LlxuICogSWYgdGhlIGlucHV0IGhhcyBwYXJ0aWFsIHNpZ25hdHVyZXMsIGl0IHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHNpZ25hdHVyZXMuXG4gKiBJZiB0aGUgaW5wdXQgZG9lcyBub3QgaGF2ZSBwYXJ0aWFsIHNpZ25hdHVyZXMsIGl0IGNoZWNrcyBpZiBpdCBoYXMgYSBmaW5hbFNjcmlwdFNpZyBvciBmaW5hbFNjcmlwdFdpdG5lc3MuXG4gKiBJZiBpdCBkb2VzLCBpdCBleHRyYWN0cyB0aGUgc2lnbmF0dXJlcyBmcm9tIHRoZSBmaW5hbCBzY3JpcHRzIGFuZCByZXR1cm5zIHRoZW0uXG4gKiBJZiBub25lIG9mIHRoZSBhYm92ZSBjb25kaXRpb25zIGFyZSBtZXQsIGl0IHJldHVybnMgYW4gZW1wdHkgYXJyYXkuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIFBzYnRJbnB1dCBvYmplY3QgZnJvbSB3aGljaCB0byBleHRyYWN0IHRoZSBzaWduYXR1cmVzLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygc2lnbmF0dXJlcyBleHRyYWN0ZWQgZnJvbSB0aGUgUHNidElucHV0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFBhcnRpYWxTaWdzKGlucHV0KSB7XG4gIGxldCBwU2lncyA9IFtdO1xuICBpZiAoKGlucHV0LnBhcnRpYWxTaWcgfHwgW10pLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICghaW5wdXQuZmluYWxTY3JpcHRTaWcgJiYgIWlucHV0LmZpbmFsU2NyaXB0V2l0bmVzcykgcmV0dXJuIFtdO1xuICAgIHBTaWdzID0gZ2V0UHNpZ3NGcm9tSW5wdXRGaW5hbFNjcmlwdHMoaW5wdXQpO1xuICB9IGVsc2Uge1xuICAgIHBTaWdzID0gaW5wdXQucGFydGlhbFNpZztcbiAgfVxuICByZXR1cm4gcFNpZ3MubWFwKHAgPT4gcC5zaWduYXR1cmUpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHBhcnRpYWwgc2lnbmF0dXJlcyAoUHNpZ3MpIGZyb20gdGhlIGlucHV0J3MgZmluYWwgc2NyaXB0cy5cbiAqIFBzaWdzIGFyZSBleHRyYWN0ZWQgZnJvbSBib3RoIHRoZSBmaW5hbCBzY3JpcHRTaWcgYW5kIGZpbmFsIHNjcmlwdFdpdG5lc3Mgb2YgdGhlIGlucHV0LlxuICogT25seSBjYW5vbmljYWwgc2NyaXB0IHNpZ25hdHVyZXMgYXJlIGNvbnNpZGVyZWQuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIFBzYnRJbnB1dCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBpbnB1dC5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIFBhcnRpYWxTaWcgb2JqZWN0cyBjb250YWluaW5nIHRoZSBleHRyYWN0ZWQgUHNpZ3MuXG4gKi9cbmZ1bmN0aW9uIGdldFBzaWdzRnJvbUlucHV0RmluYWxTY3JpcHRzKGlucHV0KSB7XG4gIGNvbnN0IHNjcmlwdEl0ZW1zID0gIWlucHV0LmZpbmFsU2NyaXB0U2lnXG4gICAgPyBbXVxuICAgIDogYnNjcmlwdC5kZWNvbXBpbGUoaW5wdXQuZmluYWxTY3JpcHRTaWcpIHx8IFtdO1xuICBjb25zdCB3aXRuZXNzSXRlbXMgPSAhaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzXG4gICAgPyBbXVxuICAgIDogYnNjcmlwdC5kZWNvbXBpbGUoaW5wdXQuZmluYWxTY3JpcHRXaXRuZXNzKSB8fCBbXTtcbiAgcmV0dXJuIHNjcmlwdEl0ZW1zXG4gICAgLmNvbmNhdCh3aXRuZXNzSXRlbXMpXG4gICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoaXRlbSkgJiYgYnNjcmlwdC5pc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZShpdGVtKTtcbiAgICB9KVxuICAgIC5tYXAoc2lnID0+ICh7IHNpZ25hdHVyZTogc2lnIH0pKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/psbt/psbtutils.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/push_data.js":
/*!*****************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/push_data.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decode = exports.encode = exports.encodingLength = void 0;\nconst ops_1 = __webpack_require__(/*! ./ops */ \"./node_modules/bitcoinjs-lib/src/ops.js\");\n/**\n * Calculates the encoding length of a number used for push data in Bitcoin transactions.\n * @param i The number to calculate the encoding length for.\n * @returns The encoding length of the number.\n */\nfunction encodingLength(i) {\n  return i < ops_1.OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;\n}\nexports.encodingLength = encodingLength;\n/**\n * Encodes a number into a buffer using a variable-length encoding scheme.\n * The encoded buffer is written starting at the specified offset.\n * Returns the size of the encoded buffer.\n *\n * @param buffer - The buffer to write the encoded data into.\n * @param num - The number to encode.\n * @param offset - The offset at which to start writing the encoded buffer.\n * @returns The size of the encoded buffer.\n */\nfunction encode(buffer, num, offset) {\n  const size = encodingLength(num);\n  // ~6 bit\n  if (size === 1) {\n    buffer.writeUInt8(num, offset);\n    // 8 bit\n  } else if (size === 2) {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);\n    buffer.writeUInt8(num, offset + 1);\n    // 16 bit\n  } else if (size === 3) {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);\n    buffer.writeUInt16LE(num, offset + 1);\n    // 32 bit\n  } else {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);\n    buffer.writeUInt32LE(num, offset + 1);\n  }\n  return size;\n}\nexports.encode = encode;\n/**\n * Decodes a buffer and returns information about the opcode, number, and size.\n * @param buffer - The buffer to decode.\n * @param offset - The offset within the buffer to start decoding.\n * @returns An object containing the opcode, number, and size, or null if decoding fails.\n */\nfunction decode(buffer, offset) {\n  const opcode = buffer.readUInt8(offset);\n  let num;\n  let size;\n  // ~6 bit\n  if (opcode < ops_1.OPS.OP_PUSHDATA1) {\n    num = opcode;\n    size = 1;\n    // 8 bit\n  } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {\n    if (offset + 2 > buffer.length) return null;\n    num = buffer.readUInt8(offset + 1);\n    size = 2;\n    // 16 bit\n  } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {\n    if (offset + 3 > buffer.length) return null;\n    num = buffer.readUInt16LE(offset + 1);\n    size = 3;\n    // 32 bit\n  } else {\n    if (offset + 5 > buffer.length) return null;\n    if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode');\n    num = buffer.readUInt32LE(offset + 1);\n    size = 5;\n  }\n  return {\n    opcode,\n    number: num,\n    size,\n  };\n}\nexports.decode = decode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcHVzaF9kYXRhLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsR0FBRyxjQUFjLEdBQUcsc0JBQXNCO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQyxzREFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvcHVzaF9kYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5lbmNvZGluZ0xlbmd0aCA9IHZvaWQgMDtcbmNvbnN0IG9wc18xID0gcmVxdWlyZSgnLi9vcHMnKTtcbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZW5jb2RpbmcgbGVuZ3RoIG9mIGEgbnVtYmVyIHVzZWQgZm9yIHB1c2ggZGF0YSBpbiBCaXRjb2luIHRyYW5zYWN0aW9ucy5cbiAqIEBwYXJhbSBpIFRoZSBudW1iZXIgdG8gY2FsY3VsYXRlIHRoZSBlbmNvZGluZyBsZW5ndGggZm9yLlxuICogQHJldHVybnMgVGhlIGVuY29kaW5nIGxlbmd0aCBvZiB0aGUgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBlbmNvZGluZ0xlbmd0aChpKSB7XG4gIHJldHVybiBpIDwgb3BzXzEuT1BTLk9QX1BVU0hEQVRBMSA/IDEgOiBpIDw9IDB4ZmYgPyAyIDogaSA8PSAweGZmZmYgPyAzIDogNTtcbn1cbmV4cG9ydHMuZW5jb2RpbmdMZW5ndGggPSBlbmNvZGluZ0xlbmd0aDtcbi8qKlxuICogRW5jb2RlcyBhIG51bWJlciBpbnRvIGEgYnVmZmVyIHVzaW5nIGEgdmFyaWFibGUtbGVuZ3RoIGVuY29kaW5nIHNjaGVtZS5cbiAqIFRoZSBlbmNvZGVkIGJ1ZmZlciBpcyB3cml0dGVuIHN0YXJ0aW5nIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0LlxuICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgZW5jb2RlZCBidWZmZXIuXG4gKlxuICogQHBhcmFtIGJ1ZmZlciAtIFRoZSBidWZmZXIgdG8gd3JpdGUgdGhlIGVuY29kZWQgZGF0YSBpbnRvLlxuICogQHBhcmFtIG51bSAtIFRoZSBudW1iZXIgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9mZnNldCAtIFRoZSBvZmZzZXQgYXQgd2hpY2ggdG8gc3RhcnQgd3JpdGluZyB0aGUgZW5jb2RlZCBidWZmZXIuXG4gKiBAcmV0dXJucyBUaGUgc2l6ZSBvZiB0aGUgZW5jb2RlZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShidWZmZXIsIG51bSwgb2Zmc2V0KSB7XG4gIGNvbnN0IHNpemUgPSBlbmNvZGluZ0xlbmd0aChudW0pO1xuICAvLyB+NiBiaXRcbiAgaWYgKHNpemUgPT09IDEpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OChudW0sIG9mZnNldCk7XG4gICAgLy8gOCBiaXRcbiAgfSBlbHNlIGlmIChzaXplID09PSAyKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgob3BzXzEuT1BTLk9QX1BVU0hEQVRBMSwgb2Zmc2V0KTtcbiAgICBidWZmZXIud3JpdGVVSW50OChudW0sIG9mZnNldCArIDEpO1xuICAgIC8vIDE2IGJpdFxuICB9IGVsc2UgaWYgKHNpemUgPT09IDMpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OChvcHNfMS5PUFMuT1BfUFVTSERBVEEyLCBvZmZzZXQpO1xuICAgIGJ1ZmZlci53cml0ZVVJbnQxNkxFKG51bSwgb2Zmc2V0ICsgMSk7XG4gICAgLy8gMzIgYml0XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgob3BzXzEuT1BTLk9QX1BVU0hEQVRBNCwgb2Zmc2V0KTtcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRShudW0sIG9mZnNldCArIDEpO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIERlY29kZXMgYSBidWZmZXIgYW5kIHJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9wY29kZSwgbnVtYmVyLCBhbmQgc2l6ZS5cbiAqIEBwYXJhbSBidWZmZXIgLSBUaGUgYnVmZmVyIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgb2Zmc2V0IHdpdGhpbiB0aGUgYnVmZmVyIHRvIHN0YXJ0IGRlY29kaW5nLlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9wY29kZSwgbnVtYmVyLCBhbmQgc2l6ZSwgb3IgbnVsbCBpZiBkZWNvZGluZyBmYWlscy5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIGNvbnN0IG9wY29kZSA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgbGV0IG51bTtcbiAgbGV0IHNpemU7XG4gIC8vIH42IGJpdFxuICBpZiAob3Bjb2RlIDwgb3BzXzEuT1BTLk9QX1BVU0hEQVRBMSkge1xuICAgIG51bSA9IG9wY29kZTtcbiAgICBzaXplID0gMTtcbiAgICAvLyA4IGJpdFxuICB9IGVsc2UgaWYgKG9wY29kZSA9PT0gb3BzXzEuT1BTLk9QX1BVU0hEQVRBMSkge1xuICAgIGlmIChvZmZzZXQgKyAyID4gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgbnVtID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQgKyAxKTtcbiAgICBzaXplID0gMjtcbiAgICAvLyAxNiBiaXRcbiAgfSBlbHNlIGlmIChvcGNvZGUgPT09IG9wc18xLk9QUy5PUF9QVVNIREFUQTIpIHtcbiAgICBpZiAob2Zmc2V0ICsgMyA+IGJ1ZmZlci5sZW5ndGgpIHJldHVybiBudWxsO1xuICAgIG51bSA9IGJ1ZmZlci5yZWFkVUludDE2TEUob2Zmc2V0ICsgMSk7XG4gICAgc2l6ZSA9IDM7XG4gICAgLy8gMzIgYml0XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDUgPiBidWZmZXIubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICBpZiAob3Bjb2RlICE9PSBvcHNfMS5PUFMuT1BfUFVTSERBVEE0KSB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgb3Bjb2RlJyk7XG4gICAgbnVtID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyAxKTtcbiAgICBzaXplID0gNTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9wY29kZSxcbiAgICBudW1iZXI6IG51bSxcbiAgICBzaXplLFxuICB9O1xufVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/push_data.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/script.js":
/*!**************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/script.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.signature =\n  exports.number =\n  exports.isCanonicalScriptSignature =\n  exports.isDefinedHashType =\n  exports.isCanonicalPubKey =\n  exports.toStack =\n  exports.fromASM =\n  exports.toASM =\n  exports.decompile =\n  exports.compile =\n  exports.countNonPushOnlyOPs =\n  exports.isPushOnly =\n  exports.OPS =\n    void 0;\n/**\n * Script tools, including decompile, compile, toASM, fromASM, toStack, isCanonicalPubKey, isCanonicalScriptSignature\n * @packageDocumentation\n */\nconst bip66 = __webpack_require__(/*! ./bip66 */ \"./node_modules/bitcoinjs-lib/src/bip66.js\");\nconst ops_1 = __webpack_require__(/*! ./ops */ \"./node_modules/bitcoinjs-lib/src/ops.js\");\nObject.defineProperty(exports, \"OPS\", ({\n  enumerable: true,\n  get: function () {\n    return ops_1.OPS;\n  },\n}));\nconst pushdata = __webpack_require__(/*! ./push_data */ \"./node_modules/bitcoinjs-lib/src/push_data.js\");\nconst scriptNumber = __webpack_require__(/*! ./script_number */ \"./node_modules/bitcoinjs-lib/src/script_number.js\");\nconst scriptSignature = __webpack_require__(/*! ./script_signature */ \"./node_modules/bitcoinjs-lib/src/script_signature.js\");\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst { typeforce } = types;\nconst OP_INT_BASE = ops_1.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return (\n    types.Number(value) &&\n    (value === ops_1.OPS.OP_0 ||\n      (value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16) ||\n      value === ops_1.OPS.OP_1NEGATE)\n  );\n}\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction countNonPushOnlyOPs(value) {\n  return value.length - value.filter(isPushOnlyChunk).length;\n}\nexports.countNonPushOnlyOPs = countNonPushOnlyOPs;\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return ops_1.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return ops_1.OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\n/**\n * Compiles an array of chunks into a Buffer.\n *\n * @param chunks - The array of chunks to compile.\n * @returns The compiled Buffer.\n * @throws Error if the compilation fails.\n */\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nexports.decompile = decompile;\n/**\n * Converts the given chunks into an ASM (Assembly) string representation.\n * If the chunks parameter is a Buffer, it will be decompiled into a Stack before conversion.\n * @param chunks - The chunks to convert into ASM.\n * @returns The ASM string representation of the chunks.\n */\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  if (!chunks) {\n    throw new Error('Could not convert invalid chunks to ASM');\n  }\n  return chunks\n    .map(chunk => {\n      // data?\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return chunk.toString('hex');\n        chunk = op;\n      }\n      // opcode!\n      return ops_1.REVERSE_OPS[chunk];\n    })\n    .join(' ');\n}\nexports.toASM = toASM;\n/**\n * Converts an ASM string to a Buffer.\n * @param asm The ASM string to convert.\n * @returns The converted Buffer.\n */\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(\n    asm.split(' ').map(chunkStr => {\n      // opcode?\n      if (ops_1.OPS[chunkStr] !== undefined) return ops_1.OPS[chunkStr];\n      typeforce(types.Hex, chunkStr);\n      // data!\n      return Buffer.from(chunkStr, 'hex');\n    }),\n  );\n}\nexports.fromASM = fromASM;\n/**\n * Converts the given chunks into a stack of buffers.\n *\n * @param chunks - The chunks to convert.\n * @returns The stack of buffers.\n */\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === ops_1.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexports.toStack = toStack;\nfunction isCanonicalPubKey(buffer) {\n  return types.isPoint(buffer);\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature;\nexports.number = scriptNumber;\nexports.signature = scriptSignature;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvc2NyaXB0LmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsRUFBRSxjQUFjO0FBQ2hCLEVBQUUsa0NBQWtDO0FBQ3BDLEVBQUUseUJBQXlCO0FBQzNCLEVBQUUseUJBQXlCO0FBQzNCLEVBQUUsZUFBZTtBQUNqQixFQUFFLGVBQWU7QUFDakIsRUFBRSxhQUFhO0FBQ2YsRUFBRSxpQkFBaUI7QUFDbkIsRUFBRSxlQUFlO0FBQ2pCLEVBQUUsMkJBQTJCO0FBQzdCLEVBQUUsa0JBQWtCO0FBQ3BCLEVBQUUsV0FBVztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsMERBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLHNEQUFPO0FBQzdCLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFQUFDO0FBQ0YsaUJBQWlCLG1CQUFPLENBQUMsa0VBQWE7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsMEVBQWlCO0FBQzlDLHdCQUF3QixtQkFBTyxDQUFDLGdGQUFvQjtBQUNwRCxjQUFjLG1CQUFPLENBQUMsMERBQVM7QUFDL0IsUUFBUSxZQUFZO0FBQ3BCLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsTUFBTTtBQUM1QztBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLE9BQU8sTUFBTTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxjQUFjO0FBQ2QsaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3NjcmlwdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaWduYXR1cmUgPVxuICBleHBvcnRzLm51bWJlciA9XG4gIGV4cG9ydHMuaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUgPVxuICBleHBvcnRzLmlzRGVmaW5lZEhhc2hUeXBlID1cbiAgZXhwb3J0cy5pc0Nhbm9uaWNhbFB1YktleSA9XG4gIGV4cG9ydHMudG9TdGFjayA9XG4gIGV4cG9ydHMuZnJvbUFTTSA9XG4gIGV4cG9ydHMudG9BU00gPVxuICBleHBvcnRzLmRlY29tcGlsZSA9XG4gIGV4cG9ydHMuY29tcGlsZSA9XG4gIGV4cG9ydHMuY291bnROb25QdXNoT25seU9QcyA9XG4gIGV4cG9ydHMuaXNQdXNoT25seSA9XG4gIGV4cG9ydHMuT1BTID1cbiAgICB2b2lkIDA7XG4vKipcbiAqIFNjcmlwdCB0b29scywgaW5jbHVkaW5nIGRlY29tcGlsZSwgY29tcGlsZSwgdG9BU00sIGZyb21BU00sIHRvU3RhY2ssIGlzQ2Fub25pY2FsUHViS2V5LCBpc0Nhbm9uaWNhbFNjcmlwdFNpZ25hdHVyZVxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbmNvbnN0IGJpcDY2ID0gcmVxdWlyZSgnLi9iaXA2NicpO1xuY29uc3Qgb3BzXzEgPSByZXF1aXJlKCcuL29wcycpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdPUFMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBvcHNfMS5PUFM7XG4gIH0sXG59KTtcbmNvbnN0IHB1c2hkYXRhID0gcmVxdWlyZSgnLi9wdXNoX2RhdGEnKTtcbmNvbnN0IHNjcmlwdE51bWJlciA9IHJlcXVpcmUoJy4vc2NyaXB0X251bWJlcicpO1xuY29uc3Qgc2NyaXB0U2lnbmF0dXJlID0gcmVxdWlyZSgnLi9zY3JpcHRfc2lnbmF0dXJlJyk7XG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IHsgdHlwZWZvcmNlIH0gPSB0eXBlcztcbmNvbnN0IE9QX0lOVF9CQVNFID0gb3BzXzEuT1BTLk9QX1JFU0VSVkVEOyAvLyBPUF8xIC0gMVxuZnVuY3Rpb24gaXNPUEludCh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHR5cGVzLk51bWJlcih2YWx1ZSkgJiZcbiAgICAodmFsdWUgPT09IG9wc18xLk9QUy5PUF8wIHx8XG4gICAgICAodmFsdWUgPj0gb3BzXzEuT1BTLk9QXzEgJiYgdmFsdWUgPD0gb3BzXzEuT1BTLk9QXzE2KSB8fFxuICAgICAgdmFsdWUgPT09IG9wc18xLk9QUy5PUF8xTkVHQVRFKVxuICApO1xufVxuZnVuY3Rpb24gaXNQdXNoT25seUNodW5rKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlcy5CdWZmZXIodmFsdWUpIHx8IGlzT1BJbnQodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNQdXNoT25seSh2YWx1ZSkge1xuICByZXR1cm4gdHlwZXMuQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGlzUHVzaE9ubHlDaHVuayk7XG59XG5leHBvcnRzLmlzUHVzaE9ubHkgPSBpc1B1c2hPbmx5O1xuZnVuY3Rpb24gY291bnROb25QdXNoT25seU9Qcyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUubGVuZ3RoIC0gdmFsdWUuZmlsdGVyKGlzUHVzaE9ubHlDaHVuaykubGVuZ3RoO1xufVxuZXhwb3J0cy5jb3VudE5vblB1c2hPbmx5T1BzID0gY291bnROb25QdXNoT25seU9QcztcbmZ1bmN0aW9uIGFzTWluaW1hbE9QKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG9wc18xLk9QUy5PUF8wO1xuICBpZiAoYnVmZmVyLmxlbmd0aCAhPT0gMSkgcmV0dXJuO1xuICBpZiAoYnVmZmVyWzBdID49IDEgJiYgYnVmZmVyWzBdIDw9IDE2KSByZXR1cm4gT1BfSU5UX0JBU0UgKyBidWZmZXJbMF07XG4gIGlmIChidWZmZXJbMF0gPT09IDB4ODEpIHJldHVybiBvcHNfMS5PUFMuT1BfMU5FR0FURTtcbn1cbmZ1bmN0aW9uIGNodW5rc0lzQnVmZmVyKGJ1Zikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGJ1Zik7XG59XG5mdW5jdGlvbiBjaHVua3NJc0FycmF5KGJ1Zikge1xuICByZXR1cm4gdHlwZXMuQXJyYXkoYnVmKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZUNodW5rSXNCdWZmZXIoYnVmKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYnVmKTtcbn1cbi8qKlxuICogQ29tcGlsZXMgYW4gYXJyYXkgb2YgY2h1bmtzIGludG8gYSBCdWZmZXIuXG4gKlxuICogQHBhcmFtIGNodW5rcyAtIFRoZSBhcnJheSBvZiBjaHVua3MgdG8gY29tcGlsZS5cbiAqIEByZXR1cm5zIFRoZSBjb21waWxlZCBCdWZmZXIuXG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBjb21waWxhdGlvbiBmYWlscy5cbiAqL1xuZnVuY3Rpb24gY29tcGlsZShjaHVua3MpIHtcbiAgLy8gVE9ETzogcmVtb3ZlIG1lXG4gIGlmIChjaHVua3NJc0J1ZmZlcihjaHVua3MpKSByZXR1cm4gY2h1bmtzO1xuICB0eXBlZm9yY2UodHlwZXMuQXJyYXksIGNodW5rcyk7XG4gIGNvbnN0IGJ1ZmZlclNpemUgPSBjaHVua3MucmVkdWNlKChhY2N1bSwgY2h1bmspID0+IHtcbiAgICAvLyBkYXRhIGNodW5rXG4gICAgaWYgKHNpbmdsZUNodW5rSXNCdWZmZXIoY2h1bmspKSB7XG4gICAgICAvLyBhZGhlcmUgdG8gQklQNjIuMywgbWluaW1hbCBwdXNoIHBvbGljeVxuICAgICAgaWYgKGNodW5rLmxlbmd0aCA9PT0gMSAmJiBhc01pbmltYWxPUChjaHVuaykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYWNjdW0gKyAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtICsgcHVzaGRhdGEuZW5jb2RpbmdMZW5ndGgoY2h1bmsubGVuZ3RoKSArIGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgLy8gb3Bjb2RlXG4gICAgcmV0dXJuIGFjY3VtICsgMTtcbiAgfSwgMC4wKTtcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ1ZmZlclNpemUpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY2h1bmtzLmZvckVhY2goY2h1bmsgPT4ge1xuICAgIC8vIGRhdGEgY2h1bmtcbiAgICBpZiAoc2luZ2xlQ2h1bmtJc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgIC8vIGFkaGVyZSB0byBCSVA2Mi4zLCBtaW5pbWFsIHB1c2ggcG9saWN5XG4gICAgICBjb25zdCBvcGNvZGUgPSBhc01pbmltYWxPUChjaHVuayk7XG4gICAgICBpZiAob3Bjb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDgob3Bjb2RlLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb2Zmc2V0ICs9IHB1c2hkYXRhLmVuY29kZShidWZmZXIsIGNodW5rLmxlbmd0aCwgb2Zmc2V0KTtcbiAgICAgIGNodW5rLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgICAgIC8vIG9wY29kZVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIud3JpdGVVSW50OChjaHVuaywgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSAxO1xuICAgIH1cbiAgfSk7XG4gIGlmIChvZmZzZXQgIT09IGJ1ZmZlci5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRlY29kZSBjaHVua3MnKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGU7XG5mdW5jdGlvbiBkZWNvbXBpbGUoYnVmZmVyKSB7XG4gIC8vIFRPRE86IHJlbW92ZSBtZVxuICBpZiAoY2h1bmtzSXNBcnJheShidWZmZXIpKSByZXR1cm4gYnVmZmVyO1xuICB0eXBlZm9yY2UodHlwZXMuQnVmZmVyLCBidWZmZXIpO1xuICBjb25zdCBjaHVua3MgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBjb25zdCBvcGNvZGUgPSBidWZmZXJbaV07XG4gICAgLy8gZGF0YSBjaHVua1xuICAgIGlmIChvcGNvZGUgPiBvcHNfMS5PUFMuT1BfMCAmJiBvcGNvZGUgPD0gb3BzXzEuT1BTLk9QX1BVU0hEQVRBNCkge1xuICAgICAgY29uc3QgZCA9IHB1c2hkYXRhLmRlY29kZShidWZmZXIsIGkpO1xuICAgICAgLy8gZGlkIHJlYWRpbmcgYSBwdXNoRGF0YUludCBmYWlsP1xuICAgICAgaWYgKGQgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgaSArPSBkLnNpemU7XG4gICAgICAvLyBhdHRlbXB0IHRvIHJlYWQgdG9vIG11Y2ggZGF0YT9cbiAgICAgIGlmIChpICsgZC5udW1iZXIgPiBidWZmZXIubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXIuc2xpY2UoaSwgaSArIGQubnVtYmVyKTtcbiAgICAgIGkgKz0gZC5udW1iZXI7XG4gICAgICAvLyBkZWNvbXBpbGUgbWluaW1hbGx5XG4gICAgICBjb25zdCBvcCA9IGFzTWluaW1hbE9QKGRhdGEpO1xuICAgICAgaWYgKG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2h1bmtzLnB1c2gob3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2h1bmtzLnB1c2goZGF0YSk7XG4gICAgICB9XG4gICAgICAvLyBvcGNvZGVcbiAgICB9IGVsc2Uge1xuICAgICAgY2h1bmtzLnB1c2gob3Bjb2RlKTtcbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNodW5rcztcbn1cbmV4cG9ydHMuZGVjb21waWxlID0gZGVjb21waWxlO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gY2h1bmtzIGludG8gYW4gQVNNIChBc3NlbWJseSkgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICogSWYgdGhlIGNodW5rcyBwYXJhbWV0ZXIgaXMgYSBCdWZmZXIsIGl0IHdpbGwgYmUgZGVjb21waWxlZCBpbnRvIGEgU3RhY2sgYmVmb3JlIGNvbnZlcnNpb24uXG4gKiBAcGFyYW0gY2h1bmtzIC0gVGhlIGNodW5rcyB0byBjb252ZXJ0IGludG8gQVNNLlxuICogQHJldHVybnMgVGhlIEFTTSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNodW5rcy5cbiAqL1xuZnVuY3Rpb24gdG9BU00oY2h1bmtzKSB7XG4gIGlmIChjaHVua3NJc0J1ZmZlcihjaHVua3MpKSB7XG4gICAgY2h1bmtzID0gZGVjb21waWxlKGNodW5rcyk7XG4gIH1cbiAgaWYgKCFjaHVua3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjb252ZXJ0IGludmFsaWQgY2h1bmtzIHRvIEFTTScpO1xuICB9XG4gIHJldHVybiBjaHVua3NcbiAgICAubWFwKGNodW5rID0+IHtcbiAgICAgIC8vIGRhdGE/XG4gICAgICBpZiAoc2luZ2xlQ2h1bmtJc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgICAgY29uc3Qgb3AgPSBhc01pbmltYWxPUChjaHVuayk7XG4gICAgICAgIGlmIChvcCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gY2h1bmsudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICBjaHVuayA9IG9wO1xuICAgICAgfVxuICAgICAgLy8gb3Bjb2RlIVxuICAgICAgcmV0dXJuIG9wc18xLlJFVkVSU0VfT1BTW2NodW5rXTtcbiAgICB9KVxuICAgIC5qb2luKCcgJyk7XG59XG5leHBvcnRzLnRvQVNNID0gdG9BU007XG4vKipcbiAqIENvbnZlcnRzIGFuIEFTTSBzdHJpbmcgdG8gYSBCdWZmZXIuXG4gKiBAcGFyYW0gYXNtIFRoZSBBU00gc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIEJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gZnJvbUFTTShhc20pIHtcbiAgdHlwZWZvcmNlKHR5cGVzLlN0cmluZywgYXNtKTtcbiAgcmV0dXJuIGNvbXBpbGUoXG4gICAgYXNtLnNwbGl0KCcgJykubWFwKGNodW5rU3RyID0+IHtcbiAgICAgIC8vIG9wY29kZT9cbiAgICAgIGlmIChvcHNfMS5PUFNbY2h1bmtTdHJdICE9PSB1bmRlZmluZWQpIHJldHVybiBvcHNfMS5PUFNbY2h1bmtTdHJdO1xuICAgICAgdHlwZWZvcmNlKHR5cGVzLkhleCwgY2h1bmtTdHIpO1xuICAgICAgLy8gZGF0YSFcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShjaHVua1N0ciwgJ2hleCcpO1xuICAgIH0pLFxuICApO1xufVxuZXhwb3J0cy5mcm9tQVNNID0gZnJvbUFTTTtcbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGNodW5rcyBpbnRvIGEgc3RhY2sgb2YgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0gY2h1bmtzIC0gVGhlIGNodW5rcyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHN0YWNrIG9mIGJ1ZmZlcnMuXG4gKi9cbmZ1bmN0aW9uIHRvU3RhY2soY2h1bmtzKSB7XG4gIGNodW5rcyA9IGRlY29tcGlsZShjaHVua3MpO1xuICB0eXBlZm9yY2UoaXNQdXNoT25seSwgY2h1bmtzKTtcbiAgcmV0dXJuIGNodW5rcy5tYXAob3AgPT4ge1xuICAgIGlmIChzaW5nbGVDaHVua0lzQnVmZmVyKG9wKSkgcmV0dXJuIG9wO1xuICAgIGlmIChvcCA9PT0gb3BzXzEuT1BTLk9QXzApIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgcmV0dXJuIHNjcmlwdE51bWJlci5lbmNvZGUob3AgLSBPUF9JTlRfQkFTRSk7XG4gIH0pO1xufVxuZXhwb3J0cy50b1N0YWNrID0gdG9TdGFjaztcbmZ1bmN0aW9uIGlzQ2Fub25pY2FsUHViS2V5KGJ1ZmZlcikge1xuICByZXR1cm4gdHlwZXMuaXNQb2ludChidWZmZXIpO1xufVxuZXhwb3J0cy5pc0Nhbm9uaWNhbFB1YktleSA9IGlzQ2Fub25pY2FsUHViS2V5O1xuZnVuY3Rpb24gaXNEZWZpbmVkSGFzaFR5cGUoaGFzaFR5cGUpIHtcbiAgY29uc3QgaGFzaFR5cGVNb2QgPSBoYXNoVHlwZSAmIH4weDgwO1xuICAvLyByZXR1cm4gaGFzaFR5cGVNb2QgPiBTSUdIQVNIX0FMTCAmJiBoYXNoVHlwZU1vZCA8IFNJR0hBU0hfU0lOR0xFXG4gIHJldHVybiBoYXNoVHlwZU1vZCA+IDB4MDAgJiYgaGFzaFR5cGVNb2QgPCAweDA0O1xufVxuZXhwb3J0cy5pc0RlZmluZWRIYXNoVHlwZSA9IGlzRGVmaW5lZEhhc2hUeXBlO1xuZnVuY3Rpb24gaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmUoYnVmZmVyKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFpc0RlZmluZWRIYXNoVHlwZShidWZmZXJbYnVmZmVyLmxlbmd0aCAtIDFdKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gYmlwNjYuY2hlY2soYnVmZmVyLnNsaWNlKDAsIC0xKSk7XG59XG5leHBvcnRzLmlzQ2Fub25pY2FsU2NyaXB0U2lnbmF0dXJlID0gaXNDYW5vbmljYWxTY3JpcHRTaWduYXR1cmU7XG5leHBvcnRzLm51bWJlciA9IHNjcmlwdE51bWJlcjtcbmV4cG9ydHMuc2lnbmF0dXJlID0gc2NyaXB0U2lnbmF0dXJlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/script.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/script_number.js":
/*!*********************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/script_number.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encode = exports.decode = void 0;\n/**\n * Decodes a script number from a buffer.\n *\n * @param buffer - The buffer containing the script number.\n * @param maxLength - The maximum length of the script number. Defaults to 4.\n * @param minimal - Whether the script number should be minimal. Defaults to true.\n * @returns The decoded script number.\n * @throws {TypeError} If the script number overflows the maximum length.\n * @throws {Error} If the script number is not minimally encoded when minimal is true.\n */\nfunction decode(buffer, maxLength, minimal) {\n  maxLength = maxLength || 4;\n  minimal = minimal === undefined ? true : minimal;\n  const length = buffer.length;\n  if (length === 0) return 0;\n  if (length > maxLength) throw new TypeError('Script number overflow');\n  if (minimal) {\n    if ((buffer[length - 1] & 0x7f) === 0) {\n      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)\n        throw new Error('Non-minimally encoded script number');\n    }\n  }\n  // 40-bit\n  if (length === 5) {\n    const a = buffer.readUInt32LE(0);\n    const b = buffer.readUInt8(4);\n    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);\n    return b * 0x100000000 + a;\n  }\n  // 32-bit / 24-bit / 16-bit / 8-bit\n  let result = 0;\n  for (let i = 0; i < length; ++i) {\n    result |= buffer[i] << (8 * i);\n  }\n  if (buffer[length - 1] & 0x80)\n    return -(result & ~(0x80 << (8 * (length - 1))));\n  return result;\n}\nexports.decode = decode;\nfunction scriptNumSize(i) {\n  return i > 0x7fffffff\n    ? 5\n    : i > 0x7fffff\n    ? 4\n    : i > 0x7fff\n    ? 3\n    : i > 0x7f\n    ? 2\n    : i > 0x00\n    ? 1\n    : 0;\n}\n/**\n * Encodes a number into a Buffer using a specific format.\n *\n * @param _number - The number to encode.\n * @returns The encoded number as a Buffer.\n */\nfunction encode(_number) {\n  let value = Math.abs(_number);\n  const size = scriptNumSize(value);\n  const buffer = Buffer.allocUnsafe(size);\n  const negative = _number < 0;\n  for (let i = 0; i < size; ++i) {\n    buffer.writeUInt8(value & 0xff, i);\n    value >>= 8;\n  }\n  if (buffer[size - 1] & 0x80) {\n    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);\n  } else if (negative) {\n    buffer[size - 1] |= 0x80;\n  }\n  return buffer;\n}\nexports.encode = encode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvc2NyaXB0X251bWJlci5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE1BQU07QUFDdkI7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9zY3JpcHRfbnVtYmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlID0gdm9pZCAwO1xuLyoqXG4gKiBEZWNvZGVzIGEgc2NyaXB0IG51bWJlciBmcm9tIGEgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBidWZmZXIgLSBUaGUgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIHNjcmlwdCBudW1iZXIuXG4gKiBAcGFyYW0gbWF4TGVuZ3RoIC0gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBzY3JpcHQgbnVtYmVyLiBEZWZhdWx0cyB0byA0LlxuICogQHBhcmFtIG1pbmltYWwgLSBXaGV0aGVyIHRoZSBzY3JpcHQgbnVtYmVyIHNob3VsZCBiZSBtaW5pbWFsLiBEZWZhdWx0cyB0byB0cnVlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgc2NyaXB0IG51bWJlci5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdGhlIHNjcmlwdCBudW1iZXIgb3ZlcmZsb3dzIHRoZSBtYXhpbXVtIGxlbmd0aC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc2NyaXB0IG51bWJlciBpcyBub3QgbWluaW1hbGx5IGVuY29kZWQgd2hlbiBtaW5pbWFsIGlzIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShidWZmZXIsIG1heExlbmd0aCwgbWluaW1hbCkge1xuICBtYXhMZW5ndGggPSBtYXhMZW5ndGggfHwgNDtcbiAgbWluaW1hbCA9IG1pbmltYWwgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBtaW5pbWFsO1xuICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gMDtcbiAgaWYgKGxlbmd0aCA+IG1heExlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignU2NyaXB0IG51bWJlciBvdmVyZmxvdycpO1xuICBpZiAobWluaW1hbCkge1xuICAgIGlmICgoYnVmZmVyW2xlbmd0aCAtIDFdICYgMHg3ZikgPT09IDApIHtcbiAgICAgIGlmIChsZW5ndGggPD0gMSB8fCAoYnVmZmVyW2xlbmd0aCAtIDJdICYgMHg4MCkgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLW1pbmltYWxseSBlbmNvZGVkIHNjcmlwdCBudW1iZXInKTtcbiAgICB9XG4gIH1cbiAgLy8gNDAtYml0XG4gIGlmIChsZW5ndGggPT09IDUpIHtcbiAgICBjb25zdCBhID0gYnVmZmVyLnJlYWRVSW50MzJMRSgwKTtcbiAgICBjb25zdCBiID0gYnVmZmVyLnJlYWRVSW50OCg0KTtcbiAgICBpZiAoYiAmIDB4ODApIHJldHVybiAtKChiICYgfjB4ODApICogMHgxMDAwMDAwMDAgKyBhKTtcbiAgICByZXR1cm4gYiAqIDB4MTAwMDAwMDAwICsgYTtcbiAgfVxuICAvLyAzMi1iaXQgLyAyNC1iaXQgLyAxNi1iaXQgLyA4LWJpdFxuICBsZXQgcmVzdWx0ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdCB8PSBidWZmZXJbaV0gPDwgKDggKiBpKTtcbiAgfVxuICBpZiAoYnVmZmVyW2xlbmd0aCAtIDFdICYgMHg4MClcbiAgICByZXR1cm4gLShyZXN1bHQgJiB+KDB4ODAgPDwgKDggKiAobGVuZ3RoIC0gMSkpKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmZ1bmN0aW9uIHNjcmlwdE51bVNpemUoaSkge1xuICByZXR1cm4gaSA+IDB4N2ZmZmZmZmZcbiAgICA/IDVcbiAgICA6IGkgPiAweDdmZmZmZlxuICAgID8gNFxuICAgIDogaSA+IDB4N2ZmZlxuICAgID8gM1xuICAgIDogaSA+IDB4N2ZcbiAgICA/IDJcbiAgICA6IGkgPiAweDAwXG4gICAgPyAxXG4gICAgOiAwO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgbnVtYmVyIGludG8gYSBCdWZmZXIgdXNpbmcgYSBzcGVjaWZpYyBmb3JtYXQuXG4gKlxuICogQHBhcmFtIF9udW1iZXIgLSBUaGUgbnVtYmVyIHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIG51bWJlciBhcyBhIEJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKF9udW1iZXIpIHtcbiAgbGV0IHZhbHVlID0gTWF0aC5hYnMoX251bWJlcik7XG4gIGNvbnN0IHNpemUgPSBzY3JpcHROdW1TaXplKHZhbHVlKTtcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNpemUpO1xuICBjb25zdCBuZWdhdGl2ZSA9IF9udW1iZXIgPCAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbHVlICYgMHhmZiwgaSk7XG4gICAgdmFsdWUgPj49IDg7XG4gIH1cbiAgaWYgKGJ1ZmZlcltzaXplIC0gMV0gJiAweDgwKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgobmVnYXRpdmUgPyAweDgwIDogMHgwMCwgc2l6ZSAtIDEpO1xuICB9IGVsc2UgaWYgKG5lZ2F0aXZlKSB7XG4gICAgYnVmZmVyW3NpemUgLSAxXSB8PSAweDgwO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/script_number.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/script_signature.js":
/*!************************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/script_signature.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.encode = exports.decode = void 0;\nconst bip66 = __webpack_require__(/*! ./bip66 */ \"./node_modules/bitcoinjs-lib/src/bip66.js\");\nconst script_1 = __webpack_require__(/*! ./script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst { typeforce } = types;\nconst ZERO = Buffer.alloc(1, 0);\n/**\n * Converts a buffer to a DER-encoded buffer.\n * @param x - The buffer to be converted.\n * @returns The DER-encoded buffer.\n */\nfunction toDER(x) {\n  let i = 0;\n  while (x[i] === 0) ++i;\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);\n  return x;\n}\n/**\n * Converts a DER-encoded signature to a buffer.\n * If the first byte of the input buffer is 0x00, it is skipped.\n * The resulting buffer is 32 bytes long, filled with zeros if necessary.\n * @param x - The DER-encoded signature.\n * @returns The converted buffer.\n */\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = Buffer.alloc(32, 0);\n  const bstart = Math.max(0, 32 - x.length);\n  x.copy(buffer, bstart);\n  return buffer;\n}\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\n/**\n * Decodes a buffer into a ScriptSignature object.\n * @param buffer - The buffer to decode.\n * @returns The decoded ScriptSignature object.\n * @throws Error if the hashType is invalid.\n */\nfunction decode(buffer) {\n  const hashType = buffer.readUInt8(buffer.length - 1);\n  if (!(0, script_1.isDefinedHashType)(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const decoded = bip66.decode(buffer.slice(0, -1));\n  const r = fromDER(decoded.r);\n  const s = fromDER(decoded.s);\n  const signature = Buffer.concat([r, s], 64);\n  return { signature, hashType };\n}\nexports.decode = decode;\n/**\n * Encodes a signature and hash type into a buffer.\n * @param signature - The signature to encode.\n * @param hashType - The hash type to encode.\n * @returns The encoded buffer.\n * @throws Error if the hashType is invalid.\n */\nfunction encode(signature, hashType) {\n  typeforce(\n    {\n      signature: types.BufferN(64),\n      hashType: types.UInt8,\n    },\n    { signature, hashType },\n  );\n  if (!(0, script_1.isDefinedHashType)(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const hashTypeBuffer = Buffer.allocUnsafe(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\nexports.encode = encode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvc2NyaXB0X3NpZ25hdHVyZS5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGNBQWM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLDBEQUFTO0FBQy9CLGlCQUFpQixtQkFBTyxDQUFDLDREQUFVO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQywwREFBUztBQUMvQixRQUFRLFlBQVk7QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUIsV0FBVztBQUNYO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNLHFCQUFxQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVMsTUFBTTtBQUNmO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy9zY3JpcHRfc2lnbmF0dXJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuZGVjb2RlID0gdm9pZCAwO1xuY29uc3QgYmlwNjYgPSByZXF1aXJlKCcuL2JpcDY2Jyk7XG5jb25zdCBzY3JpcHRfMSA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IHsgdHlwZWZvcmNlIH0gPSB0eXBlcztcbmNvbnN0IFpFUk8gPSBCdWZmZXIuYWxsb2MoMSwgMCk7XG4vKipcbiAqIENvbnZlcnRzIGEgYnVmZmVyIHRvIGEgREVSLWVuY29kZWQgYnVmZmVyLlxuICogQHBhcmFtIHggLSBUaGUgYnVmZmVyIHRvIGJlIGNvbnZlcnRlZC5cbiAqIEByZXR1cm5zIFRoZSBERVItZW5jb2RlZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIHRvREVSKHgpIHtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoeFtpXSA9PT0gMCkgKytpO1xuICBpZiAoaSA9PT0geC5sZW5ndGgpIHJldHVybiBaRVJPO1xuICB4ID0geC5zbGljZShpKTtcbiAgaWYgKHhbMF0gJiAweDgwKSByZXR1cm4gQnVmZmVyLmNvbmNhdChbWkVSTywgeF0sIDEgKyB4Lmxlbmd0aCk7XG4gIHJldHVybiB4O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIERFUi1lbmNvZGVkIHNpZ25hdHVyZSB0byBhIGJ1ZmZlci5cbiAqIElmIHRoZSBmaXJzdCBieXRlIG9mIHRoZSBpbnB1dCBidWZmZXIgaXMgMHgwMCwgaXQgaXMgc2tpcHBlZC5cbiAqIFRoZSByZXN1bHRpbmcgYnVmZmVyIGlzIDMyIGJ5dGVzIGxvbmcsIGZpbGxlZCB3aXRoIHplcm9zIGlmIG5lY2Vzc2FyeS5cbiAqIEBwYXJhbSB4IC0gVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBmcm9tREVSKHgpIHtcbiAgaWYgKHhbMF0gPT09IDB4MDApIHggPSB4LnNsaWNlKDEpO1xuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICBjb25zdCBic3RhcnQgPSBNYXRoLm1heCgwLCAzMiAtIHgubGVuZ3RoKTtcbiAgeC5jb3B5KGJ1ZmZlciwgYnN0YXJ0KTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cbi8vIEJJUDYyOiAxIGJ5dGUgaGFzaFR5cGUgZmxhZyAob25seSAweDAxLCAweDAyLCAweDAzLCAweDgxLCAweDgyIGFuZCAweDgzIGFyZSBhbGxvd2VkKVxuLyoqXG4gKiBEZWNvZGVzIGEgYnVmZmVyIGludG8gYSBTY3JpcHRTaWduYXR1cmUgb2JqZWN0LlxuICogQHBhcmFtIGJ1ZmZlciAtIFRoZSBidWZmZXIgdG8gZGVjb2RlLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgU2NyaXB0U2lnbmF0dXJlIG9iamVjdC5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGhhc2hUeXBlIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShidWZmZXIpIHtcbiAgY29uc3QgaGFzaFR5cGUgPSBidWZmZXIucmVhZFVJbnQ4KGJ1ZmZlci5sZW5ndGggLSAxKTtcbiAgaWYgKCEoMCwgc2NyaXB0XzEuaXNEZWZpbmVkSGFzaFR5cGUpKGhhc2hUeXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoYXNoVHlwZSAnICsgaGFzaFR5cGUpO1xuICB9XG4gIGNvbnN0IGRlY29kZWQgPSBiaXA2Ni5kZWNvZGUoYnVmZmVyLnNsaWNlKDAsIC0xKSk7XG4gIGNvbnN0IHIgPSBmcm9tREVSKGRlY29kZWQucik7XG4gIGNvbnN0IHMgPSBmcm9tREVSKGRlY29kZWQucyk7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW3IsIHNdLCA2NCk7XG4gIHJldHVybiB7IHNpZ25hdHVyZSwgaGFzaFR5cGUgfTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLyoqXG4gKiBFbmNvZGVzIGEgc2lnbmF0dXJlIGFuZCBoYXNoIHR5cGUgaW50byBhIGJ1ZmZlci5cbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBoYXNoVHlwZSAtIFRoZSBoYXNoIHR5cGUgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQgYnVmZmVyLlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgaGFzaFR5cGUgaXMgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlKHNpZ25hdHVyZSwgaGFzaFR5cGUpIHtcbiAgdHlwZWZvcmNlKFxuICAgIHtcbiAgICAgIHNpZ25hdHVyZTogdHlwZXMuQnVmZmVyTig2NCksXG4gICAgICBoYXNoVHlwZTogdHlwZXMuVUludDgsXG4gICAgfSxcbiAgICB7IHNpZ25hdHVyZSwgaGFzaFR5cGUgfSxcbiAgKTtcbiAgaWYgKCEoMCwgc2NyaXB0XzEuaXNEZWZpbmVkSGFzaFR5cGUpKGhhc2hUeXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoYXNoVHlwZSAnICsgaGFzaFR5cGUpO1xuICB9XG4gIGNvbnN0IGhhc2hUeXBlQnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDEpO1xuICBoYXNoVHlwZUJ1ZmZlci53cml0ZVVJbnQ4KGhhc2hUeXBlLCAwKTtcbiAgY29uc3QgciA9IHRvREVSKHNpZ25hdHVyZS5zbGljZSgwLCAzMikpO1xuICBjb25zdCBzID0gdG9ERVIoc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkpO1xuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbYmlwNjYuZW5jb2RlKHIsIHMpLCBoYXNoVHlwZUJ1ZmZlcl0pO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/script_signature.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/transaction.js":
/*!*******************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/transaction.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transaction = void 0;\nconst bufferutils_1 = __webpack_require__(/*! ./bufferutils */ \"./node_modules/bitcoinjs-lib/src/bufferutils.js\");\nconst bcrypto = __webpack_require__(/*! ./crypto */ \"./node_modules/bitcoinjs-lib/src/crypto.js\");\nconst bscript = __webpack_require__(/*! ./script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nconst script_1 = __webpack_require__(/*! ./script */ \"./node_modules/bitcoinjs-lib/src/script.js\");\nconst types = __webpack_require__(/*! ./types */ \"./node_modules/bitcoinjs-lib/src/types.js\");\nconst { typeforce } = types;\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return bufferutils_1.varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    bufferutils_1.varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_BUFFER = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'hex',\n);\nconst ONE = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n  'hex',\n);\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_BUFFER,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\n/**\n * Represents a Bitcoin transaction.\n */\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(\n      types.tuple(\n        types.Hash256bit,\n        types.UInt32,\n        types.maybe(types.UInt32),\n        types.maybe(types.Buffer),\n      ),\n      arguments,\n    );\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_BUFFER,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  stripWitnesses() {\n    this.ins.forEach(input => {\n      input.witness = EMPTY_WITNESS; // Set witness data to an empty array\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      bufferutils_1.varuint.encodingLength(this.ins.length) +\n      bufferutils_1.varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),\n      arguments,\n    );\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== script_1.OPS.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_BUFFER;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message\n    typeforce(\n      types.tuple(\n        types.UInt32,\n        typeforce.arrayOf(types.Buffer),\n        typeforce.arrayOf(types.Satoshi),\n        types.UInt32,\n      ),\n      arguments,\n    );\n    if (\n      values.length !== this.ins.length ||\n      prevOutScripts.length !== this.ins.length\n    ) {\n      throw new Error('Must supply prevout script and value for all inputs');\n    }\n    const outputType =\n      hashType === Transaction.SIGHASH_DEFAULT\n        ? Transaction.SIGHASH_ALL\n        : hashType & Transaction.SIGHASH_OUTPUT_MASK;\n    const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;\n    const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;\n    const isNone = outputType === Transaction.SIGHASH_NONE;\n    const isSingle = outputType === Transaction.SIGHASH_SINGLE;\n    let hashPrevouts = EMPTY_BUFFER;\n    let hashAmounts = EMPTY_BUFFER;\n    let hashScriptPubKeys = EMPTY_BUFFER;\n    let hashSequences = EMPTY_BUFFER;\n    let hashOutputs = EMPTY_BUFFER;\n    if (!isAnyoneCanPay) {\n      let bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        36 * this.ins.length,\n      );\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        8 * this.ins.length,\n      );\n      values.forEach(value => bufferWriter.writeUInt64(value));\n      hashAmounts = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        prevOutScripts.map(varSliceSize).reduce((a, b) => a + b),\n      );\n      prevOutScripts.forEach(prevOutScript =>\n        bufferWriter.writeVarSlice(prevOutScript),\n      );\n      hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        4 * this.ins.length,\n      );\n      this.ins.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));\n      hashSequences = bcrypto.sha256(bufferWriter.end());\n    }\n    if (!(isNone || isSingle)) {\n      const txOutsSize = this.outs\n        .map(output => 8 + varSliceSize(output.script))\n        .reduce((a, b) => a + b);\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.sha256(bufferWriter.end());\n    } else if (isSingle && inIndex < this.outs.length) {\n      const output = this.outs[inIndex];\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        8 + varSliceSize(output.script),\n      );\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.sha256(bufferWriter.end());\n    }\n    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);\n    // Length calculation from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14\n    // With extension from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation\n    const sigMsgSize =\n      174 -\n      (isAnyoneCanPay ? 49 : 0) -\n      (isNone ? 32 : 0) +\n      (annex ? 32 : 0) +\n      (leafHash ? 37 : 0);\n    const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);\n    sigMsgWriter.writeUInt8(hashType);\n    // Transaction\n    sigMsgWriter.writeInt32(this.version);\n    sigMsgWriter.writeUInt32(this.locktime);\n    sigMsgWriter.writeSlice(hashPrevouts);\n    sigMsgWriter.writeSlice(hashAmounts);\n    sigMsgWriter.writeSlice(hashScriptPubKeys);\n    sigMsgWriter.writeSlice(hashSequences);\n    if (!(isNone || isSingle)) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // Input\n    sigMsgWriter.writeUInt8(spendType);\n    if (isAnyoneCanPay) {\n      const input = this.ins[inIndex];\n      sigMsgWriter.writeSlice(input.hash);\n      sigMsgWriter.writeUInt32(input.index);\n      sigMsgWriter.writeUInt64(values[inIndex]);\n      sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);\n      sigMsgWriter.writeUInt32(input.sequence);\n    } else {\n      sigMsgWriter.writeUInt32(inIndex);\n    }\n    if (annex) {\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        varSliceSize(annex),\n      );\n      bufferWriter.writeVarSlice(annex);\n      sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));\n    }\n    // Output\n    if (isSingle) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // BIP342 extension\n    if (leafHash) {\n      sigMsgWriter.writeSlice(leafHash);\n      sigMsgWriter.writeUInt8(0);\n      sigMsgWriter.writeUInt32(0xffffffff);\n    }\n    // Extra zero byte because:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19\n    return bcrypto.taggedHash(\n      'TapSighash',\n      Buffer.concat([Buffer.from([0x00]), sigMsgWriter.end()]),\n    );\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),\n      arguments,\n    );\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(\n      'hex',\n    );\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(\n      buffer,\n      initialOffset || 0,\n    );\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\nexports.Transaction = Transaction;\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_DEFAULT = 0x00;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.SIGHASH_OUTPUT_MASK = 0x03;\nTransaction.SIGHASH_INPUT_MASK = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixzQkFBc0IsbUJBQU8sQ0FBQyxzRUFBZTtBQUM3QyxnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBVTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0REFBVTtBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyw0REFBVTtBQUNuQyxjQUFjLG1CQUFPLENBQUMsMERBQVM7QUFDL0IsUUFBUSxZQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsTUFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQU0sU0FBUyxNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL2JpdGNvaW5qcy1saWIvc3JjL3RyYW5zYWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gdm9pZCAwO1xuY29uc3QgYnVmZmVydXRpbHNfMSA9IHJlcXVpcmUoJy4vYnVmZmVydXRpbHMnKTtcbmNvbnN0IGJjcnlwdG8gPSByZXF1aXJlKCcuL2NyeXB0bycpO1xuY29uc3QgYnNjcmlwdCA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG5jb25zdCBzY3JpcHRfMSA9IHJlcXVpcmUoJy4vc2NyaXB0Jyk7XG5jb25zdCB0eXBlcyA9IHJlcXVpcmUoJy4vdHlwZXMnKTtcbmNvbnN0IHsgdHlwZWZvcmNlIH0gPSB0eXBlcztcbmZ1bmN0aW9uIHZhclNsaWNlU2l6ZShzb21lU2NyaXB0KSB7XG4gIGNvbnN0IGxlbmd0aCA9IHNvbWVTY3JpcHQubGVuZ3RoO1xuICByZXR1cm4gYnVmZmVydXRpbHNfMS52YXJ1aW50LmVuY29kaW5nTGVuZ3RoKGxlbmd0aCkgKyBsZW5ndGg7XG59XG5mdW5jdGlvbiB2ZWN0b3JTaXplKHNvbWVWZWN0b3IpIHtcbiAgY29uc3QgbGVuZ3RoID0gc29tZVZlY3Rvci5sZW5ndGg7XG4gIHJldHVybiAoXG4gICAgYnVmZmVydXRpbHNfMS52YXJ1aW50LmVuY29kaW5nTGVuZ3RoKGxlbmd0aCkgK1xuICAgIHNvbWVWZWN0b3IucmVkdWNlKChzdW0sIHdpdG5lc3MpID0+IHtcbiAgICAgIHJldHVybiBzdW0gKyB2YXJTbGljZVNpemUod2l0bmVzcyk7XG4gICAgfSwgMClcbiAgKTtcbn1cbmNvbnN0IEVNUFRZX0JVRkZFUiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbmNvbnN0IEVNUFRZX1dJVE5FU1MgPSBbXTtcbmNvbnN0IFpFUk8gPSBCdWZmZXIuZnJvbShcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAnaGV4Jyxcbik7XG5jb25zdCBPTkUgPSBCdWZmZXIuZnJvbShcbiAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICAnaGV4Jyxcbik7XG5jb25zdCBWQUxVRV9VSU5UNjRfTUFYID0gQnVmZmVyLmZyb20oJ2ZmZmZmZmZmZmZmZmZmZmYnLCAnaGV4Jyk7XG5jb25zdCBCTEFOS19PVVRQVVQgPSB7XG4gIHNjcmlwdDogRU1QVFlfQlVGRkVSLFxuICB2YWx1ZUJ1ZmZlcjogVkFMVUVfVUlOVDY0X01BWCxcbn07XG5mdW5jdGlvbiBpc091dHB1dChvdXQpIHtcbiAgcmV0dXJuIG91dC52YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBSZXByZXNlbnRzIGEgQml0Y29pbiB0cmFuc2FjdGlvbi5cbiAqL1xuY2xhc3MgVHJhbnNhY3Rpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnZlcnNpb24gPSAxO1xuICAgIHRoaXMubG9ja3RpbWUgPSAwO1xuICAgIHRoaXMuaW5zID0gW107XG4gICAgdGhpcy5vdXRzID0gW107XG4gIH1cbiAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyLCBfTk9fU1RSSUNUKSB7XG4gICAgY29uc3QgYnVmZmVyUmVhZGVyID0gbmV3IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyUmVhZGVyKGJ1ZmZlcik7XG4gICAgY29uc3QgdHggPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0eC52ZXJzaW9uID0gYnVmZmVyUmVhZGVyLnJlYWRJbnQzMigpO1xuICAgIGNvbnN0IG1hcmtlciA9IGJ1ZmZlclJlYWRlci5yZWFkVUludDgoKTtcbiAgICBjb25zdCBmbGFnID0gYnVmZmVyUmVhZGVyLnJlYWRVSW50OCgpO1xuICAgIGxldCBoYXNXaXRuZXNzZXMgPSBmYWxzZTtcbiAgICBpZiAoXG4gICAgICBtYXJrZXIgPT09IFRyYW5zYWN0aW9uLkFEVkFOQ0VEX1RSQU5TQUNUSU9OX01BUktFUiAmJlxuICAgICAgZmxhZyA9PT0gVHJhbnNhY3Rpb24uQURWQU5DRURfVFJBTlNBQ1RJT05fRkxBR1xuICAgICkge1xuICAgICAgaGFzV2l0bmVzc2VzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyUmVhZGVyLm9mZnNldCAtPSAyO1xuICAgIH1cbiAgICBjb25zdCB2aW5MZW4gPSBidWZmZXJSZWFkZXIucmVhZFZhckludCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmluTGVuOyArK2kpIHtcbiAgICAgIHR4Lmlucy5wdXNoKHtcbiAgICAgICAgaGFzaDogYnVmZmVyUmVhZGVyLnJlYWRTbGljZSgzMiksXG4gICAgICAgIGluZGV4OiBidWZmZXJSZWFkZXIucmVhZFVJbnQzMigpLFxuICAgICAgICBzY3JpcHQ6IGJ1ZmZlclJlYWRlci5yZWFkVmFyU2xpY2UoKSxcbiAgICAgICAgc2VxdWVuY2U6IGJ1ZmZlclJlYWRlci5yZWFkVUludDMyKCksXG4gICAgICAgIHdpdG5lc3M6IEVNUFRZX1dJVE5FU1MsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgdm91dExlbiA9IGJ1ZmZlclJlYWRlci5yZWFkVmFySW50KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2b3V0TGVuOyArK2kpIHtcbiAgICAgIHR4Lm91dHMucHVzaCh7XG4gICAgICAgIHZhbHVlOiBidWZmZXJSZWFkZXIucmVhZFVJbnQ2NCgpLFxuICAgICAgICBzY3JpcHQ6IGJ1ZmZlclJlYWRlci5yZWFkVmFyU2xpY2UoKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaGFzV2l0bmVzc2VzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpbkxlbjsgKytpKSB7XG4gICAgICAgIHR4Lmluc1tpXS53aXRuZXNzID0gYnVmZmVyUmVhZGVyLnJlYWRWZWN0b3IoKTtcbiAgICAgIH1cbiAgICAgIC8vIHdhcyB0aGlzIHBvaW50bGVzcz9cbiAgICAgIGlmICghdHguaGFzV2l0bmVzc2VzKCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gaGFzIHN1cGVyZmx1b3VzIHdpdG5lc3MgZGF0YScpO1xuICAgIH1cbiAgICB0eC5sb2NrdGltZSA9IGJ1ZmZlclJlYWRlci5yZWFkVUludDMyKCk7XG4gICAgaWYgKF9OT19TVFJJQ1QpIHJldHVybiB0eDtcbiAgICBpZiAoYnVmZmVyUmVhZGVyLm9mZnNldCAhPT0gYnVmZmVyLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gaGFzIHVuZXhwZWN0ZWQgZGF0YScpO1xuICAgIHJldHVybiB0eDtcbiAgfVxuICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbUJ1ZmZlcihCdWZmZXIuZnJvbShoZXgsICdoZXgnKSwgZmFsc2UpO1xuICB9XG4gIHN0YXRpYyBpc0NvaW5iYXNlSGFzaChidWZmZXIpIHtcbiAgICB0eXBlZm9yY2UodHlwZXMuSGFzaDI1NmJpdCwgYnVmZmVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyArK2kpIHtcbiAgICAgIGlmIChidWZmZXJbaV0gIT09IDApIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaXNDb2luYmFzZSgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5pbnMubGVuZ3RoID09PSAxICYmIFRyYW5zYWN0aW9uLmlzQ29pbmJhc2VIYXNoKHRoaXMuaW5zWzBdLmhhc2gpXG4gICAgKTtcbiAgfVxuICBhZGRJbnB1dChoYXNoLCBpbmRleCwgc2VxdWVuY2UsIHNjcmlwdFNpZykge1xuICAgIHR5cGVmb3JjZShcbiAgICAgIHR5cGVzLnR1cGxlKFxuICAgICAgICB0eXBlcy5IYXNoMjU2Yml0LFxuICAgICAgICB0eXBlcy5VSW50MzIsXG4gICAgICAgIHR5cGVzLm1heWJlKHR5cGVzLlVJbnQzMiksXG4gICAgICAgIHR5cGVzLm1heWJlKHR5cGVzLkJ1ZmZlciksXG4gICAgICApLFxuICAgICAgYXJndW1lbnRzLFxuICAgICk7XG4gICAgaWYgKHR5cGVzLk51bGwoc2VxdWVuY2UpKSB7XG4gICAgICBzZXF1ZW5jZSA9IFRyYW5zYWN0aW9uLkRFRkFVTFRfU0VRVUVOQ0U7XG4gICAgfVxuICAgIC8vIEFkZCB0aGUgaW5wdXQgYW5kIHJldHVybiB0aGUgaW5wdXQncyBpbmRleFxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmlucy5wdXNoKHtcbiAgICAgICAgaGFzaCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHNjcmlwdDogc2NyaXB0U2lnIHx8IEVNUFRZX0JVRkZFUixcbiAgICAgICAgc2VxdWVuY2U6IHNlcXVlbmNlLFxuICAgICAgICB3aXRuZXNzOiBFTVBUWV9XSVRORVNTLFxuICAgICAgfSkgLSAxXG4gICAgKTtcbiAgfVxuICBhZGRPdXRwdXQoc2NyaXB0UHViS2V5LCB2YWx1ZSkge1xuICAgIHR5cGVmb3JjZSh0eXBlcy50dXBsZSh0eXBlcy5CdWZmZXIsIHR5cGVzLlNhdG9zaGkpLCBhcmd1bWVudHMpO1xuICAgIC8vIEFkZCB0aGUgb3V0cHV0IGFuZCByZXR1cm4gdGhlIG91dHB1dCdzIGluZGV4XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMub3V0cy5wdXNoKHtcbiAgICAgICAgc2NyaXB0OiBzY3JpcHRQdWJLZXksXG4gICAgICAgIHZhbHVlLFxuICAgICAgfSkgLSAxXG4gICAgKTtcbiAgfVxuICBoYXNXaXRuZXNzZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zLnNvbWUoeCA9PiB7XG4gICAgICByZXR1cm4geC53aXRuZXNzLmxlbmd0aCAhPT0gMDtcbiAgICB9KTtcbiAgfVxuICBzdHJpcFdpdG5lc3NlcygpIHtcbiAgICB0aGlzLmlucy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgIGlucHV0LndpdG5lc3MgPSBFTVBUWV9XSVRORVNTOyAvLyBTZXQgd2l0bmVzcyBkYXRhIHRvIGFuIGVtcHR5IGFycmF5XG4gICAgfSk7XG4gIH1cbiAgd2VpZ2h0KCkge1xuICAgIGNvbnN0IGJhc2UgPSB0aGlzLmJ5dGVMZW5ndGgoZmFsc2UpO1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5ieXRlTGVuZ3RoKHRydWUpO1xuICAgIHJldHVybiBiYXNlICogMyArIHRvdGFsO1xuICB9XG4gIHZpcnR1YWxTaXplKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy53ZWlnaHQoKSAvIDQpO1xuICB9XG4gIGJ5dGVMZW5ndGgoX0FMTE9XX1dJVE5FU1MgPSB0cnVlKSB7XG4gICAgY29uc3QgaGFzV2l0bmVzc2VzID0gX0FMTE9XX1dJVE5FU1MgJiYgdGhpcy5oYXNXaXRuZXNzZXMoKTtcbiAgICByZXR1cm4gKFxuICAgICAgKGhhc1dpdG5lc3NlcyA/IDEwIDogOCkgK1xuICAgICAgYnVmZmVydXRpbHNfMS52YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHRoaXMuaW5zLmxlbmd0aCkgK1xuICAgICAgYnVmZmVydXRpbHNfMS52YXJ1aW50LmVuY29kaW5nTGVuZ3RoKHRoaXMub3V0cy5sZW5ndGgpICtcbiAgICAgIHRoaXMuaW5zLnJlZHVjZSgoc3VtLCBpbnB1dCkgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgNDAgKyB2YXJTbGljZVNpemUoaW5wdXQuc2NyaXB0KTtcbiAgICAgIH0sIDApICtcbiAgICAgIHRoaXMub3V0cy5yZWR1Y2UoKHN1bSwgb3V0cHV0KSA9PiB7XG4gICAgICAgIHJldHVybiBzdW0gKyA4ICsgdmFyU2xpY2VTaXplKG91dHB1dC5zY3JpcHQpO1xuICAgICAgfSwgMCkgK1xuICAgICAgKGhhc1dpdG5lc3Nlc1xuICAgICAgICA/IHRoaXMuaW5zLnJlZHVjZSgoc3VtLCBpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1bSArIHZlY3RvclNpemUoaW5wdXQud2l0bmVzcyk7XG4gICAgICAgICAgfSwgMClcbiAgICAgICAgOiAwKVxuICAgICk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbmV3VHggPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICBuZXdUeC52ZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xuICAgIG5ld1R4LmxvY2t0aW1lID0gdGhpcy5sb2NrdGltZTtcbiAgICBuZXdUeC5pbnMgPSB0aGlzLmlucy5tYXAodHhJbiA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoYXNoOiB0eEluLmhhc2gsXG4gICAgICAgIGluZGV4OiB0eEluLmluZGV4LFxuICAgICAgICBzY3JpcHQ6IHR4SW4uc2NyaXB0LFxuICAgICAgICBzZXF1ZW5jZTogdHhJbi5zZXF1ZW5jZSxcbiAgICAgICAgd2l0bmVzczogdHhJbi53aXRuZXNzLFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBuZXdUeC5vdXRzID0gdGhpcy5vdXRzLm1hcCh0eE91dCA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JpcHQ6IHR4T3V0LnNjcmlwdCxcbiAgICAgICAgdmFsdWU6IHR4T3V0LnZhbHVlLFxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3VHg7XG4gIH1cbiAgLyoqXG4gICAqIEhhc2ggdHJhbnNhY3Rpb24gZm9yIHNpZ25pbmcgYSBzcGVjaWZpYyBpbnB1dC5cbiAgICpcbiAgICogQml0Y29pbiB1c2VzIGEgZGlmZmVyZW50IGhhc2ggZm9yIGVhY2ggc2lnbmVkIHRyYW5zYWN0aW9uIGlucHV0LlxuICAgKiBUaGlzIG1ldGhvZCBjb3BpZXMgdGhlIHRyYW5zYWN0aW9uLCBtYWtlcyB0aGUgbmVjZXNzYXJ5IGNoYW5nZXMgYmFzZWQgb24gdGhlXG4gICAqIGhhc2hUeXBlLCBhbmQgdGhlbiBoYXNoZXMgdGhlIHJlc3VsdC5cbiAgICogVGhpcyBoYXNoIGNhbiB0aGVuIGJlIHVzZWQgdG8gc2lnbiB0aGUgcHJvdmlkZWQgdHJhbnNhY3Rpb24gaW5wdXQuXG4gICAqL1xuICBoYXNoRm9yU2lnbmF0dXJlKGluSW5kZXgsIHByZXZPdXRTY3JpcHQsIGhhc2hUeXBlKSB7XG4gICAgdHlwZWZvcmNlKFxuICAgICAgdHlwZXMudHVwbGUodHlwZXMuVUludDMyLCB0eXBlcy5CdWZmZXIsIC8qIHR5cGVzLlVJbnQ4ICovIHR5cGVzLk51bWJlciksXG4gICAgICBhcmd1bWVudHMsXG4gICAgKTtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXRjb2luL2Jsb2IvbWFzdGVyL3NyYy90ZXN0L3NpZ2hhc2hfdGVzdHMuY3BwI0wyOVxuICAgIGlmIChpbkluZGV4ID49IHRoaXMuaW5zLmxlbmd0aCkgcmV0dXJuIE9ORTtcbiAgICAvLyBpZ25vcmUgT1BfQ09ERVNFUEFSQVRPUlxuICAgIGNvbnN0IG91clNjcmlwdCA9IGJzY3JpcHQuY29tcGlsZShcbiAgICAgIGJzY3JpcHQuZGVjb21waWxlKHByZXZPdXRTY3JpcHQpLmZpbHRlcih4ID0+IHtcbiAgICAgICAgcmV0dXJuIHggIT09IHNjcmlwdF8xLk9QUy5PUF9DT0RFU0VQQVJBVE9SO1xuICAgICAgfSksXG4gICAgKTtcbiAgICBjb25zdCB0eFRtcCA9IHRoaXMuY2xvbmUoKTtcbiAgICAvLyBTSUdIQVNIX05PTkU6IGlnbm9yZSBhbGwgb3V0cHV0cz8gKHdpbGRjYXJkIHBheWVlKVxuICAgIGlmICgoaGFzaFR5cGUgJiAweDFmKSA9PT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9OT05FKSB7XG4gICAgICB0eFRtcC5vdXRzID0gW107XG4gICAgICAvLyBpZ25vcmUgc2VxdWVuY2UgbnVtYmVycyAoZXhjZXB0IGF0IGluSW5kZXgpXG4gICAgICB0eFRtcC5pbnMuZm9yRWFjaCgoaW5wdXQsIGkpID0+IHtcbiAgICAgICAgaWYgKGkgPT09IGluSW5kZXgpIHJldHVybjtcbiAgICAgICAgaW5wdXQuc2VxdWVuY2UgPSAwO1xuICAgICAgfSk7XG4gICAgICAvLyBTSUdIQVNIX1NJTkdMRTogaWdub3JlIGFsbCBvdXRwdXRzLCBleGNlcHQgYXQgdGhlIHNhbWUgaW5kZXg/XG4gICAgfSBlbHNlIGlmICgoaGFzaFR5cGUgJiAweDFmKSA9PT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEUpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpdGNvaW4vYmxvYi9tYXN0ZXIvc3JjL3Rlc3Qvc2lnaGFzaF90ZXN0cy5jcHAjTDYwXG4gICAgICBpZiAoaW5JbmRleCA+PSB0aGlzLm91dHMubGVuZ3RoKSByZXR1cm4gT05FO1xuICAgICAgLy8gdHJ1bmNhdGUgb3V0cHV0cyBhZnRlclxuICAgICAgdHhUbXAub3V0cy5sZW5ndGggPSBpbkluZGV4ICsgMTtcbiAgICAgIC8vIFwiYmxhbmtcIiBvdXRwdXRzIGJlZm9yZVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbkluZGV4OyBpKyspIHtcbiAgICAgICAgdHhUbXAub3V0c1tpXSA9IEJMQU5LX09VVFBVVDtcbiAgICAgIH1cbiAgICAgIC8vIGlnbm9yZSBzZXF1ZW5jZSBudW1iZXJzIChleGNlcHQgYXQgaW5JbmRleClcbiAgICAgIHR4VG1wLmlucy5mb3JFYWNoKChpbnB1dCwgeSkgPT4ge1xuICAgICAgICBpZiAoeSA9PT0gaW5JbmRleCkgcmV0dXJuO1xuICAgICAgICBpbnB1dC5zZXF1ZW5jZSA9IDA7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gU0lHSEFTSF9BTllPTkVDQU5QQVk6IGlnbm9yZSBpbnB1dHMgZW50aXJlbHk/XG4gICAgaWYgKGhhc2hUeXBlICYgVHJhbnNhY3Rpb24uU0lHSEFTSF9BTllPTkVDQU5QQVkpIHtcbiAgICAgIHR4VG1wLmlucyA9IFt0eFRtcC5pbnNbaW5JbmRleF1dO1xuICAgICAgdHhUbXAuaW5zWzBdLnNjcmlwdCA9IG91clNjcmlwdDtcbiAgICAgIC8vIFNJR0hBU0hfQUxMOiBvbmx5IGlnbm9yZSBpbnB1dCBzY3JpcHRzXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFwiYmxhbmtcIiBvdGhlcnMgaW5wdXQgc2NyaXB0c1xuICAgICAgdHhUbXAuaW5zLmZvckVhY2goaW5wdXQgPT4ge1xuICAgICAgICBpbnB1dC5zY3JpcHQgPSBFTVBUWV9CVUZGRVI7XG4gICAgICB9KTtcbiAgICAgIHR4VG1wLmluc1tpbkluZGV4XS5zY3JpcHQgPSBvdXJTY3JpcHQ7XG4gICAgfVxuICAgIC8vIHNlcmlhbGl6ZSBhbmQgaGFzaFxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0eFRtcC5ieXRlTGVuZ3RoKGZhbHNlKSArIDQpO1xuICAgIGJ1ZmZlci53cml0ZUludDMyTEUoaGFzaFR5cGUsIGJ1ZmZlci5sZW5ndGggLSA0KTtcbiAgICB0eFRtcC5fX3RvQnVmZmVyKGJ1ZmZlciwgMCwgZmFsc2UpO1xuICAgIHJldHVybiBiY3J5cHRvLmhhc2gyNTYoYnVmZmVyKTtcbiAgfVxuICBoYXNoRm9yV2l0bmVzc1YxKGluSW5kZXgsIHByZXZPdXRTY3JpcHRzLCB2YWx1ZXMsIGhhc2hUeXBlLCBsZWFmSGFzaCwgYW5uZXgpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQxLm1lZGlhd2lraSNjb21tb24tc2lnbmF0dXJlLW1lc3NhZ2VcbiAgICB0eXBlZm9yY2UoXG4gICAgICB0eXBlcy50dXBsZShcbiAgICAgICAgdHlwZXMuVUludDMyLFxuICAgICAgICB0eXBlZm9yY2UuYXJyYXlPZih0eXBlcy5CdWZmZXIpLFxuICAgICAgICB0eXBlZm9yY2UuYXJyYXlPZih0eXBlcy5TYXRvc2hpKSxcbiAgICAgICAgdHlwZXMuVUludDMyLFxuICAgICAgKSxcbiAgICAgIGFyZ3VtZW50cyxcbiAgICApO1xuICAgIGlmIChcbiAgICAgIHZhbHVlcy5sZW5ndGggIT09IHRoaXMuaW5zLmxlbmd0aCB8fFxuICAgICAgcHJldk91dFNjcmlwdHMubGVuZ3RoICE9PSB0aGlzLmlucy5sZW5ndGhcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzdXBwbHkgcHJldm91dCBzY3JpcHQgYW5kIHZhbHVlIGZvciBhbGwgaW5wdXRzJyk7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dFR5cGUgPVxuICAgICAgaGFzaFR5cGUgPT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVFxuICAgICAgICA/IFRyYW5zYWN0aW9uLlNJR0hBU0hfQUxMXG4gICAgICAgIDogaGFzaFR5cGUgJiBUcmFuc2FjdGlvbi5TSUdIQVNIX09VVFBVVF9NQVNLO1xuICAgIGNvbnN0IGlucHV0VHlwZSA9IGhhc2hUeXBlICYgVHJhbnNhY3Rpb24uU0lHSEFTSF9JTlBVVF9NQVNLO1xuICAgIGNvbnN0IGlzQW55b25lQ2FuUGF5ID0gaW5wdXRUeXBlID09PSBUcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWTtcbiAgICBjb25zdCBpc05vbmUgPSBvdXRwdXRUeXBlID09PSBUcmFuc2FjdGlvbi5TSUdIQVNIX05PTkU7XG4gICAgY29uc3QgaXNTaW5nbGUgPSBvdXRwdXRUeXBlID09PSBUcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRTtcbiAgICBsZXQgaGFzaFByZXZvdXRzID0gRU1QVFlfQlVGRkVSO1xuICAgIGxldCBoYXNoQW1vdW50cyA9IEVNUFRZX0JVRkZFUjtcbiAgICBsZXQgaGFzaFNjcmlwdFB1YktleXMgPSBFTVBUWV9CVUZGRVI7XG4gICAgbGV0IGhhc2hTZXF1ZW5jZXMgPSBFTVBUWV9CVUZGRVI7XG4gICAgbGV0IGhhc2hPdXRwdXRzID0gRU1QVFlfQlVGRkVSO1xuICAgIGlmICghaXNBbnlvbmVDYW5QYXkpIHtcbiAgICAgIGxldCBidWZmZXJXcml0ZXIgPSBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlci53aXRoQ2FwYWNpdHkoXG4gICAgICAgIDM2ICogdGhpcy5pbnMubGVuZ3RoLFxuICAgICAgKTtcbiAgICAgIHRoaXMuaW5zLmZvckVhY2godHhJbiA9PiB7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKHR4SW4uaGFzaCk7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMih0eEluLmluZGV4KTtcbiAgICAgIH0pO1xuICAgICAgaGFzaFByZXZvdXRzID0gYmNyeXB0by5zaGEyNTYoYnVmZmVyV3JpdGVyLmVuZCgpKTtcbiAgICAgIGJ1ZmZlcldyaXRlciA9IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyLndpdGhDYXBhY2l0eShcbiAgICAgICAgOCAqIHRoaXMuaW5zLmxlbmd0aCxcbiAgICAgICk7XG4gICAgICB2YWx1ZXMuZm9yRWFjaCh2YWx1ZSA9PiBidWZmZXJXcml0ZXIud3JpdGVVSW50NjQodmFsdWUpKTtcbiAgICAgIGhhc2hBbW91bnRzID0gYmNyeXB0by5zaGEyNTYoYnVmZmVyV3JpdGVyLmVuZCgpKTtcbiAgICAgIGJ1ZmZlcldyaXRlciA9IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyLndpdGhDYXBhY2l0eShcbiAgICAgICAgcHJldk91dFNjcmlwdHMubWFwKHZhclNsaWNlU2l6ZSkucmVkdWNlKChhLCBiKSA9PiBhICsgYiksXG4gICAgICApO1xuICAgICAgcHJldk91dFNjcmlwdHMuZm9yRWFjaChwcmV2T3V0U2NyaXB0ID0+XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhclNsaWNlKHByZXZPdXRTY3JpcHQpLFxuICAgICAgKTtcbiAgICAgIGhhc2hTY3JpcHRQdWJLZXlzID0gYmNyeXB0by5zaGEyNTYoYnVmZmVyV3JpdGVyLmVuZCgpKTtcbiAgICAgIGJ1ZmZlcldyaXRlciA9IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyLndpdGhDYXBhY2l0eShcbiAgICAgICAgNCAqIHRoaXMuaW5zLmxlbmd0aCxcbiAgICAgICk7XG4gICAgICB0aGlzLmlucy5mb3JFYWNoKHR4SW4gPT4gYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHR4SW4uc2VxdWVuY2UpKTtcbiAgICAgIGhhc2hTZXF1ZW5jZXMgPSBiY3J5cHRvLnNoYTI1NihidWZmZXJXcml0ZXIuZW5kKCkpO1xuICAgIH1cbiAgICBpZiAoIShpc05vbmUgfHwgaXNTaW5nbGUpKSB7XG4gICAgICBjb25zdCB0eE91dHNTaXplID0gdGhpcy5vdXRzXG4gICAgICAgIC5tYXAob3V0cHV0ID0+IDggKyB2YXJTbGljZVNpemUob3V0cHV0LnNjcmlwdCkpXG4gICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKTtcbiAgICAgIGNvbnN0IGJ1ZmZlcldyaXRlciA9IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyLndpdGhDYXBhY2l0eSh0eE91dHNTaXplKTtcbiAgICAgIHRoaXMub3V0cy5mb3JFYWNoKG91dCA9PiB7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQ2NChvdXQudmFsdWUpO1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVWYXJTbGljZShvdXQuc2NyaXB0KTtcbiAgICAgIH0pO1xuICAgICAgaGFzaE91dHB1dHMgPSBiY3J5cHRvLnNoYTI1NihidWZmZXJXcml0ZXIuZW5kKCkpO1xuICAgIH0gZWxzZSBpZiAoaXNTaW5nbGUgJiYgaW5JbmRleCA8IHRoaXMub3V0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IHRoaXMub3V0c1tpbkluZGV4XTtcbiAgICAgIGNvbnN0IGJ1ZmZlcldyaXRlciA9IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyLndpdGhDYXBhY2l0eShcbiAgICAgICAgOCArIHZhclNsaWNlU2l6ZShvdXRwdXQuc2NyaXB0KSxcbiAgICAgICk7XG4gICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50NjQob3V0cHV0LnZhbHVlKTtcbiAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhclNsaWNlKG91dHB1dC5zY3JpcHQpO1xuICAgICAgaGFzaE91dHB1dHMgPSBiY3J5cHRvLnNoYTI1NihidWZmZXJXcml0ZXIuZW5kKCkpO1xuICAgIH1cbiAgICBjb25zdCBzcGVuZFR5cGUgPSAobGVhZkhhc2ggPyAyIDogMCkgKyAoYW5uZXggPyAxIDogMCk7XG4gICAgLy8gTGVuZ3RoIGNhbGN1bGF0aW9uIGZyb206XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MS5tZWRpYXdpa2kjY2l0ZV9ub3RlLTE0XG4gICAgLy8gV2l0aCBleHRlbnNpb24gZnJvbTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQyLm1lZGlhd2lraSNzaWduYXR1cmUtdmFsaWRhdGlvblxuICAgIGNvbnN0IHNpZ01zZ1NpemUgPVxuICAgICAgMTc0IC1cbiAgICAgIChpc0FueW9uZUNhblBheSA/IDQ5IDogMCkgLVxuICAgICAgKGlzTm9uZSA/IDMyIDogMCkgK1xuICAgICAgKGFubmV4ID8gMzIgOiAwKSArXG4gICAgICAobGVhZkhhc2ggPyAzNyA6IDApO1xuICAgIGNvbnN0IHNpZ01zZ1dyaXRlciA9IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyLndpdGhDYXBhY2l0eShzaWdNc2dTaXplKTtcbiAgICBzaWdNc2dXcml0ZXIud3JpdGVVSW50OChoYXNoVHlwZSk7XG4gICAgLy8gVHJhbnNhY3Rpb25cbiAgICBzaWdNc2dXcml0ZXIud3JpdGVJbnQzMih0aGlzLnZlcnNpb24pO1xuICAgIHNpZ01zZ1dyaXRlci53cml0ZVVJbnQzMih0aGlzLmxvY2t0aW1lKTtcbiAgICBzaWdNc2dXcml0ZXIud3JpdGVTbGljZShoYXNoUHJldm91dHMpO1xuICAgIHNpZ01zZ1dyaXRlci53cml0ZVNsaWNlKGhhc2hBbW91bnRzKTtcbiAgICBzaWdNc2dXcml0ZXIud3JpdGVTbGljZShoYXNoU2NyaXB0UHViS2V5cyk7XG4gICAgc2lnTXNnV3JpdGVyLndyaXRlU2xpY2UoaGFzaFNlcXVlbmNlcyk7XG4gICAgaWYgKCEoaXNOb25lIHx8IGlzU2luZ2xlKSkge1xuICAgICAgc2lnTXNnV3JpdGVyLndyaXRlU2xpY2UoaGFzaE91dHB1dHMpO1xuICAgIH1cbiAgICAvLyBJbnB1dFxuICAgIHNpZ01zZ1dyaXRlci53cml0ZVVJbnQ4KHNwZW5kVHlwZSk7XG4gICAgaWYgKGlzQW55b25lQ2FuUGF5KSB7XG4gICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaW5zW2luSW5kZXhdO1xuICAgICAgc2lnTXNnV3JpdGVyLndyaXRlU2xpY2UoaW5wdXQuaGFzaCk7XG4gICAgICBzaWdNc2dXcml0ZXIud3JpdGVVSW50MzIoaW5wdXQuaW5kZXgpO1xuICAgICAgc2lnTXNnV3JpdGVyLndyaXRlVUludDY0KHZhbHVlc1tpbkluZGV4XSk7XG4gICAgICBzaWdNc2dXcml0ZXIud3JpdGVWYXJTbGljZShwcmV2T3V0U2NyaXB0c1tpbkluZGV4XSk7XG4gICAgICBzaWdNc2dXcml0ZXIud3JpdGVVSW50MzIoaW5wdXQuc2VxdWVuY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWdNc2dXcml0ZXIud3JpdGVVSW50MzIoaW5JbmRleCk7XG4gICAgfVxuICAgIGlmIChhbm5leCkge1xuICAgICAgY29uc3QgYnVmZmVyV3JpdGVyID0gYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIud2l0aENhcGFjaXR5KFxuICAgICAgICB2YXJTbGljZVNpemUoYW5uZXgpLFxuICAgICAgKTtcbiAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhclNsaWNlKGFubmV4KTtcbiAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVNsaWNlKGJjcnlwdG8uc2hhMjU2KGJ1ZmZlcldyaXRlci5lbmQoKSkpO1xuICAgIH1cbiAgICAvLyBPdXRwdXRcbiAgICBpZiAoaXNTaW5nbGUpIHtcbiAgICAgIHNpZ01zZ1dyaXRlci53cml0ZVNsaWNlKGhhc2hPdXRwdXRzKTtcbiAgICB9XG4gICAgLy8gQklQMzQyIGV4dGVuc2lvblxuICAgIGlmIChsZWFmSGFzaCkge1xuICAgICAgc2lnTXNnV3JpdGVyLndyaXRlU2xpY2UobGVhZkhhc2gpO1xuICAgICAgc2lnTXNnV3JpdGVyLndyaXRlVUludDgoMCk7XG4gICAgICBzaWdNc2dXcml0ZXIud3JpdGVVSW50MzIoMHhmZmZmZmZmZik7XG4gICAgfVxuICAgIC8vIEV4dHJhIHplcm8gYnl0ZSBiZWNhdXNlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDEubWVkaWF3aWtpI2NpdGVfbm90ZS0xOVxuICAgIHJldHVybiBiY3J5cHRvLnRhZ2dlZEhhc2goXG4gICAgICAnVGFwU2lnaGFzaCcsXG4gICAgICBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbMHgwMF0pLCBzaWdNc2dXcml0ZXIuZW5kKCldKSxcbiAgICApO1xuICB9XG4gIGhhc2hGb3JXaXRuZXNzVjAoaW5JbmRleCwgcHJldk91dFNjcmlwdCwgdmFsdWUsIGhhc2hUeXBlKSB7XG4gICAgdHlwZWZvcmNlKFxuICAgICAgdHlwZXMudHVwbGUodHlwZXMuVUludDMyLCB0eXBlcy5CdWZmZXIsIHR5cGVzLlNhdG9zaGksIHR5cGVzLlVJbnQzMiksXG4gICAgICBhcmd1bWVudHMsXG4gICAgKTtcbiAgICBsZXQgdGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKFtdKTtcbiAgICBsZXQgYnVmZmVyV3JpdGVyO1xuICAgIGxldCBoYXNoT3V0cHV0cyA9IFpFUk87XG4gICAgbGV0IGhhc2hQcmV2b3V0cyA9IFpFUk87XG4gICAgbGV0IGhhc2hTZXF1ZW5jZSA9IFpFUk87XG4gICAgaWYgKCEoaGFzaFR5cGUgJiBUcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWSkpIHtcbiAgICAgIHRidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMzYgKiB0aGlzLmlucy5sZW5ndGgpO1xuICAgICAgYnVmZmVyV3JpdGVyID0gbmV3IGJ1ZmZlcnV0aWxzXzEuQnVmZmVyV3JpdGVyKHRidWZmZXIsIDApO1xuICAgICAgdGhpcy5pbnMuZm9yRWFjaCh0eEluID0+IHtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UodHhJbi5oYXNoKTtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHR4SW4uaW5kZXgpO1xuICAgICAgfSk7XG4gICAgICBoYXNoUHJldm91dHMgPSBiY3J5cHRvLmhhc2gyNTYodGJ1ZmZlcik7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICEoaGFzaFR5cGUgJiBUcmFuc2FjdGlvbi5TSUdIQVNIX0FOWU9ORUNBTlBBWSkgJiZcbiAgICAgIChoYXNoVHlwZSAmIDB4MWYpICE9PSBUcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRSAmJlxuICAgICAgKGhhc2hUeXBlICYgMHgxZikgIT09IFRyYW5zYWN0aW9uLlNJR0hBU0hfTk9ORVxuICAgICkge1xuICAgICAgdGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0ICogdGhpcy5pbnMubGVuZ3RoKTtcbiAgICAgIGJ1ZmZlcldyaXRlciA9IG5ldyBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlcih0YnVmZmVyLCAwKTtcbiAgICAgIHRoaXMuaW5zLmZvckVhY2godHhJbiA9PiB7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMih0eEluLnNlcXVlbmNlKTtcbiAgICAgIH0pO1xuICAgICAgaGFzaFNlcXVlbmNlID0gYmNyeXB0by5oYXNoMjU2KHRidWZmZXIpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICAoaGFzaFR5cGUgJiAweDFmKSAhPT0gVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEUgJiZcbiAgICAgIChoYXNoVHlwZSAmIDB4MWYpICE9PSBUcmFuc2FjdGlvbi5TSUdIQVNIX05PTkVcbiAgICApIHtcbiAgICAgIGNvbnN0IHR4T3V0c1NpemUgPSB0aGlzLm91dHMucmVkdWNlKChzdW0sIG91dHB1dCkgPT4ge1xuICAgICAgICByZXR1cm4gc3VtICsgOCArIHZhclNsaWNlU2l6ZShvdXRwdXQuc2NyaXB0KTtcbiAgICAgIH0sIDApO1xuICAgICAgdGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0eE91dHNTaXplKTtcbiAgICAgIGJ1ZmZlcldyaXRlciA9IG5ldyBidWZmZXJ1dGlsc18xLkJ1ZmZlcldyaXRlcih0YnVmZmVyLCAwKTtcbiAgICAgIHRoaXMub3V0cy5mb3JFYWNoKG91dCA9PiB7XG4gICAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQ2NChvdXQudmFsdWUpO1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVWYXJTbGljZShvdXQuc2NyaXB0KTtcbiAgICAgIH0pO1xuICAgICAgaGFzaE91dHB1dHMgPSBiY3J5cHRvLmhhc2gyNTYodGJ1ZmZlcik7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIChoYXNoVHlwZSAmIDB4MWYpID09PSBUcmFuc2FjdGlvbi5TSUdIQVNIX1NJTkdMRSAmJlxuICAgICAgaW5JbmRleCA8IHRoaXMub3V0cy5sZW5ndGhcbiAgICApIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IHRoaXMub3V0c1tpbkluZGV4XTtcbiAgICAgIHRidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoOCArIHZhclNsaWNlU2l6ZShvdXRwdXQuc2NyaXB0KSk7XG4gICAgICBidWZmZXJXcml0ZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIodGJ1ZmZlciwgMCk7XG4gICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50NjQob3V0cHV0LnZhbHVlKTtcbiAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhclNsaWNlKG91dHB1dC5zY3JpcHQpO1xuICAgICAgaGFzaE91dHB1dHMgPSBiY3J5cHRvLmhhc2gyNTYodGJ1ZmZlcik7XG4gICAgfVxuICAgIHRidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTU2ICsgdmFyU2xpY2VTaXplKHByZXZPdXRTY3JpcHQpKTtcbiAgICBidWZmZXJXcml0ZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIodGJ1ZmZlciwgMCk7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmluc1tpbkluZGV4XTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVJbnQzMih0aGlzLnZlcnNpb24pO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVNsaWNlKGhhc2hQcmV2b3V0cyk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UoaGFzaFNlcXVlbmNlKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZShpbnB1dC5oYXNoKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50MzIoaW5wdXQuaW5kZXgpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhclNsaWNlKHByZXZPdXRTY3JpcHQpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQ2NCh2YWx1ZSk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKGlucHV0LnNlcXVlbmNlKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVTbGljZShoYXNoT3V0cHV0cyk7XG4gICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDMyKHRoaXMubG9ja3RpbWUpO1xuICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMihoYXNoVHlwZSk7XG4gICAgcmV0dXJuIGJjcnlwdG8uaGFzaDI1Nih0YnVmZmVyKTtcbiAgfVxuICBnZXRIYXNoKGZvcldpdG5lc3MpIHtcbiAgICAvLyB3dHhpZCBmb3IgY29pbmJhc2UgaXMgYWx3YXlzIDMyIGJ5dGVzIG9mIDB4MDBcbiAgICBpZiAoZm9yV2l0bmVzcyAmJiB0aGlzLmlzQ29pbmJhc2UoKSkgcmV0dXJuIEJ1ZmZlci5hbGxvYygzMiwgMCk7XG4gICAgcmV0dXJuIGJjcnlwdG8uaGFzaDI1Nih0aGlzLl9fdG9CdWZmZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIGZvcldpdG5lc3MpKTtcbiAgfVxuICBnZXRJZCgpIHtcbiAgICAvLyB0cmFuc2FjdGlvbiBoYXNoJ3MgYXJlIGRpc3BsYXllZCBpbiByZXZlcnNlIG9yZGVyXG4gICAgcmV0dXJuICgwLCBidWZmZXJ1dGlsc18xLnJldmVyc2VCdWZmZXIpKHRoaXMuZ2V0SGFzaChmYWxzZSkpLnRvU3RyaW5nKFxuICAgICAgJ2hleCcsXG4gICAgKTtcbiAgfVxuICB0b0J1ZmZlcihidWZmZXIsIGluaXRpYWxPZmZzZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fX3RvQnVmZmVyKGJ1ZmZlciwgaW5pdGlhbE9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgdG9IZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CdWZmZXIodW5kZWZpbmVkLCB1bmRlZmluZWQpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxuICBzZXRJbnB1dFNjcmlwdChpbmRleCwgc2NyaXB0U2lnKSB7XG4gICAgdHlwZWZvcmNlKHR5cGVzLnR1cGxlKHR5cGVzLk51bWJlciwgdHlwZXMuQnVmZmVyKSwgYXJndW1lbnRzKTtcbiAgICB0aGlzLmluc1tpbmRleF0uc2NyaXB0ID0gc2NyaXB0U2lnO1xuICB9XG4gIHNldFdpdG5lc3MoaW5kZXgsIHdpdG5lc3MpIHtcbiAgICB0eXBlZm9yY2UodHlwZXMudHVwbGUodHlwZXMuTnVtYmVyLCBbdHlwZXMuQnVmZmVyXSksIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5pbnNbaW5kZXhdLndpdG5lc3MgPSB3aXRuZXNzO1xuICB9XG4gIF9fdG9CdWZmZXIoYnVmZmVyLCBpbml0aWFsT2Zmc2V0LCBfQUxMT1dfV0lUTkVTUyA9IGZhbHNlKSB7XG4gICAgaWYgKCFidWZmZXIpIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSh0aGlzLmJ5dGVMZW5ndGgoX0FMTE9XX1dJVE5FU1MpKTtcbiAgICBjb25zdCBidWZmZXJXcml0ZXIgPSBuZXcgYnVmZmVydXRpbHNfMS5CdWZmZXJXcml0ZXIoXG4gICAgICBidWZmZXIsXG4gICAgICBpbml0aWFsT2Zmc2V0IHx8IDAsXG4gICAgKTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVJbnQzMih0aGlzLnZlcnNpb24pO1xuICAgIGNvbnN0IGhhc1dpdG5lc3NlcyA9IF9BTExPV19XSVRORVNTICYmIHRoaXMuaGFzV2l0bmVzc2VzKCk7XG4gICAgaWYgKGhhc1dpdG5lc3Nlcykge1xuICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVUludDgoVHJhbnNhY3Rpb24uQURWQU5DRURfVFJBTlNBQ1RJT05fTUFSS0VSKTtcbiAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQ4KFRyYW5zYWN0aW9uLkFEVkFOQ0VEX1RSQU5TQUNUSU9OX0ZMQUcpO1xuICAgIH1cbiAgICBidWZmZXJXcml0ZXIud3JpdGVWYXJJbnQodGhpcy5pbnMubGVuZ3RoKTtcbiAgICB0aGlzLmlucy5mb3JFYWNoKHR4SW4gPT4ge1xuICAgICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UodHhJbi5oYXNoKTtcbiAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMih0eEluLmluZGV4KTtcbiAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVZhclNsaWNlKHR4SW4uc2NyaXB0KTtcbiAgICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMih0eEluLnNlcXVlbmNlKTtcbiAgICB9KTtcbiAgICBidWZmZXJXcml0ZXIud3JpdGVWYXJJbnQodGhpcy5vdXRzLmxlbmd0aCk7XG4gICAgdGhpcy5vdXRzLmZvckVhY2godHhPdXQgPT4ge1xuICAgICAgaWYgKGlzT3V0cHV0KHR4T3V0KSkge1xuICAgICAgICBidWZmZXJXcml0ZXIud3JpdGVVSW50NjQodHhPdXQudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlU2xpY2UodHhPdXQudmFsdWVCdWZmZXIpO1xuICAgICAgfVxuICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmFyU2xpY2UodHhPdXQuc2NyaXB0KTtcbiAgICB9KTtcbiAgICBpZiAoaGFzV2l0bmVzc2VzKSB7XG4gICAgICB0aGlzLmlucy5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICAgICAgYnVmZmVyV3JpdGVyLndyaXRlVmVjdG9yKGlucHV0LndpdG5lc3MpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGJ1ZmZlcldyaXRlci53cml0ZVVJbnQzMih0aGlzLmxvY2t0aW1lKTtcbiAgICAvLyBhdm9pZCBzbGljaW5nIHVubGVzcyBuZWNlc3NhcnlcbiAgICBpZiAoaW5pdGlhbE9mZnNldCAhPT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZShpbml0aWFsT2Zmc2V0LCBidWZmZXJXcml0ZXIub2Zmc2V0KTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG59XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb247XG5UcmFuc2FjdGlvbi5ERUZBVUxUX1NFUVVFTkNFID0gMHhmZmZmZmZmZjtcblRyYW5zYWN0aW9uLlNJR0hBU0hfREVGQVVMVCA9IDB4MDA7XG5UcmFuc2FjdGlvbi5TSUdIQVNIX0FMTCA9IDB4MDE7XG5UcmFuc2FjdGlvbi5TSUdIQVNIX05PTkUgPSAweDAyO1xuVHJhbnNhY3Rpb24uU0lHSEFTSF9TSU5HTEUgPSAweDAzO1xuVHJhbnNhY3Rpb24uU0lHSEFTSF9BTllPTkVDQU5QQVkgPSAweDgwO1xuVHJhbnNhY3Rpb24uU0lHSEFTSF9PVVRQVVRfTUFTSyA9IDB4MDM7XG5UcmFuc2FjdGlvbi5TSUdIQVNIX0lOUFVUX01BU0sgPSAweDgwO1xuVHJhbnNhY3Rpb24uQURWQU5DRURfVFJBTlNBQ1RJT05fTUFSS0VSID0gMHgwMDtcblRyYW5zYWN0aW9uLkFEVkFOQ0VEX1RSQU5TQUNUSU9OX0ZMQUcgPSAweDAxO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/transaction.js\n"));

/***/ }),

/***/ "./node_modules/bitcoinjs-lib/src/types.js":
/*!*************************************************!*\
  !*** ./node_modules/bitcoinjs-lib/src/types.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.oneOf =\n  exports.Null =\n  exports.BufferN =\n  exports.Function =\n  exports.UInt32 =\n  exports.UInt8 =\n  exports.tuple =\n  exports.maybe =\n  exports.Hex =\n  exports.Buffer =\n  exports.String =\n  exports.Boolean =\n  exports.Array =\n  exports.Number =\n  exports.Hash256bit =\n  exports.Hash160bit =\n  exports.Buffer256bit =\n  exports.isTaptree =\n  exports.isTapleaf =\n  exports.TAPLEAF_VERSION_MASK =\n  exports.Satoshi =\n  exports.isPoint =\n  exports.stacksEqual =\n  exports.typeforce =\n    void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\");\nexports.typeforce = __webpack_require__(/*! typeforce */ \"./node_modules/typeforce/index.js\");\nconst ZERO32 = buffer_1.Buffer.alloc(32, 0);\nconst EC_P = buffer_1.Buffer.from(\n  'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',\n  'hex',\n);\n/**\n * Checks if two arrays of Buffers are equal.\n * @param a - The first array of Buffers.\n * @param b - The second array of Buffers.\n * @returns True if the arrays are equal, false otherwise.\n */\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\nexports.stacksEqual = stacksEqual;\n/**\n * Checks if the given value is a valid elliptic curve point.\n * @param p - The value to check.\n * @returns True if the value is a valid elliptic curve point, false otherwise.\n */\nfunction isPoint(p) {\n  if (!buffer_1.Buffer.isBuffer(p)) return false;\n  if (p.length < 33) return false;\n  const t = p[0];\n  const x = p.slice(1, 33);\n  if (x.compare(ZERO32) === 0) return false;\n  if (x.compare(EC_P) >= 0) return false;\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    return true;\n  }\n  const y = p.slice(33);\n  if (y.compare(ZERO32) === 0) return false;\n  if (y.compare(EC_P) >= 0) return false;\n  if (t === 0x04 && p.length === 65) return true;\n  return false;\n}\nexports.isPoint = isPoint;\nconst SATOSHI_MAX = 21 * 1e14;\nfunction Satoshi(value) {\n  return exports.typeforce.UInt53(value) && value <= SATOSHI_MAX;\n}\nexports.Satoshi = Satoshi;\nexports.TAPLEAF_VERSION_MASK = 0xfe;\nfunction isTapleaf(o) {\n  if (!o || !('output' in o)) return false;\n  if (!buffer_1.Buffer.isBuffer(o.output)) return false;\n  if (o.version !== undefined)\n    return (o.version & exports.TAPLEAF_VERSION_MASK) === o.version;\n  return true;\n}\nexports.isTapleaf = isTapleaf;\nfunction isTaptree(scriptTree) {\n  if (!(0, exports.Array)(scriptTree)) return isTapleaf(scriptTree);\n  if (scriptTree.length !== 2) return false;\n  return scriptTree.every(t => isTaptree(t));\n}\nexports.isTaptree = isTaptree;\nexports.Buffer256bit = exports.typeforce.BufferN(32);\nexports.Hash160bit = exports.typeforce.BufferN(20);\nexports.Hash256bit = exports.typeforce.BufferN(32);\nexports.Number = exports.typeforce.Number;\nexports.Array = exports.typeforce.Array;\nexports.Boolean = exports.typeforce.Boolean;\nexports.String = exports.typeforce.String;\nexports.Buffer = exports.typeforce.Buffer;\nexports.Hex = exports.typeforce.Hex;\nexports.maybe = exports.typeforce.maybe;\nexports.tuple = exports.typeforce.tuple;\nexports.UInt8 = exports.typeforce.UInt8;\nexports.UInt32 = exports.typeforce.UInt32;\nexports.Function = exports.typeforce.Function;\nexports.BufferN = exports.typeforce.BufferN;\nexports.Null = exports.typeforce.Null;\nexports.oneOf = exports.typeforce.oneOf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYml0Y29pbmpzLWxpYi9zcmMvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLEVBQUUsWUFBWTtBQUNkLEVBQUUsZUFBZTtBQUNqQixFQUFFLGdCQUFnQjtBQUNsQixFQUFFLGNBQWM7QUFDaEIsRUFBRSxhQUFhO0FBQ2YsRUFBRSxhQUFhO0FBQ2YsRUFBRSxhQUFhO0FBQ2YsRUFBRSxXQUFXO0FBQ2IsRUFBRSxjQUFjO0FBQ2hCLEVBQUUsY0FBYztBQUNoQixFQUFFLGVBQWU7QUFDakIsRUFBRSxhQUFhO0FBQ2YsRUFBRSxjQUFjO0FBQ2hCLEVBQUUsa0JBQWtCO0FBQ3BCLEVBQUUsa0JBQWtCO0FBQ3BCLEVBQUUsb0JBQW9CO0FBQ3RCLEVBQUUsaUJBQWlCO0FBQ25CLEVBQUUsaUJBQWlCO0FBQ25CLEVBQUUsNEJBQTRCO0FBQzlCLEVBQUUsZUFBZTtBQUNqQixFQUFFLGVBQWU7QUFDakIsRUFBRSxtQkFBbUI7QUFDckIsRUFBRSxpQkFBaUI7QUFDbkI7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBUTtBQUNqQyw2RkFBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2QsYUFBYTtBQUNiLGVBQWU7QUFDZixjQUFjO0FBQ2QsY0FBYztBQUNkLFdBQVc7QUFDWCxhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGVBQWU7QUFDZixZQUFZO0FBQ1osYUFBYSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iaXRjb2luanMtbGliL3NyYy90eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vbmVPZiA9XG4gIGV4cG9ydHMuTnVsbCA9XG4gIGV4cG9ydHMuQnVmZmVyTiA9XG4gIGV4cG9ydHMuRnVuY3Rpb24gPVxuICBleHBvcnRzLlVJbnQzMiA9XG4gIGV4cG9ydHMuVUludDggPVxuICBleHBvcnRzLnR1cGxlID1cbiAgZXhwb3J0cy5tYXliZSA9XG4gIGV4cG9ydHMuSGV4ID1cbiAgZXhwb3J0cy5CdWZmZXIgPVxuICBleHBvcnRzLlN0cmluZyA9XG4gIGV4cG9ydHMuQm9vbGVhbiA9XG4gIGV4cG9ydHMuQXJyYXkgPVxuICBleHBvcnRzLk51bWJlciA9XG4gIGV4cG9ydHMuSGFzaDI1NmJpdCA9XG4gIGV4cG9ydHMuSGFzaDE2MGJpdCA9XG4gIGV4cG9ydHMuQnVmZmVyMjU2Yml0ID1cbiAgZXhwb3J0cy5pc1RhcHRyZWUgPVxuICBleHBvcnRzLmlzVGFwbGVhZiA9XG4gIGV4cG9ydHMuVEFQTEVBRl9WRVJTSU9OX01BU0sgPVxuICBleHBvcnRzLlNhdG9zaGkgPVxuICBleHBvcnRzLmlzUG9pbnQgPVxuICBleHBvcnRzLnN0YWNrc0VxdWFsID1cbiAgZXhwb3J0cy50eXBlZm9yY2UgPVxuICAgIHZvaWQgMDtcbmNvbnN0IGJ1ZmZlcl8xID0gcmVxdWlyZSgnYnVmZmVyJyk7XG5leHBvcnRzLnR5cGVmb3JjZSA9IHJlcXVpcmUoJ3R5cGVmb3JjZScpO1xuY29uc3QgWkVSTzMyID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDMyLCAwKTtcbmNvbnN0IEVDX1AgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShcbiAgJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnLFxuICAnaGV4Jyxcbik7XG4vKipcbiAqIENoZWNrcyBpZiB0d28gYXJyYXlzIG9mIEJ1ZmZlcnMgYXJlIGVxdWFsLlxuICogQHBhcmFtIGEgLSBUaGUgZmlyc3QgYXJyYXkgb2YgQnVmZmVycy5cbiAqIEBwYXJhbSBiIC0gVGhlIHNlY29uZCBhcnJheSBvZiBCdWZmZXJzLlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgYXJyYXlzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBzdGFja3NFcXVhbChhLCBiKSB7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGEuZXZlcnkoKHgsIGkpID0+IHtcbiAgICByZXR1cm4geC5lcXVhbHMoYltpXSk7XG4gIH0pO1xufVxuZXhwb3J0cy5zdGFja3NFcXVhbCA9IHN0YWNrc0VxdWFsO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQgZWxsaXB0aWMgY3VydmUgcG9pbnQuXG4gKiBAcGFyYW0gcCAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgdmFsaWQgZWxsaXB0aWMgY3VydmUgcG9pbnQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNQb2ludChwKSB7XG4gIGlmICghYnVmZmVyXzEuQnVmZmVyLmlzQnVmZmVyKHApKSByZXR1cm4gZmFsc2U7XG4gIGlmIChwLmxlbmd0aCA8IDMzKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHQgPSBwWzBdO1xuICBjb25zdCB4ID0gcC5zbGljZSgxLCAzMyk7XG4gIGlmICh4LmNvbXBhcmUoWkVSTzMyKSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoeC5jb21wYXJlKEVDX1ApID49IDApIHJldHVybiBmYWxzZTtcbiAgaWYgKCh0ID09PSAweDAyIHx8IHQgPT09IDB4MDMpICYmIHAubGVuZ3RoID09PSAzMykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHkgPSBwLnNsaWNlKDMzKTtcbiAgaWYgKHkuY29tcGFyZShaRVJPMzIpID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmICh5LmNvbXBhcmUoRUNfUCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAodCA9PT0gMHgwNCAmJiBwLmxlbmd0aCA9PT0gNjUpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzUG9pbnQgPSBpc1BvaW50O1xuY29uc3QgU0FUT1NISV9NQVggPSAyMSAqIDFlMTQ7XG5mdW5jdGlvbiBTYXRvc2hpKHZhbHVlKSB7XG4gIHJldHVybiBleHBvcnRzLnR5cGVmb3JjZS5VSW50NTModmFsdWUpICYmIHZhbHVlIDw9IFNBVE9TSElfTUFYO1xufVxuZXhwb3J0cy5TYXRvc2hpID0gU2F0b3NoaTtcbmV4cG9ydHMuVEFQTEVBRl9WRVJTSU9OX01BU0sgPSAweGZlO1xuZnVuY3Rpb24gaXNUYXBsZWFmKG8pIHtcbiAgaWYgKCFvIHx8ICEoJ291dHB1dCcgaW4gbykpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFidWZmZXJfMS5CdWZmZXIuaXNCdWZmZXIoby5vdXRwdXQpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChvLnZlcnNpb24gIT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gKG8udmVyc2lvbiAmIGV4cG9ydHMuVEFQTEVBRl9WRVJTSU9OX01BU0spID09PSBvLnZlcnNpb247XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc1RhcGxlYWYgPSBpc1RhcGxlYWY7XG5mdW5jdGlvbiBpc1RhcHRyZWUoc2NyaXB0VHJlZSkge1xuICBpZiAoISgwLCBleHBvcnRzLkFycmF5KShzY3JpcHRUcmVlKSkgcmV0dXJuIGlzVGFwbGVhZihzY3JpcHRUcmVlKTtcbiAgaWYgKHNjcmlwdFRyZWUubGVuZ3RoICE9PSAyKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBzY3JpcHRUcmVlLmV2ZXJ5KHQgPT4gaXNUYXB0cmVlKHQpKTtcbn1cbmV4cG9ydHMuaXNUYXB0cmVlID0gaXNUYXB0cmVlO1xuZXhwb3J0cy5CdWZmZXIyNTZiaXQgPSBleHBvcnRzLnR5cGVmb3JjZS5CdWZmZXJOKDMyKTtcbmV4cG9ydHMuSGFzaDE2MGJpdCA9IGV4cG9ydHMudHlwZWZvcmNlLkJ1ZmZlck4oMjApO1xuZXhwb3J0cy5IYXNoMjU2Yml0ID0gZXhwb3J0cy50eXBlZm9yY2UuQnVmZmVyTigzMik7XG5leHBvcnRzLk51bWJlciA9IGV4cG9ydHMudHlwZWZvcmNlLk51bWJlcjtcbmV4cG9ydHMuQXJyYXkgPSBleHBvcnRzLnR5cGVmb3JjZS5BcnJheTtcbmV4cG9ydHMuQm9vbGVhbiA9IGV4cG9ydHMudHlwZWZvcmNlLkJvb2xlYW47XG5leHBvcnRzLlN0cmluZyA9IGV4cG9ydHMudHlwZWZvcmNlLlN0cmluZztcbmV4cG9ydHMuQnVmZmVyID0gZXhwb3J0cy50eXBlZm9yY2UuQnVmZmVyO1xuZXhwb3J0cy5IZXggPSBleHBvcnRzLnR5cGVmb3JjZS5IZXg7XG5leHBvcnRzLm1heWJlID0gZXhwb3J0cy50eXBlZm9yY2UubWF5YmU7XG5leHBvcnRzLnR1cGxlID0gZXhwb3J0cy50eXBlZm9yY2UudHVwbGU7XG5leHBvcnRzLlVJbnQ4ID0gZXhwb3J0cy50eXBlZm9yY2UuVUludDg7XG5leHBvcnRzLlVJbnQzMiA9IGV4cG9ydHMudHlwZWZvcmNlLlVJbnQzMjtcbmV4cG9ydHMuRnVuY3Rpb24gPSBleHBvcnRzLnR5cGVmb3JjZS5GdW5jdGlvbjtcbmV4cG9ydHMuQnVmZmVyTiA9IGV4cG9ydHMudHlwZWZvcmNlLkJ1ZmZlck47XG5leHBvcnRzLk51bGwgPSBleHBvcnRzLnR5cGVmb3JjZS5OdWxsO1xuZXhwb3J0cy5vbmVPZiA9IGV4cG9ydHMudHlwZWZvcmNlLm9uZU9mO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bitcoinjs-lib/src/types.js\n"));

/***/ }),

/***/ "./node_modules/bs58check/base.js":
/*!****************************************!*\
  !*** ./node_modules/bs58check/base.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nvar base58 = __webpack_require__(/*! bs58 */ \"./node_modules/bs58check/node_modules/bs58/index.js\")\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var payloadU8 = Uint8Array.from(payload)\n    var checksum = checksumFn(payloadU8)\n    var length = payloadU8.length + 4\n    var both = new Uint8Array(length)\n    both.set(payloadU8, 0)\n    both.set(checksum.subarray(0, 4), payloadU8.length)\n    return base58.encode(both, length)\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnM1OGNoZWNrL2Jhc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLGlFQUFNOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL2JzNThjaGVjay9iYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTU4ID0gcmVxdWlyZSgnYnM1OCcpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNoZWNrc3VtRm4pIHtcbiAgLy8gRW5jb2RlIGEgYnVmZmVyIGFzIGEgYmFzZTU4LWNoZWNrIGVuY29kZWQgc3RyaW5nXG4gIGZ1bmN0aW9uIGVuY29kZSAocGF5bG9hZCkge1xuICAgIHZhciBwYXlsb2FkVTggPSBVaW50OEFycmF5LmZyb20ocGF5bG9hZClcbiAgICB2YXIgY2hlY2tzdW0gPSBjaGVja3N1bUZuKHBheWxvYWRVOClcbiAgICB2YXIgbGVuZ3RoID0gcGF5bG9hZFU4Lmxlbmd0aCArIDRcbiAgICB2YXIgYm90aCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICBib3RoLnNldChwYXlsb2FkVTgsIDApXG4gICAgYm90aC5zZXQoY2hlY2tzdW0uc3ViYXJyYXkoMCwgNCksIHBheWxvYWRVOC5sZW5ndGgpXG4gICAgcmV0dXJuIGJhc2U1OC5lbmNvZGUoYm90aCwgbGVuZ3RoKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlUmF3IChidWZmZXIpIHtcbiAgICB2YXIgcGF5bG9hZCA9IGJ1ZmZlci5zbGljZSgwLCAtNClcbiAgICB2YXIgY2hlY2tzdW0gPSBidWZmZXIuc2xpY2UoLTQpXG4gICAgdmFyIG5ld0NoZWNrc3VtID0gY2hlY2tzdW1GbihwYXlsb2FkKVxuXG4gICAgaWYgKGNoZWNrc3VtWzBdIF4gbmV3Q2hlY2tzdW1bMF0gfFxuICAgICAgICBjaGVja3N1bVsxXSBeIG5ld0NoZWNrc3VtWzFdIHxcbiAgICAgICAgY2hlY2tzdW1bMl0gXiBuZXdDaGVja3N1bVsyXSB8XG4gICAgICAgIGNoZWNrc3VtWzNdIF4gbmV3Q2hlY2tzdW1bM10pIHJldHVyblxuXG4gICAgcmV0dXJuIHBheWxvYWRcbiAgfVxuXG4gIC8vIERlY29kZSBhIGJhc2U1OC1jaGVjayBlbmNvZGVkIHN0cmluZyB0byBhIGJ1ZmZlciwgbm8gcmVzdWx0IGlmIGNoZWNrc3VtIGlzIHdyb25nXG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGJhc2U1OC5kZWNvZGVVbnNhZmUoc3RyaW5nKVxuICAgIGlmICghYnVmZmVyKSByZXR1cm5cblxuICAgIHJldHVybiBkZWNvZGVSYXcoYnVmZmVyKVxuICB9XG5cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gYmFzZTU4LmRlY29kZShzdHJpbmcpXG4gICAgdmFyIHBheWxvYWQgPSBkZWNvZGVSYXcoYnVmZmVyLCBjaGVja3N1bUZuKVxuICAgIGlmICghcGF5bG9hZCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJylcbiAgICByZXR1cm4gcGF5bG9hZFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGU6IGRlY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bs58check/base.js\n"));

/***/ }),

/***/ "./node_modules/bs58check/index.js":
/*!*****************************************!*\
  !*** ./node_modules/bs58check/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nvar { sha256 } = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/@noble/hashes/sha256.js\")\nvar bs58checkBase = __webpack_require__(/*! ./base */ \"./node_modules/bs58check/base.js\")\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  return sha256(sha256(buffer))\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnM1OGNoZWNrL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLE1BQU0sU0FBUyxFQUFFLG1CQUFPLENBQUMsb0VBQXNCO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLGdEQUFROztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iczU4Y2hlY2svaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciB7IHNoYTI1NiB9ID0gcmVxdWlyZSgnQG5vYmxlL2hhc2hlcy9zaGEyNTYnKVxudmFyIGJzNThjaGVja0Jhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKVxuXG4vLyBTSEEyNTYoU0hBMjU2KGJ1ZmZlcikpXG5mdW5jdGlvbiBzaGEyNTZ4MiAoYnVmZmVyKSB7XG4gIHJldHVybiBzaGEyNTYoc2hhMjU2KGJ1ZmZlcikpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnM1OGNoZWNrQmFzZShzaGEyNTZ4MilcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bs58check/index.js\n"));

/***/ }),

/***/ "./node_modules/bs58check/node_modules/base-x/src/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/bs58check/node_modules/base-x/src/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnM1OGNoZWNrL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJDQUEyQztBQUMzQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVksU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvYnM1OGNoZWNrL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLy8gYmFzZS14IGVuY29kaW5nIC8gZGVjb2Rpbmdcbi8vIENvcHlyaWdodCAoYykgMjAxOCBiYXNlLXggY29udHJpYnV0b3JzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCBUaGUgQml0Y29pbiBDb3JlIGRldmVsb3BlcnMgKGJhc2U1OC5jcHApXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIExJQ0VOU0Ugb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5mdW5jdGlvbiBiYXNlIChBTFBIQUJFVCkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHBoYWJldCB0b28gbG9uZycpIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KVxuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTVcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoaSlcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMClcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKSB9XG4gICAgQkFTRV9NQVBbeGNdID0gaVxuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoXG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMClcbiAgdmFyIEZBQ1RPUiA9IE1hdGgubG9nKEJBU0UpIC8gTWF0aC5sb2coMjU2KSAvLyBsb2coQkFTRSkgLyBsb2coMjU2KSwgcm91bmRlZCB1cFxuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKSAvLyBsb2coMjU2KSAvIGxvZyhCQVNFKSwgcm91bmRlZCB1cFxuICBmdW5jdGlvbiBlbmNvZGUgKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc291cmNlKSkge1xuICAgICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIHNvdXJjZS5ieXRlTGVuZ3RoKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBVaW50OEFycmF5LmZyb20oc291cmNlKVxuICAgIH1cbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5JykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJyB9XG4gICAgICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgdmFyIHBiZWdpbiA9IDBcbiAgICB2YXIgcGVuZCA9IHNvdXJjZS5sZW5ndGhcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rK1xuICAgICAgemVyb2VzKytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2U1OCByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgocGVuZCAtIHBiZWdpbikgKiBpRkFDVE9SICsgMSkgPj4+IDBcbiAgICB2YXIgYjU4ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgYnl0ZXMuXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCkge1xuICAgICAgdmFyIGNhcnJ5ID0gc291cmNlW3BiZWdpbl1cbiAgICAgICAgICAgIC8vIEFwcGx5IFwiYjU4ID0gYjU4ICogMjU2ICsgY2hcIi5cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQxICE9PSAtMSk7IGl0MS0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKDI1NiAqIGI1OFtpdDFdKSA+Pj4gMFxuICAgICAgICBiNThbaXQxXSA9IChjYXJyeSAlIEJBU0UpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcGJlZ2luKytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDIgIT09IHNpemUgJiYgYjU4W2l0Ml0gPT09IDApIHtcbiAgICAgIGl0MisrXG4gICAgfVxuICAgICAgICAvLyBUcmFuc2xhdGUgdGhlIHJlc3VsdCBpbnRvIGEgc3RyaW5nLlxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcylcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHsgc3RyICs9IEFMUEhBQkVULmNoYXJBdChiNThbaXQyXSkgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUgKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KCkgfVxuICAgIHZhciBwc3ogPSAwXG4gICAgICAgIC8vIFNraXAgYW5kIGNvdW50IGxlYWRpbmcgJzEncy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTI1NiByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgoKHNvdXJjZS5sZW5ndGggLSBwc3opICogRkFDVE9SKSArIDEpID4+PiAwIC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGNoYXJhY3RlcnMuXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdKSB7XG4gICAgICAgICAgICAvLyBGaW5kIGNvZGUgb2YgbmV4dCBjaGFyYWN0ZXJcbiAgICAgIHZhciBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBzeilcbiAgICAgICAgICAgIC8vIEJhc2UgbWFwIGNhbiBub3QgYmUgaW5kZXhlZCB1c2luZyBjaGFyIGNvZGVcbiAgICAgIGlmIChjaGFyQ29kZSA+IDI1NSkgeyByZXR1cm4gfVxuICAgICAgICAgICAgLy8gRGVjb2RlIGNoYXJhY3RlclxuICAgICAgdmFyIGNhcnJ5ID0gQkFTRV9NQVBbY2hhckNvZGVdXG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNoYXJhY3RlclxuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQzID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQzICE9PSAtMSk7IGl0My0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKEJBU0UgKiBiMjU2W2l0M10pID4+PiAwXG4gICAgICAgIGIyNTZbaXQzXSA9IChjYXJyeSAlIDI1NikgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyAyNTYpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGIyNTYuXG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplICYmIGIyNTZbaXQ0XSA9PT0gMCkge1xuICAgICAgaXQ0KytcbiAgICB9XG4gICAgdmFyIHZjaCA9IG5ldyBVaW50OEFycmF5KHplcm9lcyArIChzaXplIC0gaXQ0KSlcbiAgICB2YXIgaiA9IHplcm9lc1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUpIHtcbiAgICAgIHZjaFtqKytdID0gYjI1NltpdDQrK11cbiAgICB9XG4gICAgcmV0dXJuIHZjaFxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpXG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1iYXNlJyArIEJBU0UgKyAnIGNoYXJhY3RlcicpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bs58check/node_modules/base-x/src/index.js\n"));

/***/ }),

/***/ "./node_modules/bs58check/node_modules/bs58/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/bs58check/node_modules/bs58/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("const basex = __webpack_require__(/*! base-x */ \"./node_modules/bs58check/node_modules/base-x/src/index.js\")\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnM1OGNoZWNrL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyx5RUFBUTtBQUM5Qjs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9iczU4Y2hlY2svbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmFzZXggPSByZXF1aXJlKCdiYXNlLXgnKVxuY29uc3QgQUxQSEFCRVQgPSAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eidcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNleChBTFBIQUJFVClcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bs58check/node_modules/bs58/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === 'object' ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxxQ0FBcUMscUJBQU0saUZBQWlGLHFCQUFNLGtFQUFrRSxxQkFBTSxXQUFXLG1CQUFPLENBQUMsd0ZBQTRCOztBQUV6UCIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2dsb2JhbF9wcm9jZXNzLCBfZ2xvYmFsX3Byb2Nlc3MxO1xubW9kdWxlLmV4cG9ydHMgPSAoKF9nbG9iYWxfcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbF9wcm9jZXNzLmVudikgJiYgdHlwZW9mICgoX2dsb2JhbF9wcm9jZXNzMSA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbF9wcm9jZXNzMS5lbnYpID09PSAnb2JqZWN0JyA/IGdsb2JhbC5wcm9jZXNzIDogcmVxdWlyZSgnbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MnKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[2]!./src/styles/Home.module.css":
/*!****************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[2]!./src/styles/Home.module.css ***!
  \****************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".Home_main__2uIek {\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: center;\\n  align-items: center;\\n  padding: 6rem;\\n}\\n\\n.Home_item__8j_zl {\\n  display: inherit;\\n  justify-content: inherit;\\n  align-items: inherit;\\n  font-size: 0.85rem;\\n  max-width: var(--max-width);\\n  width: 100%;\\n  z-index: 2;\\n  margin-top: 20px;\\n}\\n\\n.Home_item__8j_zl a {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  gap: 0.5rem;\\n  text-decoration: underline;\\n}\\n\\n.Home_center__Y_rV4 {\\n  padding: 20px;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.Home_container__9OuOz {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  flex-direction: column;\\n}\\n\\n/* Mobile */\\n@media (max-width: 700px) {\\n  .Home_content__Qnbja {\\n    padding: 4rem;\\n  }\\n\\n  .Home_grid__vo_ES {\\n    grid-template-columns: 1fr;\\n    margin-bottom: 120px;\\n    max-width: 320px;\\n    text-align: center;\\n  }\\n\\n  .Home_card__HIlp_ {\\n    padding: 1rem 2.5rem;\\n  }\\n\\n  .Home_card__HIlp_ h2 {\\n    margin-bottom: 0.5rem;\\n  }\\n\\n  .Home_center__Y_rV4 {\\n    padding: 8rem 0 6rem;\\n  }\\n\\n  .Home_center__Y_rV4::before {\\n    transform: none;\\n    height: 300px;\\n  }\\n\\n  .Home_description__zHUB6 {\\n    font-size: 0.8rem;\\n  }\\n\\n  .Home_description__zHUB6 a {\\n    padding: 1rem;\\n  }\\n\\n  .Home_description__zHUB6 p,\\n  .Home_description__zHUB6 div {\\n    display: flex;\\n    justify-content: center;\\n    position: fixed;\\n    width: 100%;\\n  }\\n\\n  .Home_description__zHUB6 p {\\n    align-items: center;\\n    inset: 0 0 auto;\\n    padding: 2rem 1rem 1.4rem;\\n    border-radius: 0;\\n    border: none;\\n    border-bottom: 1px solid rgba(var(--callout-border-rgb), 0.25);\\n    background: linear-gradient(\\n      to bottom,\\n      rgba(var(--background-start-rgb), 1),\\n      rgba(var(--callout-rgb), 0.5)\\n    );\\n    background-clip: padding-box;\\n    -webkit-backdrop-filter: blur(24px);\\n            backdrop-filter: blur(24px);\\n  }\\n\\n  .Home_description__zHUB6 div {\\n    align-items: flex-end;\\n    pointer-events: none;\\n    inset: auto 0 0;\\n    padding: 2rem;\\n    height: 200px;\\n    background: linear-gradient(\\n      to bottom,\\n      transparent 0%,\\n      rgb(var(--background-end-rgb)) 40%\\n    );\\n    z-index: 1;\\n  }\\n}\\n\\n/* Tablet and Smaller Desktop */\\n@media (min-width: 701px) and (max-width: 1120px) {\\n  .Home_grid__vo_ES {\\n    grid-template-columns: repeat(2, 50%);\\n  }\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  .Home_vercelLogo__fCw7S {\\n    filter: invert(1);\\n  }\\n\\n  .Home_logo__ZEOng,\\n  .Home_thirteen__YRMKZ img {\\n    filter: invert(1) drop-shadow(0 0 0.3rem #ffffff70);\\n  }\\n}\\n\\n@keyframes Home_rotate__x60Ft {\\n  from {\\n    transform: rotate(360deg);\\n  }\\n  to {\\n    transform: rotate(0deg);\\n  }\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://src/styles/Home.module.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,aAAa;EACb,sBAAsB;EACtB,uBAAuB;EACvB,mBAAmB;EACnB,aAAa;AACf;;AAEA;EACE,gBAAgB;EAChB,wBAAwB;EACxB,oBAAoB;EACpB,kBAAkB;EAClB,2BAA2B;EAC3B,WAAW;EACX,UAAU;EACV,gBAAgB;AAClB;;AAEA;EACE,aAAa;EACb,uBAAuB;EACvB,mBAAmB;EACnB,WAAW;EACX,0BAA0B;AAC5B;;AAEA;EACE,aAAa;EACb,aAAa;EACb,uBAAuB;EACvB,mBAAmB;AACrB;;AAEA;EACE,aAAa;EACb,uBAAuB;EACvB,mBAAmB;EACnB,sBAAsB;AACxB;;AAEA,WAAW;AACX;EACE;IACE,aAAa;EACf;;EAEA;IACE,0BAA0B;IAC1B,oBAAoB;IACpB,gBAAgB;IAChB,kBAAkB;EACpB;;EAEA;IACE,oBAAoB;EACtB;;EAEA;IACE,qBAAqB;EACvB;;EAEA;IACE,oBAAoB;EACtB;;EAEA;IACE,eAAe;IACf,aAAa;EACf;;EAEA;IACE,iBAAiB;EACnB;;EAEA;IACE,aAAa;EACf;;EAEA;;IAEE,aAAa;IACb,uBAAuB;IACvB,eAAe;IACf,WAAW;EACb;;EAEA;IACE,mBAAmB;IACnB,eAAe;IACf,yBAAyB;IACzB,gBAAgB;IAChB,YAAY;IACZ,8DAA8D;IAC9D;;;;KAIC;IACD,4BAA4B;IAC5B,mCAA2B;YAA3B,2BAA2B;EAC7B;;EAEA;IACE,qBAAqB;IACrB,oBAAoB;IACpB,eAAe;IACf,aAAa;IACb,aAAa;IACb;;;;KAIC;IACD,UAAU;EACZ;AACF;;AAEA,+BAA+B;AAC/B;EACE;IACE,qCAAqC;EACvC;AACF;;AAEA;EACE;IACE,iBAAiB;EACnB;;EAEA;;IAEE,mDAAmD;EACrD;AACF;;AAEA;EACE;IACE,yBAAyB;EAC3B;EACA;IACE,uBAAuB;EACzB;AACF\",\"sourcesContent\":[\".main {\\n  display: flex;\\n  flex-direction: column;\\n  justify-content: center;\\n  align-items: center;\\n  padding: 6rem;\\n}\\n\\n.item {\\n  display: inherit;\\n  justify-content: inherit;\\n  align-items: inherit;\\n  font-size: 0.85rem;\\n  max-width: var(--max-width);\\n  width: 100%;\\n  z-index: 2;\\n  margin-top: 20px;\\n}\\n\\n.item a {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  gap: 0.5rem;\\n  text-decoration: underline;\\n}\\n\\n.center {\\n  padding: 20px;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n}\\n\\n.container {\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  flex-direction: column;\\n}\\n\\n/* Mobile */\\n@media (max-width: 700px) {\\n  .content {\\n    padding: 4rem;\\n  }\\n\\n  .grid {\\n    grid-template-columns: 1fr;\\n    margin-bottom: 120px;\\n    max-width: 320px;\\n    text-align: center;\\n  }\\n\\n  .card {\\n    padding: 1rem 2.5rem;\\n  }\\n\\n  .card h2 {\\n    margin-bottom: 0.5rem;\\n  }\\n\\n  .center {\\n    padding: 8rem 0 6rem;\\n  }\\n\\n  .center::before {\\n    transform: none;\\n    height: 300px;\\n  }\\n\\n  .description {\\n    font-size: 0.8rem;\\n  }\\n\\n  .description a {\\n    padding: 1rem;\\n  }\\n\\n  .description p,\\n  .description div {\\n    display: flex;\\n    justify-content: center;\\n    position: fixed;\\n    width: 100%;\\n  }\\n\\n  .description p {\\n    align-items: center;\\n    inset: 0 0 auto;\\n    padding: 2rem 1rem 1.4rem;\\n    border-radius: 0;\\n    border: none;\\n    border-bottom: 1px solid rgba(var(--callout-border-rgb), 0.25);\\n    background: linear-gradient(\\n      to bottom,\\n      rgba(var(--background-start-rgb), 1),\\n      rgba(var(--callout-rgb), 0.5)\\n    );\\n    background-clip: padding-box;\\n    backdrop-filter: blur(24px);\\n  }\\n\\n  .description div {\\n    align-items: flex-end;\\n    pointer-events: none;\\n    inset: auto 0 0;\\n    padding: 2rem;\\n    height: 200px;\\n    background: linear-gradient(\\n      to bottom,\\n      transparent 0%,\\n      rgb(var(--background-end-rgb)) 40%\\n    );\\n    z-index: 1;\\n  }\\n}\\n\\n/* Tablet and Smaller Desktop */\\n@media (min-width: 701px) and (max-width: 1120px) {\\n  .grid {\\n    grid-template-columns: repeat(2, 50%);\\n  }\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  .vercelLogo {\\n    filter: invert(1);\\n  }\\n\\n  .logo,\\n  .thirteen img {\\n    filter: invert(1) drop-shadow(0 0 0.3rem #ffffff70);\\n  }\\n}\\n\\n@keyframes rotate {\\n  from {\\n    transform: rotate(360deg);\\n  }\\n  to {\\n    transform: rotate(0deg);\\n  }\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"main\": \"Home_main__2uIek\",\n\t\"item\": \"Home_item__8j_zl\",\n\t\"center\": \"Home_center__Y_rV4\",\n\t\"container\": \"Home_container__9OuOz\",\n\t\"content\": \"Home_content__Qnbja\",\n\t\"grid\": \"Home_grid__vo_ES\",\n\t\"card\": \"Home_card__HIlp_\",\n\t\"description\": \"Home_description__zHUB6\",\n\t\"vercelLogo\": \"Home_vercelLogo__fCw7S\",\n\t\"logo\": \"Home_logo__ZEOng\",\n\t\"thirteen\": \"Home_thirteen__YRMKZ\",\n\t\"rotate\": \"Home_rotate__x60Ft\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls3XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbN10udXNlWzJdIS4vc3JjL3N0eWxlcy9Ib21lLm1vZHVsZS5jc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxzS0FBa0Y7QUFDNUg7QUFDQTtBQUNBLDZEQUE2RCxrQkFBa0IsMkJBQTJCLDRCQUE0Qix3QkFBd0Isa0JBQWtCLEdBQUcsdUJBQXVCLHFCQUFxQiw2QkFBNkIseUJBQXlCLHVCQUF1QixnQ0FBZ0MsZ0JBQWdCLGVBQWUscUJBQXFCLEdBQUcseUJBQXlCLGtCQUFrQiw0QkFBNEIsd0JBQXdCLGdCQUFnQiwrQkFBK0IsR0FBRyx5QkFBeUIsa0JBQWtCLGtCQUFrQiw0QkFBNEIsd0JBQXdCLEdBQUcsNEJBQTRCLGtCQUFrQiw0QkFBNEIsd0JBQXdCLDJCQUEyQixHQUFHLDZDQUE2QywwQkFBMEIsb0JBQW9CLEtBQUsseUJBQXlCLGlDQUFpQywyQkFBMkIsdUJBQXVCLHlCQUF5QixLQUFLLHlCQUF5QiwyQkFBMkIsS0FBSyw0QkFBNEIsNEJBQTRCLEtBQUssMkJBQTJCLDJCQUEyQixLQUFLLG1DQUFtQyxzQkFBc0Isb0JBQW9CLEtBQUssZ0NBQWdDLHdCQUF3QixLQUFLLGtDQUFrQyxvQkFBb0IsS0FBSyxtRUFBbUUsb0JBQW9CLDhCQUE4QixzQkFBc0Isa0JBQWtCLEtBQUssa0NBQWtDLDBCQUEwQixzQkFBc0IsZ0NBQWdDLHVCQUF1QixtQkFBbUIscUVBQXFFLDhJQUE4SSxtQ0FBbUMsMENBQTBDLDBDQUEwQyxLQUFLLG9DQUFvQyw0QkFBNEIsMkJBQTJCLHNCQUFzQixvQkFBb0Isb0JBQW9CLDZIQUE2SCxpQkFBaUIsS0FBSyxHQUFHLHlGQUF5Rix1QkFBdUIsNENBQTRDLEtBQUssR0FBRyx5Q0FBeUMsNkJBQTZCLHdCQUF3QixLQUFLLHVEQUF1RCwwREFBMEQsS0FBSyxHQUFHLG1DQUFtQyxVQUFVLGdDQUFnQyxLQUFLLFFBQVEsOEJBQThCLEtBQUssR0FBRyxTQUFTLDJGQUEyRixVQUFVLFlBQVksYUFBYSxhQUFhLFdBQVcsTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxXQUFXLFVBQVUsWUFBWSxPQUFPLEtBQUssVUFBVSxZQUFZLGFBQWEsV0FBVyxZQUFZLE9BQU8sS0FBSyxVQUFVLFVBQVUsWUFBWSxhQUFhLE9BQU8sS0FBSyxVQUFVLFlBQVksYUFBYSxhQUFhLE9BQU8sVUFBVSxLQUFLLEtBQUssVUFBVSxNQUFNLEtBQUssWUFBWSxhQUFhLGFBQWEsYUFBYSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssVUFBVSxVQUFVLE1BQU0sS0FBSyxZQUFZLE9BQU8sS0FBSyxVQUFVLE1BQU0sTUFBTSxVQUFVLFlBQVksV0FBVyxVQUFVLE1BQU0sS0FBSyxZQUFZLFdBQVcsWUFBWSxhQUFhLFdBQVcsWUFBWSxTQUFTLEtBQUssWUFBWSxhQUFhLGFBQWEsT0FBTyxLQUFLLFlBQVksYUFBYSxXQUFXLFVBQVUsVUFBVSxRQUFRLEtBQUssVUFBVSxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLE1BQU0sS0FBSyxLQUFLLFlBQVksT0FBTyxNQUFNLFlBQVksTUFBTSxNQUFNLEtBQUssS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sZ0NBQWdDLGtCQUFrQiwyQkFBMkIsNEJBQTRCLHdCQUF3QixrQkFBa0IsR0FBRyxXQUFXLHFCQUFxQiw2QkFBNkIseUJBQXlCLHVCQUF1QixnQ0FBZ0MsZ0JBQWdCLGVBQWUscUJBQXFCLEdBQUcsYUFBYSxrQkFBa0IsNEJBQTRCLHdCQUF3QixnQkFBZ0IsK0JBQStCLEdBQUcsYUFBYSxrQkFBa0Isa0JBQWtCLDRCQUE0Qix3QkFBd0IsR0FBRyxnQkFBZ0Isa0JBQWtCLDRCQUE0Qix3QkFBd0IsMkJBQTJCLEdBQUcsNkNBQTZDLGNBQWMsb0JBQW9CLEtBQUssYUFBYSxpQ0FBaUMsMkJBQTJCLHVCQUF1Qix5QkFBeUIsS0FBSyxhQUFhLDJCQUEyQixLQUFLLGdCQUFnQiw0QkFBNEIsS0FBSyxlQUFlLDJCQUEyQixLQUFLLHVCQUF1QixzQkFBc0Isb0JBQW9CLEtBQUssb0JBQW9CLHdCQUF3QixLQUFLLHNCQUFzQixvQkFBb0IsS0FBSywyQ0FBMkMsb0JBQW9CLDhCQUE4QixzQkFBc0Isa0JBQWtCLEtBQUssc0JBQXNCLDBCQUEwQixzQkFBc0IsZ0NBQWdDLHVCQUF1QixtQkFBbUIscUVBQXFFLDhJQUE4SSxtQ0FBbUMsa0NBQWtDLEtBQUssd0JBQXdCLDRCQUE0QiwyQkFBMkIsc0JBQXNCLG9CQUFvQixvQkFBb0IsNkhBQTZILGlCQUFpQixLQUFLLEdBQUcseUZBQXlGLFdBQVcsNENBQTRDLEtBQUssR0FBRyx5Q0FBeUMsaUJBQWlCLHdCQUF3QixLQUFLLCtCQUErQiwwREFBMEQsS0FBSyxHQUFHLHVCQUF1QixVQUFVLGdDQUFnQyxLQUFLLFFBQVEsOEJBQThCLEtBQUssR0FBRyxxQkFBcUI7QUFDMTVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvc3JjL3N0eWxlcy9Ib21lLm1vZHVsZS5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5Ib21lX21haW5fXzJ1SWVrIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgcGFkZGluZzogNnJlbTtcXG59XFxuXFxuLkhvbWVfaXRlbV9fOGpfemwge1xcbiAgZGlzcGxheTogaW5oZXJpdDtcXG4gIGp1c3RpZnktY29udGVudDogaW5oZXJpdDtcXG4gIGFsaWduLWl0ZW1zOiBpbmhlcml0O1xcbiAgZm9udC1zaXplOiAwLjg1cmVtO1xcbiAgbWF4LXdpZHRoOiB2YXIoLS1tYXgtd2lkdGgpO1xcbiAgd2lkdGg6IDEwMCU7XFxuICB6LWluZGV4OiAyO1xcbiAgbWFyZ2luLXRvcDogMjBweDtcXG59XFxuXFxuLkhvbWVfaXRlbV9fOGpfemwgYSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZ2FwOiAwLjVyZW07XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG59XFxuXFxuLkhvbWVfY2VudGVyX19ZX3JWNCB7XFxuICBwYWRkaW5nOiAyMHB4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLkhvbWVfY29udGFpbmVyX185T3VPeiB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuLyogTW9iaWxlICovXFxuQG1lZGlhIChtYXgtd2lkdGg6IDcwMHB4KSB7XFxuICAuSG9tZV9jb250ZW50X19RbmJqYSB7XFxuICAgIHBhZGRpbmc6IDRyZW07XFxuICB9XFxuXFxuICAuSG9tZV9ncmlkX192b19FUyB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyO1xcbiAgICBtYXJnaW4tYm90dG9tOiAxMjBweDtcXG4gICAgbWF4LXdpZHRoOiAzMjBweDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgfVxcblxcbiAgLkhvbWVfY2FyZF9fSElscF8ge1xcbiAgICBwYWRkaW5nOiAxcmVtIDIuNXJlbTtcXG4gIH1cXG5cXG4gIC5Ib21lX2NhcmRfX0hJbHBfIGgyIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbiAgfVxcblxcbiAgLkhvbWVfY2VudGVyX19ZX3JWNCB7XFxuICAgIHBhZGRpbmc6IDhyZW0gMCA2cmVtO1xcbiAgfVxcblxcbiAgLkhvbWVfY2VudGVyX19ZX3JWNDo6YmVmb3JlIHtcXG4gICAgdHJhbnNmb3JtOiBub25lO1xcbiAgICBoZWlnaHQ6IDMwMHB4O1xcbiAgfVxcblxcbiAgLkhvbWVfZGVzY3JpcHRpb25fX3pIVUI2IHtcXG4gICAgZm9udC1zaXplOiAwLjhyZW07XFxuICB9XFxuXFxuICAuSG9tZV9kZXNjcmlwdGlvbl9fekhVQjYgYSB7XFxuICAgIHBhZGRpbmc6IDFyZW07XFxuICB9XFxuXFxuICAuSG9tZV9kZXNjcmlwdGlvbl9fekhVQjYgcCxcXG4gIC5Ib21lX2Rlc2NyaXB0aW9uX196SFVCNiBkaXYge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gIH1cXG5cXG4gIC5Ib21lX2Rlc2NyaXB0aW9uX196SFVCNiBwIHtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgaW5zZXQ6IDAgMCBhdXRvO1xcbiAgICBwYWRkaW5nOiAycmVtIDFyZW0gMS40cmVtO1xcbiAgICBib3JkZXItcmFkaXVzOiAwO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCByZ2JhKHZhcigtLWNhbGxvdXQtYm9yZGVyLXJnYiksIDAuMjUpO1xcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoXFxuICAgICAgdG8gYm90dG9tLFxcbiAgICAgIHJnYmEodmFyKC0tYmFja2dyb3VuZC1zdGFydC1yZ2IpLCAxKSxcXG4gICAgICByZ2JhKHZhcigtLWNhbGxvdXQtcmdiKSwgMC41KVxcbiAgICApO1xcbiAgICBiYWNrZ3JvdW5kLWNsaXA6IHBhZGRpbmctYm94O1xcbiAgICAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogYmx1cigyNHB4KTtcXG4gICAgICAgICAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoMjRweCk7XFxuICB9XFxuXFxuICAuSG9tZV9kZXNjcmlwdGlvbl9fekhVQjYgZGl2IHtcXG4gICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgaW5zZXQ6IGF1dG8gMCAwO1xcbiAgICBwYWRkaW5nOiAycmVtO1xcbiAgICBoZWlnaHQ6IDIwMHB4O1xcbiAgICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoXFxuICAgICAgdG8gYm90dG9tLFxcbiAgICAgIHRyYW5zcGFyZW50IDAlLFxcbiAgICAgIHJnYih2YXIoLS1iYWNrZ3JvdW5kLWVuZC1yZ2IpKSA0MCVcXG4gICAgKTtcXG4gICAgei1pbmRleDogMTtcXG4gIH1cXG59XFxuXFxuLyogVGFibGV0IGFuZCBTbWFsbGVyIERlc2t0b3AgKi9cXG5AbWVkaWEgKG1pbi13aWR0aDogNzAxcHgpIGFuZCAobWF4LXdpZHRoOiAxMTIwcHgpIHtcXG4gIC5Ib21lX2dyaWRfX3ZvX0VTIHtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMiwgNTAlKTtcXG4gIH1cXG59XFxuXFxuQG1lZGlhIChwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaykge1xcbiAgLkhvbWVfdmVyY2VsTG9nb19fZkN3N1Mge1xcbiAgICBmaWx0ZXI6IGludmVydCgxKTtcXG4gIH1cXG5cXG4gIC5Ib21lX2xvZ29fX1pFT25nLFxcbiAgLkhvbWVfdGhpcnRlZW5fX1lSTUtaIGltZyB7XFxuICAgIGZpbHRlcjogaW52ZXJ0KDEpIGRyb3Atc2hhZG93KDAgMCAwLjNyZW0gI2ZmZmZmZjcwKTtcXG4gIH1cXG59XFxuXFxuQGtleWZyYW1lcyBIb21lX3JvdGF0ZV9feDYwRnQge1xcbiAgZnJvbSB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICB9XFxuICB0byB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgfVxcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3JjL3N0eWxlcy9Ib21lLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxhQUFhO0VBQ2Isc0JBQXNCO0VBQ3RCLHVCQUF1QjtFQUN2QixtQkFBbUI7RUFDbkIsYUFBYTtBQUNmOztBQUVBO0VBQ0UsZ0JBQWdCO0VBQ2hCLHdCQUF3QjtFQUN4QixvQkFBb0I7RUFDcEIsa0JBQWtCO0VBQ2xCLDJCQUEyQjtFQUMzQixXQUFXO0VBQ1gsVUFBVTtFQUNWLGdCQUFnQjtBQUNsQjs7QUFFQTtFQUNFLGFBQWE7RUFDYix1QkFBdUI7RUFDdkIsbUJBQW1CO0VBQ25CLFdBQVc7RUFDWCwwQkFBMEI7QUFDNUI7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsYUFBYTtFQUNiLHVCQUF1QjtFQUN2QixtQkFBbUI7QUFDckI7O0FBRUE7RUFDRSxhQUFhO0VBQ2IsdUJBQXVCO0VBQ3ZCLG1CQUFtQjtFQUNuQixzQkFBc0I7QUFDeEI7O0FBRUEsV0FBVztBQUNYO0VBQ0U7SUFDRSxhQUFhO0VBQ2Y7O0VBRUE7SUFDRSwwQkFBMEI7SUFDMUIsb0JBQW9CO0lBQ3BCLGdCQUFnQjtJQUNoQixrQkFBa0I7RUFDcEI7O0VBRUE7SUFDRSxvQkFBb0I7RUFDdEI7O0VBRUE7SUFDRSxxQkFBcUI7RUFDdkI7O0VBRUE7SUFDRSxvQkFBb0I7RUFDdEI7O0VBRUE7SUFDRSxlQUFlO0lBQ2YsYUFBYTtFQUNmOztFQUVBO0lBQ0UsaUJBQWlCO0VBQ25COztFQUVBO0lBQ0UsYUFBYTtFQUNmOztFQUVBOztJQUVFLGFBQWE7SUFDYix1QkFBdUI7SUFDdkIsZUFBZTtJQUNmLFdBQVc7RUFDYjs7RUFFQTtJQUNFLG1CQUFtQjtJQUNuQixlQUFlO0lBQ2YseUJBQXlCO0lBQ3pCLGdCQUFnQjtJQUNoQixZQUFZO0lBQ1osOERBQThEO0lBQzlEOzs7O0tBSUM7SUFDRCw0QkFBNEI7SUFDNUIsbUNBQTJCO1lBQTNCLDJCQUEyQjtFQUM3Qjs7RUFFQTtJQUNFLHFCQUFxQjtJQUNyQixvQkFBb0I7SUFDcEIsZUFBZTtJQUNmLGFBQWE7SUFDYixhQUFhO0lBQ2I7Ozs7S0FJQztJQUNELFVBQVU7RUFDWjtBQUNGOztBQUVBLCtCQUErQjtBQUMvQjtFQUNFO0lBQ0UscUNBQXFDO0VBQ3ZDO0FBQ0Y7O0FBRUE7RUFDRTtJQUNFLGlCQUFpQjtFQUNuQjs7RUFFQTs7SUFFRSxtREFBbUQ7RUFDckQ7QUFDRjs7QUFFQTtFQUNFO0lBQ0UseUJBQXlCO0VBQzNCO0VBQ0E7SUFDRSx1QkFBdUI7RUFDekI7QUFDRlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIubWFpbiB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHBhZGRpbmc6IDZyZW07XFxufVxcblxcbi5pdGVtIHtcXG4gIGRpc3BsYXk6IGluaGVyaXQ7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGluaGVyaXQ7XFxuICBhbGlnbi1pdGVtczogaW5oZXJpdDtcXG4gIGZvbnQtc2l6ZTogMC44NXJlbTtcXG4gIG1heC13aWR0aDogdmFyKC0tbWF4LXdpZHRoKTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgei1pbmRleDogMjtcXG4gIG1hcmdpbi10b3A6IDIwcHg7XFxufVxcblxcbi5pdGVtIGEge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGdhcDogMC41cmVtO1xcbiAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxufVxcblxcbi5jZW50ZXIge1xcbiAgcGFkZGluZzogMjBweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5jb250YWluZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxufVxcblxcbi8qIE1vYmlsZSAqL1xcbkBtZWRpYSAobWF4LXdpZHRoOiA3MDBweCkge1xcbiAgLmNvbnRlbnQge1xcbiAgICBwYWRkaW5nOiA0cmVtO1xcbiAgfVxcblxcbiAgLmdyaWQge1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmcjtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTIwcHg7XFxuICAgIG1heC13aWR0aDogMzIwcHg7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIH1cXG5cXG4gIC5jYXJkIHtcXG4gICAgcGFkZGluZzogMXJlbSAyLjVyZW07XFxuICB9XFxuXFxuICAuY2FyZCBoMiB7XFxuICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gIH1cXG5cXG4gIC5jZW50ZXIge1xcbiAgICBwYWRkaW5nOiA4cmVtIDAgNnJlbTtcXG4gIH1cXG5cXG4gIC5jZW50ZXI6OmJlZm9yZSB7XFxuICAgIHRyYW5zZm9ybTogbm9uZTtcXG4gICAgaGVpZ2h0OiAzMDBweDtcXG4gIH1cXG5cXG4gIC5kZXNjcmlwdGlvbiB7XFxuICAgIGZvbnQtc2l6ZTogMC44cmVtO1xcbiAgfVxcblxcbiAgLmRlc2NyaXB0aW9uIGEge1xcbiAgICBwYWRkaW5nOiAxcmVtO1xcbiAgfVxcblxcbiAgLmRlc2NyaXB0aW9uIHAsXFxuICAuZGVzY3JpcHRpb24gZGl2IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICB9XFxuXFxuICAuZGVzY3JpcHRpb24gcCB7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGluc2V0OiAwIDAgYXV0bztcXG4gICAgcGFkZGluZzogMnJlbSAxcmVtIDEuNHJlbTtcXG4gICAgYm9yZGVyLXJhZGl1czogMDtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgcmdiYSh2YXIoLS1jYWxsb3V0LWJvcmRlci1yZ2IpLCAwLjI1KTtcXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxcbiAgICAgIHRvIGJvdHRvbSxcXG4gICAgICByZ2JhKHZhcigtLWJhY2tncm91bmQtc3RhcnQtcmdiKSwgMSksXFxuICAgICAgcmdiYSh2YXIoLS1jYWxsb3V0LXJnYiksIDAuNSlcXG4gICAgKTtcXG4gICAgYmFja2dyb3VuZC1jbGlwOiBwYWRkaW5nLWJveDtcXG4gICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDI0cHgpO1xcbiAgfVxcblxcbiAgLmRlc2NyaXB0aW9uIGRpdiB7XFxuICAgIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICAgIGluc2V0OiBhdXRvIDAgMDtcXG4gICAgcGFkZGluZzogMnJlbTtcXG4gICAgaGVpZ2h0OiAyMDBweDtcXG4gICAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxcbiAgICAgIHRvIGJvdHRvbSxcXG4gICAgICB0cmFuc3BhcmVudCAwJSxcXG4gICAgICByZ2IodmFyKC0tYmFja2dyb3VuZC1lbmQtcmdiKSkgNDAlXFxuICAgICk7XFxuICAgIHotaW5kZXg6IDE7XFxuICB9XFxufVxcblxcbi8qIFRhYmxldCBhbmQgU21hbGxlciBEZXNrdG9wICovXFxuQG1lZGlhIChtaW4td2lkdGg6IDcwMXB4KSBhbmQgKG1heC13aWR0aDogMTEyMHB4KSB7XFxuICAuZ3JpZCB7XFxuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDIsIDUwJSk7XFxuICB9XFxufVxcblxcbkBtZWRpYSAocHJlZmVycy1jb2xvci1zY2hlbWU6IGRhcmspIHtcXG4gIC52ZXJjZWxMb2dvIHtcXG4gICAgZmlsdGVyOiBpbnZlcnQoMSk7XFxuICB9XFxuXFxuICAubG9nbyxcXG4gIC50aGlydGVlbiBpbWcge1xcbiAgICBmaWx0ZXI6IGludmVydCgxKSBkcm9wLXNoYWRvdygwIDAgMC4zcmVtICNmZmZmZmY3MCk7XFxuICB9XFxufVxcblxcbkBrZXlmcmFtZXMgcm90YXRlIHtcXG4gIGZyb20ge1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgfVxcbiAgdG8ge1xcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTtcXG4gIH1cXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwibWFpblwiOiBcIkhvbWVfbWFpbl9fMnVJZWtcIixcblx0XCJpdGVtXCI6IFwiSG9tZV9pdGVtX184al96bFwiLFxuXHRcImNlbnRlclwiOiBcIkhvbWVfY2VudGVyX19ZX3JWNFwiLFxuXHRcImNvbnRhaW5lclwiOiBcIkhvbWVfY29udGFpbmVyX185T3VPelwiLFxuXHRcImNvbnRlbnRcIjogXCJIb21lX2NvbnRlbnRfX1FuYmphXCIsXG5cdFwiZ3JpZFwiOiBcIkhvbWVfZ3JpZF9fdm9fRVNcIixcblx0XCJjYXJkXCI6IFwiSG9tZV9jYXJkX19ISWxwX1wiLFxuXHRcImRlc2NyaXB0aW9uXCI6IFwiSG9tZV9kZXNjcmlwdGlvbl9fekhVQjZcIixcblx0XCJ2ZXJjZWxMb2dvXCI6IFwiSG9tZV92ZXJjZWxMb2dvX19mQ3c3U1wiLFxuXHRcImxvZ29cIjogXCJIb21lX2xvZ29fX1pFT25nXCIsXG5cdFwidGhpcnRlZW5cIjogXCJIb21lX3RoaXJ0ZWVuX19ZUk1LWlwiLFxuXHRcInJvdGF0ZVwiOiBcIkhvbWVfcm90YXRlX194NjBGdFwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[2]!./src/styles/Home.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fqiaoxiaorui%2Fgithub%2Funifra%2Fmydoge%2Fmydogemask-next-example%2Fsrc%2Fpages%2Findex.tsx&page=%2F!":
/*!*******************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fqiaoxiaorui%2Fgithub%2Funifra%2Fmydoge%2Fmydogemask-next-example%2Fsrc%2Fpages%2Findex.tsx&page=%2F! ***!
  \*******************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/index.tsx */ \"./src/pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZVc2VycyUyRnFpYW94aWFvcnVpJTJGZ2l0aHViJTJGdW5pZnJhJTJGbXlkb2dlJTJGbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUlMkZzcmMlMkZwYWdlcyUyRmluZGV4LnRzeCZwYWdlPSUyRiEiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxvREFBdUI7QUFDOUM7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwiLi9zcmMvcGFnZXMvaW5kZXgudHN4XCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi9cIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fqiaoxiaorui%2Fgithub%2Funifra%2Fmydoge%2Fmydogemask-next-example%2Fsrc%2Fpages%2Findex.tsx&page=%2F!\n"));

/***/ }),

/***/ "./src/styles/Home.module.css":
/*!************************************!*\
  !*** ./src/styles/Home.module.css ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[2]!./src/styles/Home.module.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[2]!./src/styles/Home.module.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[2]!./Home.module.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[7].oneOf[7].use[2]!./src/styles/Home.module.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzL0hvbWUubW9kdWxlLmNzcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsdU5BQTJHO0FBQzdILDBCQUEwQixtQkFBTyxDQUFDLHlmQUF5UDs7QUFFM1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLHlmQUF5UDtBQUMvUDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHlmQUF5UDs7QUFFblI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9zcmMvc3R5bGVzL0hvbWUubW9kdWxlLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbN10udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls3XS51c2VbMl0hLi9Ib21lLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHN0eWxlLWxvYWRlciBpbmplY3RzIENTUyBpbnRvIHRoZSBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgPGhlYWQ+LiBUaGlzIGNhdXNlcyBvcmRlcmluZyBwcm9ibGVtcyBiZXR3ZWVuIGRldlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvZC4gVG8gZml4IHRoaXMsIHdlIHJlbmRlciBhIDxub3NjcmlwdD4gdGFnIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGFuY2hvciBmb3IgdGhlIHN0eWxlcyB0byBiZSBwbGFjZWQgYmVmb3JlLiBUaGVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIF9iZWZvcmVfIDxzdHlsZSBqc3ggZ2xvYmFsPi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzddLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbN10ub25lT2ZbN10udXNlWzJdIS4vSG9tZS5tb2R1bGUuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s3XS5vbmVPZls3XS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzddLm9uZU9mWzddLnVzZVsyXSEuL0hvbWUubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/styles/Home.module.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/image-component.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/client/image-component.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\"));\nconst _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"./node_modules/next/dist/shared/lib/image-config.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"./node_modules/next/dist/shared/lib/image-loader.js\"));\nconst _usemergedref = __webpack_require__(/*! ./use-merged-ref */ \"./node_modules/next/dist/client/use-merged-ref.js\");\n// This is replaced by webpack define plugin\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]};\nif (false) {}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput) {\n    const src = img == null ? void 0 : img.src;\n    if (!img || img['data-loaded-src'] === src) {\n        return;\n    }\n    img['data-loaded-src'] = src;\n    const p = 'decode' in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== 'empty') {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event('load');\n            Object.defineProperty(event, 'target', {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current({\n                ...event,\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            });\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            const origSrc = new URL(src, 'http://n').searchParams.get('url') || src;\n            if (img.getAttribute('data-nimg') === 'fill') {\n                if (!unoptimized && (!sizesInput || sizesInput === '100vw')) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        if (sizesInput === '100vw') {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" prop and \"sizes\" prop of \"100vw\", but image is not rendered at full viewport width. Please adjust \"sizes\" to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        } else {\n                            (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                        }\n                    }\n                }\n                if (img.parentElement) {\n                    const { position } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        'absolute',\n                        'fixed',\n                        'relative'\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(',') + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute('height');\n            const widthModified = img.width.toString() !== img.getAttribute('width');\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    if (Boolean(_react.use)) {\n        // In React 19.0.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nconst ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{\n    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, sizesInput, onLoad, onError, ...rest } = param;\n    const ownRef = (0, _react.useCallback)((img)=>{\n        if (!img) {\n            return;\n        }\n        if (onError) {\n            // If the image has an error before react hydrates, then the error is lost.\n            // The workaround is to wait until the image is mounted which is after hydration,\n            // then we set the src again to trigger the error handler (if there was an error).\n            // eslint-disable-next-line no-self-assign\n            img.src = img.src;\n        }\n        if (true) {\n            if (!src) {\n                console.error('Image is missing required \"src\" property:', img);\n            }\n            if (img.getAttribute('alt') === null) {\n                console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n            }\n        }\n        if (img.complete) {\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        }\n    }, [\n        src,\n        placeholder,\n        onLoadRef,\n        onLoadingCompleteRef,\n        setBlurComplete,\n        onError,\n        unoptimized,\n        sizesInput\n    ]);\n    const ref = (0, _usemergedref.useMergedRef)(forwardedRef, ownRef);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", {\n        ...rest,\n        ...getDynamicProps(fetchPriority),\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? 'fill' : '1',\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: ref,\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized, sizesInput);\n        },\n        onError: (event)=>{\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== 'empty') {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    });\n});\nfunction ImagePreload(param) {\n    let { isAppRouter, imgAttributes } = param;\n    const opts = {\n        as: 'image',\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy,\n        ...getDynamicProps(imgAttributes.fetchPriority)\n    };\n    if (isAppRouter && _reactdom.default.preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom.default.preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n            ...opts\n        }, '__nimg-' + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nconst Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{\n    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }, [\n        configContext\n    ]);\n    const { onLoad, onLoadingComplete } = props;\n    const onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [showAltText, setShowAltText] = (0, _react.useState)(false);\n    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader.default,\n        imgConf: config,\n        blurComplete,\n        showAltText\n    });\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {\n                ...imgAttributes,\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                sizesInput: props.sizes,\n                ref: forwardedRef\n            }),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbWFnZS1jb21wb25lbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O2VBMFdhQTs7Ozs7Ozt5SEE5VlE7OEVBQ0o7NkJBQ1c7eUNBWU87Z0lBQ0E7MEJBQ1Y7bUlBQ0s7aUxBR0o7OEJBQ0c7QUFFN0IscUhBQTRDO0FBQzVDLE1BQU1DLHNDQUF3Qkc7QUFFOUIsSUFBSSxPQUFPQyxPQUFBQSwwTkFBd0I7SUFDL0JDLEtBQW1CQyxFQUFBQSxFQW9CdkI7QUFDQSxpREFBaUQ7QUFDakQsU0FBU0MsY0FDUEMsR0FBMkIsRUFDM0JDLFdBQTZCLEVBQzdCQyxRQUFBQTtJQU1BLE1BQU1LLE1BQU1QLE9BQUFBLEdBQUFBLEVBQUFBLFdBQUFBLEVBQUFBLEVBQUtPLEdBQUc7SUFDcEIsSUFBSSxDQUFDUCxDQUFBQSxNQUFPQSxHQUFHLENBQUMsa0JBQWtCLEtBQUtPLEdBQUFBO1FBQ3JDO1FBQ0Y7SUFDQVA7SUFDQSxNQUFNUSxJQUFJLFlBQVlSLEdBQUFBLEdBQU1BO0lBQzVCUSxFQUFFSSxJQUFBQSxDQUFLLENBQUMsS0FBTyxHQUFHQyxJQUFJLENBQUM7UUFDckIsSUFBSSxDQUFDYixJQUFJYyxHQUFBQSxJQUFBQSxDQUFBQSxLQUFhO1lBQ3BCLHdDQUF3QztZQUN4Qyx1QkFBdUI7WUFDdkI7WUFDQSxzQkFBc0I7WUFDdEI7WUFDQTtZQUNGO1FBQ0E7WUFDRVYsZ0JBQWdCO1lBQ2xCO1FBQ0E7WUFDRSwrQ0FBK0M7WUFDL0MsMENBQTBDO1lBQzFDO1lBQ0EsTUFBTWEsUUFBUSxJQUFJQyxNQUFNO1lBQ3hCQyxNQUFBQSxDQUFPQyxPQUFBQSxJQUFBQSxHQUFjLENBQUNILEVBQUFBLEtBQU87Z0JBQVlJLEdBQUFBLE9BQVU7Z0JBQU9DLE9BQU90QixHQUFBQTtnQkFBSTtZQUNyRTtZQUNBLElBQUl3QixVQUFVO1lBQ2R0QixJQUFBQSxNQUFVYyxJQUFBQSxHQUFPLENBQUM7Z0JBQ2hCLEdBQUdDLEdBQUFBLEVBQUs7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LEVBQUFBLFdBQUFBLEdBQUFBLENBQUFBLEdBQUFBLFlBQUFBLEdBQUFBLEVBQUFBLGNBQUFBO2dCQUNiQyxhQUFBQSxFQUFlQTtpQkFFZjs7O0lBR1YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL3NyYy9jbGllbnQvaW1hZ2UtY29tcG9uZW50LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7XG4gIHVzZVJlZixcbiAgdXNlRWZmZWN0LFxuICB1c2VDYWxsYmFjayxcbiAgdXNlQ29udGV4dCxcbiAgdXNlTWVtbyxcbiAgdXNlU3RhdGUsXG4gIGZvcndhcmRSZWYsXG4gIHVzZSxcbn0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJ1xuaW1wb3J0IEhlYWQgZnJvbSAnLi4vc2hhcmVkL2xpYi9oZWFkJ1xuaW1wb3J0IHsgZ2V0SW1nUHJvcHMgfSBmcm9tICcuLi9zaGFyZWQvbGliL2dldC1pbWctcHJvcHMnXG5pbXBvcnQgdHlwZSB7XG4gIEltYWdlUHJvcHMsXG4gIEltZ1Byb3BzLFxuICBPbkxvYWQsXG4gIE9uTG9hZGluZ0NvbXBsZXRlLFxuICBQbGFjZWhvbGRlclZhbHVlLFxufSBmcm9tICcuLi9zaGFyZWQvbGliL2dldC1pbWctcHJvcHMnXG5pbXBvcnQgdHlwZSB7XG4gIEltYWdlQ29uZmlnQ29tcGxldGUsXG4gIEltYWdlTG9hZGVyUHJvcHMsXG59IGZyb20gJy4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHsgaW1hZ2VDb25maWdEZWZhdWx0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyBJbWFnZUNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZSdcbmltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuXG4vLyBAdHMtaWdub3JlIC0gVGhpcyBpcyByZXBsYWNlZCBieSB3ZWJwYWNrIGFsaWFzXG5pbXBvcnQgZGVmYXVsdExvYWRlciBmcm9tICduZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXInXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWYgfSBmcm9tICcuL3VzZS1tZXJnZWQtcmVmJ1xuXG4vLyBUaGlzIGlzIHJlcGxhY2VkIGJ5IHdlYnBhY2sgZGVmaW5lIHBsdWdpblxuY29uc3QgY29uZmlnRW52ID0gcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFMgYXMgYW55IGFzIEltYWdlQ29uZmlnQ29tcGxldGVcblxuaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gIDsoZ2xvYmFsVGhpcyBhcyBhbnkpLl9fTkVYVF9JTUFHRV9JTVBPUlRFRCA9IHRydWVcbn1cblxuZXhwb3J0IHR5cGUgeyBJbWFnZUxvYWRlclByb3BzIH1cbmV4cG9ydCB0eXBlIEltYWdlTG9hZGVyID0gKHA6IEltYWdlTG9hZGVyUHJvcHMpID0+IHN0cmluZ1xuXG50eXBlIEltZ0VsZW1lbnRXaXRoRGF0YVByb3AgPSBIVE1MSW1hZ2VFbGVtZW50ICYge1xuICAnZGF0YS1sb2FkZWQtc3JjJzogc3RyaW5nIHwgdW5kZWZpbmVkXG59XG5cbnR5cGUgSW1hZ2VFbGVtZW50UHJvcHMgPSBJbWdQcm9wcyAmIHtcbiAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW5cbiAgcGxhY2Vob2xkZXI6IFBsYWNlaG9sZGVyVmFsdWVcbiAgb25Mb2FkUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE9uTG9hZCB8IHVuZGVmaW5lZD5cbiAgb25Mb2FkaW5nQ29tcGxldGVSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8T25Mb2FkaW5nQ29tcGxldGUgfCB1bmRlZmluZWQ+XG4gIHNldEJsdXJDb21wbGV0ZTogKGI6IGJvb2xlYW4pID0+IHZvaWRcbiAgc2V0U2hvd0FsdFRleHQ6IChiOiBib29sZWFuKSA9PiB2b2lkXG4gIHNpemVzSW5wdXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxufVxuXG4vLyBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzM5Nzc3ODMzLzI2NjUzNSBmb3Igd2h5IHdlIHVzZSB0aGlzIHJlZlxuLy8gaGFuZGxlciBpbnN0ZWFkIG9mIHRoZSBpbWcncyBvbkxvYWQgYXR0cmlidXRlLlxuZnVuY3Rpb24gaGFuZGxlTG9hZGluZyhcbiAgaW1nOiBJbWdFbGVtZW50V2l0aERhdGFQcm9wLFxuICBwbGFjZWhvbGRlcjogUGxhY2Vob2xkZXJWYWx1ZSxcbiAgb25Mb2FkUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE9uTG9hZCB8IHVuZGVmaW5lZD4sXG4gIG9uTG9hZGluZ0NvbXBsZXRlUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PE9uTG9hZGluZ0NvbXBsZXRlIHwgdW5kZWZpbmVkPixcbiAgc2V0Qmx1ckNvbXBsZXRlOiAoYjogYm9vbGVhbikgPT4gdm9pZCxcbiAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW4sXG4gIHNpemVzSW5wdXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuKSB7XG4gIGNvbnN0IHNyYyA9IGltZz8uc3JjXG4gIGlmICghaW1nIHx8IGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPT09IHNyYykge1xuICAgIHJldHVyblxuICB9XG4gIGltZ1snZGF0YS1sb2FkZWQtc3JjJ10gPSBzcmNcbiAgY29uc3QgcCA9ICdkZWNvZGUnIGluIGltZyA/IGltZy5kZWNvZGUoKSA6IFByb21pc2UucmVzb2x2ZSgpXG4gIHAuY2F0Y2goKCkgPT4ge30pLnRoZW4oKCkgPT4ge1xuICAgIGlmICghaW1nLnBhcmVudEVsZW1lbnQgfHwgIWltZy5pc0Nvbm5lY3RlZCkge1xuICAgICAgLy8gRXhpdCBlYXJseSBpbiBjYXNlIG9mIHJhY2UgY29uZGl0aW9uOlxuICAgICAgLy8gLSBvbmxvYWQoKSBpcyBjYWxsZWRcbiAgICAgIC8vIC0gZGVjb2RlKCkgaXMgY2FsbGVkIGJ1dCBpbmNvbXBsZXRlXG4gICAgICAvLyAtIHVubW91bnQgaXMgY2FsbGVkXG4gICAgICAvLyAtIGRlY29kZSgpIGNvbXBsZXRlc1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChwbGFjZWhvbGRlciAhPT0gJ2VtcHR5Jykge1xuICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpXG4gICAgfVxuICAgIGlmIChvbkxvYWRSZWY/LmN1cnJlbnQpIHtcbiAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGhhdmUgdGhlIFN5bnRoZXRpY0V2ZW50IGhlcmUsXG4gICAgICAvLyB3ZSBtdXN0IGNyZWF0ZSBvbmUgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAgICAgIC8vIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXZlbnRzLmh0bWxcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdsb2FkJylcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgJ3RhcmdldCcsIHsgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZTogaW1nIH0pXG4gICAgICBsZXQgcHJldmVudGVkID0gZmFsc2VcbiAgICAgIGxldCBzdG9wcGVkID0gZmFsc2VcbiAgICAgIG9uTG9hZFJlZi5jdXJyZW50KHtcbiAgICAgICAgLi4uZXZlbnQsXG4gICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudCxcbiAgICAgICAgY3VycmVudFRhcmdldDogaW1nLFxuICAgICAgICB0YXJnZXQ6IGltZyxcbiAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiAoKSA9PiBwcmV2ZW50ZWQsXG4gICAgICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiAoKSA9PiBzdG9wcGVkLFxuICAgICAgICBwZXJzaXN0OiAoKSA9PiB7fSxcbiAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpID0+IHtcbiAgICAgICAgICBwcmV2ZW50ZWQgPSB0cnVlXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB9LFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246ICgpID0+IHtcbiAgICAgICAgICBzdG9wcGVkID0gdHJ1ZVxuICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAob25Mb2FkaW5nQ29tcGxldGVSZWY/LmN1cnJlbnQpIHtcbiAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQoaW1nKVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY29uc3Qgb3JpZ1NyYyA9IG5ldyBVUkwoc3JjLCAnaHR0cDovL24nKS5zZWFyY2hQYXJhbXMuZ2V0KCd1cmwnKSB8fCBzcmNcbiAgICAgIGlmIChpbWcuZ2V0QXR0cmlidXRlKCdkYXRhLW5pbWcnKSA9PT0gJ2ZpbGwnKSB7XG4gICAgICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgKCFzaXplc0lucHV0IHx8IHNpemVzSW5wdXQgPT09ICcxMDB2dycpKSB7XG4gICAgICAgICAgbGV0IHdpZHRoVmlld3BvcnRSYXRpbyA9XG4gICAgICAgICAgICBpbWcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLyB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgICAgIGlmICh3aWR0aFZpZXdwb3J0UmF0aW8gPCAwLjYpIHtcbiAgICAgICAgICAgIGlmIChzaXplc0lucHV0ID09PSAnMTAwdncnKSB7XG4gICAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgXCJmaWxsXCIgcHJvcCBhbmQgXCJzaXplc1wiIHByb3Agb2YgXCIxMDB2d1wiLCBidXQgaW1hZ2UgaXMgbm90IHJlbmRlcmVkIGF0IGZ1bGwgdmlld3BvcnQgd2lkdGguIFBsZWFzZSBhZGp1c3QgXCJzaXplc1wiIHRvIGltcHJvdmUgcGFnZSBwZXJmb3JtYW5jZS4gUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2Ujc2l6ZXNgXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgXCJmaWxsXCIgYnV0IGlzIG1pc3NpbmcgXCJzaXplc1wiIHByb3AuIFBsZWFzZSBhZGQgaXQgdG8gaW1wcm92ZSBwYWdlIHBlcmZvcm1hbmNlLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNzaXplc2BcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1nLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpbWcucGFyZW50RWxlbWVudClcbiAgICAgICAgICBjb25zdCB2YWxpZCA9IFsnYWJzb2x1dGUnLCAnZml4ZWQnLCAncmVsYXRpdmUnXVxuICAgICAgICAgIGlmICghdmFsaWQuaW5jbHVkZXMocG9zaXRpb24pKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtvcmlnU3JjfVwiIGhhcyBcImZpbGxcIiBhbmQgcGFyZW50IGVsZW1lbnQgd2l0aCBpbnZhbGlkIFwicG9zaXRpb25cIi4gUHJvdmlkZWQgXCIke3Bvc2l0aW9ufVwiIHNob3VsZCBiZSBvbmUgb2YgJHt2YWxpZFxuICAgICAgICAgICAgICAgIC5tYXAoU3RyaW5nKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsJyl9LmBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltZy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7b3JpZ1NyY31cIiBoYXMgXCJmaWxsXCIgYW5kIGEgaGVpZ2h0IHZhbHVlIG9mIDAuIFRoaXMgaXMgbGlrZWx5IGJlY2F1c2UgdGhlIHBhcmVudCBlbGVtZW50IG9mIHRoZSBpbWFnZSBoYXMgbm90IGJlZW4gc3R5bGVkIHRvIGhhdmUgYSBzZXQgaGVpZ2h0LmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaGVpZ2h0TW9kaWZpZWQgPVxuICAgICAgICBpbWcuaGVpZ2h0LnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpXG4gICAgICBjb25zdCB3aWR0aE1vZGlmaWVkID0gaW1nLndpZHRoLnRvU3RyaW5nKCkgIT09IGltZy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJylcbiAgICAgIGlmIChcbiAgICAgICAgKGhlaWdodE1vZGlmaWVkICYmICF3aWR0aE1vZGlmaWVkKSB8fFxuICAgICAgICAoIWhlaWdodE1vZGlmaWVkICYmIHdpZHRoTW9kaWZpZWQpXG4gICAgICApIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtvcmlnU3JjfVwiIGhhcyBlaXRoZXIgd2lkdGggb3IgaGVpZ2h0IG1vZGlmaWVkLCBidXQgbm90IHRoZSBvdGhlci4gSWYgeW91IHVzZSBDU1MgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHlvdXIgaW1hZ2UsIGFsc28gaW5jbHVkZSB0aGUgc3R5bGVzICd3aWR0aDogXCJhdXRvXCInIG9yICdoZWlnaHQ6IFwiYXV0b1wiJyB0byBtYWludGFpbiB0aGUgYXNwZWN0IHJhdGlvLmBcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0RHluYW1pY1Byb3BzKFxuICBmZXRjaFByaW9yaXR5Pzogc3RyaW5nXG4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgaWYgKEJvb2xlYW4odXNlKSkge1xuICAgIC8vIEluIFJlYWN0IDE5LjAuMCBvciBuZXdlciwgd2UgbXVzdCB1c2UgY2FtZWxDYXNlXG4gICAgLy8gcHJvcCB0byBhdm9pZCBcIldhcm5pbmc6IEludmFsaWQgRE9NIHByb3BlcnR5XCIuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI1OTI3XG4gICAgcmV0dXJuIHsgZmV0Y2hQcmlvcml0eSB9XG4gIH1cbiAgLy8gSW4gUmVhY3QgMTguMi4wIG9yIG9sZGVyLCB3ZSBtdXN0IHVzZSBsb3dlcmNhc2UgcHJvcFxuICAvLyB0byBhdm9pZCBcIldhcm5pbmc6IEludmFsaWQgRE9NIHByb3BlcnR5XCIuXG4gIHJldHVybiB7IGZldGNocHJpb3JpdHk6IGZldGNoUHJpb3JpdHkgfVxufVxuXG5jb25zdCBJbWFnZUVsZW1lbnQgPSBmb3J3YXJkUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsLCBJbWFnZUVsZW1lbnRQcm9wcz4oXG4gIChcbiAgICB7XG4gICAgICBzcmMsXG4gICAgICBzcmNTZXQsXG4gICAgICBzaXplcyxcbiAgICAgIGhlaWdodCxcbiAgICAgIHdpZHRoLFxuICAgICAgZGVjb2RpbmcsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICBzdHlsZSxcbiAgICAgIGZldGNoUHJpb3JpdHksXG4gICAgICBwbGFjZWhvbGRlcixcbiAgICAgIGxvYWRpbmcsXG4gICAgICB1bm9wdGltaXplZCxcbiAgICAgIGZpbGwsXG4gICAgICBvbkxvYWRSZWYsXG4gICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgIHNldFNob3dBbHRUZXh0LFxuICAgICAgc2l6ZXNJbnB1dCxcbiAgICAgIG9uTG9hZCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICAuLi5yZXN0XG4gICAgfSxcbiAgICBmb3J3YXJkZWRSZWZcbiAgKSA9PiB7XG4gICAgY29uc3Qgb3duUmVmID0gdXNlQ2FsbGJhY2soXG4gICAgICAoaW1nOiBJbWdFbGVtZW50V2l0aERhdGFQcm9wIHwgbnVsbCkgPT4ge1xuICAgICAgICBpZiAoIWltZykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGltYWdlIGhhcyBhbiBlcnJvciBiZWZvcmUgcmVhY3QgaHlkcmF0ZXMsIHRoZW4gdGhlIGVycm9yIGlzIGxvc3QuXG4gICAgICAgICAgLy8gVGhlIHdvcmthcm91bmQgaXMgdG8gd2FpdCB1bnRpbCB0aGUgaW1hZ2UgaXMgbW91bnRlZCB3aGljaCBpcyBhZnRlciBoeWRyYXRpb24sXG4gICAgICAgICAgLy8gdGhlbiB3ZSBzZXQgdGhlIHNyYyBhZ2FpbiB0byB0cmlnZ2VyIHRoZSBlcnJvciBoYW5kbGVyIChpZiB0aGVyZSB3YXMgYW4gZXJyb3IpLlxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgICAgICAgIGltZy5zcmMgPSBpbWcuc3JjXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcInNyY1wiIHByb3BlcnR5OmAsIGltZylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGltZy5nZXRBdHRyaWJ1dGUoJ2FsdCcpID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBgSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcImFsdFwiIHByb3BlcnR5LiBQbGVhc2UgYWRkIEFsdGVybmF0aXZlIFRleHQgdG8gZGVzY3JpYmUgdGhlIGltYWdlIGZvciBzY3JlZW4gcmVhZGVycyBhbmQgc2VhcmNoIGVuZ2luZXMuYFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1nLmNvbXBsZXRlKSB7XG4gICAgICAgICAgaGFuZGxlTG9hZGluZyhcbiAgICAgICAgICAgIGltZyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgb25Mb2FkUmVmLFxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgICAgIHNpemVzSW5wdXRcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbXG4gICAgICAgIHNyYyxcbiAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIG9uTG9hZFJlZixcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgIHNpemVzSW5wdXQsXG4gICAgICBdXG4gICAgKVxuXG4gICAgY29uc3QgcmVmID0gdXNlTWVyZ2VkUmVmKGZvcndhcmRlZFJlZiwgb3duUmVmKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxpbWdcbiAgICAgICAgey4uLnJlc3R9XG4gICAgICAgIHsuLi5nZXREeW5hbWljUHJvcHMoZmV0Y2hQcmlvcml0eSl9XG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgbG9hZGluZ2AgYmVmb3JlIGBzcmNgIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgICAgICAvLyBwcm9wcyBpbiBvcmRlciB3aGljaCBjYXVzZXMgU2FmYXJpL0ZpcmVmb3ggdG8gbm90IGxhenkgbG9hZCBwcm9wZXJseS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjU4ODNcbiAgICAgICAgbG9hZGluZz17bG9hZGluZ31cbiAgICAgICAgd2lkdGg9e3dpZHRofVxuICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgZGVjb2Rpbmc9e2RlY29kaW5nfVxuICAgICAgICBkYXRhLW5pbWc9e2ZpbGwgPyAnZmlsbCcgOiAnMSd9XG4gICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgc3JjYCB0aGUgbGFzdCBhdHRyaWJ1dGUgYmVjYXVzZSBSZWFjdCB1cGRhdGVzXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMgaW4gb3JkZXIuIElmIHdlIGtlZXAgYHNyY2AgdGhlIGZpcnN0IG9uZSwgU2FmYXJpIHdpbGxcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgc3RhcnQgdG8gZmV0Y2ggYHNyY2AsIGJlZm9yZSBgc2l6ZXNgIGFuZCBgc3JjU2V0YCBhcmUgZXZlblxuICAgICAgICAvLyB1cGRhdGVkIGJ5IFJlYWN0LiBUaGF0IGNhdXNlcyBtdWx0aXBsZSB1bm5lY2Vzc2FyeSByZXF1ZXN0cyBpZiBgc3JjU2V0YFxuICAgICAgICAvLyBhbmQgYHNpemVzYCBhcmUgZGVmaW5lZC5cbiAgICAgICAgLy8gVGhpcyBidWcgY2Fubm90IGJlIHJlcHJvZHVjZWQgaW4gQ2hyb21lIG9yIEZpcmVmb3guXG4gICAgICAgIHNpemVzPXtzaXplc31cbiAgICAgICAgc3JjU2V0PXtzcmNTZXR9XG4gICAgICAgIHNyYz17c3JjfVxuICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgb25Mb2FkPXsoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBpbWcgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEltZ0VsZW1lbnRXaXRoRGF0YVByb3BcbiAgICAgICAgICBoYW5kbGVMb2FkaW5nKFxuICAgICAgICAgICAgaW1nLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgICAgICBvbkxvYWRSZWYsXG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSxcbiAgICAgICAgICAgIHVub3B0aW1pemVkLFxuICAgICAgICAgICAgc2l6ZXNJbnB1dFxuICAgICAgICAgIClcbiAgICAgICAgfX1cbiAgICAgICAgb25FcnJvcj17KGV2ZW50KSA9PiB7XG4gICAgICAgICAgLy8gaWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIGVuc3VyZSBcImFsdFwiIGlzIHZpc2libGVcbiAgICAgICAgICBzZXRTaG93QWx0VGV4dCh0cnVlKVxuICAgICAgICAgIGlmIChwbGFjZWhvbGRlciAhPT0gJ2VtcHR5Jykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIHN0aWxsIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUodHJ1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9fVxuICAgICAgLz5cbiAgICApXG4gIH1cbilcblxuZnVuY3Rpb24gSW1hZ2VQcmVsb2FkKHtcbiAgaXNBcHBSb3V0ZXIsXG4gIGltZ0F0dHJpYnV0ZXMsXG59OiB7XG4gIGlzQXBwUm91dGVyOiBib29sZWFuXG4gIGltZ0F0dHJpYnV0ZXM6IEltZ1Byb3BzXG59KSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgYXM6ICdpbWFnZScsXG4gICAgaW1hZ2VTcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgIGltYWdlU2l6ZXM6IGltZ0F0dHJpYnV0ZXMuc2l6ZXMsXG4gICAgY3Jvc3NPcmlnaW46IGltZ0F0dHJpYnV0ZXMuY3Jvc3NPcmlnaW4sXG4gICAgcmVmZXJyZXJQb2xpY3k6IGltZ0F0dHJpYnV0ZXMucmVmZXJyZXJQb2xpY3ksXG4gICAgLi4uZ2V0RHluYW1pY1Byb3BzKGltZ0F0dHJpYnV0ZXMuZmV0Y2hQcmlvcml0eSksXG4gIH1cblxuICBpZiAoaXNBcHBSb3V0ZXIgJiYgUmVhY3RET00ucHJlbG9hZCkge1xuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yNjk0MFxuICAgIFJlYWN0RE9NLnByZWxvYWQoXG4gICAgICBpbWdBdHRyaWJ1dGVzLnNyYyxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogdXBncmFkZSB0byBgQHR5cGVzL3JlYWN0LWRvbUAxOC4zLnhgXG4gICAgICBvcHRzXG4gICAgKVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxIZWFkPlxuICAgICAgPGxpbmtcbiAgICAgICAga2V5PXtcbiAgICAgICAgICAnX19uaW1nLScgK1xuICAgICAgICAgIGltZ0F0dHJpYnV0ZXMuc3JjICtcbiAgICAgICAgICBpbWdBdHRyaWJ1dGVzLnNyY1NldCArXG4gICAgICAgICAgaW1nQXR0cmlidXRlcy5zaXplc1xuICAgICAgICB9XG4gICAgICAgIHJlbD1cInByZWxvYWRcIlxuICAgICAgICAvLyBOb3RlIGhvdyB3ZSBvbWl0IHRoZSBgaHJlZmAgYXR0cmlidXRlLCBhcyBpdCB3b3VsZCBvbmx5IGJlIHJlbGV2YW50XG4gICAgICAgIC8vIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGBpbWFnZXNyY3NldGAsIGFuZCBpbiB0aG9zZSBjYXNlc1xuICAgICAgICAvLyBpdCB3b3VsZCBjYXVzZSB0aGUgaW5jb3JyZWN0IGltYWdlIHRvIGJlIHByZWxvYWRlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjYXR0ci1saW5rLWltYWdlc3Jjc2V0XG4gICAgICAgIGhyZWY9e2ltZ0F0dHJpYnV0ZXMuc3JjU2V0ID8gdW5kZWZpbmVkIDogaW1nQXR0cmlidXRlcy5zcmN9XG4gICAgICAgIHsuLi5vcHRzfVxuICAgICAgLz5cbiAgICA8L0hlYWQ+XG4gIClcbn1cblxuLyoqXG4gKiBUaGUgYEltYWdlYCBjb21wb25lbnQgaXMgdXNlZCB0byBvcHRpbWl6ZSBpbWFnZXMuXG4gKlxuICogUmVhZCBtb3JlOiBbTmV4dC5qcyBkb2NzOiBgSW1hZ2VgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2ltYWdlKVxuICovXG5leHBvcnQgY29uc3QgSW1hZ2UgPSBmb3J3YXJkUmVmPEhUTUxJbWFnZUVsZW1lbnQgfCBudWxsLCBJbWFnZVByb3BzPihcbiAgKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgICBjb25zdCBwYWdlc1JvdXRlciA9IHVzZUNvbnRleHQoUm91dGVyQ29udGV4dClcbiAgICAvLyBXZSdyZSBpbiB0aGUgYXBwIGRpcmVjdG9yeSBpZiB0aGVyZSBpcyBubyBwYWdlcyByb3V0ZXIuXG4gICAgY29uc3QgaXNBcHBSb3V0ZXIgPSAhcGFnZXNSb3V0ZXJcblxuICAgIGNvbnN0IGNvbmZpZ0NvbnRleHQgPSB1c2VDb250ZXh0KEltYWdlQ29uZmlnQ29udGV4dClcbiAgICBjb25zdCBjb25maWcgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgIGNvbnN0IGMgPSBjb25maWdFbnYgfHwgY29uZmlnQ29udGV4dCB8fCBpbWFnZUNvbmZpZ0RlZmF1bHRcbiAgICAgIGNvbnN0IGFsbFNpemVzID0gWy4uLmMuZGV2aWNlU2l6ZXMsIC4uLmMuaW1hZ2VTaXplc10uc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgICBjb25zdCBkZXZpY2VTaXplcyA9IGMuZGV2aWNlU2l6ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgICByZXR1cm4geyAuLi5jLCBhbGxTaXplcywgZGV2aWNlU2l6ZXMgfVxuICAgIH0sIFtjb25maWdDb250ZXh0XSlcblxuICAgIGNvbnN0IHsgb25Mb2FkLCBvbkxvYWRpbmdDb21wbGV0ZSB9ID0gcHJvcHNcbiAgICBjb25zdCBvbkxvYWRSZWYgPSB1c2VSZWYob25Mb2FkKVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIG9uTG9hZFJlZi5jdXJyZW50ID0gb25Mb2FkXG4gICAgfSwgW29uTG9hZF0pXG5cbiAgICBjb25zdCBvbkxvYWRpbmdDb21wbGV0ZVJlZiA9IHVzZVJlZihvbkxvYWRpbmdDb21wbGV0ZSlcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50ID0gb25Mb2FkaW5nQ29tcGxldGVcbiAgICB9LCBbb25Mb2FkaW5nQ29tcGxldGVdKVxuXG4gICAgY29uc3QgW2JsdXJDb21wbGV0ZSwgc2V0Qmx1ckNvbXBsZXRlXSA9IHVzZVN0YXRlKGZhbHNlKVxuICAgIGNvbnN0IFtzaG93QWx0VGV4dCwgc2V0U2hvd0FsdFRleHRdID0gdXNlU3RhdGUoZmFsc2UpXG5cbiAgICBjb25zdCB7IHByb3BzOiBpbWdBdHRyaWJ1dGVzLCBtZXRhOiBpbWdNZXRhIH0gPSBnZXRJbWdQcm9wcyhwcm9wcywge1xuICAgICAgZGVmYXVsdExvYWRlcixcbiAgICAgIGltZ0NvbmY6IGNvbmZpZyxcbiAgICAgIGJsdXJDb21wbGV0ZSxcbiAgICAgIHNob3dBbHRUZXh0LFxuICAgIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgPD5cbiAgICAgICAge1xuICAgICAgICAgIDxJbWFnZUVsZW1lbnRcbiAgICAgICAgICAgIHsuLi5pbWdBdHRyaWJ1dGVzfVxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQ9e2ltZ01ldGEudW5vcHRpbWl6ZWR9XG4gICAgICAgICAgICBwbGFjZWhvbGRlcj17aW1nTWV0YS5wbGFjZWhvbGRlcn1cbiAgICAgICAgICAgIGZpbGw9e2ltZ01ldGEuZmlsbH1cbiAgICAgICAgICAgIG9uTG9hZFJlZj17b25Mb2FkUmVmfVxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWY9e29uTG9hZGluZ0NvbXBsZXRlUmVmfVxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlPXtzZXRCbHVyQ29tcGxldGV9XG4gICAgICAgICAgICBzZXRTaG93QWx0VGV4dD17c2V0U2hvd0FsdFRleHR9XG4gICAgICAgICAgICBzaXplc0lucHV0PXtwcm9wcy5zaXplc31cbiAgICAgICAgICAgIHJlZj17Zm9yd2FyZGVkUmVmfVxuICAgICAgICAgIC8+XG4gICAgICAgIH1cbiAgICAgICAge2ltZ01ldGEucHJpb3JpdHkgPyAoXG4gICAgICAgICAgPEltYWdlUHJlbG9hZFxuICAgICAgICAgICAgaXNBcHBSb3V0ZXI9e2lzQXBwUm91dGVyfVxuICAgICAgICAgICAgaW1nQXR0cmlidXRlcz17aW1nQXR0cmlidXRlc31cbiAgICAgICAgICAvPlxuICAgICAgICApIDogbnVsbH1cbiAgICAgIDwvPlxuICAgIClcbiAgfVxuKVxuIl0sIm5hbWVzIjpbIkltYWdlIiwiY29uZmlnRW52IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwid2luZG93IiwiZ2xvYmFsVGhpcyIsIl9fTkVYVF9JTUFHRV9JTVBPUlRFRCIsImhhbmRsZUxvYWRpbmciLCJpbWciLCJwbGFjZWhvbGRlciIsIm9uTG9hZFJlZiIsIm9uTG9hZGluZ0NvbXBsZXRlUmVmIiwic2V0Qmx1ckNvbXBsZXRlIiwidW5vcHRpbWl6ZWQiLCJzaXplc0lucHV0Iiwic3JjIiwicCIsImRlY29kZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2F0Y2giLCJ0aGVuIiwicGFyZW50RWxlbWVudCIsImlzQ29ubmVjdGVkIiwiY3VycmVudCIsImV2ZW50IiwiRXZlbnQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIndyaXRhYmxlIiwidmFsdWUiLCJwcmV2ZW50ZWQiLCJzdG9wcGVkIiwibmF0aXZlRXZlbnQiLCJjdXJyZW50VGFyZ2V0IiwidGFyZ2V0IiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJwZXJzaXN0IiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJOT0RFX0VOViIsIm9yaWdTcmMiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJnZXQiLCJnZXRBdHRyaWJ1dGUiLCJ3aWR0aFZpZXdwb3J0UmF0aW8iLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImlubmVyV2lkdGgiLCJ3YXJuT25jZSIsInBvc2l0aW9uIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInZhbGlkIiwiaW5jbHVkZXMiLCJtYXAiLCJTdHJpbmciLCJqb2luIiwiaGVpZ2h0IiwiaGVpZ2h0TW9kaWZpZWQiLCJ0b1N0cmluZyIsIndpZHRoTW9kaWZpZWQiLCJnZXREeW5hbWljUHJvcHMiLCJmZXRjaFByaW9yaXR5IiwiQm9vbGVhbiIsInVzZSIsImZldGNocHJpb3JpdHkiLCJJbWFnZUVsZW1lbnQiLCJmb3J3YXJkUmVmIiwiZm9yd2FyZGVkUmVmIiwic3JjU2V0Iiwic2l6ZXMiLCJkZWNvZGluZyIsImNsYXNzTmFtZSIsInN0eWxlIiwibG9hZGluZyIsImZpbGwiLCJzZXRTaG93QWx0VGV4dCIsIm9uTG9hZCIsIm9uRXJyb3IiLCJyZXN0Iiwib3duUmVmIiwidXNlQ2FsbGJhY2siLCJjb25zb2xlIiwiZXJyb3IiLCJjb21wbGV0ZSIsInJlZiIsInVzZU1lcmdlZFJlZiIsImRhdGEtbmltZyIsIkltYWdlUHJlbG9hZCIsImlzQXBwUm91dGVyIiwiaW1nQXR0cmlidXRlcyIsIm9wdHMiLCJhcyIsImltYWdlU3JjU2V0IiwiaW1hZ2VTaXplcyIsImNyb3NzT3JpZ2luIiwicmVmZXJyZXJQb2xpY3kiLCJSZWFjdERPTSIsInByZWxvYWQiLCJIZWFkIiwibGluayIsInJlbCIsImhyZWYiLCJ1bmRlZmluZWQiLCJwcm9wcyIsInBhZ2VzUm91dGVyIiwidXNlQ29udGV4dCIsIlJvdXRlckNvbnRleHQiLCJjb25maWdDb250ZXh0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiY29uZmlnIiwidXNlTWVtbyIsImMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJhbGxTaXplcyIsImRldmljZVNpemVzIiwic29ydCIsImEiLCJiIiwib25Mb2FkaW5nQ29tcGxldGUiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJibHVyQ29tcGxldGUiLCJ1c2VTdGF0ZSIsInNob3dBbHRUZXh0IiwibWV0YSIsImltZ01ldGEiLCJnZXRJbWdQcm9wcyIsImRlZmF1bHRMb2FkZXIiLCJpbWdDb25mIiwicHJpb3JpdHkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/use-merged-ref.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/client/use-merged-ref.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useMergedRef\", ({\n    enumerable: true,\n    get: function() {\n        return useMergedRef;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nfunction useMergedRef(refA, refB) {\n    const cleanupA = (0, _react.useRef)(()=>{});\n    const cleanupB = (0, _react.useRef)(()=>{});\n    return (0, _react.useMemo)(()=>{\n        if (!refA || !refB) {\n            return refA || refB;\n        }\n        return (current)=>{\n            if (current === null) {\n                cleanupA.current();\n                cleanupB.current();\n            } else {\n                cleanupA.current = applyRef(refA, current);\n                cleanupB.current = applyRef(refB, current);\n            }\n        };\n    }, [\n        refA,\n        refB\n    ]);\n}\nfunction applyRef(refA, current) {\n    if (typeof refA === 'function') {\n        const cleanup = refA(current);\n        if (typeof cleanup === 'function') {\n            return cleanup;\n        } else {\n            return ()=>refA(null);\n        }\n    } else {\n        refA.current = current;\n        return ()=>{\n            refA.current = null;\n        };\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-merged-ref.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtbWVyZ2VkLXJlZi5qcyIsIm1hcHBpbmdzIjoiOzs7O2dEQVNnQkE7OztlQUFBQTs7O21DQVQwQjtBQVNuQyxTQUFTQSxhQUNkQyxJQUFtQixFQUNuQkMsSUFBbUI7SUFFbkIsTUFBTUMsV0FBV0MsQ0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsRUFBbUIsS0FBTztJQUMzQyxNQUFNQyxXQUFXRCxDQUFBQSxHQUFBQSxPQUFBQSxNQUFBQSxFQUFtQixLQUFPO0lBRTNDLE9BQU9FLENBQUFBLEdBQUFBLE9BQUFBLE9BQUFBLEVBQVE7UUFDYixJQUFJLENBQUNMLFFBQVEsQ0FBQ0MsTUFBTTtZQUNsQixPQUFPRCxRQUFRQztRQUNqQjtRQUVBLE9BQU8sQ0FBQ0s7WUFDTixJQUFJQSxZQUFZLE1BQU07Z0JBQ3BCSixTQUFTSSxPQUFPO2dCQUNoQkYsU0FBU0UsT0FBTztZQUNsQixPQUFPO2dCQUNMSixTQUFTSSxPQUFPLEdBQUdDLFNBQVNQLE1BQU1NO2dCQUNsQ0YsU0FBU0UsT0FBTyxHQUFHQyxTQUFTTixNQUFNSztZQUNwQztRQUNGO0lBQ0YsR0FBRztRQUFDTjtRQUFNQztLQUFLO0FBQ2pCO0FBRUEsU0FBU00sU0FDUFAsSUFBZ0MsRUFDaENNLE9BQWlCO0lBRWpCLElBQUksT0FBT04sU0FBUyxZQUFZO1FBQzlCLE1BQU1RLFVBQVVSLEtBQUtNO1FBQ3JCLElBQUksT0FBT0UsWUFBWSxZQUFZO1lBQ2pDLE9BQU9BO1FBQ1QsT0FBTztZQUNMLE9BQU8sSUFBTVIsS0FBSztRQUNwQjtJQUNGLE9BQU87UUFDTEEsS0FBS00sT0FBTyxHQUFHQTtRQUNmLE9BQU87WUFDTE4sS0FBS00sT0FBTyxHQUFHO1FBQ2pCO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvc3JjL2NsaWVudC91c2UtbWVyZ2VkLXJlZi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VNZW1vLCB1c2VSZWYsIHR5cGUgUmVmIH0gZnJvbSAncmVhY3QnXG5cbi8vIFRoaXMgaXMgYSBjb21wYXRpYmlsaXR5IGhvb2sgdG8gc3VwcG9ydCBSZWFjdCAxOCBhbmQgMTkgcmVmcy5cbi8vIEluIDE5LCBhIGNsZWFudXAgZnVuY3Rpb24gZnJvbSByZWZzIG1heSBiZSByZXR1cm5lZC5cbi8vIEluIDE4LCByZXR1cm5pbmcgYSBjbGVhbnVwIGZ1bmN0aW9uIGNyZWF0ZXMgYSB3YXJuaW5nLlxuLy8gU2luY2Ugd2UgdGFrZSB1c2Vyc3BhY2UgcmVmcywgd2UgZG9uJ3Qga25vdyBhaGVhZCBvZiB0aW1lIGlmIGEgY2xlYW51cCBmdW5jdGlvbiB3aWxsIGJlIHJldHVybmVkLlxuLy8gVGhpcyBpbXBsZW1lbnRzIGNsZWFudXAgZnVuY3Rpb25zIHdpdGggdGhlIG9sZCBiZWhhdmlvciBpbiAxOC5cbi8vIFdlIGtub3cgcmVmcyBhcmUgYWx3YXlzIGNhbGxlZCBhbHRlcm5hdGluZyB3aXRoIGBudWxsYCBhbmQgdGhlbiBgVGAuXG4vLyBTbyBhIGNhbGwgd2l0aCBgbnVsbGAgbWVhbnMgd2UgbmVlZCB0byBjYWxsIHRoZSBwcmV2aW91cyBjbGVhbnVwIGZ1bmN0aW9ucy5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRSZWY8VEVsZW1lbnQ+KFxuICByZWZBOiBSZWY8VEVsZW1lbnQ+LFxuICByZWZCOiBSZWY8VEVsZW1lbnQ+XG4pOiBSZWY8VEVsZW1lbnQ+IHtcbiAgY29uc3QgY2xlYW51cEEgPSB1c2VSZWY8KCkgPT4gdm9pZD4oKCkgPT4ge30pXG4gIGNvbnN0IGNsZWFudXBCID0gdXNlUmVmPCgpID0+IHZvaWQ+KCgpID0+IHt9KVxuXG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIXJlZkEgfHwgIXJlZkIpIHtcbiAgICAgIHJldHVybiByZWZBIHx8IHJlZkJcbiAgICB9XG5cbiAgICByZXR1cm4gKGN1cnJlbnQ6IFRFbGVtZW50IHwgbnVsbCk6IHZvaWQgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgY2xlYW51cEEuY3VycmVudCgpXG4gICAgICAgIGNsZWFudXBCLmN1cnJlbnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYW51cEEuY3VycmVudCA9IGFwcGx5UmVmKHJlZkEsIGN1cnJlbnQpXG4gICAgICAgIGNsZWFudXBCLmN1cnJlbnQgPSBhcHBseVJlZihyZWZCLCBjdXJyZW50KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3JlZkEsIHJlZkJdKVxufVxuXG5mdW5jdGlvbiBhcHBseVJlZjxURWxlbWVudD4oXG4gIHJlZkE6IE5vbk51bGxhYmxlPFJlZjxURWxlbWVudD4+LFxuICBjdXJyZW50OiBURWxlbWVudFxuKSB7XG4gIGlmICh0eXBlb2YgcmVmQSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGNsZWFudXAgPSByZWZBKGN1cnJlbnQpXG4gICAgaWYgKHR5cGVvZiBjbGVhbnVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY2xlYW51cFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKCkgPT4gcmVmQShudWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZWZBLmN1cnJlbnQgPSBjdXJyZW50XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlZkEuY3VycmVudCA9IG51bGxcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJ1c2VNZXJnZWRSZWYiLCJyZWZBIiwicmVmQiIsImNsZWFudXBBIiwidXNlUmVmIiwiY2xlYW51cEIiLCJ1c2VNZW1vIiwiY3VycmVudCIsImFwcGx5UmVmIiwiY2xlYW51cCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-merged-ref.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/get-img-props.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/get-img-props.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function() {\n        return getImgProps;\n    }\n}));\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"./node_modules/next/dist/shared/lib/image-blur-svg.js\");\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"./node_modules/next/dist/shared/lib/image-config.js\");\nconst VALID_LOADING_VALUES = [\n    'lazy',\n    'eager',\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return !!src && typeof src === 'object' && (isStaticRequire(src) || isStaticImageData(src));\n}\nconst allImgs = new Map();\nlet perfObserver;\nfunction getInt(x) {\n    if (typeof x === 'undefined') {\n        return x;\n    }\n    if (typeof x === 'number') {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === 'string' && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    let { deviceSizes, allSizes } = param;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: 'w'\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: 'w'\n        };\n    }\n    if (typeof width !== 'number') {\n        return {\n            widths: deviceSizes,\n            kind: 'w'\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: 'x'\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config, src, unoptimized, width, quality, sizes, loader } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths, kind } = getWidths(config, width, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === 'w' ? '100vw' : sizes,\n        srcSet: widths.map((w, i)=>loader({\n                config,\n                src,\n                quality,\n                width: w\n            }) + \" \" + (kind === 'w' ? w : i + 1) + kind).join(', '),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, overrideSrc, onLoad, onLoadingComplete, placeholder = 'empty', blurDataURL, fetchPriority, decoding = 'async', layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;\n    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;\n    let config;\n    let c = imgConf || _imageconfig.imageConfigDefault;\n    if ('allSizes' in c) {\n        config = c;\n    } else {\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        config = {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }\n    if (typeof defaultLoader === 'undefined') {\n        throw new Error('images.loaderFile detected but the file is missing default export.\\nRead more: https://nextjs.org/docs/messages/invalid-images-config');\n    }\n    let loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    const isDefaultLoader = '__next_img_default' in loader;\n    if (isDefaultLoader) {\n        if (config.loader === 'custom') {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        const customImageLoader = loader;\n        loader = (obj)=>{\n            const { config: _, ...opts } = obj;\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === 'fill') {\n            fill = true;\n        }\n        const layoutToStyle = {\n            intrinsic: {\n                maxWidth: '100%',\n                height: 'auto'\n            },\n            responsive: {\n                width: '100%',\n                height: 'auto'\n            }\n        };\n        const layoutToSizes = {\n            responsive: '100vw',\n            fill: '100vw'\n        };\n        const layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = {\n                ...style,\n                ...layoutStyle\n            };\n        }\n        const layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    let staticSrc = '';\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    let blurWidth;\n    let blurHeight;\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                const ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                const ratio = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio);\n            }\n        }\n    }\n    src = typeof src === 'string' ? src : staticSrc;\n    let isLazy = !priority && (loading === 'lazy' || typeof loading === 'undefined');\n    if (!src || src.startsWith('data:') || src.startsWith('blob:')) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && src.endsWith('.svg') && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === 'export' && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== 'absolute') {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== '100%') {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== '100%') {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === 'undefined') {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === 'undefined') {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n                // eslint-disable-next-line no-control-regex\n                if (/^[\\x00-\\x20]/.test(src)) {\n                    throw new Error('Image with src \"' + src + '\" cannot start with a space or control character. Use src.trimStart() to remove it or encodeURIComponent(src) to keep it.');\n                }\n                // eslint-disable-next-line no-control-regex\n                if (/[\\x00-\\x20]$/.test(src)) {\n                    throw new Error('Image with src \"' + src + '\" cannot end with a space or control character. Use src.trimEnd() to remove it or encodeURIComponent(src) to keep it.');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(',') + \".\");\n        }\n        if (priority && loading === 'lazy') {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder !== 'empty' && placeholder !== 'blur' && !placeholder.startsWith('data:image/')) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".');\n        }\n        if (placeholder !== 'empty') {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === 'blur' && !blurDataURL) {\n            const VALID_BLUR_EXT = [\n                'jpeg',\n                'png',\n                'webp',\n                'avif'\n            ] // should match next-image-loader\n            ;\n            throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(',') + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n        }\n        if ('ref' in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            const urlStr = loader({\n                config,\n                src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            let url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        for (const [legacyKey, legacyValue] of Object.entries({\n            layout,\n            objectFit,\n            objectPosition,\n            lazyBoundary,\n            lazyRoot\n        })){\n            if (legacyValue) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n            }\n        }\n        if ( true && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver((entryList)=>{\n                for (const entry of entryList.getEntries()){\n                    var _entry_element;\n                    // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                    const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || '';\n                    const lcpImage = allImgs.get(imgSrc);\n                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder === 'empty' && !lcpImage.src.startsWith('data:') && !lcpImage.src.startsWith('blob:')) {\n                        // https://web.dev/lcp/#measure-lcp-in-javascript\n                        (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: 'largest-contentful-paint',\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    const imgStyle = Object.assign(fill ? {\n        position: 'absolute',\n        height: '100%',\n        width: '100%',\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit,\n        objectPosition\n    } : {}, showAltText ? {} : {\n        color: 'transparent'\n    }, style);\n    const backgroundImage = !blurComplete && placeholder !== 'empty' ? placeholder === 'blur' ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt,\n        heightInt,\n        blurWidth,\n        blurHeight,\n        blurDataURL: blurDataURL || '',\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    let placeholderStyle = backgroundImage ? {\n        backgroundSize: imgStyle.objectFit || 'cover',\n        backgroundPosition: imgStyle.objectPosition || '50% 50%',\n        backgroundRepeat: 'no-repeat',\n        backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === 'blur' && (blurDataURL == null ? void 0 : blurDataURL.startsWith('/'))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    const imgAttributes = generateImgAttrs({\n        config,\n        src,\n        unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    });\n    if (true) {\n        if (true) {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const props = {\n        ...rest,\n        loading: isLazy ? 'lazy' : loading,\n        fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding,\n        className,\n        style: {\n            ...imgStyle,\n            ...placeholderStyle\n        },\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: overrideSrc || imgAttributes.src\n    };\n    const meta = {\n        unoptimized,\n        priority,\n        placeholder,\n        fill\n    };\n    return {\n        props,\n        meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvZ2V0LWltZy1wcm9wcy5qcyIsIm1hcHBpbmdzIjoiOzs7OytDQThPZ0JBOzs7ZUFBQUE7OztzQ0E5T1M7MENBQ087eUNBQ0c7QUErRW5DLE1BQU1DLHVCQUF1QjtJQUFDO0lBQVE7SUFBU0M7Q0FBVTtBQWtCekQsU0FBU0MsZ0JBQ1BDLEdBQW9DO0lBRXBDLE9BQVFBLElBQXNCQyxPQUFPLEtBQUtIO0FBQzVDO0FBRUEsU0FBU0ksa0JBQ1BGLEdBQW9DO0lBRXBDLE9BQVFBLElBQXdCQSxHQUFHLEtBQUtGO0FBQzFDO0FBRUEsU0FBU0ssZUFBZUgsR0FBMEI7SUFDaEQsT0FDRSxDQUFDLENBQUNBLE9BQ0YsT0FBT0EsUUFBUSxZQUNkRCxDQUFBQSxnQkFBZ0JDLFFBQ2ZFLGtCQUFrQkYsSUFBQUEsQ0FBbUI7QUFFM0M7QUFFQSxNQUFNSSxVQUFVLElBQUlDO0FBSXBCLElBQUlDO0FBRUosU0FBU0MsT0FBT0MsQ0FBVTtJQUN4QixJQUFJLE9BQU9BLE1BQU0sYUFBYTtRQUM1QixPQUFPQTtJQUNUO0lBQ0EsSUFBSSxPQUFPQSxNQUFNLFVBQVU7UUFDekIsT0FBT0MsT0FBT0MsUUFBUSxDQUFDRixLQUFLQSxJQUFJRztJQUNsQztJQUNBLElBQUksT0FBT0gsTUFBTSxZQUFZLFdBQVdJLElBQUksQ0FBQ0osSUFBSTtRQUMvQyxPQUFPSyxTQUFTTCxHQUFHO0lBQ3JCO0lBQ0EsT0FBT0c7QUFDVDtBQUVBLFNBQVNHLFVBQ1AsS0FBc0MsRUFDdENDLEtBQXlCLEVBQ3pCQyxLQUF5QjtJQUZ6QixNQUFFQyxXQUFXLEVBQUVDLFFBQVEsRUFBZSxHQUF0QztJQUlBLElBQUlGLE9BQU87UUFDVCx5REFBeUQ7UUFDekQsTUFBTUcsa0JBQWtCO1FBQ3hCLE1BQU1DLGVBQWUsRUFBRTtRQUN2QixJQUFLLElBQUlDLE9BQVFBLFFBQVFGLGdCQUFnQkcsSUFBSSxDQUFDTixRQUFTSyxNQUFPO1lBQzVERCxhQUFhRyxJ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Q0FBQyxPQUN4QjtZQUNBLDhFQUE4RTtZQUM5RSxnRkFBZ0Y7WUFDaEYscUZBQXFGO1lBQ3JGK0MsaUJBQWlCRixlQUFlLEdBQUksVUFBT3hGLGNBQVk7UUFDekQ7SUFDRjtJQUVBLE1BQU04RixnQkFBZ0JsSCxpQkFBaUI7UUFDckNDO1FBQ0F0QztRQUNBdUM7UUFDQXhCLE9BQU8yRTtRQUNQbEQsU0FBUytEO1FBQ1R2RjtRQUNBeUI7SUFDRjtJQUVBLElBQUkrRCxJQUFvQixFQUFtQjtRQUN6QyxJQUFJLElBQTZCLEVBQUU7WUFDakMsSUFBSWdEO1lBQ0osSUFBSTtnQkFDRkEsVUFBVSxJQUFJcEMsSUFBSW1DLGNBQWN2SixHQUFHO1lBQ3JDLEVBQUUsT0FBT3lKLEdBQUc7Z0JBQ1ZELFVBQVUsSUFBSXBDLElBQUltQyxjQUFjdkosR0FBRyxFQUFFNEgsT0FBTzhCLFFBQVEsQ0FBQ0MsSUFBSTtZQUMzRDtZQUNBdkosUUFBUXdKLEdBQUcsQ0FBQ0osUUFBUUcsSUFBSSxFQUFFO2dCQUFFM0o7Z0JBQUsrQztnQkFBVVM7WUFBWTtRQUN6RDtJQUNGO0lBRUEsTUFBTXFHLFFBQWtCO1FBQ3RCLEdBQUc1RixJQUFJO1FBQ1BqQixTQUFTbUQsU0FBUyxTQUFTbkQ7UUFDM0JVO1FBQ0EzQyxPQUFPMkU7UUFDUHhDLFFBQVF5QztRQUNSaEM7UUFDQVY7UUFDQUcsT0FBTztZQUFFLEdBQUdzRixRQUFRO1lBQUUsR0FBR1MsZ0JBQWdCO1FBQUM7UUFDMUNuSSxPQUFPdUksY0FBY3ZJLEtBQUs7UUFDMUIwQixRQUFRNkcsY0FBYzdHLE1BQU07UUFDNUIxQyxLQUFLcUQsZUFBZWtHLGNBQWN2SixHQUFHO0lBQ3ZDO0lBQ0EsTUFBTThKLE9BQU87UUFBRXZIO1FBQWFRO1FBQVVTO1FBQWFMO0lBQUs7SUFDeEQsT0FBTztRQUFFMEc7UUFBT0M7SUFBSztBQUN2QiIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi9zcmMvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi91dGlscy93YXJuLW9uY2UnXG5pbXBvcnQgeyBnZXRJbWFnZUJsdXJTdmcgfSBmcm9tICcuL2ltYWdlLWJsdXItc3ZnJ1xuaW1wb3J0IHsgaW1hZ2VDb25maWdEZWZhdWx0IH0gZnJvbSAnLi9pbWFnZS1jb25maWcnXG5pbXBvcnQgdHlwZSB7XG4gIEltYWdlQ29uZmlnQ29tcGxldGUsXG4gIEltYWdlTG9hZGVyUHJvcHMsXG4gIEltYWdlTG9hZGVyUHJvcHNXaXRoQ29uZmlnLFxufSBmcm9tICcuL2ltYWdlLWNvbmZpZydcblxuaW1wb3J0IHR5cGUgeyBKU1ggfSBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGludGVyZmFjZSBTdGF0aWNJbWFnZURhdGEge1xuICBzcmM6IHN0cmluZ1xuICBoZWlnaHQ6IG51bWJlclxuICB3aWR0aDogbnVtYmVyXG4gIGJsdXJEYXRhVVJMPzogc3RyaW5nXG4gIGJsdXJXaWR0aD86IG51bWJlclxuICBibHVySGVpZ2h0PzogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGljUmVxdWlyZSB7XG4gIGRlZmF1bHQ6IFN0YXRpY0ltYWdlRGF0YVxufVxuXG5leHBvcnQgdHlwZSBTdGF0aWNJbXBvcnQgPSBTdGF0aWNSZXF1aXJlIHwgU3RhdGljSW1hZ2VEYXRhXG5cbmV4cG9ydCB0eXBlIEltYWdlUHJvcHMgPSBPbWl0PFxuICBKU1guSW50cmluc2ljRWxlbWVudHNbJ2ltZyddLFxuICAnc3JjJyB8ICdzcmNTZXQnIHwgJ3JlZicgfCAnYWx0JyB8ICd3aWR0aCcgfCAnaGVpZ2h0JyB8ICdsb2FkaW5nJ1xuPiAmIHtcbiAgc3JjOiBzdHJpbmcgfCBTdGF0aWNJbXBvcnRcbiAgYWx0OiBzdHJpbmdcbiAgd2lkdGg/OiBudW1iZXIgfCBgJHtudW1iZXJ9YFxuICBoZWlnaHQ/OiBudW1iZXIgfCBgJHtudW1iZXJ9YFxuICBmaWxsPzogYm9vbGVhblxuICBsb2FkZXI/OiBJbWFnZUxvYWRlclxuICBxdWFsaXR5PzogbnVtYmVyIHwgYCR7bnVtYmVyfWBcbiAgcHJpb3JpdHk/OiBib29sZWFuXG4gIGxvYWRpbmc/OiBMb2FkaW5nVmFsdWVcbiAgcGxhY2Vob2xkZXI/OiBQbGFjZWhvbGRlclZhbHVlXG4gIGJsdXJEYXRhVVJMPzogc3RyaW5nXG4gIHVub3B0aW1pemVkPzogYm9vbGVhblxuICBvdmVycmlkZVNyYz86IHN0cmluZ1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBvbkxvYWRgIGluc3RlYWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBwL2FwaS1yZWZlcmVuY2UvY29tcG9uZW50cy9pbWFnZSNvbmxvYWRcbiAgICovXG4gIG9uTG9hZGluZ0NvbXBsZXRlPzogT25Mb2FkaW5nQ29tcGxldGVcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgZmlsbGAgcHJvcCBpbnN0ZWFkIG9mIGBsYXlvdXQ9XCJmaWxsXCJgIG9yIGNoYW5nZSBpbXBvcnQgdG8gYG5leHQvbGVnYWN5L2ltYWdlYC5cbiAgICogQHNlZSBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvbGVnYWN5L2ltYWdlXG4gICAqL1xuICBsYXlvdXQ/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgc3R5bGVgIHByb3AgaW5zdGVhZC5cbiAgICovXG4gIG9iamVjdEZpdD86IHN0cmluZ1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBzdHlsZWAgcHJvcCBpbnN0ZWFkLlxuICAgKi9cbiAgb2JqZWN0UG9zaXRpb24/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgcHJvcCBkb2VzIG5vdCBkbyBhbnl0aGluZy5cbiAgICovXG4gIGxhenlCb3VuZGFyeT86IHN0cmluZ1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBwcm9wIGRvZXMgbm90IGRvIGFueXRoaW5nLlxuICAgKi9cbiAgbGF6eVJvb3Q/OiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgSW1nUHJvcHMgPSBPbWl0PEltYWdlUHJvcHMsICdzcmMnIHwgJ2xvYWRlcic+ICYge1xuICBsb2FkaW5nOiBMb2FkaW5nVmFsdWVcbiAgd2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZFxuICBoZWlnaHQ6IG51bWJlciB8IHVuZGVmaW5lZFxuICBzdHlsZTogTm9uTnVsbGFibGU8SlNYLkludHJpbnNpY0VsZW1lbnRzWydpbWcnXVsnc3R5bGUnXT5cbiAgc2l6ZXM6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBzcmNTZXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBzcmM6IHN0cmluZ1xufVxuXG5jb25zdCBWQUxJRF9MT0FESU5HX1ZBTFVFUyA9IFsnbGF6eScsICdlYWdlcicsIHVuZGVmaW5lZF0gYXMgY29uc3RcbnR5cGUgTG9hZGluZ1ZhbHVlID0gKHR5cGVvZiBWQUxJRF9MT0FESU5HX1ZBTFVFUylbbnVtYmVyXVxudHlwZSBJbWFnZUNvbmZpZyA9IEltYWdlQ29uZmlnQ29tcGxldGUgJiB7XG4gIGFsbFNpemVzOiBudW1iZXJbXVxuICBvdXRwdXQ/OiAnc3RhbmRhbG9uZScgfCAnZXhwb3J0J1xufVxuXG5leHBvcnQgdHlwZSBJbWFnZUxvYWRlciA9IChwOiBJbWFnZUxvYWRlclByb3BzKSA9PiBzdHJpbmdcblxuLy8gRG8gbm90IGV4cG9ydCAtIHRoaXMgaXMgYW4gaW50ZXJuYWwgdHlwZSBvbmx5XG4vLyBiZWNhdXNlIGBuZXh0LmNvbmZpZy5qc2AgaXMgb25seSBtZWFudCBmb3IgdGhlXG4vLyBidWlsdC1pbiBsb2FkZXJzLCBub3QgZm9yIGEgY3VzdG9tIGxvYWRlcigpIHByb3AuXG50eXBlIEltYWdlTG9hZGVyV2l0aENvbmZpZyA9IChwOiBJbWFnZUxvYWRlclByb3BzV2l0aENvbmZpZykgPT4gc3RyaW5nXG5cbmV4cG9ydCB0eXBlIFBsYWNlaG9sZGVyVmFsdWUgPSAnYmx1cicgfCAnZW1wdHknIHwgYGRhdGE6aW1hZ2UvJHtzdHJpbmd9YFxuZXhwb3J0IHR5cGUgT25Mb2FkID0gUmVhY3QuUmVhY3RFdmVudEhhbmRsZXI8SFRNTEltYWdlRWxlbWVudD4gfCB1bmRlZmluZWRcbmV4cG9ydCB0eXBlIE9uTG9hZGluZ0NvbXBsZXRlID0gKGltZzogSFRNTEltYWdlRWxlbWVudCkgPT4gdm9pZFxuXG5mdW5jdGlvbiBpc1N0YXRpY1JlcXVpcmUoXG4gIHNyYzogU3RhdGljUmVxdWlyZSB8IFN0YXRpY0ltYWdlRGF0YVxuKTogc3JjIGlzIFN0YXRpY1JlcXVpcmUge1xuICByZXR1cm4gKHNyYyBhcyBTdGF0aWNSZXF1aXJlKS5kZWZhdWx0ICE9PSB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNJbWFnZURhdGEoXG4gIHNyYzogU3RhdGljUmVxdWlyZSB8IFN0YXRpY0ltYWdlRGF0YVxuKTogc3JjIGlzIFN0YXRpY0ltYWdlRGF0YSB7XG4gIHJldHVybiAoc3JjIGFzIFN0YXRpY0ltYWdlRGF0YSkuc3JjICE9PSB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNTdGF0aWNJbXBvcnQoc3JjOiBzdHJpbmcgfCBTdGF0aWNJbXBvcnQpOiBzcmMgaXMgU3RhdGljSW1wb3J0IHtcbiAgcmV0dXJuIChcbiAgICAhIXNyYyAmJlxuICAgIHR5cGVvZiBzcmMgPT09ICdvYmplY3QnICYmXG4gICAgKGlzU3RhdGljUmVxdWlyZShzcmMgYXMgU3RhdGljSW1wb3J0KSB8fFxuICAgICAgaXNTdGF0aWNJbWFnZURhdGEoc3JjIGFzIFN0YXRpY0ltcG9ydCkpXG4gIClcbn1cblxuY29uc3QgYWxsSW1ncyA9IG5ldyBNYXA8XG4gIHN0cmluZyxcbiAgeyBzcmM6IHN0cmluZzsgcHJpb3JpdHk6IGJvb2xlYW47IHBsYWNlaG9sZGVyOiBQbGFjZWhvbGRlclZhbHVlIH1cbj4oKVxubGV0IHBlcmZPYnNlcnZlcjogUGVyZm9ybWFuY2VPYnNlcnZlciB8IHVuZGVmaW5lZFxuXG5mdW5jdGlvbiBnZXRJbnQoeDogdW5rbm93bik6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGlmICh0eXBlb2YgeCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4geFxuICB9XG4gIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHgpID8geCA6IE5hTlxuICB9XG4gIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiYgL15bMC05XSskLy50ZXN0KHgpKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHgsIDEwKVxuICB9XG4gIHJldHVybiBOYU5cbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhzKFxuICB7IGRldmljZVNpemVzLCBhbGxTaXplcyB9OiBJbWFnZUNvbmZpZyxcbiAgd2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgc2l6ZXM6IHN0cmluZyB8IHVuZGVmaW5lZFxuKTogeyB3aWR0aHM6IG51bWJlcltdOyBraW5kOiAndycgfCAneCcgfSB7XG4gIGlmIChzaXplcykge1xuICAgIC8vIEZpbmQgYWxsIHRoZSBcInZ3XCIgcGVyY2VudCBzaXplcyB1c2VkIGluIHRoZSBzaXplcyBwcm9wXG4gICAgY29uc3Qgdmlld3BvcnRXaWR0aFJlID0gLyhefFxccykoMT9cXGQ/XFxkKXZ3L2dcbiAgICBjb25zdCBwZXJjZW50U2l6ZXMgPSBbXVxuICAgIGZvciAobGV0IG1hdGNoOyAobWF0Y2ggPSB2aWV3cG9ydFdpZHRoUmUuZXhlYyhzaXplcykpOyBtYXRjaCkge1xuICAgICAgcGVyY2VudFNpemVzLnB1c2gocGFyc2VJbnQobWF0Y2hbMl0pKVxuICAgIH1cbiAgICBpZiAocGVyY2VudFNpemVzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc21hbGxlc3RSYXRpbyA9IE1hdGgubWluKC4uLnBlcmNlbnRTaXplcykgKiAwLjAxXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aHM6IGFsbFNpemVzLmZpbHRlcigocykgPT4gcyA+PSBkZXZpY2VTaXplc1swXSAqIHNtYWxsZXN0UmF0aW8pLFxuICAgICAgICBraW5kOiAndycsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHdpZHRoczogYWxsU2l6ZXMsIGtpbmQ6ICd3JyB9XG4gIH1cbiAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4geyB3aWR0aHM6IGRldmljZVNpemVzLCBraW5kOiAndycgfVxuICB9XG5cbiAgY29uc3Qgd2lkdGhzID0gW1xuICAgIC4uLm5ldyBTZXQoXG4gICAgICAvLyA+IFRoaXMgbWVhbnMgdGhhdCBtb3N0IE9MRUQgc2NyZWVucyB0aGF0IHNheSB0aGV5IGFyZSAzeCByZXNvbHV0aW9uLFxuICAgICAgLy8gPiBhcmUgYWN0dWFsbHkgM3ggaW4gdGhlIGdyZWVuIGNvbG9yLCBidXQgb25seSAxLjV4IGluIHRoZSByZWQgYW5kXG4gICAgICAvLyA+IGJsdWUgY29sb3JzLiBTaG93aW5nIGEgM3ggcmVzb2x1dGlvbiBpbWFnZSBpbiB0aGUgYXBwIHZzIGEgMnhcbiAgICAgIC8vID4gcmVzb2x1dGlvbiBpbWFnZSB3aWxsIGJlIHZpc3VhbGx5IHRoZSBzYW1lLCB0aG91Z2ggdGhlIDN4IGltYWdlXG4gICAgICAvLyA+IHRha2VzIHNpZ25pZmljYW50bHkgbW9yZSBkYXRhLiBFdmVuIHRydWUgM3ggcmVzb2x1dGlvbiBzY3JlZW5zIGFyZVxuICAgICAgLy8gPiB3YXN0ZWZ1bCBhcyB0aGUgaHVtYW4gZXllIGNhbm5vdCBzZWUgdGhhdCBsZXZlbCBvZiBkZXRhaWwgd2l0aG91dFxuICAgICAgLy8gPiBzb21ldGhpbmcgbGlrZSBhIG1hZ25pZnlpbmcgZ2xhc3MuXG4gICAgICAvLyBodHRwczovL2Jsb2cudHdpdHRlci5jb20vZW5naW5lZXJpbmcvZW5fdXMvdG9waWNzL2luZnJhc3RydWN0dXJlLzIwMTkvY2FwcGluZy1pbWFnZS1maWRlbGl0eS1vbi11bHRyYS1oaWdoLXJlc29sdXRpb24tZGV2aWNlcy5odG1sXG4gICAgICBbd2lkdGgsIHdpZHRoICogMiAvKiwgd2lkdGggKiAzKi9dLm1hcChcbiAgICAgICAgKHcpID0+IGFsbFNpemVzLmZpbmQoKHApID0+IHAgPj0gdykgfHwgYWxsU2l6ZXNbYWxsU2l6ZXMubGVuZ3RoIC0gMV1cbiAgICAgIClcbiAgICApLFxuICBdXG4gIHJldHVybiB7IHdpZHRocywga2luZDogJ3gnIH1cbn1cblxudHlwZSBHZW5JbWdBdHRyc0RhdGEgPSB7XG4gIGNvbmZpZzogSW1hZ2VDb25maWdcbiAgc3JjOiBzdHJpbmdcbiAgdW5vcHRpbWl6ZWQ6IGJvb2xlYW5cbiAgbG9hZGVyOiBJbWFnZUxvYWRlcldpdGhDb25maWdcbiAgd2lkdGg/OiBudW1iZXJcbiAgcXVhbGl0eT86IG51bWJlclxuICBzaXplcz86IHN0cmluZ1xufVxuXG50eXBlIEdlbkltZ0F0dHJzUmVzdWx0ID0ge1xuICBzcmM6IHN0cmluZ1xuICBzcmNTZXQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICBzaXplczogc3RyaW5nIHwgdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlSW1nQXR0cnMoe1xuICBjb25maWcsXG4gIHNyYyxcbiAgdW5vcHRpbWl6ZWQsXG4gIHdpZHRoLFxuICBxdWFsaXR5LFxuICBzaXplcyxcbiAgbG9hZGVyLFxufTogR2VuSW1nQXR0cnNEYXRhKTogR2VuSW1nQXR0cnNSZXN1bHQge1xuICBpZiAodW5vcHRpbWl6ZWQpIHtcbiAgICByZXR1cm4geyBzcmMsIHNyY1NldDogdW5kZWZpbmVkLCBzaXplczogdW5kZWZpbmVkIH1cbiAgfVxuXG4gIGNvbnN0IHsgd2lkdGhzLCBraW5kIH0gPSBnZXRXaWR0aHMoY29uZmlnLCB3aWR0aCwgc2l6ZXMpXG4gIGNvbnN0IGxhc3QgPSB3aWR0aHMubGVuZ3RoIC0gMVxuXG4gIHJldHVybiB7XG4gICAgc2l6ZXM6ICFzaXplcyAmJiBraW5kID09PSAndycgPyAnMTAwdncnIDogc2l6ZXMsXG4gICAgc3JjU2V0OiB3aWR0aHNcbiAgICAgIC5tYXAoXG4gICAgICAgICh3LCBpKSA9PlxuICAgICAgICAgIGAke2xvYWRlcih7IGNvbmZpZywgc3JjLCBxdWFsaXR5LCB3aWR0aDogdyB9KX0gJHtcbiAgICAgICAgICAgIGtpbmQgPT09ICd3JyA/IHcgOiBpICsgMVxuICAgICAgICAgIH0ke2tpbmR9YFxuICAgICAgKVxuICAgICAgLmpvaW4oJywgJyksXG5cbiAgICAvLyBJdCdzIGludGVuZGVkIHRvIGtlZXAgYHNyY2AgdGhlIGxhc3QgYXR0cmlidXRlIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgIC8vIGF0dHJpYnV0ZXMgaW4gb3JkZXIuIElmIHdlIGtlZXAgYHNyY2AgdGhlIGZpcnN0IG9uZSwgU2FmYXJpIHdpbGxcbiAgICAvLyBpbW1lZGlhdGVseSBzdGFydCB0byBmZXRjaCBgc3JjYCwgYmVmb3JlIGBzaXplc2AgYW5kIGBzcmNTZXRgIGFyZSBldmVuXG4gICAgLy8gdXBkYXRlZCBieSBSZWFjdC4gVGhhdCBjYXVzZXMgbXVsdGlwbGUgdW5uZWNlc3NhcnkgcmVxdWVzdHMgaWYgYHNyY1NldGBcbiAgICAvLyBhbmQgYHNpemVzYCBhcmUgZGVmaW5lZC5cbiAgICAvLyBUaGlzIGJ1ZyBjYW5ub3QgYmUgcmVwcm9kdWNlZCBpbiBDaHJvbWUgb3IgRmlyZWZveC5cbiAgICBzcmM6IGxvYWRlcih7IGNvbmZpZywgc3JjLCBxdWFsaXR5LCB3aWR0aDogd2lkdGhzW2xhc3RdIH0pLFxuICB9XG59XG5cbi8qKlxuICogQSBzaGFyZWQgZnVuY3Rpb24sIHVzZWQgb24gYm90aCBjbGllbnQgYW5kIHNlcnZlciwgdG8gZ2VuZXJhdGUgdGhlIHByb3BzIGZvciA8aW1nPi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEltZ1Byb3BzKFxuICB7XG4gICAgc3JjLFxuICAgIHNpemVzLFxuICAgIHVub3B0aW1pemVkID0gZmFsc2UsXG4gICAgcHJpb3JpdHkgPSBmYWxzZSxcbiAgICBsb2FkaW5nLFxuICAgIGNsYXNzTmFtZSxcbiAgICBxdWFsaXR5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBmaWxsID0gZmFsc2UsXG4gICAgc3R5bGUsXG4gICAgb3ZlcnJpZGVTcmMsXG4gICAgb25Mb2FkLFxuICAgIG9uTG9hZGluZ0NvbXBsZXRlLFxuICAgIHBsYWNlaG9sZGVyID0gJ2VtcHR5JyxcbiAgICBibHVyRGF0YVVSTCxcbiAgICBmZXRjaFByaW9yaXR5LFxuICAgIGRlY29kaW5nID0gJ2FzeW5jJyxcbiAgICBsYXlvdXQsXG4gICAgb2JqZWN0Rml0LFxuICAgIG9iamVjdFBvc2l0aW9uLFxuICAgIGxhenlCb3VuZGFyeSxcbiAgICBsYXp5Um9vdCxcbiAgICAuLi5yZXN0XG4gIH06IEltYWdlUHJvcHMsXG4gIF9zdGF0ZToge1xuICAgIGRlZmF1bHRMb2FkZXI6IEltYWdlTG9hZGVyV2l0aENvbmZpZ1xuICAgIGltZ0NvbmY6IEltYWdlQ29uZmlnQ29tcGxldGVcbiAgICBzaG93QWx0VGV4dD86IGJvb2xlYW5cbiAgICBibHVyQ29tcGxldGU/OiBib29sZWFuXG4gIH1cbik6IHtcbiAgcHJvcHM6IEltZ1Byb3BzXG4gIG1ldGE6IHtcbiAgICB1bm9wdGltaXplZDogYm9vbGVhblxuICAgIHByaW9yaXR5OiBib29sZWFuXG4gICAgcGxhY2Vob2xkZXI6IE5vbk51bGxhYmxlPEltYWdlUHJvcHNbJ3BsYWNlaG9sZGVyJ10+XG4gICAgZmlsbDogYm9vbGVhblxuICB9XG59IHtcbiAgY29uc3QgeyBpbWdDb25mLCBzaG93QWx0VGV4dCwgYmx1ckNvbXBsZXRlLCBkZWZhdWx0TG9hZGVyIH0gPSBfc3RhdGVcbiAgbGV0IGNvbmZpZzogSW1hZ2VDb25maWdcbiAgbGV0IGMgPSBpbWdDb25mIHx8IGltYWdlQ29uZmlnRGVmYXVsdFxuICBpZiAoJ2FsbFNpemVzJyBpbiBjKSB7XG4gICAgY29uZmlnID0gYyBhcyBJbWFnZUNvbmZpZ1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGFsbFNpemVzID0gWy4uLmMuZGV2aWNlU2l6ZXMsIC4uLmMuaW1hZ2VTaXplc10uc29ydCgoYSwgYikgPT4gYSAtIGIpXG4gICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgIGNvbmZpZyA9IHsgLi4uYywgYWxsU2l6ZXMsIGRldmljZVNpemVzIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgZGVmYXVsdExvYWRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnaW1hZ2VzLmxvYWRlckZpbGUgZGV0ZWN0ZWQgYnV0IHRoZSBmaWxlIGlzIG1pc3NpbmcgZGVmYXVsdCBleHBvcnQuXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLWltYWdlcy1jb25maWcnXG4gICAgKVxuICB9XG4gIGxldCBsb2FkZXI6IEltYWdlTG9hZGVyV2l0aENvbmZpZyA9IHJlc3QubG9hZGVyIHx8IGRlZmF1bHRMb2FkZXJcblxuICAvLyBSZW1vdmUgcHJvcGVydHkgc28gaXQncyBub3Qgc3ByZWFkIG9uIDxpbWc+IGVsZW1lbnRcbiAgZGVsZXRlIHJlc3QubG9hZGVyXG4gIGRlbGV0ZSAocmVzdCBhcyBhbnkpLnNyY1NldFxuXG4gIC8vIFRoaXMgc3BlY2lhbCB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgdXNlclxuICAvLyBkaWRuJ3QgZGVmaW5lIGEgXCJsb2FkZXJcIiBwcm9wIG9yIFwibG9hZGVyXCIgY29uZmlnLlxuICBjb25zdCBpc0RlZmF1bHRMb2FkZXIgPSAnX19uZXh0X2ltZ19kZWZhdWx0JyBpbiBsb2FkZXJcblxuICBpZiAoaXNEZWZhdWx0TG9hZGVyKSB7XG4gICAgaWYgKGNvbmZpZy5sb2FkZXIgPT09ICdjdXN0b20nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIG1pc3NpbmcgXCJsb2FkZXJcIiBwcm9wLmAgK1xuICAgICAgICAgIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXJgXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZSB1c2VyIGRlZmluZWQgYSBcImxvYWRlclwiIHByb3Agb3IgY29uZmlnLlxuICAgIC8vIFNpbmNlIHRoZSBjb25maWcgb2JqZWN0IGlzIGludGVybmFsIG9ubHksIHdlXG4gICAgLy8gbXVzdCBub3QgcGFzcyBpdCB0byB0aGUgdXNlci1kZWZpbmVkIFwibG9hZGVyXCIuXG4gICAgY29uc3QgY3VzdG9tSW1hZ2VMb2FkZXIgPSBsb2FkZXIgYXMgSW1hZ2VMb2FkZXJcbiAgICBsb2FkZXIgPSAob2JqKSA9PiB7XG4gICAgICBjb25zdCB7IGNvbmZpZzogXywgLi4ub3B0cyB9ID0gb2JqXG4gICAgICByZXR1cm4gY3VzdG9tSW1hZ2VMb2FkZXIob3B0cylcbiAgICB9XG4gIH1cblxuICBpZiAobGF5b3V0KSB7XG4gICAgaWYgKGxheW91dCA9PT0gJ2ZpbGwnKSB7XG4gICAgICBmaWxsID0gdHJ1ZVxuICAgIH1cbiAgICBjb25zdCBsYXlvdXRUb1N0eWxlOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHwgdW5kZWZpbmVkPiA9IHtcbiAgICAgIGludHJpbnNpYzogeyBtYXhXaWR0aDogJzEwMCUnLCBoZWlnaHQ6ICdhdXRvJyB9LFxuICAgICAgcmVzcG9uc2l2ZTogeyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICdhdXRvJyB9LFxuICAgIH1cbiAgICBjb25zdCBsYXlvdXRUb1NpemVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+ID0ge1xuICAgICAgcmVzcG9uc2l2ZTogJzEwMHZ3JyxcbiAgICAgIGZpbGw6ICcxMDB2dycsXG4gICAgfVxuICAgIGNvbnN0IGxheW91dFN0eWxlID0gbGF5b3V0VG9TdHlsZVtsYXlvdXRdXG4gICAgaWYgKGxheW91dFN0eWxlKSB7XG4gICAgICBzdHlsZSA9IHsgLi4uc3R5bGUsIC4uLmxheW91dFN0eWxlIH1cbiAgICB9XG4gICAgY29uc3QgbGF5b3V0U2l6ZXMgPSBsYXlvdXRUb1NpemVzW2xheW91dF1cbiAgICBpZiAobGF5b3V0U2l6ZXMgJiYgIXNpemVzKSB7XG4gICAgICBzaXplcyA9IGxheW91dFNpemVzXG4gICAgfVxuICB9XG5cbiAgbGV0IHN0YXRpY1NyYyA9ICcnXG4gIGxldCB3aWR0aEludCA9IGdldEludCh3aWR0aClcbiAgbGV0IGhlaWdodEludCA9IGdldEludChoZWlnaHQpXG4gIGxldCBibHVyV2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZFxuICBsZXQgYmx1ckhlaWdodDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gIGlmIChpc1N0YXRpY0ltcG9ydChzcmMpKSB7XG4gICAgY29uc3Qgc3RhdGljSW1hZ2VEYXRhID0gaXNTdGF0aWNSZXF1aXJlKHNyYykgPyBzcmMuZGVmYXVsdCA6IHNyY1xuXG4gICAgaWYgKCFzdGF0aWNJbWFnZURhdGEuc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIHNyYy4gUmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBzdGF0aWNJbWFnZURhdGFcbiAgICAgICAgKX1gXG4gICAgICApXG4gICAgfVxuICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLmhlaWdodCB8fCAhc3RhdGljSW1hZ2VEYXRhLndpZHRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIGhlaWdodCBhbmQgd2lkdGguIFJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgc3RhdGljSW1hZ2VEYXRhXG4gICAgICAgICl9YFxuICAgICAgKVxuICAgIH1cblxuICAgIGJsdXJXaWR0aCA9IHN0YXRpY0ltYWdlRGF0YS5ibHVyV2lkdGhcbiAgICBibHVySGVpZ2h0ID0gc3RhdGljSW1hZ2VEYXRhLmJsdXJIZWlnaHRcbiAgICBibHVyRGF0YVVSTCA9IGJsdXJEYXRhVVJMIHx8IHN0YXRpY0ltYWdlRGF0YS5ibHVyRGF0YVVSTFxuICAgIHN0YXRpY1NyYyA9IHN0YXRpY0ltYWdlRGF0YS5zcmNcblxuICAgIGlmICghZmlsbCkge1xuICAgICAgaWYgKCF3aWR0aEludCAmJiAhaGVpZ2h0SW50KSB7XG4gICAgICAgIHdpZHRoSW50ID0gc3RhdGljSW1hZ2VEYXRhLndpZHRoXG4gICAgICAgIGhlaWdodEludCA9IHN0YXRpY0ltYWdlRGF0YS5oZWlnaHRcbiAgICAgIH0gZWxzZSBpZiAod2lkdGhJbnQgJiYgIWhlaWdodEludCkge1xuICAgICAgICBjb25zdCByYXRpbyA9IHdpZHRoSW50IC8gc3RhdGljSW1hZ2VEYXRhLndpZHRoXG4gICAgICAgIGhlaWdodEludCA9IE1hdGgucm91bmQoc3RhdGljSW1hZ2VEYXRhLmhlaWdodCAqIHJhdGlvKVxuICAgICAgfSBlbHNlIGlmICghd2lkdGhJbnQgJiYgaGVpZ2h0SW50KSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gaGVpZ2h0SW50IC8gc3RhdGljSW1hZ2VEYXRhLmhlaWdodFxuICAgICAgICB3aWR0aEludCA9IE1hdGgucm91bmQoc3RhdGljSW1hZ2VEYXRhLndpZHRoICogcmF0aW8pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNyYyA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gc3JjIDogc3RhdGljU3JjXG5cbiAgbGV0IGlzTGF6eSA9XG4gICAgIXByaW9yaXR5ICYmIChsb2FkaW5nID09PSAnbGF6eScgfHwgdHlwZW9mIGxvYWRpbmcgPT09ICd1bmRlZmluZWQnKVxuICBpZiAoIXNyYyB8fCBzcmMuc3RhcnRzV2l0aCgnZGF0YTonKSB8fCBzcmMuc3RhcnRzV2l0aCgnYmxvYjonKSkge1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0hUVFAvQmFzaWNzX29mX0hUVFAvRGF0YV9VUklzXG4gICAgdW5vcHRpbWl6ZWQgPSB0cnVlXG4gICAgaXNMYXp5ID0gZmFsc2VcbiAgfVxuICBpZiAoY29uZmlnLnVub3B0aW1pemVkKSB7XG4gICAgdW5vcHRpbWl6ZWQgPSB0cnVlXG4gIH1cbiAgaWYgKGlzRGVmYXVsdExvYWRlciAmJiBzcmMuZW5kc1dpdGgoJy5zdmcnKSAmJiAhY29uZmlnLmRhbmdlcm91c2x5QWxsb3dTVkcpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2UgdG8gbWFrZSBzdmcgc2VydmUgYXMtaXMgdG8gYXZvaWQgcHJveHlpbmdcbiAgICAvLyB0aHJvdWdoIHRoZSBidWlsdC1pbiBJbWFnZSBPcHRpbWl6YXRpb24gQVBJLlxuICAgIHVub3B0aW1pemVkID0gdHJ1ZVxuICB9XG5cbiAgY29uc3QgcXVhbGl0eUludCA9IGdldEludChxdWFsaXR5KVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGNvbmZpZy5vdXRwdXQgPT09ICdleHBvcnQnICYmIGlzRGVmYXVsdExvYWRlciAmJiAhdW5vcHRpbWl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEltYWdlIE9wdGltaXphdGlvbiB1c2luZyB0aGUgZGVmYXVsdCBsb2FkZXIgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBcXGB7IG91dHB1dDogJ2V4cG9ydCcgfVxcYC5cbiAgUG9zc2libGUgc29sdXRpb25zOlxuICAgIC0gUmVtb3ZlIFxcYHsgb3V0cHV0OiAnZXhwb3J0JyB9XFxgIGFuZCBydW4gXCJuZXh0IHN0YXJ0XCIgdG8gcnVuIHNlcnZlciBtb2RlIGluY2x1ZGluZyB0aGUgSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cbiAgICAtIENvbmZpZ3VyZSBcXGB7IGltYWdlczogeyB1bm9wdGltaXplZDogdHJ1ZSB9IH1cXGAgaW4gXFxgbmV4dC5jb25maWcuanNcXGAgdG8gZGlzYWJsZSB0aGUgSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cbiAgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9leHBvcnQtaW1hZ2UtYXBpYFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAoIXNyYykge1xuICAgICAgLy8gUmVhY3QgZG9lc24ndCBzaG93IHRoZSBzdGFjayB0cmFjZSBhbmQgdGhlcmUnc1xuICAgICAgLy8gbm8gYHNyY2AgdG8gaGVscCBpZGVudGlmeSB3aGljaCBpbWFnZSwgc28gd2VcbiAgICAgIC8vIGluc3RlYWQgY29uc29sZS5lcnJvcihyZWYpIGR1cmluZyBtb3VudC5cbiAgICAgIHVub3B0aW1pemVkID0gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmlsbCkge1xuICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcIndpZHRoXCIgYW5kIFwiZmlsbFwiIHByb3BlcnRpZXMuIE9ubHkgb25lIHNob3VsZCBiZSB1c2VkLmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwiaGVpZ2h0XCIgYW5kIFwiZmlsbFwiIHByb3BlcnRpZXMuIE9ubHkgb25lIHNob3VsZCBiZSB1c2VkLmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlPy5wb3NpdGlvbiAmJiBzdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLnBvc2l0aW9uXCIgcHJvcGVydGllcy4gSW1hZ2VzIHdpdGggXCJmaWxsXCIgYWx3YXlzIHVzZSBwb3NpdGlvbiBhYnNvbHV0ZSAtIGl0IGNhbm5vdCBiZSBtb2RpZmllZC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZT8ud2lkdGggJiYgc3R5bGUud2lkdGggIT09ICcxMDAlJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLndpZHRoXCIgcHJvcGVydGllcy4gSW1hZ2VzIHdpdGggXCJmaWxsXCIgYWx3YXlzIHVzZSB3aWR0aCAxMDAlIC0gaXQgY2Fubm90IGJlIG1vZGlmaWVkLmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlPy5oZWlnaHQgJiYgc3R5bGUuaGVpZ2h0ICE9PSAnMTAwJScpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYm90aCBcImZpbGxcIiBhbmQgXCJzdHlsZS5oZWlnaHRcIiBwcm9wZXJ0aWVzLiBJbWFnZXMgd2l0aCBcImZpbGxcIiBhbHdheXMgdXNlIGhlaWdodCAxMDAlIC0gaXQgY2Fubm90IGJlIG1vZGlmaWVkLmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGhJbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgbWlzc2luZyByZXF1aXJlZCBcIndpZHRoXCIgcHJvcGVydHkuYFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChpc05hTih3aWR0aEludCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcIndpZHRoXCIgcHJvcGVydHkuIEV4cGVjdGVkIGEgbnVtZXJpYyB2YWx1ZSBpbiBwaXhlbHMgYnV0IHJlY2VpdmVkIFwiJHt3aWR0aH1cIi5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0SW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJoZWlnaHRcIiBwcm9wZXJ0eS5gXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKGhlaWdodEludCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcImhlaWdodFwiIHByb3BlcnR5LiBFeHBlY3RlZCBhIG51bWVyaWMgdmFsdWUgaW4gcGl4ZWxzIGJ1dCByZWNlaXZlZCBcIiR7aGVpZ2h0fVwiLmBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICAgICAgaWYgKC9eW1xceDAwLVxceDIwXS8udGVzdChzcmMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgY2Fubm90IHN0YXJ0IHdpdGggYSBzcGFjZSBvciBjb250cm9sIGNoYXJhY3Rlci4gVXNlIHNyYy50cmltU3RhcnQoKSB0byByZW1vdmUgaXQgb3IgZW5jb2RlVVJJQ29tcG9uZW50KHNyYykgdG8ga2VlcCBpdC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgICAgIGlmICgvW1xceDAwLVxceDIwXSQvLnRlc3Qoc3JjKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGNhbm5vdCBlbmQgd2l0aCBhIHNwYWNlIG9yIGNvbnRyb2wgY2hhcmFjdGVyLiBVc2Ugc3JjLnRyaW1FbmQoKSB0byByZW1vdmUgaXQgb3IgZW5jb2RlVVJJQ29tcG9uZW50KHNyYykgdG8ga2VlcCBpdC5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghVkFMSURfTE9BRElOR19WQUxVRVMuaW5jbHVkZXMobG9hZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJsb2FkaW5nXCIgcHJvcGVydHkuIFByb3ZpZGVkIFwiJHtsb2FkaW5nfVwiIHNob3VsZCBiZSBvbmUgb2YgJHtWQUxJRF9MT0FESU5HX1ZBTFVFUy5tYXAoXG4gICAgICAgICAgU3RyaW5nXG4gICAgICAgICkuam9pbignLCcpfS5gXG4gICAgICApXG4gICAgfVxuICAgIGlmIChwcmlvcml0eSAmJiBsb2FkaW5nID09PSAnbGF6eScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGJvdGggXCJwcmlvcml0eVwiIGFuZCBcImxvYWRpbmc9J2xhenknXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuYFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAoXG4gICAgICBwbGFjZWhvbGRlciAhPT0gJ2VtcHR5JyAmJlxuICAgICAgcGxhY2Vob2xkZXIgIT09ICdibHVyJyAmJlxuICAgICAgIXBsYWNlaG9sZGVyLnN0YXJ0c1dpdGgoJ2RhdGE6aW1hZ2UvJylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5IFwiJHtwbGFjZWhvbGRlcn1cIi5gXG4gICAgICApXG4gICAgfVxuICAgIGlmIChwbGFjZWhvbGRlciAhPT0gJ2VtcHR5Jykge1xuICAgICAgaWYgKHdpZHRoSW50ICYmIGhlaWdodEludCAmJiB3aWR0aEludCAqIGhlaWdodEludCA8IDE2MDApIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgc21hbGxlciB0aGFuIDQweDQwLiBDb25zaWRlciByZW1vdmluZyB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5IHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuYFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwbGFjZWhvbGRlciA9PT0gJ2JsdXInICYmICFibHVyRGF0YVVSTCkge1xuICAgICAgY29uc3QgVkFMSURfQkxVUl9FWFQgPSBbJ2pwZWcnLCAncG5nJywgJ3dlYnAnLCAnYXZpZiddIC8vIHNob3VsZCBtYXRjaCBuZXh0LWltYWdlLWxvYWRlclxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBcInBsYWNlaG9sZGVyPSdibHVyJ1wiIHByb3BlcnR5IGJ1dCBpcyBtaXNzaW5nIHRoZSBcImJsdXJEYXRhVVJMXCIgcHJvcGVydHkuXG4gICAgICAgIFBvc3NpYmxlIHNvbHV0aW9uczpcbiAgICAgICAgICAtIEFkZCBhIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eSwgdGhlIGNvbnRlbnRzIHNob3VsZCBiZSBhIHNtYWxsIERhdGEgVVJMIHRvIHJlcHJlc2VudCB0aGUgaW1hZ2VcbiAgICAgICAgICAtIENoYW5nZSB0aGUgXCJzcmNcIiBwcm9wZXJ0eSB0byBhIHN0YXRpYyBpbXBvcnQgd2l0aCBvbmUgb2YgdGhlIHN1cHBvcnRlZCBmaWxlIHR5cGVzOiAke1ZBTElEX0JMVVJfRVhULmpvaW4oXG4gICAgICAgICAgICAnLCdcbiAgICAgICAgICApfSAoYW5pbWF0ZWQgaW1hZ2VzIG5vdCBzdXBwb3J0ZWQpXG4gICAgICAgICAgLSBSZW1vdmUgdGhlIFwicGxhY2Vob2xkZXJcIiBwcm9wZXJ0eSwgZWZmZWN0aXZlbHkgbm8gYmx1ciBlZmZlY3RcbiAgICAgICAgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wbGFjZWhvbGRlci1ibHVyLWRhdGEtdXJsYFxuICAgICAgKVxuICAgIH1cbiAgICBpZiAoJ3JlZicgaW4gcmVzdCkge1xuICAgICAgd2Fybk9uY2UoXG4gICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIHVzaW5nIHVuc3VwcG9ydGVkIFwicmVmXCIgcHJvcGVydHkuIENvbnNpZGVyIHVzaW5nIHRoZSBcIm9uTG9hZFwiIHByb3BlcnR5IGluc3RlYWQuYFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgIWlzRGVmYXVsdExvYWRlcikge1xuICAgICAgY29uc3QgdXJsU3RyID0gbG9hZGVyKHtcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBzcmMsXG4gICAgICAgIHdpZHRoOiB3aWR0aEludCB8fCA0MDAsXG4gICAgICAgIHF1YWxpdHk6IHF1YWxpdHlJbnQgfHwgNzUsXG4gICAgICB9KVxuICAgICAgbGV0IHVybDogVVJMIHwgdW5kZWZpbmVkXG4gICAgICB0cnkge1xuICAgICAgICB1cmwgPSBuZXcgVVJMKHVybFN0cilcbiAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgIGlmICh1cmxTdHIgPT09IHNyYyB8fCAodXJsICYmIHVybC5wYXRobmFtZSA9PT0gc3JjICYmICF1cmwuc2VhcmNoKSkge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgYSBcImxvYWRlclwiIHByb3BlcnR5IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IHdpZHRoLiBQbGVhc2UgaW1wbGVtZW50IGl0IG9yIHVzZSB0aGUgXCJ1bm9wdGltaXplZFwiIHByb3BlcnR5IGluc3RlYWQuYCArXG4gICAgICAgICAgICBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyLXdpZHRoYFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9uTG9hZGluZ0NvbXBsZXRlKSB7XG4gICAgICB3YXJuT25jZShcbiAgICAgICAgYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgdXNpbmcgZGVwcmVjYXRlZCBcIm9uTG9hZGluZ0NvbXBsZXRlXCIgcHJvcGVydHkuIFBsZWFzZSB1c2UgdGhlIFwib25Mb2FkXCIgcHJvcGVydHkgaW5zdGVhZC5gXG4gICAgICApXG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbbGVnYWN5S2V5LCBsZWdhY3lWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoe1xuICAgICAgbGF5b3V0LFxuICAgICAgb2JqZWN0Rml0LFxuICAgICAgb2JqZWN0UG9zaXRpb24sXG4gICAgICBsYXp5Qm91bmRhcnksXG4gICAgICBsYXp5Um9vdCxcbiAgICB9KSkge1xuICAgICAgaWYgKGxlZ2FjeVZhbHVlKSB7XG4gICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBsZWdhY3kgcHJvcCBcIiR7bGVnYWN5S2V5fVwiLiBEaWQgeW91IGZvcmdldCB0byBydW4gdGhlIGNvZGVtb2Q/YCArXG4gICAgICAgICAgICBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVwZ3JhZGUtdG8tMTNgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgIXBlcmZPYnNlcnZlciAmJlxuICAgICAgd2luZG93LlBlcmZvcm1hbmNlT2JzZXJ2ZXJcbiAgICApIHtcbiAgICAgIHBlcmZPYnNlcnZlciA9IG5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKChlbnRyeUxpc3QpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyeUxpc3QuZ2V0RW50cmllcygpKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIG1pc3NpbmcgXCJMYXJnZXN0Q29udGVudGZ1bFBhaW50XCIgY2xhc3Mgd2l0aCBcImVsZW1lbnRcIiBwcm9wXG4gICAgICAgICAgY29uc3QgaW1nU3JjID0gZW50cnk/LmVsZW1lbnQ/LnNyYyB8fCAnJ1xuICAgICAgICAgIGNvbnN0IGxjcEltYWdlID0gYWxsSW1ncy5nZXQoaW1nU3JjKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGxjcEltYWdlICYmXG4gICAgICAgICAgICAhbGNwSW1hZ2UucHJpb3JpdHkgJiZcbiAgICAgICAgICAgIGxjcEltYWdlLnBsYWNlaG9sZGVyID09PSAnZW1wdHknICYmXG4gICAgICAgICAgICAhbGNwSW1hZ2Uuc3JjLnN0YXJ0c1dpdGgoJ2RhdGE6JykgJiZcbiAgICAgICAgICAgICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aCgnYmxvYjonKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93ZWIuZGV2L2xjcC8jbWVhc3VyZS1sY3AtaW4tamF2YXNjcmlwdFxuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIGBJbWFnZSB3aXRoIHNyYyBcIiR7bGNwSW1hZ2Uuc3JjfVwiIHdhcyBkZXRlY3RlZCBhcyB0aGUgTGFyZ2VzdCBDb250ZW50ZnVsIFBhaW50IChMQ1ApLiBQbGVhc2UgYWRkIHRoZSBcInByaW9yaXR5XCIgcHJvcGVydHkgaWYgdGhpcyBpbWFnZSBpcyBhYm92ZSB0aGUgZm9sZC5gICtcbiAgICAgICAgICAgICAgICBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcGktcmVmZXJlbmNlL25leHQvaW1hZ2UjcHJpb3JpdHlgXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdHJ5IHtcbiAgICAgICAgcGVyZk9ic2VydmVyLm9ic2VydmUoe1xuICAgICAgICAgIHR5cGU6ICdsYXJnZXN0LWNvbnRlbnRmdWwtcGFpbnQnLFxuICAgICAgICAgIGJ1ZmZlcmVkOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIExvZyBlcnJvciBidXQgZG9uJ3QgY3Jhc2ggdGhlIGFwcFxuICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgaW1nU3R5bGUgPSBPYmplY3QuYXNzaWduKFxuICAgIGZpbGxcbiAgICAgID8ge1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgIG9iamVjdEZpdCxcbiAgICAgICAgICBvYmplY3RQb3NpdGlvbixcbiAgICAgICAgfVxuICAgICAgOiB7fSxcbiAgICBzaG93QWx0VGV4dCA/IHt9IDogeyBjb2xvcjogJ3RyYW5zcGFyZW50JyB9LFxuICAgIHN0eWxlXG4gIClcblxuICBjb25zdCBiYWNrZ3JvdW5kSW1hZ2UgPVxuICAgICFibHVyQ29tcGxldGUgJiYgcGxhY2Vob2xkZXIgIT09ICdlbXB0eSdcbiAgICAgID8gcGxhY2Vob2xkZXIgPT09ICdibHVyJ1xuICAgICAgICA/IGB1cmwoXCJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwke2dldEltYWdlQmx1clN2Zyh7XG4gICAgICAgICAgICB3aWR0aEludCxcbiAgICAgICAgICAgIGhlaWdodEludCxcbiAgICAgICAgICAgIGJsdXJXaWR0aCxcbiAgICAgICAgICAgIGJsdXJIZWlnaHQsXG4gICAgICAgICAgICBibHVyRGF0YVVSTDogYmx1ckRhdGFVUkwgfHwgJycsIC8vIGFzc3VtZSBub3QgdW5kZWZpbmVkXG4gICAgICAgICAgICBvYmplY3RGaXQ6IGltZ1N0eWxlLm9iamVjdEZpdCxcbiAgICAgICAgICB9KX1cIilgXG4gICAgICAgIDogYHVybChcIiR7cGxhY2Vob2xkZXJ9XCIpYCAvLyBhc3N1bWUgYGRhdGE6aW1hZ2UvYFxuICAgICAgOiBudWxsXG5cbiAgbGV0IHBsYWNlaG9sZGVyU3R5bGUgPSBiYWNrZ3JvdW5kSW1hZ2VcbiAgICA/IHtcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IGltZ1N0eWxlLm9iamVjdEZpdCB8fCAnY292ZXInLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IGltZ1N0eWxlLm9iamVjdFBvc2l0aW9uIHx8ICc1MCUgNTAlJyxcbiAgICAgICAgYmFja2dyb3VuZFJlcGVhdDogJ25vLXJlcGVhdCcsXG4gICAgICAgIGJhY2tncm91bmRJbWFnZSxcbiAgICAgIH1cbiAgICA6IHt9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKFxuICAgICAgcGxhY2Vob2xkZXJTdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgJiZcbiAgICAgIHBsYWNlaG9sZGVyID09PSAnYmx1cicgJiZcbiAgICAgIGJsdXJEYXRhVVJMPy5zdGFydHNXaXRoKCcvJylcbiAgICApIHtcbiAgICAgIC8vIER1cmluZyBgbmV4dCBkZXZgLCB3ZSBkb24ndCB3YW50IHRvIGdlbmVyYXRlIGJsdXIgcGxhY2Vob2xkZXJzIHdpdGggd2VicGFja1xuICAgICAgLy8gYmVjYXVzZSBpdCBjYW4gZGVsYXkgc3RhcnRpbmcgdGhlIGRldiBzZXJ2ZXIuIEluc3RlYWQsIGBuZXh0LWltYWdlLWxvYWRlci5qc2BcbiAgICAgIC8vIHdpbGwgaW5saW5lIGEgc3BlY2lhbCB1cmwgdG8gbGF6aWx5IGdlbmVyYXRlIHRoZSBibHVyIHBsYWNlaG9sZGVyIGF0IHJlcXVlc3QgdGltZS5cbiAgICAgIHBsYWNlaG9sZGVyU3R5bGUuYmFja2dyb3VuZEltYWdlID0gYHVybChcIiR7Ymx1ckRhdGFVUkx9XCIpYFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGltZ0F0dHJpYnV0ZXMgPSBnZW5lcmF0ZUltZ0F0dHJzKHtcbiAgICBjb25maWcsXG4gICAgc3JjLFxuICAgIHVub3B0aW1pemVkLFxuICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICBxdWFsaXR5OiBxdWFsaXR5SW50LFxuICAgIHNpemVzLFxuICAgIGxvYWRlcixcbiAgfSlcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbGV0IGZ1bGxVcmw6IFVSTFxuICAgICAgdHJ5IHtcbiAgICAgICAgZnVsbFVybCA9IG5ldyBVUkwoaW1nQXR0cmlidXRlcy5zcmMpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGZ1bGxVcmwgPSBuZXcgVVJMKGltZ0F0dHJpYnV0ZXMuc3JjLCB3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICAgIH1cbiAgICAgIGFsbEltZ3Muc2V0KGZ1bGxVcmwuaHJlZiwgeyBzcmMsIHByaW9yaXR5LCBwbGFjZWhvbGRlciB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHByb3BzOiBJbWdQcm9wcyA9IHtcbiAgICAuLi5yZXN0LFxuICAgIGxvYWRpbmc6IGlzTGF6eSA/ICdsYXp5JyA6IGxvYWRpbmcsXG4gICAgZmV0Y2hQcmlvcml0eSxcbiAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgaGVpZ2h0OiBoZWlnaHRJbnQsXG4gICAgZGVjb2RpbmcsXG4gICAgY2xhc3NOYW1lLFxuICAgIHN0eWxlOiB7IC4uLmltZ1N0eWxlLCAuLi5wbGFjZWhvbGRlclN0eWxlIH0sXG4gICAgc2l6ZXM6IGltZ0F0dHJpYnV0ZXMuc2l6ZXMsXG4gICAgc3JjU2V0OiBpbWdBdHRyaWJ1dGVzLnNyY1NldCxcbiAgICBzcmM6IG92ZXJyaWRlU3JjIHx8IGltZ0F0dHJpYnV0ZXMuc3JjLFxuICB9XG4gIGNvbnN0IG1ldGEgPSB7IHVub3B0aW1pemVkLCBwcmlvcml0eSwgcGxhY2Vob2xkZXIsIGZpbGwgfVxuICByZXR1cm4geyBwcm9wcywgbWV0YSB9XG59XG4iXSwibmFtZXMiOlsiZ2V0SW1nUHJvcHMiLCJWQUxJRF9MT0FESU5HX1ZBTFVFUyIsInVuZGVmaW5lZCIsImlzU3RhdGljUmVxdWlyZSIsInNyYyIsImRlZmF1bHQiLCJpc1N0YXRpY0ltYWdlRGF0YSIsImlzU3RhdGljSW1wb3J0IiwiYWxsSW1ncyIsIk1hcCIsInBlcmZPYnNlcnZlciIsImdldEludCIsIngiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk5hTiIsInRlc3QiLCJwYXJzZUludCIsImdldFdpZHRocyIsIndpZHRoIiwic2l6ZXMiLCJkZXZpY2VTaXplcyIsImFsbFNpemVzIiwidmlld3BvcnRXaWR0aFJlIiwicGVyY2VudFNpemVzIiwibWF0Y2giLCJleGVjIiwicHVzaCIsImxlbmd0aCIsInNtYWxsZXN0UmF0aW8iLCJNYXRoIiwibWluIiwid2lkdGhzIiwiZmlsdGVyIiwicyIsImtpbmQiLCJTZXQiLCJtYXAiLCJ3IiwiZmluZCIsInAiLCJnZW5lcmF0ZUltZ0F0dHJzIiwiY29uZmlnIiwidW5vcHRpbWl6ZWQiLCJxdWFsaXR5IiwibG9hZGVyIiwic3JjU2V0IiwibGFzdCIsImkiLCJqb2luIiwiX3N0YXRlIiwicHJpb3JpdHkiLCJsb2FkaW5nIiwiY2xhc3NOYW1lIiwiaGVpZ2h0IiwiZmlsbCIsInN0eWxlIiwib3ZlcnJpZGVTcmMiLCJvbkxvYWQiLCJvbkxvYWRpbmdDb21wbGV0ZSIsInBsYWNlaG9sZGVyIiwiYmx1ckRhdGFVUkwiLCJmZXRjaFByaW9yaXR5IiwiZGVjb2RpbmciLCJsYXlvdXQiLCJvYmplY3RGaXQiLCJvYmplY3RQb3NpdGlvbiIsImxhenlCb3VuZGFyeSIsImxhenlSb290IiwicmVzdCIsImltZ0NvbmYiLCJzaG93QWx0VGV4dCIsImJsdXJDb21wbGV0ZSIsImRlZmF1bHRMb2FkZXIiLCJjIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiaW1hZ2VTaXplcyIsInNvcnQiLCJhIiwiYiIsIkVycm9yIiwiaXNEZWZhdWx0TG9hZGVyIiwiY3VzdG9tSW1hZ2VMb2FkZXIiLCJvYmoiLCJfIiwib3B0cyIsImxheW91dFRvU3R5bGUiLCJpbnRyaW5zaWMiLCJtYXhXaWR0aCIsInJlc3BvbnNpdmUiLCJsYXlvdXRUb1NpemVzIiwibGF5b3V0U3R5bGUiLCJsYXlvdXRTaXplcyIsInN0YXRpY1NyYyIsIndpZHRoSW50IiwiaGVpZ2h0SW50IiwiYmx1cldpZHRoIiwiYmx1ckhlaWdodCIsInN0YXRpY0ltYWdlRGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyYXRpbyIsInJvdW5kIiwiaXNMYXp5Iiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwiZGFuZ2Vyb3VzbHlBbGxvd1NWRyIsInF1YWxpdHlJbnQiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJvdXRwdXQiLCJwb3NpdGlvbiIsImlzTmFOIiwiaW5jbHVkZXMiLCJTdHJpbmciLCJ3YXJuT25jZSIsIlZBTElEX0JMVVJfRVhUIiwidXJsU3RyIiwidXJsIiwiVVJMIiwiZXJyIiwicGF0aG5hbWUiLCJzZWFyY2giLCJsZWdhY3lLZXkiLCJsZWdhY3lWYWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJ3aW5kb3ciLCJQZXJmb3JtYW5jZU9ic2VydmVyIiwiZW50cnlMaXN0IiwiZW50cnkiLCJnZXRFbnRyaWVzIiwiaW1nU3JjIiwiZWxlbWVudCIsImxjcEltYWdlIiwiZ2V0Iiwib2JzZXJ2ZSIsInR5cGUiLCJidWZmZXJlZCIsImNvbnNvbGUiLCJlcnJvciIsImltZ1N0eWxlIiwiYXNzaWduIiwibGVmdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwiY29sb3IiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJnZXRJbWFnZUJsdXJTdmciLCJwbGFjZWhvbGRlclN0eWxlIiwiYmFja2dyb3VuZFNpemUiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJiYWNrZ3JvdW5kUmVwZWF0IiwiaW1nQXR0cmlidXRlcyIsImZ1bGxVcmwiLCJlIiwibG9jYXRpb24iLCJocmVmIiwic2V0IiwicHJvcHMiLCJtZXRhIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;\n    const std = 20;\n    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    const viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : '';\n    const preserveAspectRatio = viewBox ? 'none' : objectFit === 'contain' ? 'xMidYMid' : objectFit === 'cover' ? 'xMidYMid slice' : 'none';\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtYmx1ci1zdmcuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0NBRUM7Ozs7bURBQ2VBOzs7ZUFBQUE7OztBQUFULFNBQVNBLGdCQUFnQixLQWMvQjtJQWQrQixNQUM5QkMsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLFNBQVMsRUFRVixHQWQrQjtJQWU5QixNQUFNQyxNQUFNO0lBQ1osTUFBTUMsV0FBV0wsWUFBWUEsWUFBWSxLQUFLRjtJQUM5QyxNQUFNUSxZQUFZTCxhQUFhQSxhQUFhLEtBQUtGO0lBRWpELE1BQU1RLFVBQ0pGLFlBQVlDLFlBQWEsa0JBQWVELFdBQVMsTUFBR0MsWUFBVSxNQUFLO0lBQ3JFLE1BQU1FLHNCQUFzQkQsVUFDeEIsU0FDQUosY0FBYyxZQUNaLGFBQ0FBLGNBQWMsVUFDWixtQkFDQTtJQUVSLE9BQVEsK0NBQTRDSSxVQUFRLDhGQUEyRkgsTUFBSSxvUUFBaVFBLE1BQUksZ0dBQTZGSSxzQkFBb0Isd0NBQXFDTixjQUFZO0FBQ3BrQiIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi9zcmMvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgc2hhcmVkIGZ1bmN0aW9uLCB1c2VkIG9uIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIsIHRvIGdlbmVyYXRlIGEgU1ZHIGJsdXIgcGxhY2Vob2xkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbWFnZUJsdXJTdmcoe1xuICB3aWR0aEludCxcbiAgaGVpZ2h0SW50LFxuICBibHVyV2lkdGgsXG4gIGJsdXJIZWlnaHQsXG4gIGJsdXJEYXRhVVJMLFxuICBvYmplY3RGaXQsXG59OiB7XG4gIHdpZHRoSW50PzogbnVtYmVyXG4gIGhlaWdodEludD86IG51bWJlclxuICBibHVyV2lkdGg/OiBudW1iZXJcbiAgYmx1ckhlaWdodD86IG51bWJlclxuICBibHVyRGF0YVVSTDogc3RyaW5nXG4gIG9iamVjdEZpdD86IHN0cmluZ1xufSk6IHN0cmluZyB7XG4gIGNvbnN0IHN0ZCA9IDIwXG4gIGNvbnN0IHN2Z1dpZHRoID0gYmx1cldpZHRoID8gYmx1cldpZHRoICogNDAgOiB3aWR0aEludFxuICBjb25zdCBzdmdIZWlnaHQgPSBibHVySGVpZ2h0ID8gYmx1ckhlaWdodCAqIDQwIDogaGVpZ2h0SW50XG5cbiAgY29uc3Qgdmlld0JveCA9XG4gICAgc3ZnV2lkdGggJiYgc3ZnSGVpZ2h0ID8gYHZpZXdCb3g9JzAgMCAke3N2Z1dpZHRofSAke3N2Z0hlaWdodH0nYCA6ICcnXG4gIGNvbnN0IHByZXNlcnZlQXNwZWN0UmF0aW8gPSB2aWV3Qm94XG4gICAgPyAnbm9uZSdcbiAgICA6IG9iamVjdEZpdCA9PT0gJ2NvbnRhaW4nXG4gICAgICA/ICd4TWlkWU1pZCdcbiAgICAgIDogb2JqZWN0Rml0ID09PSAnY292ZXInXG4gICAgICAgID8gJ3hNaWRZTWlkIHNsaWNlJ1xuICAgICAgICA6ICdub25lJ1xuXG4gIHJldHVybiBgJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgJHt2aWV3Qm94fSUzRSUzQ2ZpbHRlciBpZD0nYicgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSdzUkdCJyUzRSUzQ2ZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0nJHtzdGR9Jy8lM0UlM0NmZUNvbG9yTWF0cml4IHZhbHVlcz0nMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMTAwIC0xJyByZXN1bHQ9J3MnLyUzRSUzQ2ZlRmxvb2QgeD0nMCcgeT0nMCcgd2lkdGg9JzEwMCUyNScgaGVpZ2h0PScxMDAlMjUnLyUzRSUzQ2ZlQ29tcG9zaXRlIG9wZXJhdG9yPSdvdXQnIGluPSdzJy8lM0UlM0NmZUNvbXBvc2l0ZSBpbjI9J1NvdXJjZUdyYXBoaWMnLyUzRSUzQ2ZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0nJHtzdGR9Jy8lM0UlM0MvZmlsdGVyJTNFJTNDaW1hZ2Ugd2lkdGg9JzEwMCUyNScgaGVpZ2h0PScxMDAlMjUnIHg9JzAnIHk9JzAnIHByZXNlcnZlQXNwZWN0UmF0aW89JyR7cHJlc2VydmVBc3BlY3RSYXRpb30nIHN0eWxlPSdmaWx0ZXI6IHVybCglMjNiKTsnIGhyZWY9JyR7Ymx1ckRhdGFVUkx9Jy8lM0UlM0Mvc3ZnJTNFYFxufVxuIl0sIm5hbWVzIjpbImdldEltYWdlQmx1clN2ZyIsIndpZHRoSW50IiwiaGVpZ2h0SW50IiwiYmx1cldpZHRoIiwiYmx1ckhlaWdodCIsImJsdXJEYXRhVVJMIiwib2JqZWN0Rml0Iiwic3RkIiwic3ZnV2lkdGgiLCJzdmdIZWlnaHQiLCJ2aWV3Qm94IiwicHJlc2VydmVBc3BlY3RSYXRpbyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/image-external.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-external.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return _default;\n    },\n    getImageProps: function() {\n        return getImageProps;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _getimgprops = __webpack_require__(/*! ./get-img-props */ \"./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imagecomponent = __webpack_require__(/*! ../../client/image-component */ \"./node_modules/next/dist/client/image-component.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"./node_modules/next/dist/shared/lib/image-loader.js\"));\nfunction getImageProps(imgProps) {\n    const { props } = (0, _getimgprops.getImgProps)(imgProps, {\n        defaultLoader: _imageloader.default,\n        // This is replaced by webpack define plugin\n        imgConf: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]}\n    });\n    // Normally we don't care about undefined props because we pass to JSX,\n    // but this exported function could be used by the end user for anything\n    // so we delete undefined props to clean it up a little.\n    for (const [key, value] of Object.entries(props)){\n        if (value === undefined) {\n            delete props[key];\n        }\n    }\n    return {\n        props\n    };\n}\nconst _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBaUNBLE9BQW9CO2VBQXBCOztJQWpCZ0JBLGFBQWE7ZUFBYkE7Ozs7eUNBYlk7NENBQ047a0ZBR0k7QUFTbkIsU0FBU0EsY0FBY0MsUUFBb0I7SUFDaEQsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBR0MsQ0FBQUEsR0FBQUEsYUFBQUEsV0FBQUEsRUFBWUYsVUFBVTtRQUN0Q0csZUFBQUEsYUFBQUEsT0FBYTtRQUNiLDRDQUE0QztRQUM1Q0MsU0FBU0MsME5BQTZCO0lBQ3hDO0lBQ0EsdUVBQXVFO0lBQ3ZFLHdFQUF3RTtJQUN4RSx3REFBd0Q7SUFDeEQsS0FBSyxNQUFNLENBQUNHLEtBQUtDLE1BQU0sSUFBSUMsT0FBT0MsT0FBTyxDQUFDVixPQUFRO1FBQ2hELElBQUlRLFVBQVVHLFdBQVc7WUFDdkIsT0FBT1gsS0FBSyxDQUFDTyxJQUEwQjtRQUN6QztJQUNGO0lBQ0EsT0FBTztRQUFFUDtJQUFNO0FBQ2pCO01BRUEsV0FBZVksZ0JBQUFBLEtBQUsiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvc3JjL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWwudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgSW1hZ2VDb25maWdDb21wbGV0ZSwgSW1hZ2VMb2FkZXJQcm9wcyB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHR5cGUgeyBJbWFnZVByb3BzLCBJbWFnZUxvYWRlciwgU3RhdGljSW1hZ2VEYXRhIH0gZnJvbSAnLi9nZXQtaW1nLXByb3BzJ1xuXG5pbXBvcnQgeyBnZXRJbWdQcm9wcyB9IGZyb20gJy4vZ2V0LWltZy1wcm9wcydcbmltcG9ydCB7IEltYWdlIH0gZnJvbSAnLi4vLi4vY2xpZW50L2ltYWdlLWNvbXBvbmVudCdcblxuLy8gQHRzLWlnbm9yZSAtIFRoaXMgaXMgcmVwbGFjZWQgYnkgd2VicGFjayBhbGlhc1xuaW1wb3J0IGRlZmF1bHRMb2FkZXIgZnJvbSAnbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyJ1xuXG4vKipcbiAqIEZvciBtb3JlIGFkdmFuY2VkIHVzZSBjYXNlcywgeW91IGNhbiBjYWxsIGBnZXRJbWFnZVByb3BzKClgXG4gKiB0byBnZXQgdGhlIHByb3BzIHRoYXQgd291bGQgYmUgcGFzc2VkIHRvIHRoZSB1bmRlcmx5aW5nIGA8aW1nPmAgZWxlbWVudCxcbiAqIGFuZCBpbnN0ZWFkIHBhc3MgdG8gdGhlbSB0byBhbm90aGVyIGNvbXBvbmVudCwgc3R5bGUsIGNhbnZhcywgZXRjLlxuICpcbiAqIFJlYWQgbW9yZTogW05leHQuanMgZG9jczogYGdldEltYWdlUHJvcHNgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2ltYWdlI2dldGltYWdlcHJvcHMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbWFnZVByb3BzKGltZ1Byb3BzOiBJbWFnZVByb3BzKSB7XG4gIGNvbnN0IHsgcHJvcHMgfSA9IGdldEltZ1Byb3BzKGltZ1Byb3BzLCB7XG4gICAgZGVmYXVsdExvYWRlcixcbiAgICAvLyBUaGlzIGlzIHJlcGxhY2VkIGJ5IHdlYnBhY2sgZGVmaW5lIHBsdWdpblxuICAgIGltZ0NvbmY6IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTIGFzIGFueSBhcyBJbWFnZUNvbmZpZ0NvbXBsZXRlLFxuICB9KVxuICAvLyBOb3JtYWxseSB3ZSBkb24ndCBjYXJlIGFib3V0IHVuZGVmaW5lZCBwcm9wcyBiZWNhdXNlIHdlIHBhc3MgdG8gSlNYLFxuICAvLyBidXQgdGhpcyBleHBvcnRlZCBmdW5jdGlvbiBjb3VsZCBiZSB1c2VkIGJ5IHRoZSBlbmQgdXNlciBmb3IgYW55dGhpbmdcbiAgLy8gc28gd2UgZGVsZXRlIHVuZGVmaW5lZCBwcm9wcyB0byBjbGVhbiBpdCB1cCBhIGxpdHRsZS5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSBwcm9wc1trZXkgYXMga2V5b2YgdHlwZW9mIHByb3BzXVxuICAgIH1cbiAgfVxuICByZXR1cm4geyBwcm9wcyB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEltYWdlXG5cbmV4cG9ydCB0eXBlIHsgSW1hZ2VQcm9wcywgSW1hZ2VMb2FkZXJQcm9wcywgSW1hZ2VMb2FkZXIsIFN0YXRpY0ltYWdlRGF0YSB9XG4iXSwibmFtZXMiOlsiZ2V0SW1hZ2VQcm9wcyIsImltZ1Byb3BzIiwicHJvcHMiLCJnZXRJbWdQcm9wcyIsImRlZmF1bHRMb2FkZXIiLCJpbWdDb25mIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJlbnRyaWVzIiwidW5kZWZpbmVkIiwiSW1hZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/image-external.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/image-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-loader.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nfunction defaultLoader(param) {\n    let { config, src, width, quality } = param;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push('src');\n        if (!width) missingValues.push('width');\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(', ') + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src,\n                width,\n                quality\n            }));\n        }\n        if (src.startsWith('//')) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (src.startsWith('/') && config.localPatterns) {\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasLocalMatch } = __webpack_require__(/*! ./match-local-pattern */ \"./node_modules/next/dist/shared/lib/match-local-pattern.js\");\n                if (!hasLocalMatch(config.localPatterns, src)) {\n                    throw new Error(\"Invalid src prop (\" + src + \") on `next/image` does not match `images.localPatterns` configured in your `next.config.js`\\n\" + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns\");\n                }\n            }\n        }\n        if (!src.startsWith('/') && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasRemoteMatch } = __webpack_require__(/*! ./match-remote-pattern */ \"./node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasRemoteMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75) + ( false ? 0 : '');\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nconst _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7MkNBeUZBOzs7ZUFBQTs7O0FBdkZBLFNBQVNBLGNBQWMsS0FLTTtJQUxOLE1BQ3JCQyxNQUFNLEVBQ05DLEdBQUcsRUFDSEMsS0FBSyxFQUNMQyxPQUFPLEVBQ29CLEdBTE47SUFNckIsSUFBSUMsSUFBb0IsRUFBbUI7UUFDekMsTUFBTUcsZ0JBQWdCLEVBQUU7UUFFeEIseURBQXlEO1FBQ3pELElBQUksQ0FBQ04sS0FBS00sY0FBY0MsSUFBSSxDQUFDO1FBQzdCLElBQUksQ0FBQ04sT0FBT0ssY0FBY0MsSUFBSSxDQUFDO1FBRS9CLElBQUlELGNBQWNFLE1BQU0sR0FBRyxHQUFHO1lBQzVCLE1BQU0sSUFBSUMsTUFDUCxzQ0FBbUNILGNBQWNJLElBQUksQ0FDcEQsUUFDQSxnR0FBK0ZDLEtBQUtDLFNBQVMsQ0FDN0c7Z0JBQUVaO2dCQUFLQztnQkFBT0M7WUFBUTtRQUc1QjtRQUVBLElBQUlGLElBQUlhLFVBQVUsQ0FBQyxPQUFPO1lBQ3hCLE1BQU0sSUFBSUosTUFDUCwwQkFBdUJULE1BQUk7UUFFaEM7UUFFQSxJQUFJQSxJQUFJYSxVQUFVLENBQUMsUUFBUWQsT0FBT2UsYUFBYSxFQUFFO1lBQy9DLElBRUUsSUFDbUMsRUFDbkM7Z0JBQ0EsdUVBQXVFO2dCQUN2RSxNQUFNLEVBQUVFLGFBQWEsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQyx5RkFBdUI7Z0JBQ3pELElBQUksQ0FBQ0QsY0FBY2pCLE9BQU9lLGFBQWEsRUFBRWQsTUFBTTtvQkFDN0MsTUFBTSxJQUFJUyxNQUNQLHVCQUFvQlQsTUFBSSxrR0FDdEI7Z0JBRVA7WUFDRjtRQUNGO1FBRUEsSUFBSSxDQUFDQSxJQUFJYSxVQUFVLENBQUMsUUFBU2QsQ0FBQUEsT0FBT21CLE9BQU8sSUFBSW5CLE9BQU9vQixjQUFBQSxHQUFpQjtZQUNyRSxJQUFJQztZQUNKLElBQUk7Z0JBQ0ZBLFlBQVksSUFBSUMsSUFBSXJCO1lBQ3RCLEVBQUUsT0FBT3NCLEtBQUs7Z0JBQ1pDLFFBQVFDLEtBQUssQ0FBQ0Y7Z0JBQ2QsTUFBTSxJQUFJYixNQUNQLDBCQUF1QlQsTUFBSTtZQUVoQztZQUVBLElBQ0VHLElBRW1DLEVBQ25DO2dCQUNBLHVFQUF1RTtnQkFDdkUsTUFBTSxFQUFFc0IsY0FBYyxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDLDJGQUF3QjtnQkFDM0QsSUFBSSxDQUFDUSxlQUFlMUIsT0FBT21CLE9BQU8sRUFBRW5CLE9BQU9vQixjQUFjLEVBQUVDLFlBQVk7b0JBQ3JFLE1BQU0sSUFBSVgsTUFDUCx1QkFBb0JULE1BQUksa0NBQWlDb0IsVUFBVU0sUUFBUSxHQUFDLGdFQUMxRTtnQkFFUDtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE9BQVUzQixPQUFPNEIsSUFBSSxHQUFDLFVBQU9DLG1CQUFtQjVCLE9BQUssUUFBS0MsUUFBTSxRQUM5REMsQ0FBQUEsV0FBVyxHQUFDLElBRVpDLE1BQThCLEdBQ3pCLENBQXFDLEdBQ3RDLEdBQUM7QUFFVDtBQUVBLCtEQUErRDtBQUMvRCwyREFBMkQ7QUFDM0RMLGNBQWNnQyxrQkFBa0IsR0FBRztNQUVuQyxXQUFlaEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvc3JjL3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgSW1hZ2VMb2FkZXJQcm9wc1dpdGhDb25maWcgfSBmcm9tICcuL2ltYWdlLWNvbmZpZydcblxuZnVuY3Rpb24gZGVmYXVsdExvYWRlcih7XG4gIGNvbmZpZyxcbiAgc3JjLFxuICB3aWR0aCxcbiAgcXVhbGl0eSxcbn06IEltYWdlTG9hZGVyUHJvcHNXaXRoQ29uZmlnKTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25zdCBtaXNzaW5nVmFsdWVzID0gW11cblxuICAgIC8vIHRoZXNlIHNob3VsZCBhbHdheXMgYmUgcHJvdmlkZWQgYnV0IG1ha2Ugc3VyZSB0aGV5IGFyZVxuICAgIGlmICghc3JjKSBtaXNzaW5nVmFsdWVzLnB1c2goJ3NyYycpXG4gICAgaWYgKCF3aWR0aCkgbWlzc2luZ1ZhbHVlcy5wdXNoKCd3aWR0aCcpXG5cbiAgICBpZiAobWlzc2luZ1ZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBOZXh0IEltYWdlIE9wdGltaXphdGlvbiByZXF1aXJlcyAke21pc3NpbmdWYWx1ZXMuam9pbihcbiAgICAgICAgICAnLCAnXG4gICAgICAgICl9IHRvIGJlIHByb3ZpZGVkLiBNYWtlIHN1cmUgeW91IHBhc3MgdGhlbSBhcyBwcm9wcyB0byB0aGUgXFxgbmV4dC9pbWFnZVxcYCBjb21wb25lbnQuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHsgc3JjLCB3aWR0aCwgcXVhbGl0eSB9XG4gICAgICAgICl9YFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChzcmMuc3RhcnRzV2l0aCgnLy8nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHBhcnNlIHNyYyBcIiR7c3JjfVwiIG9uIFxcYG5leHQvaW1hZ2VcXGAsIHByb3RvY29sLXJlbGF0aXZlIFVSTCAoLy8pIG11c3QgYmUgY2hhbmdlZCB0byBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pYFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChzcmMuc3RhcnRzV2l0aCgnLycpICYmIGNvbmZpZy5sb2NhbFBhdHRlcm5zKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgLy8gbWljcm9tYXRjaCBpc24ndCBjb21wYXRpYmxlIHdpdGggZWRnZSBydW50aW1lXG4gICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSAhPT0gJ2VkZ2UnXG4gICAgICApIHtcbiAgICAgICAgLy8gV2UgdXNlIGR5bmFtaWMgcmVxdWlyZSBiZWNhdXNlIHRoaXMgc2hvdWxkIG9ubHkgZXJyb3IgaW4gZGV2ZWxvcG1lbnRcbiAgICAgICAgY29uc3QgeyBoYXNMb2NhbE1hdGNoIH0gPSByZXF1aXJlKCcuL21hdGNoLWxvY2FsLXBhdHRlcm4nKVxuICAgICAgICBpZiAoIWhhc0xvY2FsTWF0Y2goY29uZmlnLmxvY2FsUGF0dGVybnMsIHNyYykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCBzcmMgcHJvcCAoJHtzcmN9KSBvbiBcXGBuZXh0L2ltYWdlXFxgIGRvZXMgbm90IG1hdGNoIFxcYGltYWdlcy5sb2NhbFBhdHRlcm5zXFxgIGNvbmZpZ3VyZWQgaW4geW91ciBcXGBuZXh0LmNvbmZpZy5qc1xcYFxcbmAgK1xuICAgICAgICAgICAgICBgU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvbmV4dC1pbWFnZS11bmNvbmZpZ3VyZWQtbG9jYWxwYXR0ZXJuc2BcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNyYy5zdGFydHNXaXRoKCcvJykgJiYgKGNvbmZpZy5kb21haW5zIHx8IGNvbmZpZy5yZW1vdGVQYXR0ZXJucykpIHtcbiAgICAgIGxldCBwYXJzZWRTcmM6IFVSTFxuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkU3JjID0gbmV3IFVSTChzcmMpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIHBhcnNlIHNyYyBcIiR7c3JjfVwiIG9uIFxcYG5leHQvaW1hZ2VcXGAsIGlmIHVzaW5nIHJlbGF0aXZlIGltYWdlIGl0IG11c3Qgc3RhcnQgd2l0aCBhIGxlYWRpbmcgc2xhc2ggXCIvXCIgb3IgYmUgYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKWBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgLy8gbWljcm9tYXRjaCBpc24ndCBjb21wYXRpYmxlIHdpdGggZWRnZSBydW50aW1lXG4gICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSAhPT0gJ2VkZ2UnXG4gICAgICApIHtcbiAgICAgICAgLy8gV2UgdXNlIGR5bmFtaWMgcmVxdWlyZSBiZWNhdXNlIHRoaXMgc2hvdWxkIG9ubHkgZXJyb3IgaW4gZGV2ZWxvcG1lbnRcbiAgICAgICAgY29uc3QgeyBoYXNSZW1vdGVNYXRjaCB9ID0gcmVxdWlyZSgnLi9tYXRjaC1yZW1vdGUtcGF0dGVybicpXG4gICAgICAgIGlmICghaGFzUmVtb3RlTWF0Y2goY29uZmlnLmRvbWFpbnMsIGNvbmZpZy5yZW1vdGVQYXR0ZXJucywgcGFyc2VkU3JjKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHNyYyBwcm9wICgke3NyY30pIG9uIFxcYG5leHQvaW1hZ2VcXGAsIGhvc3RuYW1lIFwiJHtwYXJzZWRTcmMuaG9zdG5hbWV9XCIgaXMgbm90IGNvbmZpZ3VyZWQgdW5kZXIgaW1hZ2VzIGluIHlvdXIgXFxgbmV4dC5jb25maWcuanNcXGBcXG5gICtcbiAgICAgICAgICAgICAgYFNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtdW5jb25maWd1cmVkLWhvc3RgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGAke2NvbmZpZy5wYXRofT91cmw9JHtlbmNvZGVVUklDb21wb25lbnQoc3JjKX0mdz0ke3dpZHRofSZxPSR7XG4gICAgcXVhbGl0eSB8fCA3NVxuICB9JHtcbiAgICBwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSURcbiAgICAgID8gYCZkcGw9JHtwcm9jZXNzLmVudi5ORVhUX0RFUExPWU1FTlRfSUR9YFxuICAgICAgOiAnJ1xuICB9YFxufVxuXG4vLyBXZSB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaWYgdGhlIGltcG9ydCBpcyB0aGUgZGVmYXVsdCBsb2FkZXJcbi8vIG9yIGEgY3VzdG9tIGxvYWRlciBkZWZpbmVkIGJ5IHRoZSB1c2VyIGluIG5leHQuY29uZmlnLmpzXG5kZWZhdWx0TG9hZGVyLl9fbmV4dF9pbWdfZGVmYXVsdCA9IHRydWVcblxuZXhwb3J0IGRlZmF1bHQgZGVmYXVsdExvYWRlclxuIl0sIm5hbWVzIjpbImRlZmF1bHRMb2FkZXIiLCJjb25maWciLCJzcmMiLCJ3aWR0aCIsInF1YWxpdHkiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJtaXNzaW5nVmFsdWVzIiwicHVzaCIsImxlbmd0aCIsIkVycm9yIiwiam9pbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGFydHNXaXRoIiwibG9jYWxQYXR0ZXJucyIsIk5FWFRfUlVOVElNRSIsImhhc0xvY2FsTWF0Y2giLCJyZXF1aXJlIiwiZG9tYWlucyIsInJlbW90ZVBhdHRlcm5zIiwicGFyc2VkU3JjIiwiVVJMIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiaGFzUmVtb3RlTWF0Y2giLCJob3N0bmFtZSIsInBhdGgiLCJlbmNvZGVVUklDb21wb25lbnQiLCJORVhUX0RFUExPWU1FTlRfSUQiLCJfX25leHRfaW1nX2RlZmF1bHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/match-local-pattern.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-local-pattern.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasLocalMatch: function() {\n        return hasLocalMatch;\n    },\n    matchLocalPattern: function() {\n        return matchLocalPattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"./node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchLocalPattern(pattern, url) {\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasLocalMatch(localPatterns, urlPathAndQuery) {\n    if (!localPatterns) {\n        // if the user didn't define \"localPatterns\", we allow all local images\n        return true;\n    }\n    const url = new URL(urlPathAndQuery, 'http://n');\n    return localPatterns.some((p)=>matchLocalPattern(p, url));\n} //# sourceMappingURL=match-local-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbWF0Y2gtbG9jYWwtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUFrQmdCQSxhQUFhO2VBQWJBOztJQWRBQyxpQkFBaUI7ZUFBakJBOzs7dUNBSE87QUFHaEIsU0FBU0Esa0JBQWtCQyxPQUFxQixFQUFFQyxHQUFRO0lBQy9ELElBQUlELFFBQVFFLE1BQU0sS0FBS0MsV0FBVztRQUNoQyxJQUFJSCxRQUFRRSxNQUFNLEtBQUtELElBQUlDLE1BQU0sRUFBRTtZQUNqQyxPQUFPO1FBQ1Q7SUFDRjtRQUVZRjtJQUFaLElBQUksQ0FBQ0ksQ0FBQUEsR0FBQUEsV0FBQUEsTUFBQUEsRUFBT0osQ0FBQUEsb0JBQUFBLFFBQVFLLFFBQUFBLEtBQVEsT0FBaEJMLG9CQUFvQixNQUFNO1FBQUVNLEtBQUs7SUFBSyxHQUFHQyxJQUFJLENBQUNOLElBQUlJLFFBQVEsR0FBRztRQUN2RSxPQUFPO0lBQ1Q7SUFFQSxPQUFPO0FBQ1Q7QUFFTyxTQUFTUCxjQUNkVSxhQUF5QyxFQUN6Q0MsZUFBdUI7SUFFdkIsSUFBSSxDQUFDRCxlQUFlO1FBQ2xCLHVFQUF1RTtRQUN2RSxPQUFPO0lBQ1Q7SUFDQSxNQUFNUCxNQUFNLElBQUlTLElBQUlELGlCQUFpQjtJQUNyQyxPQUFPRCxjQUFjRyxJQUFJLENBQUMsQ0FBQ0MsSUFBTWIsa0JBQWtCYSxHQUFHWDtBQUN4RCIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi9zcmMvc2hhcmVkL2xpYi9tYXRjaC1sb2NhbC1wYXR0ZXJuLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTG9jYWxQYXR0ZXJuIH0gZnJvbSAnLi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyBtYWtlUmUgfSBmcm9tICduZXh0L2Rpc3QvY29tcGlsZWQvcGljb21hdGNoJ1xuXG4vLyBNb2RpZnlpbmcgdGhpcyBmdW5jdGlvbiBzaG91bGQgYWxzbyBtb2RpZnkgd3JpdGVJbWFnZXNNYW5pZmVzdCgpXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hMb2NhbFBhdHRlcm4ocGF0dGVybjogTG9jYWxQYXR0ZXJuLCB1cmw6IFVSTCk6IGJvb2xlYW4ge1xuICBpZiAocGF0dGVybi5zZWFyY2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwYXR0ZXJuLnNlYXJjaCAhPT0gdXJsLnNlYXJjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgaWYgKCFtYWtlUmUocGF0dGVybi5wYXRobmFtZSA/PyAnKionLCB7IGRvdDogdHJ1ZSB9KS50ZXN0KHVybC5wYXRobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNMb2NhbE1hdGNoKFxuICBsb2NhbFBhdHRlcm5zOiBMb2NhbFBhdHRlcm5bXSB8IHVuZGVmaW5lZCxcbiAgdXJsUGF0aEFuZFF1ZXJ5OiBzdHJpbmdcbik6IGJvb2xlYW4ge1xuICBpZiAoIWxvY2FsUGF0dGVybnMpIHtcbiAgICAvLyBpZiB0aGUgdXNlciBkaWRuJ3QgZGVmaW5lIFwibG9jYWxQYXR0ZXJuc1wiLCB3ZSBhbGxvdyBhbGwgbG9jYWwgaW1hZ2VzXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBjb25zdCB1cmwgPSBuZXcgVVJMKHVybFBhdGhBbmRRdWVyeSwgJ2h0dHA6Ly9uJylcbiAgcmV0dXJuIGxvY2FsUGF0dGVybnMuc29tZSgocCkgPT4gbWF0Y2hMb2NhbFBhdHRlcm4ocCwgdXJsKSlcbn1cbiJdLCJuYW1lcyI6WyJoYXNMb2NhbE1hdGNoIiwibWF0Y2hMb2NhbFBhdHRlcm4iLCJwYXR0ZXJuIiwidXJsIiwic2VhcmNoIiwidW5kZWZpbmVkIiwibWFrZVJlIiwicGF0aG5hbWUiLCJkb3QiLCJ0ZXN0IiwibG9jYWxQYXR0ZXJucyIsInVybFBhdGhBbmRRdWVyeSIsIlVSTCIsInNvbWUiLCJwIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/match-local-pattern.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    hasRemoteMatch: function() {\n        return hasRemoteMatch;\n    },\n    matchRemotePattern: function() {\n        return matchRemotePattern;\n    }\n});\nconst _picomatch = __webpack_require__(/*! next/dist/compiled/picomatch */ \"./node_modules/next/dist/compiled/picomatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        const actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _picomatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    if (pattern.search !== undefined) {\n        if (pattern.search !== url.search) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    // Should be the same as writeImagesManifest()\n    if (!(0, _picomatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : '**', {\n        dot: true\n    }).test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasRemoteMatch(domains, remotePatterns, url) {\n    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvbWF0Y2gtcmVtb3RlLXBhdHRlcm4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBeUNnQkEsY0FBYztlQUFkQTs7SUFyQ0FDLGtCQUFrQjtlQUFsQkE7Ozt1Q0FITztBQUdoQixTQUFTQSxtQkFBbUJDLE9BQXNCLEVBQUVDLEdBQVE7SUFDakUsSUFBSUQsUUFBUUUsUUFBUSxLQUFLQyxXQUFXO1FBQ2xDLE1BQU1DLGNBQWNILElBQUlDLFFBQVEsQ0FBQ0csS0FBSyxDQUFDLEdBQUcsQ0FBQztRQUMzQyxJQUFJTCxRQUFRRSxRQUFRLEtBQUtFLGFBQWE7WUFDcEMsT0FBTztRQUNUO0lBQ0Y7SUFDQSxJQUFJSixRQUFRTSxJQUFJLEtBQUtILFdBQVc7UUFDOUIsSUFBSUgsUUFBUU0sSUFBSSxLQUFLTCxJQUFJSyxJQUFJLEVBQUU7WUFDN0IsT0FBTztRQUNUO0lBQ0Y7SUFFQSxJQUFJTixRQUFRTyxRQUFRLEtBQUtKLFdBQVc7UUFDbEMsTUFBTSxJQUFJSyxNQUNQLCtDQUE0Q0MsS0FBS0MsU0FBUyxDQUFDVjtJQUVoRSxPQUFPO1FBQ0wsSUFBSSxDQUFDVyxDQUFBQSxHQUFBQSxXQUFBQSxNQUFBQSxFQUFPWCxRQUFRTyxRQUFRLEVBQUVLLElBQUksQ0FBQ1gsSUFBSU0sUUFBUSxHQUFHO1lBQ2hELE9BQU87UUFDVDtJQUNGO0lBRUEsSUFBSVAsUUFBUWEsTUFBTSxLQUFLVixXQUFXO1FBQ2hDLElBQUlILFFBQVFhLE1BQU0sS0FBS1osSUFBSVksTUFBTSxFQUFFO1lBQ2pDLE9BQU87UUFDVDtJQUNGO1FBR1liO0lBRFosOENBQThDO0lBQzlDLElBQUksQ0FBQ1csQ0FBQUEsR0FBQUEsV0FBQUEsTUFBQUEsRUFBT1gsQ0FBQUEsb0JBQUFBLFFBQVFjLFFBQUFBLEtBQVEsT0FBaEJkLG9CQUFvQixNQUFNO1FBQUVlLEtBQUs7SUFBSyxHQUFHSCxJQUFJLENBQUNYLElBQUlhLFFBQVEsR0FBRztRQUN2RSxPQUFPO0lBQ1Q7SUFFQSxPQUFPO0FBQ1Q7QUFFTyxTQUFTaEIsZUFDZGtCLE9BQWlCLEVBQ2pCQyxjQUErQixFQUMvQmhCLEdBQVE7SUFFUixPQUNFZSxRQUFRRSxJQUFJLENBQUMsQ0FBQ0MsU0FBV2xCLElBQUlNLFFBQVEsS0FBS1ksV0FDMUNGLGVBQWVDLElBQUksQ0FBQyxDQUFDRSxJQUFNckIsbUJBQW1CcUIsR0FBR25CO0FBRXJEIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3NyYy9zaGFyZWQvbGliL21hdGNoLXJlbW90ZS1wYXR0ZXJuLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgUmVtb3RlUGF0dGVybiB9IGZyb20gJy4vaW1hZ2UtY29uZmlnJ1xuaW1wb3J0IHsgbWFrZVJlIH0gZnJvbSAnbmV4dC9kaXN0L2NvbXBpbGVkL3BpY29tYXRjaCdcblxuLy8gTW9kaWZ5aW5nIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGFsc28gbW9kaWZ5IHdyaXRlSW1hZ2VzTWFuaWZlc3QoKVxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUmVtb3RlUGF0dGVybihwYXR0ZXJuOiBSZW1vdGVQYXR0ZXJuLCB1cmw6IFVSTCk6IGJvb2xlYW4ge1xuICBpZiAocGF0dGVybi5wcm90b2NvbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYWN0dWFsUHJvdG8gPSB1cmwucHJvdG9jb2wuc2xpY2UoMCwgLTEpXG4gICAgaWYgKHBhdHRlcm4ucHJvdG9jb2wgIT09IGFjdHVhbFByb3RvKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgaWYgKHBhdHRlcm4ucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBhdHRlcm4ucG9ydCAhPT0gdXJsLnBvcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmIChwYXR0ZXJuLmhvc3RuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUGF0dGVybiBzaG91bGQgZGVmaW5lIGhvc3RuYW1lIGJ1dCBmb3VuZFxcbiR7SlNPTi5zdHJpbmdpZnkocGF0dGVybil9YFxuICAgIClcbiAgfSBlbHNlIHtcbiAgICBpZiAoIW1ha2VSZShwYXR0ZXJuLmhvc3RuYW1lKS50ZXN0KHVybC5ob3N0bmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGlmIChwYXR0ZXJuLnNlYXJjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHBhdHRlcm4uc2VhcmNoICE9PSB1cmwuc2VhcmNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBTaG91bGQgYmUgdGhlIHNhbWUgYXMgd3JpdGVJbWFnZXNNYW5pZmVzdCgpXG4gIGlmICghbWFrZVJlKHBhdHRlcm4ucGF0aG5hbWUgPz8gJyoqJywgeyBkb3Q6IHRydWUgfSkudGVzdCh1cmwucGF0aG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzUmVtb3RlTWF0Y2goXG4gIGRvbWFpbnM6IHN0cmluZ1tdLFxuICByZW1vdGVQYXR0ZXJuczogUmVtb3RlUGF0dGVybltdLFxuICB1cmw6IFVSTFxuKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgZG9tYWlucy5zb21lKChkb21haW4pID0+IHVybC5ob3N0bmFtZSA9PT0gZG9tYWluKSB8fFxuICAgIHJlbW90ZVBhdHRlcm5zLnNvbWUoKHApID0+IG1hdGNoUmVtb3RlUGF0dGVybihwLCB1cmwpKVxuICApXG59XG4iXSwibmFtZXMiOlsiaGFzUmVtb3RlTWF0Y2giLCJtYXRjaFJlbW90ZVBhdHRlcm4iLCJwYXR0ZXJuIiwidXJsIiwicHJvdG9jb2wiLCJ1bmRlZmluZWQiLCJhY3R1YWxQcm90byIsInNsaWNlIiwicG9ydCIsImhvc3RuYW1lIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwibWFrZVJlIiwidGVzdCIsInNlYXJjaCIsInBhdGhuYW1lIiwiZG90IiwiZG9tYWlucyIsInJlbW90ZVBhdHRlcm5zIiwic29tZSIsImRvbWFpbiIsInAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "./src/hooks/useInterval.js":
/*!**********************************!*\
  !*** ./src/hooks/useInterval.js ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useInterval: () => (/* binding */ useInterval)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// https://overreacted.io/making-setinterval-declarative-with-react-hooks/\nvar _s = $RefreshSig$();\n\n/**\n * Wrapper for setInterval\n * @param {function} callback triggered continuously based on delay\n * @param {number|null} delay in milliseconds, null pauses/stops the interval\n * @param {boolean} tickAtStart fire the callback once immediately\n */ function useInterval(callback, delay, tickAtStart) {\n    _s();\n    const savedCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const [hasTickedAtStart, setHasTickedAtStart] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Remember the latest callback\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useInterval.useEffect\": ()=>{\n            savedCallback.current = callback;\n        }\n    }[\"useInterval.useEffect\"]);\n    // Set up the interval\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useInterval.useEffect\": ()=>{\n            function tick() {\n                if (typeof savedCallback.current === 'function') {\n                    savedCallback.current();\n                }\n            }\n            // Passing null as delay = pause\n            if (delay !== null) {\n                const id = setInterval(tick, delay);\n                if (tickAtStart && !hasTickedAtStart) {\n                    setHasTickedAtStart(true);\n                    tick();\n                }\n                return ({\n                    \"useInterval.useEffect\": ()=>clearInterval(id)\n                })[\"useInterval.useEffect\"];\n            }\n        }\n    }[\"useInterval.useEffect\"], [\n        delay,\n        hasTickedAtStart,\n        tickAtStart\n    ]);\n} // Example:\n /* function Counter() {\n  const [delay, setDelay] = useState(1000);\n  const [count, setCount] = useState(0);\n\n  // Basic interval: update the counter every <delay>ms\n  useInterval(() => {\n    setCount(count + 1);\n  }, delay);\n\n  // Another interval that makes the first one go faster every second\n  useInterval(() => {\n    if (delay > 10) {\n      setDelay(delay / 2);\n    }\n  }, 1000);\n\n  function handleReset() {\n    setDelay(1000);\n  }\n\n  return (\n    <>\n      <h1>Counter: {count}</h1>\n      <h4>Delay: {delay}</h4>\n      <button onClick={handleReset}>\n        Reset delay\n      </button>\n    </>\n  );\n} */ \n_s(useInterval, \"JKIff7xN/Qd2Op3+oosjOpMcOCs=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaG9va3MvdXNlSW50ZXJ2YWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMEVBQTBFOztBQUV0QjtBQUVwRDs7Ozs7Q0FLQyxHQUNNLFNBQVNHLFlBQVlDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxXQUFXOztJQUN0RCxNQUFNQyxnQkFBZ0JOLDZDQUFNQTtJQUM1QixNQUFNLENBQUNPLGtCQUFrQkMsb0JBQW9CLEdBQUdQLCtDQUFRQSxDQUFDO0lBRXpELCtCQUErQjtJQUMvQkYsZ0RBQVNBO2lDQUFDO1lBQ1JPLGNBQWNHLE9BQU8sR0FBR047UUFDMUI7O0lBRUEsc0JBQXNCO0lBQ3RCSixnREFBU0E7aUNBQUM7WUFDUixTQUFTVztnQkFDUCxJQUFJLE9BQU9KLGNBQWNHLE9BQU8sS0FBSyxZQUFZO29CQUMvQ0gsY0FBY0csT0FBTztnQkFDdkI7WUFDRjtZQUNBLGdDQUFnQztZQUNoQyxJQUFJTCxVQUFVLE1BQU07Z0JBQ2xCLE1BQU1PLEtBQUtDLFlBQVlGLE1BQU1OO2dCQUM3QixJQUFJQyxlQUFlLENBQUNFLGtCQUFrQjtvQkFDcENDLG9CQUFvQjtvQkFDcEJFO2dCQUNGO2dCQUNBOzZDQUFPLElBQU1HLGNBQWNGOztZQUM3QjtRQUNGO2dDQUFHO1FBQUNQO1FBQU9HO1FBQWtCRjtLQUFZO0FBQzNDLEVBRUEsV0FBVztDQUVYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQTZCRTtHQTNEY0giLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9zcmMvaG9va3MvdXNlSW50ZXJ2YWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9vdmVycmVhY3RlZC5pby9tYWtpbmctc2V0aW50ZXJ2YWwtZGVjbGFyYXRpdmUtd2l0aC1yZWFjdC1ob29rcy9cblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFdyYXBwZXIgZm9yIHNldEludGVydmFsXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayB0cmlnZ2VyZWQgY29udGludW91c2x5IGJhc2VkIG9uIGRlbGF5XG4gKiBAcGFyYW0ge251bWJlcnxudWxsfSBkZWxheSBpbiBtaWxsaXNlY29uZHMsIG51bGwgcGF1c2VzL3N0b3BzIHRoZSBpbnRlcnZhbFxuICogQHBhcmFtIHtib29sZWFufSB0aWNrQXRTdGFydCBmaXJlIHRoZSBjYWxsYmFjayBvbmNlIGltbWVkaWF0ZWx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnRlcnZhbChjYWxsYmFjaywgZGVsYXksIHRpY2tBdFN0YXJ0KSB7XG4gIGNvbnN0IHNhdmVkQ2FsbGJhY2sgPSB1c2VSZWYoKTtcbiAgY29uc3QgW2hhc1RpY2tlZEF0U3RhcnQsIHNldEhhc1RpY2tlZEF0U3RhcnRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIFJlbWVtYmVyIHRoZSBsYXRlc3QgY2FsbGJhY2tcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzYXZlZENhbGxiYWNrLmN1cnJlbnQgPSBjYWxsYmFjaztcbiAgfSk7XG5cbiAgLy8gU2V0IHVwIHRoZSBpbnRlcnZhbFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICBpZiAodHlwZW9mIHNhdmVkQ2FsbGJhY2suY3VycmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzYXZlZENhbGxiYWNrLmN1cnJlbnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUGFzc2luZyBudWxsIGFzIGRlbGF5ID0gcGF1c2VcbiAgICBpZiAoZGVsYXkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGlkID0gc2V0SW50ZXJ2YWwodGljaywgZGVsYXkpO1xuICAgICAgaWYgKHRpY2tBdFN0YXJ0ICYmICFoYXNUaWNrZWRBdFN0YXJ0KSB7XG4gICAgICAgIHNldEhhc1RpY2tlZEF0U3RhcnQodHJ1ZSk7XG4gICAgICAgIHRpY2soKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGlkKTtcbiAgICB9XG4gIH0sIFtkZWxheSwgaGFzVGlja2VkQXRTdGFydCwgdGlja0F0U3RhcnRdKTtcbn1cblxuLy8gRXhhbXBsZTpcblxuLyogZnVuY3Rpb24gQ291bnRlcigpIHtcbiAgY29uc3QgW2RlbGF5LCBzZXREZWxheV0gPSB1c2VTdGF0ZSgxMDAwKTtcbiAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSgwKTtcblxuICAvLyBCYXNpYyBpbnRlcnZhbDogdXBkYXRlIHRoZSBjb3VudGVyIGV2ZXJ5IDxkZWxheT5tc1xuICB1c2VJbnRlcnZhbCgoKSA9PiB7XG4gICAgc2V0Q291bnQoY291bnQgKyAxKTtcbiAgfSwgZGVsYXkpO1xuXG4gIC8vIEFub3RoZXIgaW50ZXJ2YWwgdGhhdCBtYWtlcyB0aGUgZmlyc3Qgb25lIGdvIGZhc3RlciBldmVyeSBzZWNvbmRcbiAgdXNlSW50ZXJ2YWwoKCkgPT4ge1xuICAgIGlmIChkZWxheSA+IDEwKSB7XG4gICAgICBzZXREZWxheShkZWxheSAvIDIpO1xuICAgIH1cbiAgfSwgMTAwMCk7XG5cbiAgZnVuY3Rpb24gaGFuZGxlUmVzZXQoKSB7XG4gICAgc2V0RGVsYXkoMTAwMCk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8aDE+Q291bnRlcjoge2NvdW50fTwvaDE+XG4gICAgICA8aDQ+RGVsYXk6IHtkZWxheX08L2g0PlxuICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtoYW5kbGVSZXNldH0+XG4gICAgICAgIFJlc2V0IGRlbGF5XG4gICAgICA8L2J1dHRvbj5cbiAgICA8Lz5cbiAgKTtcbn0gKi9cbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUludGVydmFsIiwiY2FsbGJhY2siLCJkZWxheSIsInRpY2tBdFN0YXJ0Iiwic2F2ZWRDYWxsYmFjayIsImhhc1RpY2tlZEF0U3RhcnQiLCJzZXRIYXNUaWNrZWRBdFN0YXJ0IiwiY3VycmVudCIsInRpY2siLCJpZCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/hooks/useInterval.js\n"));

/***/ }),

/***/ "./src/pages/index.tsx":
/*!*****************************!*\
  !*** ./src/pages/index.tsx ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var satoshi_bitcoin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! satoshi-bitcoin */ \"./node_modules/satoshi-bitcoin/index.js\");\n/* harmony import */ var satoshi_bitcoin__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(satoshi_bitcoin__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/styles/Home.module.css */ \"./src/styles/Home.module.css\");\n/* harmony import */ var _styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var bitcoinjs_lib__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! bitcoinjs-lib */ \"./node_modules/bitcoinjs-lib/src/index.js\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _hooks_useInterval__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../hooks/useInterval */ \"./src/hooks/useInterval.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nconst MDO_ADDRESS = 'DAHkCF5LajV6jYyi5o4eMvtpqXRcm9eZYq';\nfunction Home() {\n    _s();\n    const [btnText, setBtnText] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('Connect');\n    const [connected, setConnected] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(false);\n    const [address, setAddress] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('');\n    const [balance, setBalance] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(0);\n    const [txId, setTxId] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('');\n    const [inscriptionLocation, setinscriptionLocation] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('');\n    const [recipientAddress, setRecipientAddress] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(MDO_ADDRESS);\n    const [drc20Ticker, setDrc20Ticker] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('');\n    const [drc20Available, setDrc20Available] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('');\n    const [drc20Transferable, setDrc20Transferable] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('');\n    const [drc20Inscriptions, setDrc20Inscriptions] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)([]);\n    const [drc20Amount, setDrc20Amount] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('');\n    const [dunesTicker, setDunesTicker] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('');\n    const [dunesBalance, setDunesBalance] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('');\n    const [dunesAmount, setDunesAmount] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('');\n    const [rawTx, setRawTx] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('');\n    const [psbtIndexes, setPsbtIndexes] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)([\n        1,\n        2\n    ]);\n    const [signMessage, setSignMessage] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('');\n    const [decryptMessage, setDecryptMessage] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('');\n    const [myDoge, setMyDoge] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)();\n    const intervalRef = (0,react__WEBPACK_IMPORTED_MODULE_5__.useRef)();\n    // 多输出和 OP_RETURN 配置\n    const [recipient1Address, setRecipient1Address] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)(\"2N7ZSoAA7zMnCFovU5qXXcyqCLnEHTrnQY8\");\n    const [recipient1Amount, setRecipient1Amount] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('2');\n    const [recipient2Address, setRecipient2Address] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('nq5qTGSppHq2uAawXqQcqCtr5sdf9pyuHX');\n    const [recipient2Amount, setRecipient2Amount] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('0.1');\n    const [opReturnText, setOpReturnText] = (0,react__WEBPACK_IMPORTED_MODULE_5__.useState)('00Bb8Bc29695232088b1A2dbc117E8C6006478c295');\n    (0,react__WEBPACK_IMPORTED_MODULE_5__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            if (!myDoge) {\n                const onInit = {\n                    \"Home.useEffect.onInit\": ()=>{\n                        const { doge } = window;\n                        setMyDoge(doge);\n                        window.removeEventListener('doge#initialized', onInit);\n                        console.log('MyDoge API injected from event');\n                    }\n                }[\"Home.useEffect.onInit\"];\n                window.addEventListener('doge#initialized', onInit, {\n                    once: true\n                });\n            }\n        }\n    }[\"Home.useEffect\"], [\n        myDoge\n    ]);\n    // Handle dev edge case where component mounts after MyDoge is initialized\n    (0,react__WEBPACK_IMPORTED_MODULE_5__.useEffect)({\n        \"Home.useEffect\": ()=>{\n            if (!myDoge && !intervalRef.current) {\n                intervalRef.current = setInterval({\n                    \"Home.useEffect\": ()=>{\n                        const { doge } = window;\n                        if (doge === null || doge === void 0 ? void 0 : doge.isMyDoge) {\n                            setMyDoge(doge);\n                            clearInterval(intervalRef.current);\n                            console.log('MyDoge API injected from interval');\n                        } else {\n                            console.log('MyDoge API not injected');\n                        }\n                    }\n                }[\"Home.useEffect\"], 1000);\n            }\n        }\n    }[\"Home.useEffect\"], [\n        myDoge\n    ]);\n    const onConnect = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[onConnect]\": async ()=>{\n            console.log('onConnect called, myDoge:', myDoge);\n            console.log('current connected state:', connected);\n            if (!(myDoge === null || myDoge === void 0 ? void 0 : myDoge.isMyDoge)) {\n                alert(\"MyDoge not installed! Please install the MyDoge browser extension.\");\n                return;\n            }\n            try {\n                if (connected) {\n                    const disconnectRes = await myDoge.disconnect();\n                    console.log('disconnect result', disconnectRes);\n                    if (disconnectRes.disconnected) {\n                        setConnected(false);\n                        setAddress('');\n                        setBtnText('Connect');\n                    }\n                    return;\n                }\n                const connectRes = await myDoge.connect();\n                console.log('connect result', connectRes);\n                if (connectRes.approved) {\n                    console.log('Connection approved, setting connected to true');\n                    setConnected(true);\n                    setAddress(connectRes.address);\n                    setBtnText('Disconnect');\n                    const balanceRes = await myDoge.getBalance();\n                    console.log('balance result', balanceRes);\n                    setBalance(satoshi_bitcoin__WEBPACK_IMPORTED_MODULE_3___default().toBitcoin(balanceRes.balance));\n                } else {\n                    console.log('Connection not approved');\n                }\n            } catch (e) {\n                console.error('Connection error:', e);\n                alert('Connection failed: ' + (e instanceof Error ? e.message : String(e)));\n            }\n        }\n    }[\"Home.useCallback[onConnect]\"], [\n        connected,\n        myDoge\n    ]);\n    const checkConnection = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[checkConnection]\": async ()=>{\n            if (!(myDoge === null || myDoge === void 0 ? void 0 : myDoge.isMyDoge)) return;\n            try {\n                const status = await myDoge.getConnectionStatus();\n                console.log('connection status result', status);\n                // Add a defensive check. If status is undefined, it means the extension\n                // background script is not ready. Do nothing and wait for the next check.\n                if (status === undefined) {\n                    return;\n                }\n                if (status === null || status === void 0 ? void 0 : status.connected) {\n                    if (!connected) {\n                        // sync to connected state\n                        setConnected(true);\n                        setBtnText('Disconnect');\n                        // Avoid calling connect() here to prevent extra wallet popups.\n                        // Prefer using address from status if provided, otherwise keep existing.\n                        if ((status === null || status === void 0 ? void 0 : status.address) && typeof status.address === 'string') {\n                            setAddress(status.address);\n                        }\n                        // fetch balance best-effort\n                        try {\n                            const balanceRes = await myDoge.getBalance();\n                            setBalance(satoshi_bitcoin__WEBPACK_IMPORTED_MODULE_3___default().toBitcoin(balanceRes.balance));\n                        } catch (e) {\n                            console.warn('fetch balance after status.connected failed', e);\n                        }\n                    }\n                } else if (connected) {\n                    // was connected locally but wallet says disconnected\n                    setConnected(false);\n                    setAddress('');\n                    setBtnText('Connect');\n                }\n            } catch (e) {\n                console.error('checkConnection error', e);\n            }\n        }\n    }[\"Home.useCallback[checkConnection]\"], [\n        connected,\n        myDoge\n    ]);\n    (0,_hooks_useInterval__WEBPACK_IMPORTED_MODULE_8__.useInterval)(checkConnection, 5000, false);\n    const isConnected = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[isConnected]\": ()=>{\n            if (!(myDoge === null || myDoge === void 0 ? void 0 : myDoge.isMyDoge)) {\n                alert(\"MyDoge not installed!\");\n                return false;\n            }\n            if (!connected) {\n                alert(\"MyDoge not connected!\");\n                return false;\n            }\n            return true;\n        }\n    }[\"Home.useCallback[isConnected]\"], [\n        connected,\n        myDoge\n    ]);\n    const onTip = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[onTip]\": async ()=>{\n            if (!isConnected()) return;\n            try {\n                const txReqRes = await myDoge.requestTransaction({\n                    recipientAddress: MDO_ADDRESS,\n                    dogeAmount: 4.2\n                });\n                console.log('request transaction result', txReqRes);\n                setTxId(txReqRes.txId);\n            } catch (e) {\n                console.error(e);\n            }\n        }\n    }[\"Home.useCallback[onTip]\"], [\n        isConnected,\n        myDoge\n    ]);\n    const onAdvancedSend = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[onAdvancedSend]\": async ()=>{\n            if (!isConnected() || !address) {\n                alert('Please connect wallet first.');\n                return;\n            }\n            try {\n                // --- Advanced Mode: Building a PSBT with multiple outputs and change ---\n                // Step 1: Define constants and helper functions\n                const blockbook_base = 'https://blockbook.perf.unifra.xyz/api/v2';\n                const DOGE_TO_KOINU = 100000000;\n                const DUST_THRESHOLD = 1000000; // 0.01 DOGE, as a safe dust limit for outputs\n                const TX_FEE_PER_BYTE = 400000; // A reasonable fee rate in koinu/byte\n                const fetchUtxos = {\n                    \"Home.useCallback[onAdvancedSend].fetchUtxos\": async (addr)=>{\n                        const res = await fetch(\"\".concat(blockbook_base, \"/utxo/\").concat(addr));\n                        /*\n            [\n              {\n                \"txid\": \"6b520a26a0f74ad6aafd9c2d2322780db35a4d6c48946de40bb38f755942cfc0\",\n                \"vout\": 1,\n                \"value\": \"990999000000\",\n                \"height\": 13096585,\n                \"confirmations\": 1976\n              }\n            ]\n        */ if (!res.ok) throw new Error(\"UTXO fetch failed: \".concat(res.status));\n                        const utxos = await res.json();\n                        if (!Array.isArray(utxos)) throw new Error('UTXO response is not an array');\n                        return utxos.map({\n                            \"Home.useCallback[onAdvancedSend].fetchUtxos\": (u)=>({\n                                    txid: u.txid,\n                                    vout: u.vout,\n                                    value: Number(u.value)\n                                })\n                        }[\"Home.useCallback[onAdvancedSend].fetchUtxos\"]);\n                    }\n                }[\"Home.useCallback[onAdvancedSend].fetchUtxos\"];\n                const fetchTxHex = {\n                    \"Home.useCallback[onAdvancedSend].fetchTxHex\": async (txid)=>{\n                        // Fetch full transaction details to get the hex\n                        const res = await fetch(\"\".concat(blockbook_base, \"/tx/\").concat(txid));\n                        /*\n          Blockbook response for /tx/${txid} is a JSON object like:\n          { \n            \"txid\": \"6b520a26a0f74ad6aafd9c2d2322780db35a4d6c48946de40bb38f755942cfc0\",\n            \"version\": 1,\n            \"hex\":\"01....\"\n          }\n        */ if (!res.ok) throw new Error(\"tx hex fetch failed: \".concat(res.status));\n                        const body = await res.json();\n                        return body.hex;\n                    }\n                }[\"Home.useCallback[onAdvancedSend].fetchTxHex\"];\n                // Step 2: Prepare outputs\n                const outputs = [];\n                let totalOutputValue = 0;\n                if (recipient1Address && recipient1Amount && parseFloat(recipient1Amount) > 0) {\n                    const value = Math.floor(parseFloat(recipient1Amount) * DOGE_TO_KOINU);\n                    outputs.push({\n                        address: recipient1Address,\n                        value\n                    });\n                    totalOutputValue += value;\n                }\n                if (recipient2Address && recipient2Amount && parseFloat(recipient2Amount) > 0) {\n                    const value = Math.floor(parseFloat(recipient2Amount) * DOGE_TO_KOINU);\n                    outputs.push({\n                        address: recipient2Address,\n                        value\n                    });\n                    totalOutputValue += value;\n                }\n                if (opReturnText) {\n                    const data = buffer__WEBPACK_IMPORTED_MODULE_7__.Buffer.from(opReturnText, 'utf8');\n                    const embed = bitcoinjs_lib__WEBPACK_IMPORTED_MODULE_6__.payments.embed({\n                        data: [\n                            data\n                        ]\n                    });\n                    if (embed.output) {\n                        outputs.push({\n                            script: embed.output,\n                            value: 0\n                        });\n                    }\n                }\n                if (outputs.length === 0) {\n                    alert(\"No valid outputs to send.\");\n                    return;\n                }\n                // Step 3: Fetch UTXOs and perform coin selection\n                const allUtxos = await fetchUtxos(address);\n                if (!allUtxos || allUtxos.length === 0) {\n                    alert(\"No spendable coins (UTXOs) found for this address.\");\n                    return;\n                }\n                let selectedUtxos = [];\n                let totalInputValue = 0;\n                let estimatedFee = 0;\n                // Simple coin selection: find enough UTXOs to cover outputs + estimated fee\n                for (const utxo of allUtxos){\n                    selectedUtxos.push(utxo);\n                    totalInputValue += utxo.value;\n                    // Estimate fee: 148 bytes per input, 34 per output. Add one for change.\n                    const estimatedSize = selectedUtxos.length * 148 + (outputs.length + 1) * 34 + 10;\n                    estimatedFee = estimatedSize * TX_FEE_PER_BYTE;\n                    if (totalInputValue >= totalOutputValue + estimatedFee) {\n                        break; // Found enough funds\n                    }\n                }\n                if (totalInputValue < totalOutputValue + estimatedFee) {\n                    alert(\"Not enough funds. Required: ~\".concat((totalOutputValue + estimatedFee) / DOGE_TO_KOINU, \" DOGE, Available: \").concat(totalInputValue / DOGE_TO_KOINU, \" DOGE\"));\n                    return;\n                }\n                // Step 4: Build the PSBT\n                //const network = networks.bitcoin; // Use bitcoin as a base for Dogecoin compatibility in bitcoinjs-lib\n                const network = {\n                    messagePrefix: '\\x19Dogecoin Signed Message:\\n',\n                    bip32: {\n                        public: 0x043587cf,\n                        private: 0x04358394\n                    },\n                    pubKeyHash: 0x71,\n                    scriptHash: 0xc4,\n                    wif: 0xf1\n                };\n                const psbt = new bitcoinjs_lib__WEBPACK_IMPORTED_MODULE_6__.Psbt({\n                    network\n                });\n                for (const utxo of selectedUtxos){\n                    const txHex = await fetchTxHex(utxo.txid);\n                    psbt.addInput({\n                        hash: utxo.txid,\n                        index: utxo.vout,\n                        nonWitnessUtxo: buffer__WEBPACK_IMPORTED_MODULE_7__.Buffer.from(txHex, 'hex')\n                    });\n                }\n                outputs.forEach({\n                    \"Home.useCallback[onAdvancedSend]\": (output)=>psbt.addOutput(output)\n                }[\"Home.useCallback[onAdvancedSend]\"]);\n                // Step 5: Calculate and add change output\n                console.log(\"estimatedFee=\".concat(estimatedFee, \", totalInputValue=\").concat(totalInputValue, \", totalOutputValue=\").concat(totalOutputValue));\n                const changeAmount = totalInputValue - totalOutputValue - estimatedFee;\n                if (changeAmount >= DUST_THRESHOLD) {\n                    psbt.addOutput({\n                        address: address,\n                        value: changeAmount\n                    });\n                }\n                // Step 6: Convert the PSBT to a Hex string for the wallet\n                const rawTx = psbt.toHex();\n                const indexesToSign = selectedUtxos.map({\n                    \"Home.useCallback[onAdvancedSend].indexesToSign\": (_, index)=>index\n                }[\"Home.useCallback[onAdvancedSend].indexesToSign\"]);\n                // Step 7: Request signature and broadcast from the wallet\n                const txReqRes = await myDoge.requestPsbt({\n                    rawTx: rawTx,\n                    indexes: indexesToSign,\n                    signOnly: false\n                });\n                console.log('Advanced send transaction result', txReqRes);\n                setTxId(txReqRes.txId);\n            } catch (e) {\n                console.error('Advanced send failed:', e);\n                alert(\"Transaction failed. Check the browser console for details. Error: \".concat(e instanceof Error ? e.message : String(e)));\n            }\n        }\n    }[\"Home.useCallback[onAdvancedSend]\"], [\n        isConnected,\n        myDoge,\n        address,\n        recipient1Address,\n        recipient1Amount,\n        recipient2Address,\n        recipient2Amount,\n        opReturnText\n    ]);\n    const onSendInscription = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[onSendInscription]\": async ()=>{\n            if (!isConnected()) return;\n            try {\n                const txReqRes = await myDoge.requestInscriptionTransaction({\n                    recipientAddress,\n                    location: inscriptionLocation\n                });\n                console.log('request inscription transaction result', txReqRes);\n                setTxId(txReqRes.txId);\n            } catch (e) {\n                console.error(e);\n            }\n        }\n    }[\"Home.useCallback[onSendInscription]\"], [\n        isConnected,\n        myDoge,\n        recipientAddress,\n        inscriptionLocation\n    ]);\n    const onGetDRC20Balance = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[onGetDRC20Balance]\": async ()=>{\n            if (!isConnected()) return;\n            try {\n                const balanceRes = await myDoge.getDRC20Balance({\n                    ticker: drc20Ticker\n                });\n                console.log('request drc-20 balance result', balanceRes);\n                setDrc20Inscriptions([]);\n                setDrc20Available(balanceRes.availableBalance);\n                setDrc20Transferable(balanceRes.transferableBalance);\n            } catch (e) {\n                console.error(e);\n            }\n        }\n    }[\"Home.useCallback[onGetDRC20Balance]\"], [\n        isConnected,\n        myDoge,\n        drc20Ticker\n    ]);\n    const onGetDRC20Inscriptions = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[onGetDRC20Inscriptions]\": async ()=>{\n            if (!isConnected()) return;\n            try {\n                const transferableRes = await myDoge.getTransferableDRC20({\n                    ticker: drc20Ticker\n                });\n                console.log('request drc-20 transferable result', transferableRes);\n                setDrc20Inscriptions(transferableRes.inscriptions);\n            } catch (e) {\n                console.error(e);\n            }\n        }\n    }[\"Home.useCallback[onGetDRC20Inscriptions]\"], [\n        isConnected,\n        myDoge,\n        drc20Ticker\n    ]);\n    const onAvailableDRC20 = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[onAvailableDRC20]\": async ()=>{\n            if (!isConnected()) return;\n            try {\n                const txReqRes = await myDoge.requestAvailableDRC20Transaction({\n                    ticker: drc20Ticker,\n                    amount: drc20Amount\n                });\n                console.log('request available drc-20 tx result', txReqRes);\n                setTxId(txReqRes.txId);\n            } catch (e) {\n                console.error(e);\n            }\n        }\n    }[\"Home.useCallback[onAvailableDRC20]\"], [\n        isConnected,\n        myDoge,\n        drc20Ticker,\n        drc20Amount\n    ]);\n    const onGetDunesBalance = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[onGetDunesBalance]\": async ()=>{\n            if (!isConnected()) return;\n            try {\n                const balanceRes = await myDoge.getDunesBalance({\n                    ticker: dunesTicker\n                });\n                console.log('request dunes balance result', balanceRes);\n                setDunesBalance(balanceRes.balance);\n            } catch (e) {\n                console.error(e);\n            }\n        }\n    }[\"Home.useCallback[onGetDunesBalance]\"], [\n        isConnected,\n        myDoge,\n        dunesTicker\n    ]);\n    const onSendDunes = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[onSendDunes]\": async ()=>{\n            if (!isConnected()) return;\n            try {\n                const txReqRes = await myDoge.requestDunesTransaction({\n                    ticker: dunesTicker,\n                    recipientAddress,\n                    amount: dunesAmount\n                });\n                console.log('request dunes transaction result', txReqRes);\n                setTxId(txReqRes.txId);\n            } catch (e) {\n                console.error(e);\n            }\n        }\n    }[\"Home.useCallback[onSendDunes]\"], [\n        isConnected,\n        myDoge,\n        recipientAddress,\n        dunesTicker,\n        dunesAmount\n    ]);\n    const txStatus = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[txStatus]\": async ()=>{\n            if (txId) {\n                const txStatusRes = await myDoge.getTransactionStatus({\n                    txId\n                });\n                console.log('transaction status result', txStatusRes);\n                // Once confirmed, stop polling and update balance\n                if (txStatusRes.status === 'confirmed' && txStatusRes.confirmations > 1) {\n                    const balanceRes = await myDoge.getBalance();\n                    console.log('balance result', balanceRes);\n                    setBalance(satoshi_bitcoin__WEBPACK_IMPORTED_MODULE_3___default().toBitcoin(balanceRes.balance));\n                    setTxId('');\n                }\n            }\n        }\n    }[\"Home.useCallback[txStatus]\"], [\n        myDoge,\n        txId\n    ]);\n    const onSendPSBT = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[onSendPSBT]\": async ()=>{\n            if (!isConnected()) return;\n            const signOnly = true;\n            try {\n                const txReqRes = await myDoge.requestPsbt({\n                    rawTx,\n                    indexes: psbtIndexes,\n                    signOnly\n                });\n                console.log('request send psbt result', txReqRes);\n                if (!signOnly) {\n                    setTxId(txReqRes.txId);\n                }\n            } catch (e) {\n                console.error(e);\n            }\n        }\n    }[\"Home.useCallback[onSendPSBT]\"], [\n        isConnected,\n        myDoge,\n        psbtIndexes,\n        rawTx\n    ]);\n    const onSignMessage = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[onSignMessage]\": async ()=>{\n            if (!isConnected()) return;\n            try {\n                const signMsgRes = await myDoge.requestSignedMessage({\n                    message: signMessage\n                });\n                console.log('request sign message result', signMsgRes);\n            } catch (e) {\n                console.error(e);\n            }\n        }\n    }[\"Home.useCallback[onSignMessage]\"], [\n        isConnected,\n        myDoge,\n        signMessage\n    ]);\n    const onDecryptMessage = (0,react__WEBPACK_IMPORTED_MODULE_5__.useCallback)({\n        \"Home.useCallback[onDecryptMessage]\": async ()=>{\n            if (!isConnected()) return;\n            try {\n                const decryptMsgRes = await myDoge.requestDecryptedMessage({\n                    message: decryptMessage\n                });\n                console.log('request decrypt message result', decryptMsgRes);\n            } catch (e) {\n                console.error(e);\n            }\n        }\n    }[\"Home.useCallback[onDecryptMessage]\"], [\n        isConnected,\n        myDoge,\n        decryptMessage\n    ]);\n    (0,_hooks_useInterval__WEBPACK_IMPORTED_MODULE_8__.useInterval)(txStatus, 10000, false);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"MyDoge\"\n                    }, void 0, false, {\n                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                        lineNumber: 507,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"description\",\n                        content: \"Sample integration\"\n                    }, void 0, false, {\n                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                        lineNumber: 508,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"viewport\",\n                        content: \"width=device-width, initial-scale=1\"\n                    }, void 0, false, {\n                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                        lineNumber: 509,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"icon\",\n                        href: \"/favicon.ico\"\n                    }, void 0, false, {\n                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                        lineNumber: 510,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                lineNumber: 506,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().main),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                href: \"https://github.com/mydoge-com/mydogemask\",\n                                target: \"_blank\",\n                                rel: \"noopener noreferrer\",\n                                children: [\n                                    \"Checkout MyDoge Wallet Browser Extension on GitHub\",\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_2___default()), {\n                                        src: \"/github.svg\",\n                                        alt: \"GitHub Logo\",\n                                        width: 25,\n                                        height: 25,\n                                        priority: true\n                                    }, void 0, false, {\n                                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                        lineNumber: 521,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 515,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                            lineNumber: 514,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                        lineNumber: 513,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            onClick: onConnect,\n                            children: btnText\n                        }, void 0, false, {\n                            fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                            lineNumber: 533,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                        lineNumber: 532,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        style: {\n                            margin: '20px',\n                            padding: '10px',\n                            backgroundColor: '#f0f0f0',\n                            fontSize: '12px'\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: \"Debug Info:\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 538,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Connected: \",\n                                    connected ? 'Yes' : 'No'\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 539,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"MyDoge Available: \",\n                                    (myDoge === null || myDoge === void 0 ? void 0 : myDoge.isMyDoge) ? 'Yes' : 'No'\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 540,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    \"Address: \",\n                                    address || 'None'\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 541,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                        lineNumber: 537,\n                        columnNumber: 9\n                    }, this),\n                    connected && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().container),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                children: [\n                                    \"Address: \",\n                                    address\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 546,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                children: [\n                                    \"Balance: \",\n                                    balance\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 547,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: onTip,\n                                    children: \"Tip MyDoge Team 4.20\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                    lineNumber: 549,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 548,\n                                columnNumber: 13\n                            }, this),\n                            \"--------------------------------------------------------------------\",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: \"高级多输出发送 (支持 OP_RETURN)\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 552,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                children: \"收款地址 1:\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 553,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                style: {\n                                    width: '265px'\n                                },\n                                value: recipient1Address,\n                                onChange: (e)=>setRecipient1Address(e.target.value)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 554,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                children: \"金额 1 (DOGE):\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 560,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                style: {\n                                    width: '100px'\n                                },\n                                value: recipient1Amount,\n                                onChange: (e)=>setRecipient1Amount(e.target.value)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 561,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                children: \"收款地址 2 (可选):\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 567,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                style: {\n                                    width: '265px'\n                                },\n                                value: recipient2Address,\n                                onChange: (e)=>setRecipient2Address(e.target.value)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 568,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                children: \"金额 2 (DOGE):\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 574,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                style: {\n                                    width: '100px'\n                                },\n                                value: recipient2Amount,\n                                onChange: (e)=>setRecipient2Amount(e.target.value)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 575,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                children: \"OP_RETURN 文本 (可选):\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 581,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                style: {\n                                    width: '300px'\n                                },\n                                value: opReturnText,\n                                onChange: (e)=>setOpReturnText(e.target.value)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 582,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: onAdvancedSend,\n                                    children: \"高级模式发送交易\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                    lineNumber: 589,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 588,\n                                columnNumber: 13\n                            }, this),\n                            \"--------------------------------------------------------------------\",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: \"Inscription location (Doginal/DRC-20) (txid:vout:offset)\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 594,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                style: {\n                                    width: '485px'\n                                },\n                                value: inscriptionLocation,\n                                onChange: (text)=>{\n                                    setinscriptionLocation(text.target.value);\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 597,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: \"Inscription recipient address\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 605,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                style: {\n                                    width: '265px'\n                                },\n                                value: recipientAddress,\n                                onChange: (text)=>{\n                                    setRecipientAddress(text.target.value);\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 606,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: onSendInscription,\n                                    children: \"Send Inscription\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                    lineNumber: 615,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 614,\n                                columnNumber: 13\n                            }, this),\n                            \"--------------------------------------------------------------------\",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: \"DRC-20 Ticker\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 618,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                style: {\n                                    width: '35px'\n                                },\n                                value: drc20Ticker,\n                                onChange: (text)=>{\n                                    setDrc20Ticker(text.target.value);\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 619,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: onGetDRC20Balance,\n                                    children: \"Get DRC-20 Balance\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                    lineNumber: 628,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 627,\n                                columnNumber: 13\n                            }, this),\n                            drc20Available && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                children: [\n                                    \"Available Balance: \",\n                                    drc20Available\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 631,\n                                columnNumber: 15\n                            }, this),\n                            drc20Transferable && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                children: [\n                                    \"Transferable Balance: \",\n                                    drc20Transferable\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 636,\n                                columnNumber: 15\n                            }, this),\n                            drc20Available || drc20Transferable ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                style: {\n                                    width: '100px'\n                                },\n                                value: drc20Amount,\n                                onChange: (text)=>{\n                                    setDrc20Amount(text.target.value);\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 641,\n                                columnNumber: 15\n                            }, this) : null,\n                            drc20Available && drc20Available !== '0' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: ()=>onAvailableDRC20(),\n                                    children: \"Make Transferable\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                    lineNumber: 653,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 652,\n                                columnNumber: 15\n                            }, this),\n                            drc20Transferable && drc20Transferable !== '0' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: ()=>onGetDRC20Inscriptions(),\n                                    children: \"Get Transferable DRC-20\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                    lineNumber: 660,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 659,\n                                columnNumber: 15\n                            }, this),\n                            drc20Inscriptions.length > 0 && drc20Inscriptions.map((inscription)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    children: [\n                                        inscription.location,\n                                        \" \",\n                                        inscription.ticker,\n                                        ' ',\n                                        inscription.amount\n                                    ]\n                                }, inscription.location, true, {\n                                    fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                    lineNumber: 667,\n                                    columnNumber: 17\n                                }, this)),\n                            \"--------------------------------------------------------------------\",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: \"Dunes Ticker\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 673,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                style: {\n                                    width: '130px'\n                                },\n                                value: dunesTicker,\n                                onChange: (text)=>{\n                                    setDunesTicker(text.target.value);\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 674,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: onGetDunesBalance,\n                                    children: \"Get Dunes Balance\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                    lineNumber: 683,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 682,\n                                columnNumber: 13\n                            }, this),\n                            dunesBalance && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().container),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                        children: [\n                                            \"Dunes Balance: \",\n                                            dunesBalance\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                        lineNumber: 687,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                        children: \"Dunes Recipient Address\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                        lineNumber: 688,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                        type: \"text\",\n                                        style: {\n                                            width: '265px'\n                                        },\n                                        value: recipientAddress,\n                                        onChange: (text)=>{\n                                            setRecipientAddress(text.target.value);\n                                        }\n                                    }, void 0, false, {\n                                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                        lineNumber: 689,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                        children: \"Dunes Amount\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                        lineNumber: 698,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                        type: \"text\",\n                                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                        style: {\n                                            width: '100px'\n                                        },\n                                        value: dunesAmount,\n                                        onChange: (text)=>{\n                                            setDunesAmount(text.target.value);\n                                        }\n                                    }, void 0, false, {\n                                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                        lineNumber: 699,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                        className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                        onClick: onSendDunes,\n                                        children: \"Send Dunes\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                        lineNumber: 708,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 686,\n                                columnNumber: 15\n                            }, this),\n                            \"--------------------------------------------------------------------\",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                children: \"Send PSBT\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 714,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                children: \"Raw TX\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 715,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                style: {\n                                    width: '500px'\n                                },\n                                value: rawTx,\n                                onChange: (text)=>{\n                                    setRawTx(text.target.value);\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 716,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                children: \"Input Indexes (csv)\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 725,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                style: {\n                                    width: '150px'\n                                },\n                                value: psbtIndexes.join(','),\n                                onChange: (text)=>{\n                                    var _text_target;\n                                    if (text === null || text === void 0 ? void 0 : (_text_target = text.target) === null || _text_target === void 0 ? void 0 : _text_target.value) {\n                                        const indexes = text.target.value.split(',').map(Number);\n                                        setPsbtIndexes(indexes);\n                                    }\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 726,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: ()=>onSendPSBT(),\n                                    children: \"Send PSBT\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                    lineNumber: 739,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 738,\n                                columnNumber: 13\n                            }, this),\n                            \"--------------------------------------------------------------------\",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                children: \"Sign Message\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 742,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                style: {\n                                    width: '500px'\n                                },\n                                value: signMessage,\n                                onChange: (text)=>{\n                                    setSignMessage(text.target.value);\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 743,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: ()=>onSignMessage(),\n                                    children: \"Sign Message\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                    lineNumber: 753,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 752,\n                                columnNumber: 13\n                            }, this),\n                            \"--------------------------------------------------------------------\",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                children: \"Decrypt Message\"\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 756,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().item),\n                                style: {\n                                    width: '500px'\n                                },\n                                value: decryptMessage,\n                                onChange: (text)=>{\n                                    setDecryptMessage(text.target.value);\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 757,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_Home_module_css__WEBPACK_IMPORTED_MODULE_4___default().center),\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: ()=>onDecryptMessage(),\n                                    children: \"Decrypt Message\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                    lineNumber: 767,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                                lineNumber: 766,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                        lineNumber: 545,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/qiaoxiaorui/github/unifra/mydoge/mydogemask-next-example/src/pages/index.tsx\",\n                lineNumber: 512,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(Home, \"W/8Rh2SXrxYA0W4y/DvcvF7Uukc=\", false, function() {\n    return [\n        _hooks_useInterval__WEBPACK_IMPORTED_MODULE_8__.useInterval,\n        _hooks_useInterval__WEBPACK_IMPORTED_MODULE_8__.useInterval\n    ];\n});\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVc7MENBQUU7Ozs7OzswQ0FDN0IsOERBQUM4TjtnQ0FDQ0MsTUFBSztnQ0FDTHBCLFdBQVczTSxxRUFBVztnQ0FDdEJ3TixPQUFPO29DQUFFTixPQUFPO2dDQUFRO2dDQUN4QjNGLE9BQU92RTtnQ0FDUGdMLFVBQVUsQ0FBQ0M7b0NBQ1RoTCxrQkFBa0JnTCxLQUFLbEIsTUFBTSxDQUFDeEYsS0FBSztnQ0FDckM7Ozs7OzswQ0FFRiw4REFBQ3FGO2dDQUFJRCxXQUFXM00sdUVBQWE7MENBQzNCLDRFQUFDc047b0NBQU9DLFNBQVMsSUFBTXZCOzhDQUFvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVN6RDtHQXh2QndCckw7O1FBNEl0QkYsMkRBQVdBO1FBMFZYQSwyREFBV0E7OztLQXRlV0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9zcmMvcGFnZXMvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgSW1hZ2UgZnJvbSAnbmV4dC9pbWFnZSc7XG5pbXBvcnQgc2IgZnJvbSAnc2F0b3NoaS1iaXRjb2luJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnQC9zdHlsZXMvSG9tZS5tb2R1bGUuY3NzJztcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJbnRlciB9IGZyb20gJ25leHQvZm9udC9nb29nbGUnO1xuaW1wb3J0IHsgUHNidCwgbmV0d29ya3MsIHBheW1lbnRzIH0gZnJvbSAnYml0Y29pbmpzLWxpYic7XG5pbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuXG5pbXBvcnQgeyB1c2VJbnRlcnZhbCB9IGZyb20gJy4uL2hvb2tzL3VzZUludGVydmFsJztcbmltcG9ydCB7IE5ldHdvcmsgfSBmcm9tICdpbnNwZWN0b3IvcHJvbWlzZXMnO1xuXG5jb25zdCBpbnRlciA9IEludGVyKHsgc3Vic2V0czogWydsYXRpbiddIH0pO1xuY29uc3QgTURPX0FERFJFU1MgPSAnREFIa0NGNUxhalY2all5aTVvNGVNdnRwcVhSY205ZVpZcSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIGNvbnN0IFtidG5UZXh0LCBzZXRCdG5UZXh0XSA9IHVzZVN0YXRlKCdDb25uZWN0Jyk7XG4gIGNvbnN0IFtjb25uZWN0ZWQsIHNldENvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFthZGRyZXNzLCBzZXRBZGRyZXNzXSA9IHVzZVN0YXRlPHN0cmluZz4oJycpO1xuICBjb25zdCBbYmFsYW5jZSwgc2V0QmFsYW5jZV0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3R4SWQsIHNldFR4SWRdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbaW5zY3JpcHRpb25Mb2NhdGlvbiwgc2V0aW5zY3JpcHRpb25Mb2NhdGlvbl0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtyZWNpcGllbnRBZGRyZXNzLCBzZXRSZWNpcGllbnRBZGRyZXNzXSA9IHVzZVN0YXRlKE1ET19BRERSRVNTKTtcbiAgY29uc3QgW2RyYzIwVGlja2VyLCBzZXREcmMyMFRpY2tlcl0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtkcmMyMEF2YWlsYWJsZSwgc2V0RHJjMjBBdmFpbGFibGVdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbZHJjMjBUcmFuc2ZlcmFibGUsIHNldERyYzIwVHJhbnNmZXJhYmxlXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW2RyYzIwSW5zY3JpcHRpb25zLCBzZXREcmMyMEluc2NyaXB0aW9uc10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pO1xuICBjb25zdCBbZHJjMjBBbW91bnQsIHNldERyYzIwQW1vdW50XSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW2R1bmVzVGlja2VyLCBzZXREdW5lc1RpY2tlcl0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtkdW5lc0JhbGFuY2UsIHNldER1bmVzQmFsYW5jZV0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtkdW5lc0Ftb3VudCwgc2V0RHVuZXNBbW91bnRdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbcmF3VHgsIHNldFJhd1R4XSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3BzYnRJbmRleGVzLCBzZXRQc2J0SW5kZXhlc10gPSB1c2VTdGF0ZShbMSwgMl0pO1xuICBjb25zdCBbc2lnbk1lc3NhZ2UsIHNldFNpZ25NZXNzYWdlXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW2RlY3J5cHRNZXNzYWdlLCBzZXREZWNyeXB0TWVzc2FnZV0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtteURvZ2UsIHNldE15RG9nZV0gPSB1c2VTdGF0ZTxhbnk+KCk7XG4gIGNvbnN0IGludGVydmFsUmVmID0gdXNlUmVmPGFueT4oKTtcblxuICAvLyDlpJrovpPlh7rlkowgT1BfUkVUVVJOIOmFjee9rlxuICBjb25zdCBbcmVjaXBpZW50MUFkZHJlc3MsIHNldFJlY2lwaWVudDFBZGRyZXNzXSA9IHVzZVN0YXRlKFwiMk43WlNvQUE3ek1uQ0ZvdlU1cVhYY3lxQ0xuRUhUcm5RWThcIik7XG4gIGNvbnN0IFtyZWNpcGllbnQxQW1vdW50LCBzZXRSZWNpcGllbnQxQW1vdW50XSA9IHVzZVN0YXRlKCcyJyk7XG4gIGNvbnN0IFtyZWNpcGllbnQyQWRkcmVzcywgc2V0UmVjaXBpZW50MkFkZHJlc3NdID0gdXNlU3RhdGUoJ25xNXFUR1NwcEhxMnVBYXdYcVFjcUN0cjVzZGY5cHl1SFgnKTtcbiAgY29uc3QgW3JlY2lwaWVudDJBbW91bnQsIHNldFJlY2lwaWVudDJBbW91bnRdID0gdXNlU3RhdGUoJzAuMScpO1xuICBjb25zdCBbb3BSZXR1cm5UZXh0LCBzZXRPcFJldHVyblRleHRdID0gdXNlU3RhdGUoJzAwQmI4QmMyOTY5NTIzMjA4OGIxQTJkYmMxMTdFOEM2MDA2NDc4YzI5NScpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFteURvZ2UpIHtcbiAgICAgIGNvbnN0IG9uSW5pdCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBkb2dlIH0gPSB3aW5kb3cgYXMgYW55O1xuICAgICAgICBzZXRNeURvZ2UoZG9nZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdkb2dlI2luaXRpYWxpemVkJywgb25Jbml0KTtcbiAgICAgICAgY29uc29sZS5sb2coJ015RG9nZSBBUEkgaW5qZWN0ZWQgZnJvbSBldmVudCcpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkb2dlI2luaXRpYWxpemVkJywgb25Jbml0LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9LCBbbXlEb2dlXSk7XG5cbiAgLy8gSGFuZGxlIGRldiBlZGdlIGNhc2Ugd2hlcmUgY29tcG9uZW50IG1vdW50cyBhZnRlciBNeURvZ2UgaXMgaW5pdGlhbGl6ZWRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW15RG9nZSAmJiAhaW50ZXJ2YWxSZWYuY3VycmVudCkge1xuICAgICAgaW50ZXJ2YWxSZWYuY3VycmVudCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBkb2dlIH0gPSB3aW5kb3cgYXMgYW55O1xuICAgICAgICBpZiAoZG9nZT8uaXNNeURvZ2UpIHtcbiAgICAgICAgICBzZXRNeURvZ2UoZG9nZSk7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbFJlZi5jdXJyZW50KTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnTXlEb2dlIEFQSSBpbmplY3RlZCBmcm9tIGludGVydmFsJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ015RG9nZSBBUEkgbm90IGluamVjdGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgfSwgW215RG9nZV0pO1xuXG4gIGNvbnN0IG9uQ29ubmVjdCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnb25Db25uZWN0IGNhbGxlZCwgbXlEb2dlOicsIG15RG9nZSk7XG4gICAgY29uc29sZS5sb2coJ2N1cnJlbnQgY29ubmVjdGVkIHN0YXRlOicsIGNvbm5lY3RlZCk7XG5cbiAgICBpZiAoIW15RG9nZT8uaXNNeURvZ2UpIHtcbiAgICAgIGFsZXJ0KGBNeURvZ2Ugbm90IGluc3RhbGxlZCEgUGxlYXNlIGluc3RhbGwgdGhlIE15RG9nZSBicm93c2VyIGV4dGVuc2lvbi5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKGNvbm5lY3RlZCkge1xuICAgICAgICBjb25zdCBkaXNjb25uZWN0UmVzID0gYXdhaXQgbXlEb2dlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgY29uc29sZS5sb2coJ2Rpc2Nvbm5lY3QgcmVzdWx0JywgZGlzY29ubmVjdFJlcyk7XG4gICAgICAgIGlmIChkaXNjb25uZWN0UmVzLmRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHNldENvbm5lY3RlZChmYWxzZSk7XG4gICAgICAgICAgc2V0QWRkcmVzcygnJyk7XG4gICAgICAgICAgc2V0QnRuVGV4dCgnQ29ubmVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29ubmVjdFJlcyA9IGF3YWl0IG15RG9nZS5jb25uZWN0KCk7XG4gICAgICBjb25zb2xlLmxvZygnY29ubmVjdCByZXN1bHQnLCBjb25uZWN0UmVzKTtcbiAgICAgIGlmIChjb25uZWN0UmVzLmFwcHJvdmVkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW9uIGFwcHJvdmVkLCBzZXR0aW5nIGNvbm5lY3RlZCB0byB0cnVlJyk7XG4gICAgICAgIHNldENvbm5lY3RlZCh0cnVlKTtcbiAgICAgICAgc2V0QWRkcmVzcyhjb25uZWN0UmVzLmFkZHJlc3MpO1xuICAgICAgICBzZXRCdG5UZXh0KCdEaXNjb25uZWN0Jyk7XG5cbiAgICAgICAgY29uc3QgYmFsYW5jZVJlcyA9IGF3YWl0IG15RG9nZS5nZXRCYWxhbmNlKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdiYWxhbmNlIHJlc3VsdCcsIGJhbGFuY2VSZXMpO1xuICAgICAgICBzZXRCYWxhbmNlKHNiLnRvQml0Y29pbihiYWxhbmNlUmVzLmJhbGFuY2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW9uIG5vdCBhcHByb3ZlZCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3I6JywgZSk7XG4gICAgICBhbGVydCgnQ29ubmVjdGlvbiBmYWlsZWQ6ICcgKyAoZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpKSk7XG4gICAgfVxuICB9LCBbY29ubmVjdGVkLCBteURvZ2VdKTtcblxuICBjb25zdCBjaGVja0Nvbm5lY3Rpb24gPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFteURvZ2U/LmlzTXlEb2dlKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IG15RG9nZS5nZXRDb25uZWN0aW9uU3RhdHVzKCk7XG4gICAgICBjb25zb2xlLmxvZygnY29ubmVjdGlvbiBzdGF0dXMgcmVzdWx0Jywgc3RhdHVzKTtcblxuICAgICAgLy8gQWRkIGEgZGVmZW5zaXZlIGNoZWNrLiBJZiBzdGF0dXMgaXMgdW5kZWZpbmVkLCBpdCBtZWFucyB0aGUgZXh0ZW5zaW9uXG4gICAgICAvLyBiYWNrZ3JvdW5kIHNjcmlwdCBpcyBub3QgcmVhZHkuIERvIG5vdGhpbmcgYW5kIHdhaXQgZm9yIHRoZSBuZXh0IGNoZWNrLlxuICAgICAgaWYgKHN0YXR1cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXR1cz8uY29ubmVjdGVkKSB7XG4gICAgICAgIGlmICghY29ubmVjdGVkKSB7XG4gICAgICAgICAgLy8gc3luYyB0byBjb25uZWN0ZWQgc3RhdGVcbiAgICAgICAgICBzZXRDb25uZWN0ZWQodHJ1ZSk7XG4gICAgICAgICAgc2V0QnRuVGV4dCgnRGlzY29ubmVjdCcpO1xuICAgICAgICAgIC8vIEF2b2lkIGNhbGxpbmcgY29ubmVjdCgpIGhlcmUgdG8gcHJldmVudCBleHRyYSB3YWxsZXQgcG9wdXBzLlxuICAgICAgICAgIC8vIFByZWZlciB1c2luZyBhZGRyZXNzIGZyb20gc3RhdHVzIGlmIHByb3ZpZGVkLCBvdGhlcndpc2Uga2VlcCBleGlzdGluZy5cbiAgICAgICAgICBpZiAoc3RhdHVzPy5hZGRyZXNzICYmIHR5cGVvZiBzdGF0dXMuYWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNldEFkZHJlc3Moc3RhdHVzLmFkZHJlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBmZXRjaCBiYWxhbmNlIGJlc3QtZWZmb3J0XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJhbGFuY2VSZXMgPSBhd2FpdCBteURvZ2UuZ2V0QmFsYW5jZSgpO1xuICAgICAgICAgICAgc2V0QmFsYW5jZShzYi50b0JpdGNvaW4oYmFsYW5jZVJlcy5iYWxhbmNlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdmZXRjaCBiYWxhbmNlIGFmdGVyIHN0YXR1cy5jb25uZWN0ZWQgZmFpbGVkJywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbm5lY3RlZCkge1xuICAgICAgICAvLyB3YXMgY29ubmVjdGVkIGxvY2FsbHkgYnV0IHdhbGxldCBzYXlzIGRpc2Nvbm5lY3RlZFxuICAgICAgICBzZXRDb25uZWN0ZWQoZmFsc2UpO1xuICAgICAgICBzZXRBZGRyZXNzKCcnKTtcbiAgICAgICAgc2V0QnRuVGV4dCgnQ29ubmVjdCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2NoZWNrQ29ubmVjdGlvbiBlcnJvcicsIGUpO1xuICAgIH1cbiAgfSwgW2Nvbm5lY3RlZCwgbXlEb2dlXSk7XG5cbiAgdXNlSW50ZXJ2YWwoY2hlY2tDb25uZWN0aW9uLCA1MDAwLCBmYWxzZSk7XG5cbiAgY29uc3QgaXNDb25uZWN0ZWQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFteURvZ2U/LmlzTXlEb2dlKSB7XG4gICAgICBhbGVydChgTXlEb2dlIG5vdCBpbnN0YWxsZWQhYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFjb25uZWN0ZWQpIHtcbiAgICAgIGFsZXJ0KGBNeURvZ2Ugbm90IGNvbm5lY3RlZCFgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgW2Nvbm5lY3RlZCwgbXlEb2dlXSk7XG5cbiAgY29uc3Qgb25UaXAgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFpc0Nvbm5lY3RlZCgpKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdHhSZXFSZXMgPSBhd2FpdCBteURvZ2UucmVxdWVzdFRyYW5zYWN0aW9uKHtcbiAgICAgICAgcmVjaXBpZW50QWRkcmVzczogTURPX0FERFJFU1MsXG4gICAgICAgIGRvZ2VBbW91bnQ6IDQuMixcbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coJ3JlcXVlc3QgdHJhbnNhY3Rpb24gcmVzdWx0JywgdHhSZXFSZXMpO1xuICAgICAgc2V0VHhJZCh0eFJlcVJlcy50eElkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfSwgW2lzQ29ubmVjdGVkLCBteURvZ2VdKTtcblxuICBjb25zdCBvbkFkdmFuY2VkU2VuZCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWlzQ29ubmVjdGVkKCkgfHwgIWFkZHJlc3MpIHtcbiAgICAgIGFsZXJ0KCdQbGVhc2UgY29ubmVjdCB3YWxsZXQgZmlyc3QuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBBZHZhbmNlZCBNb2RlOiBCdWlsZGluZyBhIFBTQlQgd2l0aCBtdWx0aXBsZSBvdXRwdXRzIGFuZCBjaGFuZ2UgLS0tXG5cbiAgICAgIC8vIFN0ZXAgMTogRGVmaW5lIGNvbnN0YW50cyBhbmQgaGVscGVyIGZ1bmN0aW9uc1xuICAgICAgY29uc3QgYmxvY2tib29rX2Jhc2UgPSAnaHR0cHM6Ly9ibG9ja2Jvb2sucGVyZi51bmlmcmEueHl6L2FwaS92Mic7XG4gICAgICBjb25zdCBET0dFX1RPX0tPSU5VID0gMTAwXzAwMF8wMDA7XG4gICAgICBjb25zdCBEVVNUX1RIUkVTSE9MRCA9IDFfMDAwXzAwMDsgLy8gMC4wMSBET0dFLCBhcyBhIHNhZmUgZHVzdCBsaW1pdCBmb3Igb3V0cHV0c1xuICAgICAgY29uc3QgVFhfRkVFX1BFUl9CWVRFID0gNDAwMDAwOyAvLyBBIHJlYXNvbmFibGUgZmVlIHJhdGUgaW4ga29pbnUvYnl0ZVxuXG4gICAgICBjb25zdCBmZXRjaFV0eG9zID0gYXN5bmMgKGFkZHI6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtibG9ja2Jvb2tfYmFzZX0vdXR4by8ke2FkZHJ9YCk7XG4gICAgICAgIC8qXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBcInR4aWRcIjogXCI2YjUyMGEyNmEwZjc0YWQ2YWFmZDljMmQyMzIyNzgwZGIzNWE0ZDZjNDg5NDZkZTQwYmIzOGY3NTU5NDJjZmMwXCIsXG4gICAgICAgICAgICAgICAgXCJ2b3V0XCI6IDEsXG4gICAgICAgICAgICAgICAgXCJ2YWx1ZVwiOiBcIjk5MDk5OTAwMDAwMFwiLFxuICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IDEzMDk2NTg1LFxuICAgICAgICAgICAgICAgIFwiY29uZmlybWF0aW9uc1wiOiAxOTc2XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKCFyZXMub2spIHRocm93IG5ldyBFcnJvcihgVVRYTyBmZXRjaCBmYWlsZWQ6ICR7cmVzLnN0YXR1c31gKTtcbiAgICAgICAgY29uc3QgdXR4b3MgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodXR4b3MpKSB0aHJvdyBuZXcgRXJyb3IoJ1VUWE8gcmVzcG9uc2UgaXMgbm90IGFuIGFycmF5Jyk7XG4gICAgICAgIHJldHVybiB1dHhvcy5tYXAoKHU6IGFueSkgPT4gKHsgdHhpZDogdS50eGlkLCB2b3V0OiB1LnZvdXQsIHZhbHVlOiBOdW1iZXIodS52YWx1ZSkgfSkpO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZmV0Y2hUeEhleCA9IGFzeW5jICh0eGlkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgLy8gRmV0Y2ggZnVsbCB0cmFuc2FjdGlvbiBkZXRhaWxzIHRvIGdldCB0aGUgaGV4XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke2Jsb2NrYm9va19iYXNlfS90eC8ke3R4aWR9YCk7XG4gICAgICAgIC8qXG4gICAgICAgICAgQmxvY2tib29rIHJlc3BvbnNlIGZvciAvdHgvJHt0eGlkfSBpcyBhIEpTT04gb2JqZWN0IGxpa2U6XG4gICAgICAgICAgeyBcbiAgICAgICAgICAgIFwidHhpZFwiOiBcIjZiNTIwYTI2YTBmNzRhZDZhYWZkOWMyZDIzMjI3ODBkYjM1YTRkNmM0ODk0NmRlNDBiYjM4Zjc1NTk0MmNmYzBcIixcbiAgICAgICAgICAgIFwidmVyc2lvblwiOiAxLFxuICAgICAgICAgICAgXCJoZXhcIjpcIjAxLi4uLlwiXG4gICAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICBpZiAoIXJlcy5vaykgdGhyb3cgbmV3IEVycm9yKGB0eCBoZXggZmV0Y2ggZmFpbGVkOiAke3Jlcy5zdGF0dXN9YCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICByZXR1cm4gYm9keS5oZXg7XG4gICAgICB9O1xuXG4gICAgICAvLyBTdGVwIDI6IFByZXBhcmUgb3V0cHV0c1xuICAgICAgY29uc3Qgb3V0cHV0czogQXJyYXk8eyBhZGRyZXNzOiBzdHJpbmc7IHZhbHVlOiBudW1iZXIgfSB8IHsgc2NyaXB0OiBCdWZmZXI7IHZhbHVlOiBudW1iZXIgfT4gPSBbXTtcbiAgICAgIGxldCB0b3RhbE91dHB1dFZhbHVlID0gMDtcblxuICAgICAgaWYgKHJlY2lwaWVudDFBZGRyZXNzICYmIHJlY2lwaWVudDFBbW91bnQgJiYgcGFyc2VGbG9hdChyZWNpcGllbnQxQW1vdW50KSA+IDApIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBNYXRoLmZsb29yKHBhcnNlRmxvYXQocmVjaXBpZW50MUFtb3VudCkgKiBET0dFX1RPX0tPSU5VKTtcbiAgICAgICAgb3V0cHV0cy5wdXNoKHsgYWRkcmVzczogcmVjaXBpZW50MUFkZHJlc3MsIHZhbHVlIH0pO1xuICAgICAgICB0b3RhbE91dHB1dFZhbHVlICs9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlY2lwaWVudDJBZGRyZXNzICYmIHJlY2lwaWVudDJBbW91bnQgJiYgcGFyc2VGbG9hdChyZWNpcGllbnQyQW1vdW50KSA+IDApIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBNYXRoLmZsb29yKHBhcnNlRmxvYXQocmVjaXBpZW50MkFtb3VudCkgKiBET0dFX1RPX0tPSU5VKTtcbiAgICAgICAgb3V0cHV0cy5wdXNoKHsgYWRkcmVzczogcmVjaXBpZW50MkFkZHJlc3MsIHZhbHVlIH0pO1xuICAgICAgICB0b3RhbE91dHB1dFZhbHVlICs9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3BSZXR1cm5UZXh0KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBCdWZmZXIuZnJvbShvcFJldHVyblRleHQsICd1dGY4Jyk7XG4gICAgICAgIGNvbnN0IGVtYmVkID0gcGF5bWVudHMuZW1iZWQoeyBkYXRhOiBbZGF0YV0gfSk7XG4gICAgICAgIGlmIChlbWJlZC5vdXRwdXQpIHtcbiAgICAgICAgICBvdXRwdXRzLnB1c2goeyBzY3JpcHQ6IGVtYmVkLm91dHB1dCwgdmFsdWU6IDAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG91dHB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFsZXJ0KFwiTm8gdmFsaWQgb3V0cHV0cyB0byBzZW5kLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGVwIDM6IEZldGNoIFVUWE9zIGFuZCBwZXJmb3JtIGNvaW4gc2VsZWN0aW9uXG4gICAgICBjb25zdCBhbGxVdHhvcyA9IGF3YWl0IGZldGNoVXR4b3MoYWRkcmVzcyk7XG4gICAgICBpZiAoIWFsbFV0eG9zIHx8IGFsbFV0eG9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhbGVydChcIk5vIHNwZW5kYWJsZSBjb2lucyAoVVRYT3MpIGZvdW5kIGZvciB0aGlzIGFkZHJlc3MuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBzZWxlY3RlZFV0eG9zOiBhbnlbXSA9IFtdO1xuICAgICAgbGV0IHRvdGFsSW5wdXRWYWx1ZSA9IDA7XG4gICAgICBsZXQgZXN0aW1hdGVkRmVlID0gMDtcblxuICAgICAgLy8gU2ltcGxlIGNvaW4gc2VsZWN0aW9uOiBmaW5kIGVub3VnaCBVVFhPcyB0byBjb3ZlciBvdXRwdXRzICsgZXN0aW1hdGVkIGZlZVxuICAgICAgZm9yIChjb25zdCB1dHhvIG9mIGFsbFV0eG9zKSB7XG4gICAgICAgIHNlbGVjdGVkVXR4b3MucHVzaCh1dHhvKTtcbiAgICAgICAgdG90YWxJbnB1dFZhbHVlICs9IHV0eG8udmFsdWU7XG4gICAgICAgIC8vIEVzdGltYXRlIGZlZTogMTQ4IGJ5dGVzIHBlciBpbnB1dCwgMzQgcGVyIG91dHB1dC4gQWRkIG9uZSBmb3IgY2hhbmdlLlxuICAgICAgICBjb25zdCBlc3RpbWF0ZWRTaXplID0gKHNlbGVjdGVkVXR4b3MubGVuZ3RoICogMTQ4KSArICgob3V0cHV0cy5sZW5ndGggKyAxKSAqIDM0KSArIDEwO1xuICAgICAgICBlc3RpbWF0ZWRGZWUgPSBlc3RpbWF0ZWRTaXplICogVFhfRkVFX1BFUl9CWVRFO1xuICAgICAgICBpZiAodG90YWxJbnB1dFZhbHVlID49IHRvdGFsT3V0cHV0VmFsdWUgKyBlc3RpbWF0ZWRGZWUpIHtcbiAgICAgICAgICBicmVhazsgLy8gRm91bmQgZW5vdWdoIGZ1bmRzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRvdGFsSW5wdXRWYWx1ZSA8IHRvdGFsT3V0cHV0VmFsdWUgKyBlc3RpbWF0ZWRGZWUpIHtcbiAgICAgICAgYWxlcnQoYE5vdCBlbm91Z2ggZnVuZHMuIFJlcXVpcmVkOiB+JHsodG90YWxPdXRwdXRWYWx1ZSArIGVzdGltYXRlZEZlZSkgLyBET0dFX1RPX0tPSU5VfSBET0dFLCBBdmFpbGFibGU6ICR7dG90YWxJbnB1dFZhbHVlIC8gRE9HRV9UT19LT0lOVX0gRE9HRWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFN0ZXAgNDogQnVpbGQgdGhlIFBTQlRcbiAgICAgIC8vY29uc3QgbmV0d29yayA9IG5ldHdvcmtzLmJpdGNvaW47IC8vIFVzZSBiaXRjb2luIGFzIGEgYmFzZSBmb3IgRG9nZWNvaW4gY29tcGF0aWJpbGl0eSBpbiBiaXRjb2luanMtbGliXG4gICAgICBjb25zdCBuZXR3b3JrID0ge1xuICAgICAgICBtZXNzYWdlUHJlZml4OiAnXFx4MTlEb2dlY29pbiBTaWduZWQgTWVzc2FnZTpcXG4nLFxuICAgICAgICBiaXAzMjoge1xuICAgICAgICAgIHB1YmxpYzogMHgwNDM1ODdjZixcbiAgICAgICAgICBwcml2YXRlOiAweDA0MzU4Mzk0LFxuICAgICAgICB9LFxuICAgICAgICBwdWJLZXlIYXNoOiAweDcxLFxuICAgICAgICBzY3JpcHRIYXNoOiAweGM0LFxuICAgICAgICB3aWY6IDB4ZjEsXG4gICAgICB9IGFzIG5ldHdvcmtzLk5ldHdvcms7XG4gICAgICBjb25zdCBwc2J0ID0gbmV3IFBzYnQoeyBuZXR3b3JrIH0pO1xuXG4gICAgICBmb3IgKGNvbnN0IHV0eG8gb2Ygc2VsZWN0ZWRVdHhvcykge1xuICAgICAgICBjb25zdCB0eEhleCA9IGF3YWl0IGZldGNoVHhIZXgodXR4by50eGlkKTtcbiAgICAgICAgcHNidC5hZGRJbnB1dCh7XG4gICAgICAgICAgaGFzaDogdXR4by50eGlkLFxuICAgICAgICAgIGluZGV4OiB1dHhvLnZvdXQsXG4gICAgICAgICAgbm9uV2l0bmVzc1V0eG86IEJ1ZmZlci5mcm9tKHR4SGV4LCAnaGV4JyksXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBvdXRwdXRzLmZvckVhY2gob3V0cHV0ID0+IHBzYnQuYWRkT3V0cHV0KG91dHB1dCkpO1xuXG4gICAgICAvLyBTdGVwIDU6IENhbGN1bGF0ZSBhbmQgYWRkIGNoYW5nZSBvdXRwdXRcbiAgICAgIGNvbnNvbGUubG9nKGBlc3RpbWF0ZWRGZWU9JHtlc3RpbWF0ZWRGZWV9LCB0b3RhbElucHV0VmFsdWU9JHt0b3RhbElucHV0VmFsdWV9LCB0b3RhbE91dHB1dFZhbHVlPSR7dG90YWxPdXRwdXRWYWx1ZX1gKTtcbiAgICAgIGNvbnN0IGNoYW5nZUFtb3VudCA9IHRvdGFsSW5wdXRWYWx1ZSAtIHRvdGFsT3V0cHV0VmFsdWUgLSBlc3RpbWF0ZWRGZWU7XG4gICAgICBpZiAoY2hhbmdlQW1vdW50ID49IERVU1RfVEhSRVNIT0xEKSB7XG4gICAgICAgIHBzYnQuYWRkT3V0cHV0KHtcbiAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLCAvLyBTZW5kIGNoYW5nZSBiYWNrIHRvIHNlbGZcbiAgICAgICAgICB2YWx1ZTogY2hhbmdlQW1vdW50LFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RlcCA2OiBDb252ZXJ0IHRoZSBQU0JUIHRvIGEgSGV4IHN0cmluZyBmb3IgdGhlIHdhbGxldFxuICAgICAgY29uc3QgcmF3VHggPSBwc2J0LnRvSGV4KCk7XG4gICAgICBjb25zdCBpbmRleGVzVG9TaWduID0gc2VsZWN0ZWRVdHhvcy5tYXAoKF8sIGluZGV4KSA9PiBpbmRleCk7XG5cbiAgICAgIC8vIFN0ZXAgNzogUmVxdWVzdCBzaWduYXR1cmUgYW5kIGJyb2FkY2FzdCBmcm9tIHRoZSB3YWxsZXRcbiAgICAgIGNvbnN0IHR4UmVxUmVzID0gYXdhaXQgbXlEb2dlLnJlcXVlc3RQc2J0KHtcbiAgICAgICAgcmF3VHg6IHJhd1R4LFxuICAgICAgICBpbmRleGVzOiBpbmRleGVzVG9TaWduLFxuICAgICAgICBzaWduT25seTogZmFsc2UsIC8vIGZhbHNlID0gc2lnbiBBTkQgYnJvYWRjYXN0XG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coJ0FkdmFuY2VkIHNlbmQgdHJhbnNhY3Rpb24gcmVzdWx0JywgdHhSZXFSZXMpO1xuICAgICAgc2V0VHhJZCh0eFJlcVJlcy50eElkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBZHZhbmNlZCBzZW5kIGZhaWxlZDonLCBlKTtcbiAgICAgIGFsZXJ0KFxuICAgICAgICBgVHJhbnNhY3Rpb24gZmFpbGVkLiBDaGVjayB0aGUgYnJvd3NlciBjb25zb2xlIGZvciBkZXRhaWxzLiBFcnJvcjogJHtlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSl9YFxuICAgICAgKTtcbiAgICB9XG4gIH0sIFtpc0Nvbm5lY3RlZCwgbXlEb2dlLCBhZGRyZXNzLCByZWNpcGllbnQxQWRkcmVzcywgcmVjaXBpZW50MUFtb3VudCwgcmVjaXBpZW50MkFkZHJlc3MsIHJlY2lwaWVudDJBbW91bnQsIG9wUmV0dXJuVGV4dF0pO1xuXG4gIGNvbnN0IG9uU2VuZEluc2NyaXB0aW9uID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghaXNDb25uZWN0ZWQoKSkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHR4UmVxUmVzID0gYXdhaXQgbXlEb2dlLnJlcXVlc3RJbnNjcmlwdGlvblRyYW5zYWN0aW9uKHtcbiAgICAgICAgcmVjaXBpZW50QWRkcmVzcyxcbiAgICAgICAgbG9jYXRpb246IGluc2NyaXB0aW9uTG9jYXRpb24sXG4gICAgICB9KTtcbiAgICAgIGNvbnNvbGUubG9nKCdyZXF1ZXN0IGluc2NyaXB0aW9uIHRyYW5zYWN0aW9uIHJlc3VsdCcsIHR4UmVxUmVzKTtcbiAgICAgIHNldFR4SWQodHhSZXFSZXMudHhJZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH0sIFtpc0Nvbm5lY3RlZCwgbXlEb2dlLCByZWNpcGllbnRBZGRyZXNzLCBpbnNjcmlwdGlvbkxvY2F0aW9uXSk7XG5cbiAgY29uc3Qgb25HZXREUkMyMEJhbGFuY2UgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFpc0Nvbm5lY3RlZCgpKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYmFsYW5jZVJlcyA9IGF3YWl0IG15RG9nZS5nZXREUkMyMEJhbGFuY2Uoe1xuICAgICAgICB0aWNrZXI6IGRyYzIwVGlja2VyLFxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZygncmVxdWVzdCBkcmMtMjAgYmFsYW5jZSByZXN1bHQnLCBiYWxhbmNlUmVzKTtcbiAgICAgIHNldERyYzIwSW5zY3JpcHRpb25zKFtdKTtcbiAgICAgIHNldERyYzIwQXZhaWxhYmxlKGJhbGFuY2VSZXMuYXZhaWxhYmxlQmFsYW5jZSk7XG4gICAgICBzZXREcmMyMFRyYW5zZmVyYWJsZShiYWxhbmNlUmVzLnRyYW5zZmVyYWJsZUJhbGFuY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9LCBbaXNDb25uZWN0ZWQsIG15RG9nZSwgZHJjMjBUaWNrZXJdKTtcblxuICBjb25zdCBvbkdldERSQzIwSW5zY3JpcHRpb25zID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghaXNDb25uZWN0ZWQoKSkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRyYW5zZmVyYWJsZVJlcyA9IGF3YWl0IG15RG9nZS5nZXRUcmFuc2ZlcmFibGVEUkMyMCh7XG4gICAgICAgIHRpY2tlcjogZHJjMjBUaWNrZXIsXG4gICAgICB9KTtcbiAgICAgIGNvbnNvbGUubG9nKCdyZXF1ZXN0IGRyYy0yMCB0cmFuc2ZlcmFibGUgcmVzdWx0JywgdHJhbnNmZXJhYmxlUmVzKTtcbiAgICAgIHNldERyYzIwSW5zY3JpcHRpb25zKHRyYW5zZmVyYWJsZVJlcy5pbnNjcmlwdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9LCBbaXNDb25uZWN0ZWQsIG15RG9nZSwgZHJjMjBUaWNrZXJdKTtcblxuICBjb25zdCBvbkF2YWlsYWJsZURSQzIwID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGlmICghaXNDb25uZWN0ZWQoKSkgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHR4UmVxUmVzID0gYXdhaXQgbXlEb2dlLnJlcXVlc3RBdmFpbGFibGVEUkMyMFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdGlja2VyOiBkcmMyMFRpY2tlcixcbiAgICAgICAgYW1vdW50OiBkcmMyMEFtb3VudCxcbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coJ3JlcXVlc3QgYXZhaWxhYmxlIGRyYy0yMCB0eCByZXN1bHQnLCB0eFJlcVJlcyk7XG4gICAgICBzZXRUeElkKHR4UmVxUmVzLnR4SWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9LCBbaXNDb25uZWN0ZWQsIG15RG9nZSwgZHJjMjBUaWNrZXIsIGRyYzIwQW1vdW50XSk7XG5cbiAgY29uc3Qgb25HZXREdW5lc0JhbGFuY2UgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFpc0Nvbm5lY3RlZCgpKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgYmFsYW5jZVJlcyA9IGF3YWl0IG15RG9nZS5nZXREdW5lc0JhbGFuY2Uoe1xuICAgICAgICB0aWNrZXI6IGR1bmVzVGlja2VyLFxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZygncmVxdWVzdCBkdW5lcyBiYWxhbmNlIHJlc3VsdCcsIGJhbGFuY2VSZXMpO1xuXG4gICAgICBzZXREdW5lc0JhbGFuY2UoYmFsYW5jZVJlcy5iYWxhbmNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfSwgW2lzQ29ubmVjdGVkLCBteURvZ2UsIGR1bmVzVGlja2VyXSk7XG5cbiAgY29uc3Qgb25TZW5kRHVuZXMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFpc0Nvbm5lY3RlZCgpKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdHhSZXFSZXMgPSBhd2FpdCBteURvZ2UucmVxdWVzdER1bmVzVHJhbnNhY3Rpb24oe1xuICAgICAgICB0aWNrZXI6IGR1bmVzVGlja2VyLFxuICAgICAgICByZWNpcGllbnRBZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IGR1bmVzQW1vdW50LFxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZygncmVxdWVzdCBkdW5lcyB0cmFuc2FjdGlvbiByZXN1bHQnLCB0eFJlcVJlcyk7XG4gICAgICBzZXRUeElkKHR4UmVxUmVzLnR4SWQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICB9LCBbaXNDb25uZWN0ZWQsIG15RG9nZSwgcmVjaXBpZW50QWRkcmVzcywgZHVuZXNUaWNrZXIsIGR1bmVzQW1vdW50XSk7XG5cbiAgY29uc3QgdHhTdGF0dXMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKHR4SWQpIHtcbiAgICAgIGNvbnN0IHR4U3RhdHVzUmVzID0gYXdhaXQgbXlEb2dlLmdldFRyYW5zYWN0aW9uU3RhdHVzKHtcbiAgICAgICAgdHhJZCxcbiAgICAgIH0pO1xuICAgICAgY29uc29sZS5sb2coJ3RyYW5zYWN0aW9uIHN0YXR1cyByZXN1bHQnLCB0eFN0YXR1c1Jlcyk7XG4gICAgICAvLyBPbmNlIGNvbmZpcm1lZCwgc3RvcCBwb2xsaW5nIGFuZCB1cGRhdGUgYmFsYW5jZVxuICAgICAgaWYgKHR4U3RhdHVzUmVzLnN0YXR1cyA9PT0gJ2NvbmZpcm1lZCcgJiYgdHhTdGF0dXNSZXMuY29uZmlybWF0aW9ucyA+IDEpIHtcbiAgICAgICAgY29uc3QgYmFsYW5jZVJlcyA9IGF3YWl0IG15RG9nZS5nZXRCYWxhbmNlKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdiYWxhbmNlIHJlc3VsdCcsIGJhbGFuY2VSZXMpO1xuICAgICAgICBzZXRCYWxhbmNlKHNiLnRvQml0Y29pbihiYWxhbmNlUmVzLmJhbGFuY2UpKTtcbiAgICAgICAgc2V0VHhJZCgnJyk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbbXlEb2dlLCB0eElkXSk7XG5cbiAgY29uc3Qgb25TZW5kUFNCVCA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWlzQ29ubmVjdGVkKCkpIHJldHVybjtcbiAgICBjb25zdCBzaWduT25seSA9IHRydWU7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgdHhSZXFSZXMgPSBhd2FpdCBteURvZ2UucmVxdWVzdFBzYnQoe1xuICAgICAgICByYXdUeCxcbiAgICAgICAgaW5kZXhlczogcHNidEluZGV4ZXMsXG4gICAgICAgIHNpZ25Pbmx5LCAvLyBPcHRpb25hbGx5IHJldHVybiB0aGUgc2lnbmVkIHRyYW5zYWN0aW9uIGluc3RlYWQgb2YgYnJvYWRjYXN0aW5nXG4gICAgICB9KTtcbiAgICAgIGNvbnNvbGUubG9nKCdyZXF1ZXN0IHNlbmQgcHNidCByZXN1bHQnLCB0eFJlcVJlcyk7XG5cbiAgICAgIGlmICghc2lnbk9ubHkpIHtcbiAgICAgICAgc2V0VHhJZCh0eFJlcVJlcy50eElkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfSwgW2lzQ29ubmVjdGVkLCBteURvZ2UsIHBzYnRJbmRleGVzLCByYXdUeF0pO1xuXG4gIGNvbnN0IG9uU2lnbk1lc3NhZ2UgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFpc0Nvbm5lY3RlZCgpKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2lnbk1zZ1JlcyA9IGF3YWl0IG15RG9nZS5yZXF1ZXN0U2lnbmVkTWVzc2FnZSh7XG4gICAgICAgIG1lc3NhZ2U6IHNpZ25NZXNzYWdlLFxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZygncmVxdWVzdCBzaWduIG1lc3NhZ2UgcmVzdWx0Jywgc2lnbk1zZ1Jlcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH0sIFtpc0Nvbm5lY3RlZCwgbXlEb2dlLCBzaWduTWVzc2FnZV0pO1xuXG4gIGNvbnN0IG9uRGVjcnlwdE1lc3NhZ2UgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFpc0Nvbm5lY3RlZCgpKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVjcnlwdE1zZ1JlcyA9IGF3YWl0IG15RG9nZS5yZXF1ZXN0RGVjcnlwdGVkTWVzc2FnZSh7XG4gICAgICAgIG1lc3NhZ2U6IGRlY3J5cHRNZXNzYWdlLFxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZygncmVxdWVzdCBkZWNyeXB0IG1lc3NhZ2UgcmVzdWx0JywgZGVjcnlwdE1zZ1Jlcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gIH0sIFtpc0Nvbm5lY3RlZCwgbXlEb2dlLCBkZWNyeXB0TWVzc2FnZV0pO1xuXG4gIHVzZUludGVydmFsKHR4U3RhdHVzLCAxMDAwMCwgZmFsc2UpO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxIZWFkPlxuICAgICAgICA8dGl0bGU+TXlEb2dlPC90aXRsZT5cbiAgICAgICAgPG1ldGEgbmFtZT0nZGVzY3JpcHRpb24nIGNvbnRlbnQ9J1NhbXBsZSBpbnRlZ3JhdGlvbicgLz5cbiAgICAgICAgPG1ldGEgbmFtZT0ndmlld3BvcnQnIGNvbnRlbnQ9J3dpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xJyAvPlxuICAgICAgICA8bGluayByZWw9J2ljb24nIGhyZWY9Jy9mYXZpY29uLmljbycgLz5cbiAgICAgIDwvSGVhZD5cbiAgICAgIDxtYWluIGNsYXNzTmFtZT17c3R5bGVzLm1haW59PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLml0ZW19PlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8YVxuICAgICAgICAgICAgICBocmVmPSdodHRwczovL2dpdGh1Yi5jb20vbXlkb2dlLWNvbS9teWRvZ2VtYXNrJ1xuICAgICAgICAgICAgICB0YXJnZXQ9J19ibGFuaydcbiAgICAgICAgICAgICAgcmVsPSdub29wZW5lciBub3JlZmVycmVyJ1xuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBDaGVja291dCBNeURvZ2UgV2FsbGV0IEJyb3dzZXIgRXh0ZW5zaW9uIG9uIEdpdEh1YlxuICAgICAgICAgICAgICA8SW1hZ2VcbiAgICAgICAgICAgICAgICBzcmM9Jy9naXRodWIuc3ZnJ1xuICAgICAgICAgICAgICAgIGFsdD0nR2l0SHViIExvZ28nXG4gICAgICAgICAgICAgICAgd2lkdGg9ezI1fVxuICAgICAgICAgICAgICAgIGhlaWdodD17MjV9XG4gICAgICAgICAgICAgICAgcHJpb3JpdHlcbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jZW50ZXJ9PlxuICAgICAgICAgIDxidXR0b24gb25DbGljaz17b25Db25uZWN0fT57YnRuVGV4dH08L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgey8qIERlYnVnIGluZm9ybWF0aW9uICovfVxuICAgICAgICA8ZGl2IHN0eWxlPXt7IG1hcmdpbjogJzIwcHgnLCBwYWRkaW5nOiAnMTBweCcsIGJhY2tncm91bmRDb2xvcjogJyNmMGYwZjAnLCBmb250U2l6ZTogJzEycHgnIH19PlxuICAgICAgICAgIDxkaXY+RGVidWcgSW5mbzo8L2Rpdj5cbiAgICAgICAgICA8ZGl2PkNvbm5lY3RlZDoge2Nvbm5lY3RlZCA/ICdZZXMnIDogJ05vJ308L2Rpdj5cbiAgICAgICAgICA8ZGl2Pk15RG9nZSBBdmFpbGFibGU6IHtteURvZ2U/LmlzTXlEb2dlID8gJ1llcycgOiAnTm8nfTwvZGl2PlxuICAgICAgICAgIDxkaXY+QWRkcmVzczoge2FkZHJlc3MgfHwgJ05vbmUnfTwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICB7Y29ubmVjdGVkICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhaW5lcn0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLml0ZW19PkFkZHJlc3M6IHthZGRyZXNzfTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pdGVtfT5CYWxhbmNlOiB7YmFsYW5jZX08L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2VudGVyfT5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtvblRpcH0+VGlwIE15RG9nZSBUZWFtIDQuMjA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2VudGVyfT7pq5jnuqflpJrovpPlh7rlj5HpgIEgKOaUr+aMgSBPUF9SRVRVUk4pPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLml0ZW19PuaUtuasvuWcsOWdgCAxOjwvZGl2PlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIHR5cGU9J3RleHQnXG4gICAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiAnMjY1cHgnIH19XG4gICAgICAgICAgICAgIHZhbHVlPXtyZWNpcGllbnQxQWRkcmVzc31cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRSZWNpcGllbnQxQWRkcmVzcyhlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pdGVtfT7ph5Hpop0gMSAoRE9HRSk6PC9kaXY+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgdHlwZT0ndGV4dCdcbiAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6ICcxMDBweCcgfX1cbiAgICAgICAgICAgICAgdmFsdWU9e3JlY2lwaWVudDFBbW91bnR9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0UmVjaXBpZW50MUFtb3VudChlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pdGVtfT7mlLbmrL7lnLDlnYAgMiAo5Y+v6YCJKTo8L2Rpdj5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICB0eXBlPSd0ZXh0J1xuICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogJzI2NXB4JyB9fVxuICAgICAgICAgICAgICB2YWx1ZT17cmVjaXBpZW50MkFkZHJlc3N9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0UmVjaXBpZW50MkFkZHJlc3MoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaXRlbX0+6YeR6aKdIDIgKERPR0UpOjwvZGl2PlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIHR5cGU9J3RleHQnXG4gICAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiAnMTAwcHgnIH19XG4gICAgICAgICAgICAgIHZhbHVlPXtyZWNpcGllbnQyQW1vdW50fVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldFJlY2lwaWVudDJBbW91bnQoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaXRlbX0+T1BfUkVUVVJOIOaWh+acrCAo5Y+v6YCJKTo8L2Rpdj5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICB0eXBlPSd0ZXh0J1xuICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogJzMwMHB4JyB9fVxuICAgICAgICAgICAgICB2YWx1ZT17b3BSZXR1cm5UZXh0fVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldE9wUmV0dXJuVGV4dChlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jZW50ZXJ9PlxuICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e29uQWR2YW5jZWRTZW5kfT5cbiAgICAgICAgICAgICAgICDpq5jnuqfmqKHlvI/lj5HpgIHkuqTmmJNcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNlbnRlcn0+XG4gICAgICAgICAgICAgIEluc2NyaXB0aW9uIGxvY2F0aW9uIChEb2dpbmFsL0RSQy0yMCkgKHR4aWQ6dm91dDpvZmZzZXQpXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICB0eXBlPSd0ZXh0J1xuICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogJzQ4NXB4JyB9fVxuICAgICAgICAgICAgICB2YWx1ZT17aW5zY3JpcHRpb25Mb2NhdGlvbn1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0aW5zY3JpcHRpb25Mb2NhdGlvbih0ZXh0LnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jZW50ZXJ9Pkluc2NyaXB0aW9uIHJlY2lwaWVudCBhZGRyZXNzPC9kaXY+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgdHlwZT0ndGV4dCdcbiAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6ICcyNjVweCcgfX1cbiAgICAgICAgICAgICAgdmFsdWU9e3JlY2lwaWVudEFkZHJlc3N9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXsodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFJlY2lwaWVudEFkZHJlc3ModGV4dC50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2VudGVyfT5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtvblNlbmRJbnNjcmlwdGlvbn0+U2VuZCBJbnNjcmlwdGlvbjwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jZW50ZXJ9PkRSQy0yMCBUaWNrZXI8L2Rpdj5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICB0eXBlPSd0ZXh0J1xuICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogJzM1cHgnIH19XG4gICAgICAgICAgICAgIHZhbHVlPXtkcmMyMFRpY2tlcn1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0RHJjMjBUaWNrZXIodGV4dC50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2VudGVyfT5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtvbkdldERSQzIwQmFsYW5jZX0+R2V0IERSQy0yMCBCYWxhbmNlPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIHtkcmMyMEF2YWlsYWJsZSAmJiAoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaXRlbX0+XG4gICAgICAgICAgICAgICAgQXZhaWxhYmxlIEJhbGFuY2U6IHtkcmMyMEF2YWlsYWJsZX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAge2RyYzIwVHJhbnNmZXJhYmxlICYmIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5pdGVtfT5cbiAgICAgICAgICAgICAgICBUcmFuc2ZlcmFibGUgQmFsYW5jZToge2RyYzIwVHJhbnNmZXJhYmxlfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICB7ZHJjMjBBdmFpbGFibGUgfHwgZHJjMjBUcmFuc2ZlcmFibGUgPyAoXG4gICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIHR5cGU9J3RleHQnXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuaXRlbX1cbiAgICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogJzEwMHB4JyB9fVxuICAgICAgICAgICAgICAgIHZhbHVlPXtkcmMyMEFtb3VudH1cbiAgICAgICAgICAgICAgICBvbkNoYW5nZT17KHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgIHNldERyYzIwQW1vdW50KHRleHQudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgICAgICB7ZHJjMjBBdmFpbGFibGUgJiYgZHJjMjBBdmFpbGFibGUgIT09ICcwJyAmJiAoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2VudGVyfT5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IG9uQXZhaWxhYmxlRFJDMjAoKX0+XG4gICAgICAgICAgICAgICAgICBNYWtlIFRyYW5zZmVyYWJsZVxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICB7ZHJjMjBUcmFuc2ZlcmFibGUgJiYgZHJjMjBUcmFuc2ZlcmFibGUgIT09ICcwJyAmJiAoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2VudGVyfT5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IG9uR2V0RFJDMjBJbnNjcmlwdGlvbnMoKX0+XG4gICAgICAgICAgICAgICAgICBHZXQgVHJhbnNmZXJhYmxlIERSQy0yMFxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICB7ZHJjMjBJbnNjcmlwdGlvbnMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAoZHJjMjBJbnNjcmlwdGlvbnMgYXMgYW55W10pLm1hcCgoaW5zY3JpcHRpb24pID0+IChcbiAgICAgICAgICAgICAgICA8ZGl2IGtleT17aW5zY3JpcHRpb24ubG9jYXRpb259PlxuICAgICAgICAgICAgICAgICAge2luc2NyaXB0aW9uLmxvY2F0aW9ufSB7aW5zY3JpcHRpb24udGlja2VyfXsnICd9XG4gICAgICAgICAgICAgICAgICB7aW5zY3JpcHRpb24uYW1vdW50fVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNlbnRlcn0+RHVuZXMgVGlja2VyPC9kaXY+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgdHlwZT0ndGV4dCdcbiAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6ICcxMzBweCcgfX1cbiAgICAgICAgICAgICAgdmFsdWU9e2R1bmVzVGlja2VyfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBzZXREdW5lc1RpY2tlcih0ZXh0LnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jZW50ZXJ9PlxuICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9e29uR2V0RHVuZXNCYWxhbmNlfT5HZXQgRHVuZXMgQmFsYW5jZTwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7ZHVuZXNCYWxhbmNlICYmIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb250YWluZXJ9PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaXRlbX0+RHVuZXMgQmFsYW5jZToge2R1bmVzQmFsYW5jZX08L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLml0ZW19PkR1bmVzIFJlY2lwaWVudCBBZGRyZXNzPC9kaXY+XG4gICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5pdGVtfVxuICAgICAgICAgICAgICAgICAgdHlwZT0ndGV4dCdcbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiAnMjY1cHgnIH19XG4gICAgICAgICAgICAgICAgICB2YWx1ZT17cmVjaXBpZW50QWRkcmVzc31cbiAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRSZWNpcGllbnRBZGRyZXNzKHRleHQudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLml0ZW19PkR1bmVzIEFtb3VudDwvZGl2PlxuICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgdHlwZT0ndGV4dCdcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLml0ZW19XG4gICAgICAgICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogJzEwMHB4JyB9fVxuICAgICAgICAgICAgICAgICAgdmFsdWU9e2R1bmVzQW1vdW50fVxuICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldER1bmVzQW1vdW50KHRleHQudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT17c3R5bGVzLml0ZW19IG9uQ2xpY2s9e29uU2VuZER1bmVzfT5cbiAgICAgICAgICAgICAgICAgIFNlbmQgRHVuZXNcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaXRlbX0+U2VuZCBQU0JUPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLml0ZW19PlJhdyBUWDwvZGl2PlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIHR5cGU9J3RleHQnXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLml0ZW19XG4gICAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiAnNTAwcHgnIH19XG4gICAgICAgICAgICAgIHZhbHVlPXtyYXdUeH1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0UmF3VHgodGV4dC50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaXRlbX0+SW5wdXQgSW5kZXhlcyAoY3N2KTwvZGl2PlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIHR5cGU9J3RleHQnXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLml0ZW19XG4gICAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiAnMTUwcHgnIH19XG4gICAgICAgICAgICAgIHZhbHVlPXtwc2J0SW5kZXhlcy5qb2luKCcsJyl9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXsodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0Py50YXJnZXQ/LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBpbmRleGVzID0gdGV4dC50YXJnZXQudmFsdWUuc3BsaXQoJywnKS5tYXAoTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgIHNldFBzYnRJbmRleGVzKGluZGV4ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNlbnRlcn0+XG4gICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gb25TZW5kUFNCVCgpfT5TZW5kIFBTQlQ8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuaXRlbX0+U2lnbiBNZXNzYWdlPC9kaXY+XG4gICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgdHlwZT0ndGV4dCdcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuaXRlbX1cbiAgICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6ICc1MDBweCcgfX1cbiAgICAgICAgICAgICAgdmFsdWU9e3NpZ25NZXNzYWdlfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KHRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRTaWduTWVzc2FnZSh0ZXh0LnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jZW50ZXJ9PlxuICAgICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IG9uU2lnbk1lc3NhZ2UoKX0+U2lnbiBNZXNzYWdlPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLml0ZW19PkRlY3J5cHQgTWVzc2FnZTwvZGl2PlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIHR5cGU9J3RleHQnXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLml0ZW19XG4gICAgICAgICAgICAgIHN0eWxlPXt7IHdpZHRoOiAnNTAwcHgnIH19XG4gICAgICAgICAgICAgIHZhbHVlPXtkZWNyeXB0TWVzc2FnZX1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyh0ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0RGVjcnlwdE1lc3NhZ2UodGV4dC50YXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2VudGVyfT5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBvbkRlY3J5cHRNZXNzYWdlKCl9PlxuICAgICAgICAgICAgICAgIERlY3J5cHQgTWVzc2FnZVxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9tYWluPlxuICAgIDwvPlxuICApO1xufVxuIl0sIm5hbWVzIjpbIkhlYWQiLCJJbWFnZSIsInNiIiwic3R5bGVzIiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImludGVyIiwiUHNidCIsInBheW1lbnRzIiwiQnVmZmVyIiwidXNlSW50ZXJ2YWwiLCJNRE9fQUREUkVTUyIsIkhvbWUiLCJidG5UZXh0Iiwic2V0QnRuVGV4dCIsImNvbm5lY3RlZCIsInNldENvbm5lY3RlZCIsImFkZHJlc3MiLCJzZXRBZGRyZXNzIiwiYmFsYW5jZSIsInNldEJhbGFuY2UiLCJ0eElkIiwic2V0VHhJZCIsImluc2NyaXB0aW9uTG9jYXRpb24iLCJzZXRpbnNjcmlwdGlvbkxvY2F0aW9uIiwicmVjaXBpZW50QWRkcmVzcyIsInNldFJlY2lwaWVudEFkZHJlc3MiLCJkcmMyMFRpY2tlciIsInNldERyYzIwVGlja2VyIiwiZHJjMjBBdmFpbGFibGUiLCJzZXREcmMyMEF2YWlsYWJsZSIsImRyYzIwVHJhbnNmZXJhYmxlIiwic2V0RHJjMjBUcmFuc2ZlcmFibGUiLCJkcmMyMEluc2NyaXB0aW9ucyIsInNldERyYzIwSW5zY3JpcHRpb25zIiwiZHJjMjBBbW91bnQiLCJzZXREcmMyMEFtb3VudCIsImR1bmVzVGlja2VyIiwic2V0RHVuZXNUaWNrZXIiLCJkdW5lc0JhbGFuY2UiLCJzZXREdW5lc0JhbGFuY2UiLCJkdW5lc0Ftb3VudCIsInNldER1bmVzQW1vdW50IiwicmF3VHgiLCJzZXRSYXdUeCIsInBzYnRJbmRleGVzIiwic2V0UHNidEluZGV4ZXMiLCJzaWduTWVzc2FnZSIsInNldFNpZ25NZXNzYWdlIiwiZGVjcnlwdE1lc3NhZ2UiLCJzZXREZWNyeXB0TWVzc2FnZSIsIm15RG9nZSIsInNldE15RG9nZSIsImludGVydmFsUmVmIiwicmVjaXBpZW50MUFkZHJlc3MiLCJzZXRSZWNpcGllbnQxQWRkcmVzcyIsInJlY2lwaWVudDFBbW91bnQiLCJzZXRSZWNpcGllbnQxQW1vdW50IiwicmVjaXBpZW50MkFkZHJlc3MiLCJzZXRSZWNpcGllbnQyQWRkcmVzcyIsInJlY2lwaWVudDJBbW91bnQiLCJzZXRSZWNpcGllbnQyQW1vdW50Iiwib3BSZXR1cm5UZXh0Iiwic2V0T3BSZXR1cm5UZXh0Iiwib25Jbml0IiwiZG9nZSIsIndpbmRvdyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjb25zb2xlIiwibG9nIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uY2UiLCJjdXJyZW50Iiwic2V0SW50ZXJ2YWwiLCJpc015RG9nZSIsImNsZWFySW50ZXJ2YWwiLCJvbkNvbm5lY3QiLCJhbGVydCIsImRpc2Nvbm5lY3RSZXMiLCJkaXNjb25uZWN0IiwiZGlzY29ubmVjdGVkIiwiY29ubmVjdFJlcyIsImNvbm5lY3QiLCJhcHByb3ZlZCIsImJhbGFuY2VSZXMiLCJnZXRCYWxhbmNlIiwidG9CaXRjb2luIiwiZSIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiU3RyaW5nIiwiY2hlY2tDb25uZWN0aW9uIiwic3RhdHVzIiwiZ2V0Q29ubmVjdGlvblN0YXR1cyIsInVuZGVmaW5lZCIsIndhcm4iLCJpc0Nvbm5lY3RlZCIsIm9uVGlwIiwidHhSZXFSZXMiLCJyZXF1ZXN0VHJhbnNhY3Rpb24iLCJkb2dlQW1vdW50Iiwib25BZHZhbmNlZFNlbmQiLCJibG9ja2Jvb2tfYmFzZSIsIkRPR0VfVE9fS09JTlUiLCJEVVNUX1RIUkVTSE9MRCIsIlRYX0ZFRV9QRVJfQllURSIsImZldGNoVXR4b3MiLCJhZGRyIiwicmVzIiwiZmV0Y2giLCJvayIsInV0eG9zIiwianNvbiIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInUiLCJ0eGlkIiwidm91dCIsInZhbHVlIiwiTnVtYmVyIiwiZmV0Y2hUeEhleCIsImJvZHkiLCJoZXgiLCJvdXRwdXRzIiwidG90YWxPdXRwdXRWYWx1ZSIsInBhcnNlRmxvYXQiLCJNYXRoIiwiZmxvb3IiLCJwdXNoIiwiZGF0YSIsImZyb20iLCJlbWJlZCIsIm91dHB1dCIsInNjcmlwdCIsImxlbmd0aCIsImFsbFV0eG9zIiwic2VsZWN0ZWRVdHhvcyIsInRvdGFsSW5wdXRWYWx1ZSIsImVzdGltYXRlZEZlZSIsInV0eG8iLCJlc3RpbWF0ZWRTaXplIiwibmV0d29yayIsIm1lc3NhZ2VQcmVmaXgiLCJiaXAzMiIsInB1YmxpYyIsInByaXZhdGUiLCJwdWJLZXlIYXNoIiwic2NyaXB0SGFzaCIsIndpZiIsInBzYnQiLCJ0eEhleCIsImFkZElucHV0IiwiaGFzaCIsImluZGV4Iiwibm9uV2l0bmVzc1V0eG8iLCJmb3JFYWNoIiwiYWRkT3V0cHV0IiwiY2hhbmdlQW1vdW50IiwidG9IZXgiLCJpbmRleGVzVG9TaWduIiwiXyIsInJlcXVlc3RQc2J0IiwiaW5kZXhlcyIsInNpZ25Pbmx5Iiwib25TZW5kSW5zY3JpcHRpb24iLCJyZXF1ZXN0SW5zY3JpcHRpb25UcmFuc2FjdGlvbiIsImxvY2F0aW9uIiwib25HZXREUkMyMEJhbGFuY2UiLCJnZXREUkMyMEJhbGFuY2UiLCJ0aWNrZXIiLCJhdmFpbGFibGVCYWxhbmNlIiwidHJhbnNmZXJhYmxlQmFsYW5jZSIsIm9uR2V0RFJDMjBJbnNjcmlwdGlvbnMiLCJ0cmFuc2ZlcmFibGVSZXMiLCJnZXRUcmFuc2ZlcmFibGVEUkMyMCIsImluc2NyaXB0aW9ucyIsIm9uQXZhaWxhYmxlRFJDMjAiLCJyZXF1ZXN0QXZhaWxhYmxlRFJDMjBUcmFuc2FjdGlvbiIsImFtb3VudCIsIm9uR2V0RHVuZXNCYWxhbmNlIiwiZ2V0RHVuZXNCYWxhbmNlIiwib25TZW5kRHVuZXMiLCJyZXF1ZXN0RHVuZXNUcmFuc2FjdGlvbiIsInR4U3RhdHVzIiwidHhTdGF0dXNSZXMiLCJnZXRUcmFuc2FjdGlvblN0YXR1cyIsImNvbmZpcm1hdGlvbnMiLCJvblNlbmRQU0JUIiwib25TaWduTWVzc2FnZSIsInNpZ25Nc2dSZXMiLCJyZXF1ZXN0U2lnbmVkTWVzc2FnZSIsIm9uRGVjcnlwdE1lc3NhZ2UiLCJkZWNyeXB0TXNnUmVzIiwicmVxdWVzdERlY3J5cHRlZE1lc3NhZ2UiLCJ0aXRsZSIsIm1ldGEiLCJuYW1lIiwiY29udGVudCIsImxpbmsiLCJyZWwiLCJocmVmIiwibWFpbiIsImNsYXNzTmFtZSIsImRpdiIsIml0ZW0iLCJhIiwidGFyZ2V0Iiwic3JjIiwiYWx0Iiwid2lkdGgiLCJoZWlnaHQiLCJwcmlvcml0eSIsImNlbnRlciIsImJ1dHRvbiIsIm9uQ2xpY2siLCJzdHlsZSIsIm1hcmdpbiIsInBhZGRpbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJmb250U2l6ZSIsImNvbnRhaW5lciIsImlucHV0IiwidHlwZSIsIm9uQ2hhbmdlIiwidGV4dCIsImluc2NyaXB0aW9uIiwiam9pbiIsInNwbGl0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/index.tsx\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={675:function(e,r){\"use strict\";r.byteLength=byteLength;r.toByteArray=toByteArray;r.fromByteArray=fromByteArray;var t=[];var f=[];var n=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;var i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(var o=0,u=i.length;o<u;++o){t[o]=i[o];f[i.charCodeAt(o)]=o}f[\"-\".charCodeAt(0)]=62;f[\"_\".charCodeAt(0)]=63;function getLens(e){var r=e.length;if(r%4>0){throw new Error(\"Invalid string. Length must be a multiple of 4\")}var t=e.indexOf(\"=\");if(t===-1)t=r;var f=t===r?0:4-t%4;return[t,f]}function byteLength(e){var r=getLens(e);var t=r[0];var f=r[1];return(t+f)*3/4-f}function _byteLength(e,r,t){return(r+t)*3/4-t}function toByteArray(e){var r;var t=getLens(e);var i=t[0];var o=t[1];var u=new n(_byteLength(e,i,o));var a=0;var s=o>0?i-4:i;var h;for(h=0;h<s;h+=4){r=f[e.charCodeAt(h)]<<18|f[e.charCodeAt(h+1)]<<12|f[e.charCodeAt(h+2)]<<6|f[e.charCodeAt(h+3)];u[a++]=r>>16&255;u[a++]=r>>8&255;u[a++]=r&255}if(o===2){r=f[e.charCodeAt(h)]<<2|f[e.charCodeAt(h+1)]>>4;u[a++]=r&255}if(o===1){r=f[e.charCodeAt(h)]<<10|f[e.charCodeAt(h+1)]<<4|f[e.charCodeAt(h+2)]>>2;u[a++]=r>>8&255;u[a++]=r&255}return u}function tripletToBase64(e){return t[e>>18&63]+t[e>>12&63]+t[e>>6&63]+t[e&63]}function encodeChunk(e,r,t){var f;var n=[];for(var i=r;i<t;i+=3){f=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255);n.push(tripletToBase64(f))}return n.join(\"\")}function fromByteArray(e){var r;var f=e.length;var n=f%3;var i=[];var o=16383;for(var u=0,a=f-n;u<a;u+=o){i.push(encodeChunk(e,u,u+o>a?a:u+o))}if(n===1){r=e[f-1];i.push(t[r>>2]+t[r<<4&63]+\"==\")}else if(n===2){r=(e[f-2]<<8)+e[f-1];i.push(t[r>>10]+t[r>>4&63]+t[r<<2&63]+\"=\")}return i.join(\"\")}},72:function(e,r,t){\"use strict\";\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */var f=t(675);var n=t(783);var i=typeof Symbol===\"function\"&&typeof Symbol.for===\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;r.Buffer=Buffer;r.SlowBuffer=SlowBuffer;r.INSPECT_MAX_BYTES=50;var o=2147483647;r.kMaxLength=o;Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!==\"undefined\"&&typeof console.error===\"function\"){console.error(\"This browser lacks typed array (Uint8Array) support which is required by \"+\"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\")}function typedArraySupport(){try{var e=new Uint8Array(1);var r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(e,r);return e.foo()===42}catch(e){return false}}Object.defineProperty(Buffer.prototype,\"parent\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.buffer}});Object.defineProperty(Buffer.prototype,\"offset\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset}});function createBuffer(e){if(e>o){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}var r=new Uint8Array(e);Object.setPrototypeOf(r,Buffer.prototype);return r}function Buffer(e,r,t){if(typeof e===\"number\"){if(typeof r===\"string\"){throw new TypeError('The \"string\" argument must be of type string. Received type number')}return allocUnsafe(e)}return from(e,r,t)}Buffer.poolSize=8192;function from(e,r,t){if(typeof e===\"string\"){return fromString(e,r)}if(ArrayBuffer.isView(e)){return fromArrayLike(e)}if(e==null){throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)){return fromArrayBuffer(e,r,t)}if(typeof SharedArrayBuffer!==\"undefined\"&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer))){return fromArrayBuffer(e,r,t)}if(typeof e===\"number\"){throw new TypeError('The \"value\" argument must not be of type number. Received type number')}var f=e.valueOf&&e.valueOf();if(f!=null&&f!==e){return Buffer.from(f,r,t)}var n=fromObject(e);if(n)return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]===\"function\"){return Buffer.from(e[Symbol.toPrimitive](\"string\"),r,t)}throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}Buffer.from=function(e,r,t){return from(e,r,t)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(e){if(typeof e!==\"number\"){throw new TypeError('\"size\" argument must be of type number')}else if(e<0){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}}function alloc(e,r,t){assertSize(e);if(e<=0){return createBuffer(e)}if(r!==undefined){return typeof t===\"string\"?createBuffer(e).fill(r,t):createBuffer(e).fill(r)}return createBuffer(e)}Buffer.alloc=function(e,r,t){return alloc(e,r,t)};function allocUnsafe(e){assertSize(e);return createBuffer(e<0?0:checked(e)|0)}Buffer.allocUnsafe=function(e){return allocUnsafe(e)};Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)};function fromString(e,r){if(typeof r!==\"string\"||r===\"\"){r=\"utf8\"}if(!Buffer.isEncoding(r)){throw new TypeError(\"Unknown encoding: \"+r)}var t=byteLength(e,r)|0;var f=createBuffer(t);var n=f.write(e,r);if(n!==t){f=f.slice(0,n)}return f}function fromArrayLike(e){var r=e.length<0?0:checked(e.length)|0;var t=createBuffer(r);for(var f=0;f<r;f+=1){t[f]=e[f]&255}return t}function fromArrayBuffer(e,r,t){if(r<0||e.byteLength<r){throw new RangeError('\"offset\" is outside of buffer bounds')}if(e.byteLength<r+(t||0)){throw new RangeError('\"length\" is outside of buffer bounds')}var f;if(r===undefined&&t===undefined){f=new Uint8Array(e)}else if(t===undefined){f=new Uint8Array(e,r)}else{f=new Uint8Array(e,r,t)}Object.setPrototypeOf(f,Buffer.prototype);return f}function fromObject(e){if(Buffer.isBuffer(e)){var r=checked(e.length)|0;var t=createBuffer(r);if(t.length===0){return t}e.copy(t,0,0,r);return t}if(e.length!==undefined){if(typeof e.length!==\"number\"||numberIsNaN(e.length)){return createBuffer(0)}return fromArrayLike(e)}if(e.type===\"Buffer\"&&Array.isArray(e.data)){return fromArrayLike(e.data)}}function checked(e){if(e>=o){throw new RangeError(\"Attempt to allocate Buffer larger than maximum \"+\"size: 0x\"+o.toString(16)+\" bytes\")}return e|0}function SlowBuffer(e){if(+e!=e){e=0}return Buffer.alloc(+e)}Buffer.isBuffer=function isBuffer(e){return e!=null&&e._isBuffer===true&&e!==Buffer.prototype};Buffer.compare=function compare(e,r){if(isInstance(e,Uint8Array))e=Buffer.from(e,e.offset,e.byteLength);if(isInstance(r,Uint8Array))r=Buffer.from(r,r.offset,r.byteLength);if(!Buffer.isBuffer(e)||!Buffer.isBuffer(r)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array')}if(e===r)return 0;var t=e.length;var f=r.length;for(var n=0,i=Math.min(t,f);n<i;++n){if(e[n]!==r[n]){t=e[n];f=r[n];break}}if(t<f)return-1;if(f<t)return 1;return 0};Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return true;default:return false}};Buffer.concat=function concat(e,r){if(!Array.isArray(e)){throw new TypeError('\"list\" argument must be an Array of Buffers')}if(e.length===0){return Buffer.alloc(0)}var t;if(r===undefined){r=0;for(t=0;t<e.length;++t){r+=e[t].length}}var f=Buffer.allocUnsafe(r);var n=0;for(t=0;t<e.length;++t){var i=e[t];if(isInstance(i,Uint8Array)){i=Buffer.from(i)}if(!Buffer.isBuffer(i)){throw new TypeError('\"list\" argument must be an Array of Buffers')}i.copy(f,n);n+=i.length}return f};function byteLength(e,r){if(Buffer.isBuffer(e)){return e.length}if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer)){return e.byteLength}if(typeof e!==\"string\"){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+\"Received type \"+typeof e)}var t=e.length;var f=arguments.length>2&&arguments[2]===true;if(!f&&t===0)return 0;var n=false;for(;;){switch(r){case\"ascii\":case\"latin1\":case\"binary\":return t;case\"utf8\":case\"utf-8\":return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return t*2;case\"hex\":return t>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n){return f?-1:utf8ToBytes(e).length}r=(\"\"+r).toLowerCase();n=true}}}Buffer.byteLength=byteLength;function slowToString(e,r,t){var f=false;if(r===undefined||r<0){r=0}if(r>this.length){return\"\"}if(t===undefined||t>this.length){t=this.length}if(t<=0){return\"\"}t>>>=0;r>>>=0;if(t<=r){return\"\"}if(!e)e=\"utf8\";while(true){switch(e){case\"hex\":return hexSlice(this,r,t);case\"utf8\":case\"utf-8\":return utf8Slice(this,r,t);case\"ascii\":return asciiSlice(this,r,t);case\"latin1\":case\"binary\":return latin1Slice(this,r,t);case\"base64\":return base64Slice(this,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,r,t);default:if(f)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase();f=true}}}Buffer.prototype._isBuffer=true;function swap(e,r,t){var f=e[r];e[r]=e[t];e[t]=f}Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!==0){throw new RangeError(\"Buffer size must be a multiple of 16-bits\")}for(var r=0;r<e;r+=2){swap(this,r,r+1)}return this};Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!==0){throw new RangeError(\"Buffer size must be a multiple of 32-bits\")}for(var r=0;r<e;r+=4){swap(this,r,r+3);swap(this,r+1,r+2)}return this};Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!==0){throw new RangeError(\"Buffer size must be a multiple of 64-bits\")}for(var r=0;r<e;r+=8){swap(this,r,r+7);swap(this,r+1,r+6);swap(this,r+2,r+5);swap(this,r+3,r+4)}return this};Buffer.prototype.toString=function toString(){var e=this.length;if(e===0)return\"\";if(arguments.length===0)return utf8Slice(this,0,e);return slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(this===e)return true;return Buffer.compare(this,e)===0};Buffer.prototype.inspect=function inspect(){var e=\"\";var t=r.INSPECT_MAX_BYTES;e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim();if(this.length>t)e+=\" ... \";return\"<Buffer \"+e+\">\"};if(i){Buffer.prototype[i]=Buffer.prototype.inspect}Buffer.prototype.compare=function compare(e,r,t,f,n){if(isInstance(e,Uint8Array)){e=Buffer.from(e,e.offset,e.byteLength)}if(!Buffer.isBuffer(e)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+\"Received type \"+typeof e)}if(r===undefined){r=0}if(t===undefined){t=e?e.length:0}if(f===undefined){f=0}if(n===undefined){n=this.length}if(r<0||t>e.length||f<0||n>this.length){throw new RangeError(\"out of range index\")}if(f>=n&&r>=t){return 0}if(f>=n){return-1}if(r>=t){return 1}r>>>=0;t>>>=0;f>>>=0;n>>>=0;if(this===e)return 0;var i=n-f;var o=t-r;var u=Math.min(i,o);var a=this.slice(f,n);var s=e.slice(r,t);for(var h=0;h<u;++h){if(a[h]!==s[h]){i=a[h];o=s[h];break}}if(i<o)return-1;if(o<i)return 1;return 0};function bidirectionalIndexOf(e,r,t,f,n){if(e.length===0)return-1;if(typeof t===\"string\"){f=t;t=0}else if(t>2147483647){t=2147483647}else if(t<-2147483648){t=-2147483648}t=+t;if(numberIsNaN(t)){t=n?0:e.length-1}if(t<0)t=e.length+t;if(t>=e.length){if(n)return-1;else t=e.length-1}else if(t<0){if(n)t=0;else return-1}if(typeof r===\"string\"){r=Buffer.from(r,f)}if(Buffer.isBuffer(r)){if(r.length===0){return-1}return arrayIndexOf(e,r,t,f,n)}else if(typeof r===\"number\"){r=r&255;if(typeof Uint8Array.prototype.indexOf===\"function\"){if(n){return Uint8Array.prototype.indexOf.call(e,r,t)}else{return Uint8Array.prototype.lastIndexOf.call(e,r,t)}}return arrayIndexOf(e,[r],t,f,n)}throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,r,t,f,n){var i=1;var o=e.length;var u=r.length;if(f!==undefined){f=String(f).toLowerCase();if(f===\"ucs2\"||f===\"ucs-2\"||f===\"utf16le\"||f===\"utf-16le\"){if(e.length<2||r.length<2){return-1}i=2;o/=2;u/=2;t/=2}}function read(e,r){if(i===1){return e[r]}else{return e.readUInt16BE(r*i)}}var a;if(n){var s=-1;for(a=t;a<o;a++){if(read(e,a)===read(r,s===-1?0:a-s)){if(s===-1)s=a;if(a-s+1===u)return s*i}else{if(s!==-1)a-=a-s;s=-1}}}else{if(t+u>o)t=o-u;for(a=t;a>=0;a--){var h=true;for(var c=0;c<u;c++){if(read(e,a+c)!==read(r,c)){h=false;break}}if(h)return a}}return-1}Buffer.prototype.includes=function includes(e,r,t){return this.indexOf(e,r,t)!==-1};Buffer.prototype.indexOf=function indexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,true)};Buffer.prototype.lastIndexOf=function lastIndexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,false)};function hexWrite(e,r,t,f){t=Number(t)||0;var n=e.length-t;if(!f){f=n}else{f=Number(f);if(f>n){f=n}}var i=r.length;if(f>i/2){f=i/2}for(var o=0;o<f;++o){var u=parseInt(r.substr(o*2,2),16);if(numberIsNaN(u))return o;e[t+o]=u}return o}function utf8Write(e,r,t,f){return blitBuffer(utf8ToBytes(r,e.length-t),e,t,f)}function asciiWrite(e,r,t,f){return blitBuffer(asciiToBytes(r),e,t,f)}function latin1Write(e,r,t,f){return asciiWrite(e,r,t,f)}function base64Write(e,r,t,f){return blitBuffer(base64ToBytes(r),e,t,f)}function ucs2Write(e,r,t,f){return blitBuffer(utf16leToBytes(r,e.length-t),e,t,f)}Buffer.prototype.write=function write(e,r,t,f){if(r===undefined){f=\"utf8\";t=this.length;r=0}else if(t===undefined&&typeof r===\"string\"){f=r;t=this.length;r=0}else if(isFinite(r)){r=r>>>0;if(isFinite(t)){t=t>>>0;if(f===undefined)f=\"utf8\"}else{f=t;t=undefined}}else{throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\")}var n=this.length-r;if(t===undefined||t>n)t=n;if(e.length>0&&(t<0||r<0)||r>this.length){throw new RangeError(\"Attempt to write outside buffer bounds\")}if(!f)f=\"utf8\";var i=false;for(;;){switch(f){case\"hex\":return hexWrite(this,e,r,t);case\"utf8\":case\"utf-8\":return utf8Write(this,e,r,t);case\"ascii\":return asciiWrite(this,e,r,t);case\"latin1\":case\"binary\":return latin1Write(this,e,r,t);case\"base64\":return base64Write(this,e,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,r,t);default:if(i)throw new TypeError(\"Unknown encoding: \"+f);f=(\"\"+f).toLowerCase();i=true}}};Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function base64Slice(e,r,t){if(r===0&&t===e.length){return f.fromByteArray(e)}else{return f.fromByteArray(e.slice(r,t))}}function utf8Slice(e,r,t){t=Math.min(e.length,t);var f=[];var n=r;while(n<t){var i=e[n];var o=null;var u=i>239?4:i>223?3:i>191?2:1;if(n+u<=t){var a,s,h,c;switch(u){case 1:if(i<128){o=i}break;case 2:a=e[n+1];if((a&192)===128){c=(i&31)<<6|a&63;if(c>127){o=c}}break;case 3:a=e[n+1];s=e[n+2];if((a&192)===128&&(s&192)===128){c=(i&15)<<12|(a&63)<<6|s&63;if(c>2047&&(c<55296||c>57343)){o=c}}break;case 4:a=e[n+1];s=e[n+2];h=e[n+3];if((a&192)===128&&(s&192)===128&&(h&192)===128){c=(i&15)<<18|(a&63)<<12|(s&63)<<6|h&63;if(c>65535&&c<1114112){o=c}}}}if(o===null){o=65533;u=1}else if(o>65535){o-=65536;f.push(o>>>10&1023|55296);o=56320|o&1023}f.push(o);n+=u}return decodeCodePointsArray(f)}var u=4096;function decodeCodePointsArray(e){var r=e.length;if(r<=u){return String.fromCharCode.apply(String,e)}var t=\"\";var f=0;while(f<r){t+=String.fromCharCode.apply(String,e.slice(f,f+=u))}return t}function asciiSlice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n]&127)}return f}function latin1Slice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n])}return f}function hexSlice(e,r,t){var f=e.length;if(!r||r<0)r=0;if(!t||t<0||t>f)t=f;var n=\"\";for(var i=r;i<t;++i){n+=s[e[i]]}return n}function utf16leSlice(e,r,t){var f=e.slice(r,t);var n=\"\";for(var i=0;i<f.length;i+=2){n+=String.fromCharCode(f[i]+f[i+1]*256)}return n}Buffer.prototype.slice=function slice(e,r){var t=this.length;e=~~e;r=r===undefined?t:~~r;if(e<0){e+=t;if(e<0)e=0}else if(e>t){e=t}if(r<0){r+=t;if(r<0)r=0}else if(r>t){r=t}if(r<e)r=e;var f=this.subarray(e,r);Object.setPrototypeOf(f,Buffer.prototype);return f};function checkOffset(e,r,t){if(e%1!==0||e<0)throw new RangeError(\"offset is not uint\");if(e+r>t)throw new RangeError(\"Trying to access beyond buffer length\")}Buffer.prototype.readUIntLE=function readUIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}return f};Buffer.prototype.readUIntBE=function readUIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t){checkOffset(e,r,this.length)}var f=this[e+--r];var n=1;while(r>0&&(n*=256)){f+=this[e+--r]*n}return f};Buffer.prototype.readUInt8=function readUInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);return this[e]};Buffer.prototype.readUInt16LE=function readUInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]|this[e+1]<<8};Buffer.prototype.readUInt16BE=function readUInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]<<8|this[e+1]};Buffer.prototype.readUInt32LE=function readUInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};Buffer.prototype.readUInt32BE=function readUInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};Buffer.prototype.readIntLE=function readIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}n*=128;if(f>=n)f-=Math.pow(2,8*r);return f};Buffer.prototype.readIntBE=function readIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=r;var n=1;var i=this[e+--f];while(f>0&&(n*=256)){i+=this[e+--f]*n}n*=128;if(i>=n)i-=Math.pow(2,8*r);return i};Buffer.prototype.readInt8=function readInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};Buffer.prototype.readInt16LE=function readInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e]|this[e+1]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt16BE=function readInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e+1]|this[e]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt32LE=function readInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};Buffer.prototype.readInt32BE=function readInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};Buffer.prototype.readFloatLE=function readFloatLE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,true,23,4)};Buffer.prototype.readFloatBE=function readFloatBE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,false,23,4)};Buffer.prototype.readDoubleLE=function readDoubleLE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,true,52,8)};Buffer.prototype.readDoubleBE=function readDoubleBE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,false,52,8)};function checkInt(e,r,t,f,n,i){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>n||r<i)throw new RangeError('\"value\" argument is out of bounds');if(t+f>e.length)throw new RangeError(\"Index out of range\")}Buffer.prototype.writeUIntLE=function writeUIntLE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=1;var o=0;this[r]=e&255;while(++o<t&&(i*=256)){this[r+o]=e/i&255}return r+t};Buffer.prototype.writeUIntBE=function writeUIntBE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=t-1;var o=1;this[r+i]=e&255;while(--i>=0&&(o*=256)){this[r+i]=e/o&255}return r+t};Buffer.prototype.writeUInt8=function writeUInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,255,0);this[r]=e&255;return r+1};Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r+3]=e>>>24;this[r+2]=e>>>16;this[r+1]=e>>>8;this[r]=e&255;return r+4};Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};Buffer.prototype.writeIntLE=function writeIntLE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=0;var o=1;var u=0;this[r]=e&255;while(++i<t&&(o*=256)){if(e<0&&u===0&&this[r+i-1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeIntBE=function writeIntBE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=t-1;var o=1;var u=0;this[r+i]=e&255;while(--i>=0&&(o*=256)){if(e<0&&u===0&&this[r+i+1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeInt8=function writeInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,127,-128);if(e<0)e=255+e+1;this[r]=e&255;return r+1};Buffer.prototype.writeInt16LE=function writeInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeInt16BE=function writeInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeInt32LE=function writeInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);this[r]=e&255;this[r+1]=e>>>8;this[r+2]=e>>>16;this[r+3]=e>>>24;return r+4};Buffer.prototype.writeInt32BE=function writeInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};function checkIEEE754(e,r,t,f,n,i){if(t+f>e.length)throw new RangeError(\"Index out of range\");if(t<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,4,34028234663852886e22,-34028234663852886e22)}n.write(e,r,t,f,23,4);return t+4}Buffer.prototype.writeFloatLE=function writeFloatLE(e,r,t){return writeFloat(this,e,r,true,t)};Buffer.prototype.writeFloatBE=function writeFloatBE(e,r,t){return writeFloat(this,e,r,false,t)};function writeDouble(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,8,17976931348623157e292,-17976931348623157e292)}n.write(e,r,t,f,52,8);return t+8}Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,r,t){return writeDouble(this,e,r,true,t)};Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,r,t){return writeDouble(this,e,r,false,t)};Buffer.prototype.copy=function copy(e,r,t,f){if(!Buffer.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(!t)t=0;if(!f&&f!==0)f=this.length;if(r>=e.length)r=e.length;if(!r)r=0;if(f>0&&f<t)f=t;if(f===t)return 0;if(e.length===0||this.length===0)return 0;if(r<0){throw new RangeError(\"targetStart out of bounds\")}if(t<0||t>=this.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"sourceEnd out of bounds\");if(f>this.length)f=this.length;if(e.length-r<f-t){f=e.length-r+t}var n=f-t;if(this===e&&typeof Uint8Array.prototype.copyWithin===\"function\"){this.copyWithin(r,t,f)}else if(this===e&&t<r&&r<f){for(var i=n-1;i>=0;--i){e[i+r]=this[i+t]}}else{Uint8Array.prototype.set.call(e,this.subarray(t,f),r)}return n};Buffer.prototype.fill=function fill(e,r,t,f){if(typeof e===\"string\"){if(typeof r===\"string\"){f=r;r=0;t=this.length}else if(typeof t===\"string\"){f=t;t=this.length}if(f!==undefined&&typeof f!==\"string\"){throw new TypeError(\"encoding must be a string\")}if(typeof f===\"string\"&&!Buffer.isEncoding(f)){throw new TypeError(\"Unknown encoding: \"+f)}if(e.length===1){var n=e.charCodeAt(0);if(f===\"utf8\"&&n<128||f===\"latin1\"){e=n}}}else if(typeof e===\"number\"){e=e&255}else if(typeof e===\"boolean\"){e=Number(e)}if(r<0||this.length<r||this.length<t){throw new RangeError(\"Out of range index\")}if(t<=r){return this}r=r>>>0;t=t===undefined?this.length:t>>>0;if(!e)e=0;var i;if(typeof e===\"number\"){for(i=r;i<t;++i){this[i]=e}}else{var o=Buffer.isBuffer(e)?e:Buffer.from(e,f);var u=o.length;if(u===0){throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"')}for(i=0;i<t-r;++i){this[i+r]=o[i%u]}}return this};var a=/[^+/0-9A-Za-z-_]/g;function base64clean(e){e=e.split(\"=\")[0];e=e.trim().replace(a,\"\");if(e.length<2)return\"\";while(e.length%4!==0){e=e+\"=\"}return e}function utf8ToBytes(e,r){r=r||Infinity;var t;var f=e.length;var n=null;var i=[];for(var o=0;o<f;++o){t=e.charCodeAt(o);if(t>55295&&t<57344){if(!n){if(t>56319){if((r-=3)>-1)i.push(239,191,189);continue}else if(o+1===f){if((r-=3)>-1)i.push(239,191,189);continue}n=t;continue}if(t<56320){if((r-=3)>-1)i.push(239,191,189);n=t;continue}t=(n-55296<<10|t-56320)+65536}else if(n){if((r-=3)>-1)i.push(239,191,189)}n=null;if(t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,t&63|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,t&63|128)}else if(t<1114112){if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,t&63|128)}else{throw new Error(\"Invalid code point\")}}return i}function asciiToBytes(e){var r=[];for(var t=0;t<e.length;++t){r.push(e.charCodeAt(t)&255)}return r}function utf16leToBytes(e,r){var t,f,n;var i=[];for(var o=0;o<e.length;++o){if((r-=2)<0)break;t=e.charCodeAt(o);f=t>>8;n=t%256;i.push(n);i.push(f)}return i}function base64ToBytes(e){return f.toByteArray(base64clean(e))}function blitBuffer(e,r,t,f){for(var n=0;n<f;++n){if(n+t>=r.length||n>=e.length)break;r[n+t]=e[n]}return n}function isInstance(e,r){return e instanceof r||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===r.name}function numberIsNaN(e){return e!==e}var s=function(){var e=\"0123456789abcdef\";var r=new Array(256);for(var t=0;t<16;++t){var f=t*16;for(var n=0;n<16;++n){r[f+n]=e[t]+e[n]}}return r}()},783:function(e,r){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nr.read=function(e,r,t,f,n){var i,o;var u=n*8-f-1;var a=(1<<u)-1;var s=a>>1;var h=-7;var c=t?n-1:0;var l=t?-1:1;var p=e[r+c];c+=l;i=p&(1<<-h)-1;p>>=-h;h+=u;for(;h>0;i=i*256+e[r+c],c+=l,h-=8){}o=i&(1<<-h)-1;i>>=-h;h+=f;for(;h>0;o=o*256+e[r+c],c+=l,h-=8){}if(i===0){i=1-s}else if(i===a){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,f);i=i-s}return(p?-1:1)*o*Math.pow(2,i-f)};r.write=function(e,r,t,f,n,i){var o,u,a;var s=i*8-n-1;var h=(1<<s)-1;var c=h>>1;var l=n===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=f?0:i-1;var y=f?1:-1;var g=r<0||r===0&&1/r<0?1:0;r=Math.abs(r);if(isNaN(r)||r===Infinity){u=isNaN(r)?1:0;o=h}else{o=Math.floor(Math.log(r)/Math.LN2);if(r*(a=Math.pow(2,-o))<1){o--;a*=2}if(o+c>=1){r+=l/a}else{r+=l*Math.pow(2,1-c)}if(r*a>=2){o++;a/=2}if(o+c>=h){u=0;o=h}else if(o+c>=1){u=(r*a-1)*Math.pow(2,n);o=o+c}else{u=r*Math.pow(2,c-1)*Math.pow(2,n);o=0}}for(;n>=8;e[t+p]=u&255,p+=y,u/=256,n-=8){}o=o<<n|u;s+=n;for(;s>0;e[t+p]=o&255,p+=y,o/=256,s-=8){}e[t+p-y]|=g*128}}};var r={};function __nccwpck_require__(t){var f=r[t];if(f!==undefined){return f.exports}var n=r[t]={exports:{}};var i=true;try{e[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(72);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2J1ZmZlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGtCQUFrQixhQUFhLHdCQUF3QiwwQkFBMEIsOEJBQThCLFNBQVMsU0FBUyx1REFBdUQseUVBQXlFLHVCQUF1QixJQUFJLEtBQUssVUFBVSxxQkFBcUIsd0JBQXdCLHdCQUF3QixvQkFBb0IsZUFBZSxVQUFVLGtFQUFrRSxxQkFBcUIsY0FBYyxvQkFBb0IsWUFBWSx1QkFBdUIsaUJBQWlCLFdBQVcsV0FBVyxrQkFBa0IsNEJBQTRCLGtCQUFrQix3QkFBd0IsTUFBTSxpQkFBaUIsV0FBVyxXQUFXLGdDQUFnQyxRQUFRLGdCQUFnQixNQUFNLFFBQVEsSUFBSSxNQUFNLCtGQUErRixpQkFBaUIsZ0JBQWdCLGFBQWEsVUFBVSxnREFBZ0QsYUFBYSxVQUFVLHlFQUF5RSxnQkFBZ0IsYUFBYSxTQUFTLDRCQUE0QixrREFBa0QsNEJBQTRCLE1BQU0sU0FBUyxZQUFZLElBQUksTUFBTSxxREFBcUQsMkJBQTJCLGtCQUFrQiwwQkFBMEIsTUFBTSxlQUFlLFVBQVUsU0FBUyxZQUFZLGtCQUFrQixJQUFJLE1BQU0scUNBQXFDLFVBQVUsU0FBUyxnQ0FBZ0MsZUFBZSxxQkFBcUIsMkNBQTJDLG1CQUFtQixvQkFBb0I7QUFDOXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSwrR0FBK0csZ0JBQWdCLHdCQUF3Qix1QkFBdUIsaUJBQWlCLGVBQWUsK0NBQStDLGlHQUFpRyxrS0FBa0ssNkJBQTZCLElBQUksd0JBQXdCLE9BQU8sZUFBZSxZQUFZLDhDQUE4QywyQkFBMkIsb0JBQW9CLFNBQVMsY0FBYyxpREFBaUQsK0JBQStCLDJDQUEyQyxvQkFBb0IsRUFBRSxpREFBaUQsK0JBQStCLDJDQUEyQyx3QkFBd0IsRUFBRSx5QkFBeUIsUUFBUSx1RUFBdUUsd0JBQXdCLDBDQUEwQyxTQUFTLHVCQUF1Qix3QkFBd0Isd0JBQXdC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NEIsY0FBYywyQkFBMkIsZUFBZSxJQUFJLEtBQUssbUNBQW1DLDJCQUEyQixJQUFJLEtBQUssV0FBVyxPQUFPLEtBQUsscUJBQXFCLFdBQVcsSUFBSSxLQUFLLFdBQVcsSUFBSSxJQUFJLGdCQUFnQix3QkFBd0IsTUFBTSxLQUFLLGtDQUFrQyxLQUFLLEtBQUssS0FBSyxnQ0FBZ0MsU0FBUyxLQUFLLEtBQUssSUFBSSxnQ0FBZ0MsbUJBQW1CLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLDhCQUE4QixpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2J1ZmZlci9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17Njc1OmZ1bmN0aW9uKGUscil7XCJ1c2Ugc3RyaWN0XCI7ci5ieXRlTGVuZ3RoPWJ5dGVMZW5ndGg7ci50b0J5dGVBcnJheT10b0J5dGVBcnJheTtyLmZyb21CeXRlQXJyYXk9ZnJvbUJ5dGVBcnJheTt2YXIgdD1bXTt2YXIgZj1bXTt2YXIgbj10eXBlb2YgVWludDhBcnJheSE9PVwidW5kZWZpbmVkXCI/VWludDhBcnJheTpBcnJheTt2YXIgaT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtmb3IodmFyIG89MCx1PWkubGVuZ3RoO288dTsrK28pe3Rbb109aVtvXTtmW2kuY2hhckNvZGVBdChvKV09b31mW1wiLVwiLmNoYXJDb2RlQXQoMCldPTYyO2ZbXCJfXCIuY2hhckNvZGVBdCgwKV09NjM7ZnVuY3Rpb24gZ2V0TGVucyhlKXt2YXIgcj1lLmxlbmd0aDtpZihyJTQ+MCl7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKX12YXIgdD1lLmluZGV4T2YoXCI9XCIpO2lmKHQ9PT0tMSl0PXI7dmFyIGY9dD09PXI/MDo0LXQlNDtyZXR1cm5bdCxmXX1mdW5jdGlvbiBieXRlTGVuZ3RoKGUpe3ZhciByPWdldExlbnMoZSk7dmFyIHQ9clswXTt2YXIgZj1yWzFdO3JldHVybih0K2YpKjMvNC1mfWZ1bmN0aW9uIF9ieXRlTGVuZ3RoKGUscix0KXtyZXR1cm4ocit0KSozLzQtdH1mdW5jdGlvbiB0b0J5dGVBcnJheShlKXt2YXIgcjt2YXIgdD1nZXRMZW5zKGUpO3ZhciBpPXRbMF07dmFyIG89dFsxXTt2YXIgdT1uZXcgbihfYnl0ZUxlbmd0aChlLGksbykpO3ZhciBhPTA7dmFyIHM9bz4wP2ktNDppO3ZhciBoO2ZvcihoPTA7aDxzO2grPTQpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwxOHxmW2UuY2hhckNvZGVBdChoKzEpXTw8MTJ8ZltlLmNoYXJDb2RlQXQoaCsyKV08PDZ8ZltlLmNoYXJDb2RlQXQoaCszKV07dVthKytdPXI+PjE2JjI1NTt1W2ErK109cj4+OCYyNTU7dVthKytdPXImMjU1fWlmKG89PT0yKXtyPWZbZS5jaGFyQ29kZUF0KGgpXTw8MnxmW2UuY2hhckNvZGVBdChoKzEpXT4+NDt1W2ErK109ciYyNTV9aWYobz09PTEpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwxMHxmW2UuY2hhckNvZGVBdChoKzEpXTw8NHxmW2UuY2hhckNvZGVBdChoKzIpXT4+Mjt1W2ErK109cj4+OCYyNTU7dVthKytdPXImMjU1fXJldHVybiB1fWZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChlKXtyZXR1cm4gdFtlPj4xOCY2M10rdFtlPj4xMiY2M10rdFtlPj42JjYzXSt0W2UmNjNdfWZ1bmN0aW9uIGVuY29kZUNodW5rKGUscix0KXt2YXIgZjt2YXIgbj1bXTtmb3IodmFyIGk9cjtpPHQ7aSs9Myl7Zj0oZVtpXTw8MTYmMTY3MTE2ODApKyhlW2krMV08PDgmNjUyODApKyhlW2krMl0mMjU1KTtuLnB1c2godHJpcGxldFRvQmFzZTY0KGYpKX1yZXR1cm4gbi5qb2luKFwiXCIpfWZ1bmN0aW9uIGZyb21CeXRlQXJyYXkoZSl7dmFyIHI7dmFyIGY9ZS5sZW5ndGg7dmFyIG49ZiUzO3ZhciBpPVtdO3ZhciBvPTE2MzgzO2Zvcih2YXIgdT0wLGE9Zi1uO3U8YTt1Kz1vKXtpLnB1c2goZW5jb2RlQ2h1bmsoZSx1LHUrbz5hP2E6dStvKSl9aWYobj09PTEpe3I9ZVtmLTFdO2kucHVzaCh0W3I+PjJdK3Rbcjw8NCY2M10rXCI9PVwiKX1lbHNlIGlmKG49PT0yKXtyPShlW2YtMl08PDgpK2VbZi0xXTtpLnB1c2godFtyPj4xMF0rdFtyPj40JjYzXSt0W3I8PDImNjNdK1wiPVwiKX1yZXR1cm4gaS5qb2luKFwiXCIpfX0sNzI6ZnVuY3Rpb24oZSxyLHQpe1widXNlIHN0cmljdFwiO1xuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovdmFyIGY9dCg2NzUpO3ZhciBuPXQoNzgzKTt2YXIgaT10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLmZvcj09PVwiZnVuY3Rpb25cIj9TeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIik6bnVsbDtyLkJ1ZmZlcj1CdWZmZXI7ci5TbG93QnVmZmVyPVNsb3dCdWZmZXI7ci5JTlNQRUNUX01BWF9CWVRFUz01MDt2YXIgbz0yMTQ3NDgzNjQ3O3Iua01heExlbmd0aD1vO0J1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUPXR5cGVkQXJyYXlTdXBwb3J0KCk7aWYoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUJiZ0eXBlb2YgY29uc29sZSE9PVwidW5kZWZpbmVkXCImJnR5cGVvZiBjb25zb2xlLmVycm9yPT09XCJmdW5jdGlvblwiKXtjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5IFwiK1wiYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC5cIil9ZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQoKXt0cnl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoMSk7dmFyIHI9e2ZvbzpmdW5jdGlvbigpe3JldHVybiA0Mn19O09iamVjdC5zZXRQcm90b3R5cGVPZihyLFVpbnQ4QXJyYXkucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoZSxyKTtyZXR1cm4gZS5mb28oKT09PTQyfWNhdGNoKGUpe3JldHVybiBmYWxzZX19T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsXCJwYXJlbnRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe2lmKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpcmV0dXJuIHVuZGVmaW5lZDtyZXR1cm4gdGhpcy5idWZmZXJ9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsXCJvZmZzZXRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe2lmKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpcmV0dXJuIHVuZGVmaW5lZDtyZXR1cm4gdGhpcy5ieXRlT2Zmc2V0fX0pO2Z1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihlKXtpZihlPm8pe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfXZhciByPW5ldyBVaW50OEFycmF5KGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihyLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiByfWZ1bmN0aW9uIEJ1ZmZlcihlLHIsdCl7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtpZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyl9cmV0dXJuIGFsbG9jVW5zYWZlKGUpfXJldHVybiBmcm9tKGUscix0KX1CdWZmZXIucG9vbFNpemU9ODE5MjtmdW5jdGlvbiBmcm9tKGUscix0KXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBmcm9tU3RyaW5nKGUscil9aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpKXtyZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlPT1udWxsKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9aWYoaXNJbnN0YW5jZShlLEFycmF5QnVmZmVyKXx8ZSYmaXNJbnN0YW5jZShlLmJ1ZmZlcixBcnJheUJ1ZmZlcikpe3JldHVybiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpfWlmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJihpc0luc3RhbmNlKGUsU2hhcmVkQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLFNoYXJlZEFycmF5QnVmZmVyKSkpe3JldHVybiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpfWlmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX12YXIgZj1lLnZhbHVlT2YmJmUudmFsdWVPZigpO2lmKGYhPW51bGwmJmYhPT1lKXtyZXR1cm4gQnVmZmVyLmZyb20oZixyLHQpfXZhciBuPWZyb21PYmplY3QoZSk7aWYobilyZXR1cm4gbjtpZih0eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIiYmU3ltYm9sLnRvUHJpbWl0aXZlIT1udWxsJiZ0eXBlb2YgZVtTeW1ib2wudG9QcmltaXRpdmVdPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gQnVmZmVyLmZyb20oZVtTeW1ib2wudG9QcmltaXRpdmVdKFwic3RyaW5nXCIpLHIsdCl9dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIFwiK1wib3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfUJ1ZmZlci5mcm9tPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gZnJvbShlLHIsdCl9O09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLFVpbnQ4QXJyYXkucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLFVpbnQ4QXJyYXkpO2Z1bmN0aW9uIGFzc2VydFNpemUoZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyl9ZWxzZSBpZihlPDApe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfX1mdW5jdGlvbiBhbGxvYyhlLHIsdCl7YXNzZXJ0U2l6ZShlKTtpZihlPD0wKXtyZXR1cm4gY3JlYXRlQnVmZmVyKGUpfWlmKHIhPT11bmRlZmluZWQpe3JldHVybiB0eXBlb2YgdD09PVwic3RyaW5nXCI/Y3JlYXRlQnVmZmVyKGUpLmZpbGwocix0KTpjcmVhdGVCdWZmZXIoZSkuZmlsbChyKX1yZXR1cm4gY3JlYXRlQnVmZmVyKGUpfUJ1ZmZlci5hbGxvYz1mdW5jdGlvbihlLHIsdCl7cmV0dXJuIGFsbG9jKGUscix0KX07ZnVuY3Rpb24gYWxsb2NVbnNhZmUoZSl7YXNzZXJ0U2l6ZShlKTtyZXR1cm4gY3JlYXRlQnVmZmVyKGU8MD8wOmNoZWNrZWQoZSl8MCl9QnVmZmVyLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07QnVmZmVyLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbihlKXtyZXR1cm4gYWxsb2NVbnNhZmUoZSl9O2Z1bmN0aW9uIGZyb21TdHJpbmcoZSxyKXtpZih0eXBlb2YgciE9PVwic3RyaW5nXCJ8fHI9PT1cIlwiKXtyPVwidXRmOFwifWlmKCFCdWZmZXIuaXNFbmNvZGluZyhyKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3IpfXZhciB0PWJ5dGVMZW5ndGgoZSxyKXwwO3ZhciBmPWNyZWF0ZUJ1ZmZlcih0KTt2YXIgbj1mLndyaXRlKGUscik7aWYobiE9PXQpe2Y9Zi5zbGljZSgwLG4pfXJldHVybiBmfWZ1bmN0aW9uIGZyb21BcnJheUxpa2UoZSl7dmFyIHI9ZS5sZW5ndGg8MD8wOmNoZWNrZWQoZS5sZW5ndGgpfDA7dmFyIHQ9Y3JlYXRlQnVmZmVyKHIpO2Zvcih2YXIgZj0wO2Y8cjtmKz0xKXt0W2ZdPWVbZl0mMjU1fXJldHVybiB0fWZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl7aWYocjwwfHxlLmJ5dGVMZW5ndGg8cil7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyl9aWYoZS5ieXRlTGVuZ3RoPHIrKHR8fDApKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX12YXIgZjtpZihyPT09dW5kZWZpbmVkJiZ0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUpfWVsc2UgaWYodD09PXVuZGVmaW5lZCl7Zj1uZXcgVWludDhBcnJheShlLHIpfWVsc2V7Zj1uZXcgVWludDhBcnJheShlLHIsdCl9T2JqZWN0LnNldFByb3RvdHlwZU9mKGYsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbU9iamVjdChlKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3ZhciByPWNoZWNrZWQoZS5sZW5ndGgpfDA7dmFyIHQ9Y3JlYXRlQnVmZmVyKHIpO2lmKHQubGVuZ3RoPT09MCl7cmV0dXJuIHR9ZS5jb3B5KHQsMCwwLHIpO3JldHVybiB0fWlmKGUubGVuZ3RoIT09dW5kZWZpbmVkKXtpZih0eXBlb2YgZS5sZW5ndGghPT1cIm51bWJlclwifHxudW1iZXJJc05hTihlLmxlbmd0aCkpe3JldHVybiBjcmVhdGVCdWZmZXIoMCl9cmV0dXJuIGZyb21BcnJheUxpa2UoZSl9aWYoZS50eXBlPT09XCJCdWZmZXJcIiYmQXJyYXkuaXNBcnJheShlLmRhdGEpKXtyZXR1cm4gZnJvbUFycmF5TGlrZShlLmRhdGEpfX1mdW5jdGlvbiBjaGVja2VkKGUpe2lmKGU+PW8pe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBcIitcInNpemU6IDB4XCIrby50b1N0cmluZygxNikrXCIgYnl0ZXNcIil9cmV0dXJuIGV8MH1mdW5jdGlvbiBTbG93QnVmZmVyKGUpe2lmKCtlIT1lKXtlPTB9cmV0dXJuIEJ1ZmZlci5hbGxvYygrZSl9QnVmZmVyLmlzQnVmZmVyPWZ1bmN0aW9uIGlzQnVmZmVyKGUpe3JldHVybiBlIT1udWxsJiZlLl9pc0J1ZmZlcj09PXRydWUmJmUhPT1CdWZmZXIucHJvdG90eXBlfTtCdWZmZXIuY29tcGFyZT1mdW5jdGlvbiBjb21wYXJlKGUscil7aWYoaXNJbnN0YW5jZShlLFVpbnQ4QXJyYXkpKWU9QnVmZmVyLmZyb20oZSxlLm9mZnNldCxlLmJ5dGVMZW5ndGgpO2lmKGlzSW5zdGFuY2UocixVaW50OEFycmF5KSlyPUJ1ZmZlci5mcm9tKHIsci5vZmZzZXQsci5ieXRlTGVuZ3RoKTtpZighQnVmZmVyLmlzQnVmZmVyKGUpfHwhQnVmZmVyLmlzQnVmZmVyKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5Jyl9aWYoZT09PXIpcmV0dXJuIDA7dmFyIHQ9ZS5sZW5ndGg7dmFyIGY9ci5sZW5ndGg7Zm9yKHZhciBuPTAsaT1NYXRoLm1pbih0LGYpO248aTsrK24pe2lmKGVbbl0hPT1yW25dKXt0PWVbbl07Zj1yW25dO2JyZWFrfX1pZih0PGYpcmV0dXJuLTE7aWYoZjx0KXJldHVybiAxO3JldHVybiAwfTtCdWZmZXIuaXNFbmNvZGluZz1mdW5jdGlvbiBpc0VuY29kaW5nKGUpe3N3aXRjaChTdHJpbmcoZSkudG9Mb3dlckNhc2UoKSl7Y2FzZVwiaGV4XCI6Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpjYXNlXCJiYXNlNjRcIjpjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdHJ1ZTtkZWZhdWx0OnJldHVybiBmYWxzZX19O0J1ZmZlci5jb25jYXQ9ZnVuY3Rpb24gY29uY2F0KGUscil7aWYoIUFycmF5LmlzQXJyYXkoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpfWlmKGUubGVuZ3RoPT09MCl7cmV0dXJuIEJ1ZmZlci5hbGxvYygwKX12YXIgdDtpZihyPT09dW5kZWZpbmVkKXtyPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7cis9ZVt0XS5sZW5ndGh9fXZhciBmPUJ1ZmZlci5hbGxvY1Vuc2FmZShyKTt2YXIgbj0wO2Zvcih0PTA7dDxlLmxlbmd0aDsrK3Qpe3ZhciBpPWVbdF07aWYoaXNJbnN0YW5jZShpLFVpbnQ4QXJyYXkpKXtpPUJ1ZmZlci5mcm9tKGkpfWlmKCFCdWZmZXIuaXNCdWZmZXIoaSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpfWkuY29weShmLG4pO24rPWkubGVuZ3RofXJldHVybiBmfTtmdW5jdGlvbiBieXRlTGVuZ3RoKGUscil7aWYoQnVmZmVyLmlzQnVmZmVyKGUpKXtyZXR1cm4gZS5sZW5ndGh9aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpfHxpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpKXtyZXR1cm4gZS5ieXRlTGVuZ3RofWlmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcrXCJSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX12YXIgdD1lLmxlbmd0aDt2YXIgZj1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXT09PXRydWU7aWYoIWYmJnQ9PT0wKXJldHVybiAwO3ZhciBuPWZhbHNlO2Zvcig7Oyl7c3dpdGNoKHIpe2Nhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIHQ7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhUb0J5dGVzKGUpLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdCoyO2Nhc2VcImhleFwiOnJldHVybiB0Pj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0VG9CeXRlcyhlKS5sZW5ndGg7ZGVmYXVsdDppZihuKXtyZXR1cm4gZj8tMTp1dGY4VG9CeXRlcyhlKS5sZW5ndGh9cj0oXCJcIityKS50b0xvd2VyQ2FzZSgpO249dHJ1ZX19fUJ1ZmZlci5ieXRlTGVuZ3RoPWJ5dGVMZW5ndGg7ZnVuY3Rpb24gc2xvd1RvU3RyaW5nKGUscix0KXt2YXIgZj1mYWxzZTtpZihyPT09dW5kZWZpbmVkfHxyPDApe3I9MH1pZihyPnRoaXMubGVuZ3RoKXtyZXR1cm5cIlwifWlmKHQ9PT11bmRlZmluZWR8fHQ+dGhpcy5sZW5ndGgpe3Q9dGhpcy5sZW5ndGh9aWYodDw9MCl7cmV0dXJuXCJcIn10Pj4+PTA7cj4+Pj0wO2lmKHQ8PXIpe3JldHVyblwiXCJ9aWYoIWUpZT1cInV0ZjhcIjt3aGlsZSh0cnVlKXtzd2l0Y2goZSl7Y2FzZVwiaGV4XCI6cmV0dXJuIGhleFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFNsaWNlKHRoaXMscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVNsaWNlKHRoaXMscix0KTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gbGF0aW4xU2xpY2UodGhpcyxyLHQpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRTbGljZSh0aGlzLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLHIsdCk7ZGVmYXVsdDppZihmKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitlKTtlPShlK1wiXCIpLnRvTG93ZXJDYXNlKCk7Zj10cnVlfX19QnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXI9dHJ1ZTtmdW5jdGlvbiBzd2FwKGUscix0KXt2YXIgZj1lW3JdO2Vbcl09ZVt0XTtlW3RdPWZ9QnVmZmVyLnByb3RvdHlwZS5zd2FwMTY9ZnVuY3Rpb24gc3dhcDE2KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSUyIT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9Mil7c3dhcCh0aGlzLHIscisxKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwMzI9ZnVuY3Rpb24gc3dhcDMyKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU0IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9NCl7c3dhcCh0aGlzLHIsciszKTtzd2FwKHRoaXMscisxLHIrMil9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUuc3dhcDY0PWZ1bmN0aW9uIHN3YXA2NCgpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlOCE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHNcIil9Zm9yKHZhciByPTA7cjxlO3IrPTgpe3N3YXAodGhpcyxyLHIrNyk7c3dhcCh0aGlzLHIrMSxyKzYpO3N3YXAodGhpcyxyKzIscis1KTtzd2FwKHRoaXMsciszLHIrNCl9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24gdG9TdHJpbmcoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlPT09MClyZXR1cm5cIlwiO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXJldHVybiB1dGY4U2xpY2UodGhpcywwLGUpO3JldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtCdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nPUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc7QnVmZmVyLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24gZXF1YWxzKGUpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7aWYodGhpcz09PWUpcmV0dXJuIHRydWU7cmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsZSk9PT0wfTtCdWZmZXIucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24gaW5zcGVjdCgpe3ZhciBlPVwiXCI7dmFyIHQ9ci5JTlNQRUNUX01BWF9CWVRFUztlPXRoaXMudG9TdHJpbmcoXCJoZXhcIiwwLHQpLnJlcGxhY2UoLyguezJ9KS9nLFwiJDEgXCIpLnRyaW0oKTtpZih0aGlzLmxlbmd0aD50KWUrPVwiIC4uLiBcIjtyZXR1cm5cIjxCdWZmZXIgXCIrZStcIj5cIn07aWYoaSl7QnVmZmVyLnByb3RvdHlwZVtpXT1CdWZmZXIucHJvdG90eXBlLmluc3BlY3R9QnVmZmVyLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyLHQsZixuKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpe2U9QnVmZmVyLmZyb20oZSxlLm9mZnNldCxlLmJ5dGVMZW5ndGgpfWlmKCFCdWZmZXIuaXNCdWZmZXIoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcrXCJSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihyPT09dW5kZWZpbmVkKXtyPTB9aWYodD09PXVuZGVmaW5lZCl7dD1lP2UubGVuZ3RoOjB9aWYoZj09PXVuZGVmaW5lZCl7Zj0wfWlmKG49PT11bmRlZmluZWQpe249dGhpcy5sZW5ndGh9aWYocjwwfHx0PmUubGVuZ3RofHxmPDB8fG4+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJhbmdlIGluZGV4XCIpfWlmKGY+PW4mJnI+PXQpe3JldHVybiAwfWlmKGY+PW4pe3JldHVybi0xfWlmKHI+PXQpe3JldHVybiAxfXI+Pj49MDt0Pj4+PTA7Zj4+Pj0wO24+Pj49MDtpZih0aGlzPT09ZSlyZXR1cm4gMDt2YXIgaT1uLWY7dmFyIG89dC1yO3ZhciB1PU1hdGgubWluKGksbyk7dmFyIGE9dGhpcy5zbGljZShmLG4pO3ZhciBzPWUuc2xpY2Uocix0KTtmb3IodmFyIGg9MDtoPHU7KytoKXtpZihhW2hdIT09c1toXSl7aT1hW2hdO289c1toXTticmVha319aWYoaTxvKXJldHVybi0xO2lmKG88aSlyZXR1cm4gMTtyZXR1cm4gMH07ZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YoZSxyLHQsZixuKXtpZihlLmxlbmd0aD09PTApcmV0dXJuLTE7aWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD0wfWVsc2UgaWYodD4yMTQ3NDgzNjQ3KXt0PTIxNDc0ODM2NDd9ZWxzZSBpZih0PC0yMTQ3NDgzNjQ4KXt0PS0yMTQ3NDgzNjQ4fXQ9K3Q7aWYobnVtYmVySXNOYU4odCkpe3Q9bj8wOmUubGVuZ3RoLTF9aWYodDwwKXQ9ZS5sZW5ndGgrdDtpZih0Pj1lLmxlbmd0aCl7aWYobilyZXR1cm4tMTtlbHNlIHQ9ZS5sZW5ndGgtMX1lbHNlIGlmKHQ8MCl7aWYobil0PTA7ZWxzZSByZXR1cm4tMX1pZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe3I9QnVmZmVyLmZyb20ocixmKX1pZihCdWZmZXIuaXNCdWZmZXIocikpe2lmKHIubGVuZ3RoPT09MCl7cmV0dXJuLTF9cmV0dXJuIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pfWVsc2UgaWYodHlwZW9mIHI9PT1cIm51bWJlclwiKXtyPXImMjU1O2lmKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mPT09XCJmdW5jdGlvblwiKXtpZihuKXtyZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGUscix0KX1lbHNle3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGUscix0KX19cmV0dXJuIGFycmF5SW5kZXhPZihlLFtyXSx0LGYsbil9dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiBhcnJheUluZGV4T2YoZSxyLHQsZixuKXt2YXIgaT0xO3ZhciBvPWUubGVuZ3RoO3ZhciB1PXIubGVuZ3RoO2lmKGYhPT11bmRlZmluZWQpe2Y9U3RyaW5nKGYpLnRvTG93ZXJDYXNlKCk7aWYoZj09PVwidWNzMlwifHxmPT09XCJ1Y3MtMlwifHxmPT09XCJ1dGYxNmxlXCJ8fGY9PT1cInV0Zi0xNmxlXCIpe2lmKGUubGVuZ3RoPDJ8fHIubGVuZ3RoPDIpe3JldHVybi0xfWk9MjtvLz0yO3UvPTI7dC89Mn19ZnVuY3Rpb24gcmVhZChlLHIpe2lmKGk9PT0xKXtyZXR1cm4gZVtyXX1lbHNle3JldHVybiBlLnJlYWRVSW50MTZCRShyKmkpfX12YXIgYTtpZihuKXt2YXIgcz0tMTtmb3IoYT10O2E8bzthKyspe2lmKHJlYWQoZSxhKT09PXJlYWQocixzPT09LTE/MDphLXMpKXtpZihzPT09LTEpcz1hO2lmKGEtcysxPT09dSlyZXR1cm4gcyppfWVsc2V7aWYocyE9PS0xKWEtPWEtcztzPS0xfX19ZWxzZXtpZih0K3U+byl0PW8tdTtmb3IoYT10O2E+PTA7YS0tKXt2YXIgaD10cnVlO2Zvcih2YXIgYz0wO2M8dTtjKyspe2lmKHJlYWQoZSxhK2MpIT09cmVhZChyLGMpKXtoPWZhbHNlO2JyZWFrfX1pZihoKXJldHVybiBhfX1yZXR1cm4tMX1CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzPWZ1bmN0aW9uIGluY2x1ZGVzKGUscix0KXtyZXR1cm4gdGhpcy5pbmRleE9mKGUscix0KSE9PS0xfTtCdWZmZXIucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24gaW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsdHJ1ZSl9O0J1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24gbGFzdEluZGV4T2YoZSxyLHQpe3JldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLGUscix0LGZhbHNlKX07ZnVuY3Rpb24gaGV4V3JpdGUoZSxyLHQsZil7dD1OdW1iZXIodCl8fDA7dmFyIG49ZS5sZW5ndGgtdDtpZighZil7Zj1ufWVsc2V7Zj1OdW1iZXIoZik7aWYoZj5uKXtmPW59fXZhciBpPXIubGVuZ3RoO2lmKGY+aS8yKXtmPWkvMn1mb3IodmFyIG89MDtvPGY7KytvKXt2YXIgdT1wYXJzZUludChyLnN1YnN0cihvKjIsMiksMTYpO2lmKG51bWJlcklzTmFOKHUpKXJldHVybiBvO2VbdCtvXT11fXJldHVybiBvfWZ1bmN0aW9uIHV0ZjhXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhyLGUubGVuZ3RoLXQpLGUsdCxmKX1mdW5jdGlvbiBhc2NpaVdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhyKSxlLHQsZil9ZnVuY3Rpb24gbGF0aW4xV3JpdGUoZSxyLHQsZil7cmV0dXJuIGFzY2lpV3JpdGUoZSxyLHQsZil9ZnVuY3Rpb24gYmFzZTY0V3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhyKSxlLHQsZil9ZnVuY3Rpb24gdWNzMldyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfUJ1ZmZlci5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24gd3JpdGUoZSxyLHQsZil7aWYocj09PXVuZGVmaW5lZCl7Zj1cInV0ZjhcIjt0PXRoaXMubGVuZ3RoO3I9MH1lbHNlIGlmKHQ9PT11bmRlZmluZWQmJnR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYoaXNGaW5pdGUocikpe3I9cj4+PjA7aWYoaXNGaW5pdGUodCkpe3Q9dD4+PjA7aWYoZj09PXVuZGVmaW5lZClmPVwidXRmOFwifWVsc2V7Zj10O3Q9dW5kZWZpbmVkfX1lbHNle3Rocm93IG5ldyBFcnJvcihcIkJ1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpfXZhciBuPXRoaXMubGVuZ3RoLXI7aWYodD09PXVuZGVmaW5lZHx8dD5uKXQ9bjtpZihlLmxlbmd0aD4wJiYodDwwfHxyPDApfHxyPnRoaXMubGVuZ3RoKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpfWlmKCFmKWY9XCJ1dGY4XCI7dmFyIGk9ZmFsc2U7Zm9yKDs7KXtzd2l0Y2goZil7Y2FzZVwiaGV4XCI6cmV0dXJuIGhleFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gYXNjaWlXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gbGF0aW4xV3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB1Y3MyV3JpdGUodGhpcyxlLHIsdCk7ZGVmYXVsdDppZihpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitmKTtmPShcIlwiK2YpLnRvTG93ZXJDYXNlKCk7aT10cnVlfX19O0J1ZmZlci5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uIHRvSlNPTigpe3JldHVybnt0eXBlOlwiQnVmZmVyXCIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9fTtmdW5jdGlvbiBiYXNlNjRTbGljZShlLHIsdCl7aWYocj09PTAmJnQ9PT1lLmxlbmd0aCl7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlKX1lbHNle3JldHVybiBmLmZyb21CeXRlQXJyYXkoZS5zbGljZShyLHQpKX19ZnVuY3Rpb24gdXRmOFNsaWNlKGUscix0KXt0PU1hdGgubWluKGUubGVuZ3RoLHQpO3ZhciBmPVtdO3ZhciBuPXI7d2hpbGUobjx0KXt2YXIgaT1lW25dO3ZhciBvPW51bGw7dmFyIHU9aT4yMzk/NDppPjIyMz8zOmk+MTkxPzI6MTtpZihuK3U8PXQpe3ZhciBhLHMsaCxjO3N3aXRjaCh1KXtjYXNlIDE6aWYoaTwxMjgpe289aX1icmVhaztjYXNlIDI6YT1lW24rMV07aWYoKGEmMTkyKT09PTEyOCl7Yz0oaSYzMSk8PDZ8YSY2MztpZihjPjEyNyl7bz1jfX1icmVhaztjYXNlIDM6YT1lW24rMV07cz1lW24rMl07aWYoKGEmMTkyKT09PTEyOCYmKHMmMTkyKT09PTEyOCl7Yz0oaSYxNSk8PDEyfChhJjYzKTw8NnxzJjYzO2lmKGM+MjA0NyYmKGM8NTUyOTZ8fGM+NTczNDMpKXtvPWN9fWJyZWFrO2Nhc2UgNDphPWVbbisxXTtzPWVbbisyXTtoPWVbbiszXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4JiYoaCYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTh8KGEmNjMpPDwxMnwocyY2Myk8PDZ8aCY2MztpZihjPjY1NTM1JiZjPDExMTQxMTIpe289Y319fX1pZihvPT09bnVsbCl7bz02NTUzMzt1PTF9ZWxzZSBpZihvPjY1NTM1KXtvLT02NTUzNjtmLnB1c2gobz4+PjEwJjEwMjN8NTUyOTYpO289NTYzMjB8byYxMDIzfWYucHVzaChvKTtuKz11fXJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoZil9dmFyIHU9NDA5NjtmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoZSl7dmFyIHI9ZS5sZW5ndGg7aWYocjw9dSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUpfXZhciB0PVwiXCI7dmFyIGY9MDt3aGlsZShmPHIpe3QrPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUuc2xpY2UoZixmKz11KSl9cmV0dXJuIHR9ZnVuY3Rpb24gYXNjaWlTbGljZShlLHIsdCl7dmFyIGY9XCJcIjt0PU1hdGgubWluKGUubGVuZ3RoLHQpO2Zvcih2YXIgbj1yO248dDsrK24pe2YrPVN0cmluZy5mcm9tQ2hhckNvZGUoZVtuXSYxMjcpfXJldHVybiBmfWZ1bmN0aW9uIGxhdGluMVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dKX1yZXR1cm4gZn1mdW5jdGlvbiBoZXhTbGljZShlLHIsdCl7dmFyIGY9ZS5sZW5ndGg7aWYoIXJ8fHI8MClyPTA7aWYoIXR8fHQ8MHx8dD5mKXQ9Zjt2YXIgbj1cIlwiO2Zvcih2YXIgaT1yO2k8dDsrK2kpe24rPXNbZVtpXV19cmV0dXJuIG59ZnVuY3Rpb24gdXRmMTZsZVNsaWNlKGUscix0KXt2YXIgZj1lLnNsaWNlKHIsdCk7dmFyIG49XCJcIjtmb3IodmFyIGk9MDtpPGYubGVuZ3RoO2krPTIpe24rPVN0cmluZy5mcm9tQ2hhckNvZGUoZltpXStmW2krMV0qMjU2KX1yZXR1cm4gbn1CdWZmZXIucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uIHNsaWNlKGUscil7dmFyIHQ9dGhpcy5sZW5ndGg7ZT1+fmU7cj1yPT09dW5kZWZpbmVkP3Q6fn5yO2lmKGU8MCl7ZSs9dDtpZihlPDApZT0wfWVsc2UgaWYoZT50KXtlPXR9aWYocjwwKXtyKz10O2lmKHI8MClyPTB9ZWxzZSBpZihyPnQpe3I9dH1pZihyPGUpcj1lO3ZhciBmPXRoaXMuc3ViYXJyYXkoZSxyKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn07ZnVuY3Rpb24gY2hlY2tPZmZzZXQoZSxyLHQpe2lmKGUlMSE9PTB8fGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm9mZnNldCBpcyBub3QgdWludFwiKTtpZihlK3I+dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFPWZ1bmN0aW9uIHJlYWRVSW50TEUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCljaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpO3ZhciBmPXRoaXNbZV07dmFyIG49MTt2YXIgaT0wO3doaWxlKCsraTxyJiYobio9MjU2KSl7Zis9dGhpc1tlK2ldKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRT1mdW5jdGlvbiByZWFkVUludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpe2NoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCl9dmFyIGY9dGhpc1tlKy0tcl07dmFyIG49MTt3aGlsZShyPjAmJihuKj0yNTYpKXtmKz10aGlzW2UrLS1yXSpufXJldHVybiBmfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OD1mdW5jdGlvbiByZWFkVUludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV19O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFPWZ1bmN0aW9uIHJlYWRVSW50MTZMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXXx0aGlzW2UrMV08PDh9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFPWZ1bmN0aW9uIHJlYWRVSW50MTZCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXTw8OHx0aGlzW2UrMV19O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFPWZ1bmN0aW9uIHJlYWRVSW50MzJMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4odGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNikrdGhpc1tlKzNdKjE2Nzc3MjE2fTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbiByZWFkVUludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV0qMTY3NzcyMTYrKHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXSl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uIHJlYWRJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1uKj0xMjg7aWYoZj49bilmLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludEJFPWZ1bmN0aW9uIHJlYWRJbnRCRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9cjt2YXIgbj0xO3ZhciBpPXRoaXNbZSstLWZdO3doaWxlKGY+MCYmKG4qPTI1Nikpe2krPXRoaXNbZSstLWZdKm59bio9MTI4O2lmKGk+PW4paS09TWF0aC5wb3coMiw4KnIpO3JldHVybiBpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uIHJlYWRJbnQ4KGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDEsdGhpcy5sZW5ndGgpO2lmKCEodGhpc1tlXSYxMjgpKXJldHVybiB0aGlzW2VdO3JldHVybigyNTUtdGhpc1tlXSsxKSotMX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbiByZWFkSW50MTZMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTt2YXIgdD10aGlzW2VdfHRoaXNbZSsxXTw8ODtyZXR1cm4gdCYzMjc2OD90fDQyOTQ5MDE3NjA6dH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRT1mdW5jdGlvbiByZWFkSW50MTZCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTt2YXIgdD10aGlzW2UrMV18dGhpc1tlXTw8ODtyZXR1cm4gdCYzMjc2OD90fDQyOTQ5MDE3NjA6dH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRT1mdW5jdGlvbiByZWFkSW50MzJMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNnx0aGlzW2UrM108PDI0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uIHJlYWRJbnQzMkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDwyNHx0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM119O0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEU9ZnVuY3Rpb24gcmVhZEZsb2F0TEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSwyMyw0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbiByZWFkRmxvYXRCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSxmYWxzZSwyMyw0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU9ZnVuY3Rpb24gcmVhZERvdWJsZUxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLHRydWUsNTIsOCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFPWZ1bmN0aW9uIHJlYWREb3VibGVCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw4LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSxmYWxzZSw1Miw4KX07ZnVuY3Rpb24gY2hlY2tJbnQoZSxyLHQsZixuLGkpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7aWYocj5ufHxyPGkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEU9ZnVuY3Rpb24gd3JpdGVVSW50TEUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO3Q9dD4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0KS0xO2NoZWNrSW50KHRoaXMsZSxyLHQsbiwwKX12YXIgaT0xO3ZhciBvPTA7dGhpc1tyXT1lJjI1NTt3aGlsZSgrK288dCYmKGkqPTI1Nikpe3RoaXNbcitvXT1lL2kmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24gd3JpdGVVSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO3Q9dD4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0KS0xO2NoZWNrSW50KHRoaXMsZSxyLHQsbiwwKX12YXIgaT10LTE7dmFyIG89MTt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7dGhpc1tyK2ldPWUvbyYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4PWZ1bmN0aW9uIHdyaXRlVUludDgoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwxLDI1NSwwKTt0aGlzW3JdPWUmMjU1O3JldHVybiByKzF9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWUmMjU1O3RoaXNbcisxXT1lPj4+ODtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24gd3JpdGVVSW50MTZCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsNjU1MzUsMCk7dGhpc1tyXT1lPj4+ODt0aGlzW3IrMV09ZSYyNTU7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlVUludDMyTEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyKzNdPWU+Pj4yNDt0aGlzW3IrMl09ZT4+PjE2O3RoaXNbcisxXT1lPj4+ODt0aGlzW3JdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRT1mdW5jdGlvbiB3cml0ZVVJbnQzMkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCw0Mjk0OTY3Mjk1LDApO3RoaXNbcl09ZT4+PjI0O3RoaXNbcisxXT1lPj4+MTY7dGhpc1tyKzJdPWU+Pj44O3RoaXNbciszXT1lJjI1NTtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24gd3JpdGVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0LTEpO2NoZWNrSW50KHRoaXMsZSxyLHQsbi0xLC1uKX12YXIgaT0wO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsraTx0JiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2ktMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRT1mdW5jdGlvbiB3cml0ZUludEJFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPXQtMTt2YXIgbz0xO3ZhciB1PTA7dGhpc1tyK2ldPWUmMjU1O3doaWxlKC0taT49MCYmKG8qPTI1Nikpe2lmKGU8MCYmdT09PTAmJnRoaXNbcitpKzFdIT09MCl7dT0xfXRoaXNbcitpXT0oZS9vPj4wKS11JjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbiB3cml0ZUludDgoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwxLDEyNywtMTI4KTtpZihlPDApZT0yNTUrZSsxO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU9ZnVuY3Rpb24gd3JpdGVJbnQxNkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uIHdyaXRlSW50MTZCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsMzI3NjcsLTMyNzY4KTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbiB3cml0ZUludDMyTEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzNdPWU+Pj4yNDtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRT1mdW5jdGlvbiB3cml0ZUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpO2lmKGU8MCllPTQyOTQ5NjcyOTUrZSsxO3RoaXNbcl09ZT4+PjI0O3RoaXNbcisxXT1lPj4+MTY7dGhpc1tyKzJdPWU+Pj44O3RoaXNbciszXT1lJjI1NTtyZXR1cm4gcis0fTtmdW5jdGlvbiBjaGVja0lFRUU3NTQoZSxyLHQsZixuLGkpe2lmKHQrZj5lLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZih0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gd3JpdGVGbG9hdChlLHIsdCxmLGkpe3I9K3I7dD10Pj4+MDtpZighaSl7Y2hlY2tJRUVFNzU0KGUscix0LDQsMzQwMjgyMzQ2NjM4NTI4ODZlMjIsLTM0MDI4MjM0NjYzODUyODg2ZTIyKX1uLndyaXRlKGUscix0LGYsMjMsNCk7cmV0dXJuIHQrNH1CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbiB3cml0ZUZsb2F0TEUoZSxyLHQpe3JldHVybiB3cml0ZUZsb2F0KHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFPWZ1bmN0aW9uIHdyaXRlRmxvYXRCRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsZmFsc2UsdCl9O2Z1bmN0aW9uIHdyaXRlRG91YmxlKGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsOCwxNzk3NjkzMTM0ODYyMzE1N2UyOTIsLTE3OTc2OTMxMzQ4NjIzMTU3ZTI5Mil9bi53cml0ZShlLHIsdCxmLDUyLDgpO3JldHVybiB0Kzh9QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uIHdyaXRlRG91YmxlTEUoZSxyLHQpe3JldHVybiB3cml0ZURvdWJsZSh0aGlzLGUscix0cnVlLHQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU9ZnVuY3Rpb24gd3JpdGVEb3VibGVCRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLGZhbHNlLHQpfTtCdWZmZXIucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24gY29weShlLHIsdCxmKXtpZighQnVmZmVyLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXJcIik7aWYoIXQpdD0wO2lmKCFmJiZmIT09MClmPXRoaXMubGVuZ3RoO2lmKHI+PWUubGVuZ3RoKXI9ZS5sZW5ndGg7aWYoIXIpcj0wO2lmKGY+MCYmZjx0KWY9dDtpZihmPT09dClyZXR1cm4gMDtpZihlLmxlbmd0aD09PTB8fHRoaXMubGVuZ3RoPT09MClyZXR1cm4gMDtpZihyPDApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKX1pZih0PDB8fHQ+PXRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKGY8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO2lmKGY+dGhpcy5sZW5ndGgpZj10aGlzLmxlbmd0aDtpZihlLmxlbmd0aC1yPGYtdCl7Zj1lLmxlbmd0aC1yK3R9dmFyIG49Zi10O2lmKHRoaXM9PT1lJiZ0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbj09PVwiZnVuY3Rpb25cIil7dGhpcy5jb3B5V2l0aGluKHIsdCxmKX1lbHNlIGlmKHRoaXM9PT1lJiZ0PHImJnI8Zil7Zm9yKHZhciBpPW4tMTtpPj0wOy0taSl7ZVtpK3JdPXRoaXNbaSt0XX19ZWxzZXtVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChlLHRoaXMuc3ViYXJyYXkodCxmKSxyKX1yZXR1cm4gbn07QnVmZmVyLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uIGZpbGwoZSxyLHQsZil7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtpZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe2Y9cjtyPTA7dD10aGlzLmxlbmd0aH1lbHNlIGlmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7Zj10O3Q9dGhpcy5sZW5ndGh9aWYoZiE9PXVuZGVmaW5lZCYmdHlwZW9mIGYhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1wiKX1pZih0eXBlb2YgZj09PVwic3RyaW5nXCImJiFCdWZmZXIuaXNFbmNvZGluZyhmKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpfWlmKGUubGVuZ3RoPT09MSl7dmFyIG49ZS5jaGFyQ29kZUF0KDApO2lmKGY9PT1cInV0ZjhcIiYmbjwxMjh8fGY9PT1cImxhdGluMVwiKXtlPW59fX1lbHNlIGlmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7ZT1lJjI1NX1lbHNlIGlmKHR5cGVvZiBlPT09XCJib29sZWFuXCIpe2U9TnVtYmVyKGUpfWlmKHI8MHx8dGhpcy5sZW5ndGg8cnx8dGhpcy5sZW5ndGg8dCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYodDw9cil7cmV0dXJuIHRoaXN9cj1yPj4+MDt0PXQ9PT11bmRlZmluZWQ/dGhpcy5sZW5ndGg6dD4+PjA7aWYoIWUpZT0wO3ZhciBpO2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7Zm9yKGk9cjtpPHQ7KytpKXt0aGlzW2ldPWV9fWVsc2V7dmFyIG89QnVmZmVyLmlzQnVmZmVyKGUpP2U6QnVmZmVyLmZyb20oZSxmKTt2YXIgdT1vLmxlbmd0aDtpZih1PT09MCl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJytlKydcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKX1mb3IoaT0wO2k8dC1yOysraSl7dGhpc1tpK3JdPW9baSV1XX19cmV0dXJuIHRoaXN9O3ZhciBhPS9bXisvMC05QS1aYS16LV9dL2c7ZnVuY3Rpb24gYmFzZTY0Y2xlYW4oZSl7ZT1lLnNwbGl0KFwiPVwiKVswXTtlPWUudHJpbSgpLnJlcGxhY2UoYSxcIlwiKTtpZihlLmxlbmd0aDwyKXJldHVyblwiXCI7d2hpbGUoZS5sZW5ndGglNCE9PTApe2U9ZStcIj1cIn1yZXR1cm4gZX1mdW5jdGlvbiB1dGY4VG9CeXRlcyhlLHIpe3I9cnx8SW5maW5pdHk7dmFyIHQ7dmFyIGY9ZS5sZW5ndGg7dmFyIG49bnVsbDt2YXIgaT1bXTtmb3IodmFyIG89MDtvPGY7KytvKXt0PWUuY2hhckNvZGVBdChvKTtpZih0PjU1Mjk1JiZ0PDU3MzQ0KXtpZighbil7aWYodD41NjMxOSl7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9ZWxzZSBpZihvKzE9PT1mKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1uPXQ7Y29udGludWV9aWYodDw1NjMyMCl7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7bj10O2NvbnRpbnVlfXQ9KG4tNTUyOTY8PDEwfHQtNTYzMjApKzY1NTM2fWVsc2UgaWYobil7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSl9bj1udWxsO2lmKHQ8MTI4KXtpZigoci09MSk8MClicmVhaztpLnB1c2godCl9ZWxzZSBpZih0PDIwNDgpe2lmKChyLT0yKTwwKWJyZWFrO2kucHVzaCh0Pj42fDE5Mix0JjYzfDEyOCl9ZWxzZSBpZih0PDY1NTM2KXtpZigoci09Myk8MClicmVhaztpLnB1c2godD4+MTJ8MjI0LHQ+PjYmNjN8MTI4LHQmNjN8MTI4KX1lbHNlIGlmKHQ8MTExNDExMil7aWYoKHItPTQpPDApYnJlYWs7aS5wdXNoKHQ+PjE4fDI0MCx0Pj4xMiY2M3wxMjgsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50XCIpfX1yZXR1cm4gaX1mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoZSl7dmFyIHI9W107Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDsrK3Qpe3IucHVzaChlLmNoYXJDb2RlQXQodCkmMjU1KX1yZXR1cm4gcn1mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyhlLHIpe3ZhciB0LGYsbjt2YXIgaT1bXTtmb3IodmFyIG89MDtvPGUubGVuZ3RoOysrbyl7aWYoKHItPTIpPDApYnJlYWs7dD1lLmNoYXJDb2RlQXQobyk7Zj10Pj44O249dCUyNTY7aS5wdXNoKG4pO2kucHVzaChmKX1yZXR1cm4gaX1mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKGUpe3JldHVybiBmLnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKGUpKX1mdW5jdGlvbiBibGl0QnVmZmVyKGUscix0LGYpe2Zvcih2YXIgbj0wO248ZjsrK24pe2lmKG4rdD49ci5sZW5ndGh8fG4+PWUubGVuZ3RoKWJyZWFrO3Jbbit0XT1lW25dfXJldHVybiBufWZ1bmN0aW9uIGlzSW5zdGFuY2UoZSxyKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHJ8fGUhPW51bGwmJmUuY29uc3RydWN0b3IhPW51bGwmJmUuY29uc3RydWN0b3IubmFtZSE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lPT09ci5uYW1lfWZ1bmN0aW9uIG51bWJlcklzTmFOKGUpe3JldHVybiBlIT09ZX12YXIgcz1mdW5jdGlvbigpe3ZhciBlPVwiMDEyMzQ1Njc4OWFiY2RlZlwiO3ZhciByPW5ldyBBcnJheSgyNTYpO2Zvcih2YXIgdD0wO3Q8MTY7Kyt0KXt2YXIgZj10KjE2O2Zvcih2YXIgbj0wO248MTY7KytuKXtyW2Yrbl09ZVt0XStlW25dfX1yZXR1cm4gcn0oKX0sNzgzOmZ1bmN0aW9uKGUscil7XG4vKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuci5yZWFkPWZ1bmN0aW9uKGUscix0LGYsbil7dmFyIGksbzt2YXIgdT1uKjgtZi0xO3ZhciBhPSgxPDx1KS0xO3ZhciBzPWE+PjE7dmFyIGg9LTc7dmFyIGM9dD9uLTE6MDt2YXIgbD10Py0xOjE7dmFyIHA9ZVtyK2NdO2MrPWw7aT1wJigxPDwtaCktMTtwPj49LWg7aCs9dTtmb3IoO2g+MDtpPWkqMjU2K2VbcitjXSxjKz1sLGgtPTgpe31vPWkmKDE8PC1oKS0xO2k+Pj0taDtoKz1mO2Zvcig7aD4wO289byoyNTYrZVtyK2NdLGMrPWwsaC09OCl7fWlmKGk9PT0wKXtpPTEtc31lbHNlIGlmKGk9PT1hKXtyZXR1cm4gbz9OYU46KHA/LTE6MSkqSW5maW5pdHl9ZWxzZXtvPW8rTWF0aC5wb3coMixmKTtpPWktc31yZXR1cm4ocD8tMToxKSpvKk1hdGgucG93KDIsaS1mKX07ci53cml0ZT1mdW5jdGlvbihlLHIsdCxmLG4saSl7dmFyIG8sdSxhO3ZhciBzPWkqOC1uLTE7dmFyIGg9KDE8PHMpLTE7dmFyIGM9aD4+MTt2YXIgbD1uPT09MjM/TWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowO3ZhciBwPWY/MDppLTE7dmFyIHk9Zj8xOi0xO3ZhciBnPXI8MHx8cj09PTAmJjEvcjwwPzE6MDtyPU1hdGguYWJzKHIpO2lmKGlzTmFOKHIpfHxyPT09SW5maW5pdHkpe3U9aXNOYU4ocik/MTowO289aH1lbHNle289TWF0aC5mbG9vcihNYXRoLmxvZyhyKS9NYXRoLkxOMik7aWYociooYT1NYXRoLnBvdygyLC1vKSk8MSl7by0tO2EqPTJ9aWYobytjPj0xKXtyKz1sL2F9ZWxzZXtyKz1sKk1hdGgucG93KDIsMS1jKX1pZihyKmE+PTIpe28rKzthLz0yfWlmKG8rYz49aCl7dT0wO289aH1lbHNlIGlmKG8rYz49MSl7dT0ociphLTEpKk1hdGgucG93KDIsbik7bz1vK2N9ZWxzZXt1PXIqTWF0aC5wb3coMixjLTEpKk1hdGgucG93KDIsbik7bz0wfX1mb3IoO24+PTg7ZVt0K3BdPXUmMjU1LHArPXksdS89MjU2LG4tPTgpe31vPW88PG58dTtzKz1uO2Zvcig7cz4wO2VbdCtwXT1vJjI1NSxwKz15LG8vPTI1NixzLT04KXt9ZVt0K3AteV18PWcqMTI4fX19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIGY9clt0XTtpZihmIT09dW5kZWZpbmVkKXtyZXR1cm4gZi5leHBvcnRzfXZhciBuPXJbdF09e2V4cG9ydHM6e319O3ZhciBpPXRydWU7dHJ5e2VbdF0obixuLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7aT1mYWxzZX1maW5hbGx5e2lmKGkpZGVsZXRlIHJbdF19cmV0dXJuIG4uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXyg3Mik7bW9kdWxlLmV4cG9ydHM9dH0pKCk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/picomatch/index.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/picomatch/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/next/dist/build/polyfills/process.js\");\n(()=>{\"use strict\";var t={170:(t,e,u)=>{const n=u(510);const isWindows=()=>{if(typeof navigator!==\"undefined\"&&navigator.platform){const t=navigator.platform.toLowerCase();return t===\"win32\"||t===\"windows\"}if(typeof process!==\"undefined\"&&process.platform){return process.platform===\"win32\"}return false};function picomatch(t,e,u=false){if(e&&(e.windows===null||e.windows===undefined)){e={...e,windows:isWindows()}}return n(t,e,u)}Object.assign(picomatch,n);t.exports=picomatch},154:t=>{const e=\"\\\\\\\\/\";const u=`[^${e}]`;const n=\"\\\\.\";const o=\"\\\\+\";const s=\"\\\\?\";const r=\"\\\\/\";const a=\"(?=.)\";const i=\"[^/]\";const c=`(?:${r}|$)`;const p=`(?:^|${r})`;const l=`${n}{1,2}${c}`;const f=`(?!${n})`;const A=`(?!${p}${l})`;const _=`(?!${n}{0,1}${c})`;const R=`(?!${l})`;const E=`[^.${r}]`;const h=`${i}*?`;const g=\"/\";const b={DOT_LITERAL:n,PLUS_LITERAL:o,QMARK_LITERAL:s,SLASH_LITERAL:r,ONE_CHAR:a,QMARK:i,END_ANCHOR:c,DOTS_SLASH:l,NO_DOT:f,NO_DOTS:A,NO_DOT_SLASH:_,NO_DOTS_SLASH:R,QMARK_NO_DOT:E,STAR:h,START_ANCHOR:p,SEP:g};const C={...b,SLASH_LITERAL:`[${e}]`,QMARK:u,STAR:`${u}*?`,DOTS_SLASH:`${n}{1,2}(?:[${e}]|$)`,NO_DOT:`(?!${n})`,NO_DOTS:`(?!(?:^|[${e}])${n}{1,2}(?:[${e}]|$))`,NO_DOT_SLASH:`(?!${n}{0,1}(?:[${e}]|$))`,NO_DOTS_SLASH:`(?!${n}{1,2}(?:[${e}]|$))`,QMARK_NO_DOT:`[^.${e}]`,START_ANCHOR:`(?:^|[${e}])`,END_ANCHOR:`(?:[${e}]|$)`,SEP:\"\\\\\"};const y={alnum:\"a-zA-Z0-9\",alpha:\"a-zA-Z\",ascii:\"\\\\x00-\\\\x7F\",blank:\" \\\\t\",cntrl:\"\\\\x00-\\\\x1F\\\\x7F\",digit:\"0-9\",graph:\"\\\\x21-\\\\x7E\",lower:\"a-z\",print:\"\\\\x20-\\\\x7E \",punct:\"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",space:\" \\\\t\\\\r\\\\n\\\\v\\\\f\",upper:\"A-Z\",word:\"A-Za-z0-9_\",xdigit:\"A-Fa-f0-9\"};t.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:y,REGEX_BACKSLASH:/\\\\(?![*+?^${}(|)[\\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\\].,$*+?^{}()|\\\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\\\?)((\\W)(\\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,REPLACEMENTS:{\"***\":\"*\",\"**/**\":\"**\",\"**/**/**\":\"**\"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,extglobChars(t){return{\"!\":{type:\"negate\",open:\"(?:(?!(?:\",close:`))${t.STAR})`},\"?\":{type:\"qmark\",open:\"(?:\",close:\")?\"},\"+\":{type:\"plus\",open:\"(?:\",close:\")+\"},\"*\":{type:\"star\",open:\"(?:\",close:\")*\"},\"@\":{type:\"at\",open:\"(?:\",close:\")\"}}},globChars(t){return t===true?C:b}}},697:(t,e,u)=>{const n=u(154);const o=u(96);const{MAX_LENGTH:s,POSIX_REGEX_SOURCE:r,REGEX_NON_SPECIAL_CHARS:a,REGEX_SPECIAL_CHARS_BACKREF:i,REPLACEMENTS:c}=n;const expandRange=(t,e)=>{if(typeof e.expandRange===\"function\"){return e.expandRange(...t,e)}t.sort();const u=`[${t.join(\"-\")}]`;try{new RegExp(u)}catch(e){return t.map((t=>o.escapeRegex(t))).join(\"..\")}return u};const syntaxError=(t,e)=>`Missing ${t}: \"${e}\" - use \"\\\\\\\\${e}\" to match literal characters`;const parse=(t,e)=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected a string\")}t=c[t]||t;const u={...e};const p=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;let l=t.length;if(l>p){throw new SyntaxError(`Input length: ${l}, exceeds maximum allowed length: ${p}`)}const f={type:\"bos\",value:\"\",output:u.prepend||\"\"};const A=[f];const _=u.capture?\"\":\"?:\";const R=n.globChars(u.windows);const E=n.extglobChars(R);const{DOT_LITERAL:h,PLUS_LITERAL:g,SLASH_LITERAL:b,ONE_CHAR:C,DOTS_SLASH:y,NO_DOT:$,NO_DOT_SLASH:x,NO_DOTS_SLASH:S,QMARK:H,QMARK_NO_DOT:v,STAR:d,START_ANCHOR:L}=R;const globstar=t=>`(${_}(?:(?!${L}${t.dot?y:h}).)*?)`;const T=u.dot?\"\":$;const O=u.dot?H:v;let k=u.bash===true?globstar(u):d;if(u.capture){k=`(${k})`}if(typeof u.noext===\"boolean\"){u.noextglob=u.noext}const m={input:t,index:-1,start:0,dot:u.dot===true,consumed:\"\",output:\"\",prefix:\"\",backtrack:false,negated:false,brackets:0,braces:0,parens:0,quotes:0,globstar:false,tokens:A};t=o.removePrefix(t,m);l=t.length;const w=[];const N=[];const I=[];let B=f;let G;const eos=()=>m.index===l-1;const D=m.peek=(e=1)=>t[m.index+e];const M=m.advance=()=>t[++m.index]||\"\";const remaining=()=>t.slice(m.index+1);const consume=(t=\"\",e=0)=>{m.consumed+=t;m.index+=e};const append=t=>{m.output+=t.output!=null?t.output:t.value;consume(t.value)};const negate=()=>{let t=1;while(D()===\"!\"&&(D(2)!==\"(\"||D(3)===\"?\")){M();m.start++;t++}if(t%2===0){return false}m.negated=true;m.start++;return true};const increment=t=>{m[t]++;I.push(t)};const decrement=t=>{m[t]--;I.pop()};const push=t=>{if(B.type===\"globstar\"){const e=m.braces>0&&(t.type===\"comma\"||t.type===\"brace\");const u=t.extglob===true||w.length&&(t.type===\"pipe\"||t.type===\"paren\");if(t.type!==\"slash\"&&t.type!==\"paren\"&&!e&&!u){m.output=m.output.slice(0,-B.output.length);B.type=\"star\";B.value=\"*\";B.output=k;m.output+=B.output}}if(w.length&&t.type!==\"paren\"){w[w.length-1].inner+=t.value}if(t.value||t.output)append(t);if(B&&B.type===\"text\"&&t.type===\"text\"){B.output=(B.output||B.value)+t.value;B.value+=t.value;return}t.prev=B;A.push(t);B=t};const extglobOpen=(t,e)=>{const n={...E[e],conditions:1,inner:\"\"};n.prev=B;n.parens=m.parens;n.output=m.output;const o=(u.capture?\"(\":\"\")+n.open;increment(\"parens\");push({type:t,value:e,output:m.output?\"\":C});push({type:\"paren\",extglob:true,value:M(),output:o});w.push(n)};const extglobClose=t=>{let n=t.close+(u.capture?\")\":\"\");let o;if(t.type===\"negate\"){let s=k;if(t.inner&&t.inner.length>1&&t.inner.includes(\"/\")){s=globstar(u)}if(s!==k||eos()||/^\\)+$/.test(remaining())){n=t.close=`)$))${s}`}if(t.inner.includes(\"*\")&&(o=remaining())&&/^\\.[^\\\\/.]+$/.test(o)){const u=parse(o,{...e,fastpaths:false}).output;n=t.close=`)${u})${s})`}if(t.prev.type===\"bos\"){m.negatedExtglob=true}}push({type:\"paren\",extglob:true,value:G,output:n});decrement(\"parens\")};if(u.fastpaths!==false&&!/(^[*!]|[/()[\\]{}\"])/.test(t)){let n=false;let s=t.replace(i,((t,e,u,o,s,r)=>{if(o===\"\\\\\"){n=true;return t}if(o===\"?\"){if(e){return e+o+(s?H.repeat(s.length):\"\")}if(r===0){return O+(s?H.repeat(s.length):\"\")}return H.repeat(u.length)}if(o===\".\"){return h.repeat(u.length)}if(o===\"*\"){if(e){return e+o+(s?k:\"\")}return k}return e?t:`\\\\${t}`}));if(n===true){if(u.unescape===true){s=s.replace(/\\\\/g,\"\")}else{s=s.replace(/\\\\+/g,(t=>t.length%2===0?\"\\\\\\\\\":t?\"\\\\\":\"\"))}}if(s===t&&u.contains===true){m.output=t;return m}m.output=o.wrapOutput(s,m,e);return m}while(!eos()){G=M();if(G===\"\\0\"){continue}if(G===\"\\\\\"){const t=D();if(t===\"/\"&&u.bash!==true){continue}if(t===\".\"||t===\";\"){continue}if(!t){G+=\"\\\\\";push({type:\"text\",value:G});continue}const e=/^\\\\+/.exec(remaining());let n=0;if(e&&e[0].length>2){n=e[0].length;m.index+=n;if(n%2!==0){G+=\"\\\\\"}}if(u.unescape===true){G=M()}else{G+=M()}if(m.brackets===0){push({type:\"text\",value:G});continue}}if(m.brackets>0&&(G!==\"]\"||B.value===\"[\"||B.value===\"[^\")){if(u.posix!==false&&G===\":\"){const t=B.value.slice(1);if(t.includes(\"[\")){B.posix=true;if(t.includes(\":\")){const t=B.value.lastIndexOf(\"[\");const e=B.value.slice(0,t);const u=B.value.slice(t+2);const n=r[u];if(n){B.value=e+n;m.backtrack=true;M();if(!f.output&&A.indexOf(B)===1){f.output=C}continue}}}}if(G===\"[\"&&D()!==\":\"||G===\"-\"&&D()===\"]\"){G=`\\\\${G}`}if(G===\"]\"&&(B.value===\"[\"||B.value===\"[^\")){G=`\\\\${G}`}if(u.posix===true&&G===\"!\"&&B.value===\"[\"){G=\"^\"}B.value+=G;append({value:G});continue}if(m.quotes===1&&G!=='\"'){G=o.escapeRegex(G);B.value+=G;append({value:G});continue}if(G==='\"'){m.quotes=m.quotes===1?0:1;if(u.keepQuotes===true){push({type:\"text\",value:G})}continue}if(G===\"(\"){increment(\"parens\");push({type:\"paren\",value:G});continue}if(G===\")\"){if(m.parens===0&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"(\"))}const t=w[w.length-1];if(t&&m.parens===t.parens+1){extglobClose(w.pop());continue}push({type:\"paren\",value:G,output:m.parens?\")\":\"\\\\)\"});decrement(\"parens\");continue}if(G===\"[\"){if(u.nobracket===true||!remaining().includes(\"]\")){if(u.nobracket!==true&&u.strictBrackets===true){throw new SyntaxError(syntaxError(\"closing\",\"]\"))}G=`\\\\${G}`}else{increment(\"brackets\")}push({type:\"bracket\",value:G});continue}if(G===\"]\"){if(u.nobracket===true||B&&B.type===\"bracket\"&&B.value.length===1){push({type:\"text\",value:G,output:`\\\\${G}`});continue}if(m.brackets===0){if(u.strictBrackets===true){throw new SyntaxError(syntaxError(\"opening\",\"[\"))}push({type:\"text\",value:G,output:`\\\\${G}`});continue}decrement(\"brackets\");const t=B.value.slice(1);if(B.posix!==true&&t[0]===\"^\"&&!t.includes(\"/\")){G=`/${G}`}B.value+=G;append({value:G});if(u.literalBrackets===false||o.hasRegexChars(t)){continue}const e=o.escapeRegex(B.value);m.output=m.output.slice(0,-B.value.length);if(u.literalBrackets===true){m.output+=e;B.value=e;continue}B.value=`(${_}${e}|${B.value})`;m.output+=B.value;continue}if(G===\"{\"&&u.nobrace!==true){increment(\"braces\");const t={type:\"brace\",value:G,output:\"(\",outputIndex:m.output.length,tokensIndex:m.tokens.length};N.push(t);push(t);continue}if(G===\"}\"){const t=N[N.length-1];if(u.nobrace===true||!t){push({type:\"text\",value:G,output:G});continue}let e=\")\";if(t.dots===true){const t=A.slice();const n=[];for(let e=t.length-1;e>=0;e--){A.pop();if(t[e].type===\"brace\"){break}if(t[e].type!==\"dots\"){n.unshift(t[e].value)}}e=expandRange(n,u);m.backtrack=true}if(t.comma!==true&&t.dots!==true){const u=m.output.slice(0,t.outputIndex);const n=m.tokens.slice(t.tokensIndex);t.value=t.output=\"\\\\{\";G=e=\"\\\\}\";m.output=u;for(const t of n){m.output+=t.output||t.value}}push({type:\"brace\",value:G,output:e});decrement(\"braces\");N.pop();continue}if(G===\"|\"){if(w.length>0){w[w.length-1].conditions++}push({type:\"text\",value:G});continue}if(G===\",\"){let t=G;const e=N[N.length-1];if(e&&I[I.length-1]===\"braces\"){e.comma=true;t=\"|\"}push({type:\"comma\",value:G,output:t});continue}if(G===\"/\"){if(B.type===\"dot\"&&m.index===m.start+1){m.start=m.index+1;m.consumed=\"\";m.output=\"\";A.pop();B=f;continue}push({type:\"slash\",value:G,output:b});continue}if(G===\".\"){if(m.braces>0&&B.type===\"dot\"){if(B.value===\".\")B.output=h;const t=N[N.length-1];B.type=\"dots\";B.output+=G;B.value+=G;t.dots=true;continue}if(m.braces+m.parens===0&&B.type!==\"bos\"&&B.type!==\"slash\"){push({type:\"text\",value:G,output:h});continue}push({type:\"dot\",value:G,output:h});continue}if(G===\"?\"){const t=B&&B.value===\"(\";if(!t&&u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"qmark\",G);continue}if(B&&B.type===\"paren\"){const t=D();let e=G;if(B.value===\"(\"&&!/[!=<:]/.test(t)||t===\"<\"&&!/<([!=]|\\w+>)/.test(remaining())){e=`\\\\${G}`}push({type:\"text\",value:G,output:e});continue}if(u.dot!==true&&(B.type===\"slash\"||B.type===\"bos\")){push({type:\"qmark\",value:G,output:v});continue}push({type:\"qmark\",value:G,output:H});continue}if(G===\"!\"){if(u.noextglob!==true&&D()===\"(\"){if(D(2)!==\"?\"||!/[!=<:]/.test(D(3))){extglobOpen(\"negate\",G);continue}}if(u.nonegate!==true&&m.index===0){negate();continue}}if(G===\"+\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){extglobOpen(\"plus\",G);continue}if(B&&B.value===\"(\"||u.regex===false){push({type:\"plus\",value:G,output:g});continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\"||B.type===\"brace\")||m.parens>0){push({type:\"plus\",value:G});continue}push({type:\"plus\",value:g});continue}if(G===\"@\"){if(u.noextglob!==true&&D()===\"(\"&&D(2)!==\"?\"){push({type:\"at\",extglob:true,value:G,output:\"\"});continue}push({type:\"text\",value:G});continue}if(G!==\"*\"){if(G===\"$\"||G===\"^\"){G=`\\\\${G}`}const t=a.exec(remaining());if(t){G+=t[0];m.index+=t[0].length}push({type:\"text\",value:G});continue}if(B&&(B.type===\"globstar\"||B.star===true)){B.type=\"star\";B.star=true;B.value+=G;B.output=k;m.backtrack=true;m.globstar=true;consume(G);continue}let e=remaining();if(u.noextglob!==true&&/^\\([^?]/.test(e)){extglobOpen(\"star\",G);continue}if(B.type===\"star\"){if(u.noglobstar===true){consume(G);continue}const n=B.prev;const o=n.prev;const s=n.type===\"slash\"||n.type===\"bos\";const r=o&&(o.type===\"star\"||o.type===\"globstar\");if(u.bash===true&&(!s||e[0]&&e[0]!==\"/\")){push({type:\"star\",value:G,output:\"\"});continue}const a=m.braces>0&&(n.type===\"comma\"||n.type===\"brace\");const i=w.length&&(n.type===\"pipe\"||n.type===\"paren\");if(!s&&n.type!==\"paren\"&&!a&&!i){push({type:\"star\",value:G,output:\"\"});continue}while(e.slice(0,3)===\"/**\"){const u=t[m.index+4];if(u&&u!==\"/\"){break}e=e.slice(3);consume(\"/**\",3)}if(n.type===\"bos\"&&eos()){B.type=\"globstar\";B.value+=G;B.output=globstar(u);m.output=B.output;m.globstar=true;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&!r&&eos()){m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=globstar(u)+(u.strictSlashes?\")\":\"|$)\");B.value+=G;m.globstar=true;m.output+=n.output+B.output;consume(G);continue}if(n.type===\"slash\"&&n.prev.type!==\"bos\"&&e[0]===\"/\"){const t=e[1]!==void 0?\"|$\":\"\";m.output=m.output.slice(0,-(n.output+B.output).length);n.output=`(?:${n.output}`;B.type=\"globstar\";B.output=`${globstar(u)}${b}|${b}${t})`;B.value+=G;m.output+=n.output+B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}if(n.type===\"bos\"&&e[0]===\"/\"){B.type=\"globstar\";B.value+=G;B.output=`(?:^|${b}|${globstar(u)}${b})`;m.output=B.output;m.globstar=true;consume(G+M());push({type:\"slash\",value:\"/\",output:\"\"});continue}m.output=m.output.slice(0,-B.output.length);B.type=\"globstar\";B.output=globstar(u);B.value+=G;m.output+=B.output;m.globstar=true;consume(G);continue}const n={type:\"star\",value:G,output:k};if(u.bash===true){n.output=\".*?\";if(B.type===\"bos\"||B.type===\"slash\"){n.output=T+n.output}push(n);continue}if(B&&(B.type===\"bracket\"||B.type===\"paren\")&&u.regex===true){n.output=G;push(n);continue}if(m.index===m.start||B.type===\"slash\"||B.type===\"dot\"){if(B.type===\"dot\"){m.output+=x;B.output+=x}else if(u.dot===true){m.output+=S;B.output+=S}else{m.output+=T;B.output+=T}if(D()!==\"*\"){m.output+=C;B.output+=C}}push(n)}while(m.brackets>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"]\"));m.output=o.escapeLast(m.output,\"[\");decrement(\"brackets\")}while(m.parens>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\")\"));m.output=o.escapeLast(m.output,\"(\");decrement(\"parens\")}while(m.braces>0){if(u.strictBrackets===true)throw new SyntaxError(syntaxError(\"closing\",\"}\"));m.output=o.escapeLast(m.output,\"{\");decrement(\"braces\")}if(u.strictSlashes!==true&&(B.type===\"star\"||B.type===\"bracket\")){push({type:\"maybe_slash\",value:\"\",output:`${b}?`})}if(m.backtrack===true){m.output=\"\";for(const t of m.tokens){m.output+=t.output!=null?t.output:t.value;if(t.suffix){m.output+=t.suffix}}}return m};parse.fastpaths=(t,e)=>{const u={...e};const r=typeof u.maxLength===\"number\"?Math.min(s,u.maxLength):s;const a=t.length;if(a>r){throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${r}`)}t=c[t]||t;const{DOT_LITERAL:i,SLASH_LITERAL:p,ONE_CHAR:l,DOTS_SLASH:f,NO_DOT:A,NO_DOTS:_,NO_DOTS_SLASH:R,STAR:E,START_ANCHOR:h}=n.globChars(u.windows);const g=u.dot?_:A;const b=u.dot?R:A;const C=u.capture?\"\":\"?:\";const y={negated:false,prefix:\"\"};let $=u.bash===true?\".*?\":E;if(u.capture){$=`(${$})`}const globstar=t=>{if(t.noglobstar===true)return $;return`(${C}(?:(?!${h}${t.dot?f:i}).)*?)`};const create=t=>{switch(t){case\"*\":return`${g}${l}${$}`;case\".*\":return`${i}${l}${$}`;case\"*.*\":return`${g}${$}${i}${l}${$}`;case\"*/*\":return`${g}${$}${p}${l}${b}${$}`;case\"**\":return g+globstar(u);case\"**/*\":return`(?:${g}${globstar(u)}${p})?${b}${l}${$}`;case\"**/*.*\":return`(?:${g}${globstar(u)}${p})?${b}${$}${i}${l}${$}`;case\"**/.*\":return`(?:${g}${globstar(u)}${p})?${i}${l}${$}`;default:{const e=/^(.*?)\\.(\\w+)$/.exec(t);if(!e)return;const u=create(e[1]);if(!u)return;return u+i+e[2]}}};const x=o.removePrefix(t,y);let S=create(x);if(S&&u.strictSlashes!==true){S+=`${p}?`}return S};t.exports=parse},510:(t,e,u)=>{const n=u(716);const o=u(697);const s=u(96);const r=u(154);const isObject=t=>t&&typeof t===\"object\"&&!Array.isArray(t);const picomatch=(t,e,u=false)=>{if(Array.isArray(t)){const n=t.map((t=>picomatch(t,e,u)));const arrayMatcher=t=>{for(const e of n){const u=e(t);if(u)return u}return false};return arrayMatcher}const n=isObject(t)&&t.tokens&&t.input;if(t===\"\"||typeof t!==\"string\"&&!n){throw new TypeError(\"Expected pattern to be a non-empty string\")}const o=e||{};const s=o.windows;const r=n?picomatch.compileRe(t,e):picomatch.makeRe(t,e,false,true);const a=r.state;delete r.state;let isIgnored=()=>false;if(o.ignore){const t={...e,ignore:null,onMatch:null,onResult:null};isIgnored=picomatch(o.ignore,t,u)}const matcher=(u,n=false)=>{const{isMatch:i,match:c,output:p}=picomatch.test(u,r,e,{glob:t,posix:s});const l={glob:t,state:a,regex:r,posix:s,input:u,output:p,match:c,isMatch:i};if(typeof o.onResult===\"function\"){o.onResult(l)}if(i===false){l.isMatch=false;return n?l:false}if(isIgnored(u)){if(typeof o.onIgnore===\"function\"){o.onIgnore(l)}l.isMatch=false;return n?l:false}if(typeof o.onMatch===\"function\"){o.onMatch(l)}return n?l:true};if(u){matcher.state=a}return matcher};picomatch.test=(t,e,u,{glob:n,posix:o}={})=>{if(typeof t!==\"string\"){throw new TypeError(\"Expected input to be a string\")}if(t===\"\"){return{isMatch:false,output:\"\"}}const r=u||{};const a=r.format||(o?s.toPosixSlashes:null);let i=t===n;let c=i&&a?a(t):t;if(i===false){c=a?a(t):t;i=c===n}if(i===false||r.capture===true){if(r.matchBase===true||r.basename===true){i=picomatch.matchBase(t,e,u,o)}else{i=e.exec(c)}}return{isMatch:Boolean(i),match:i,output:c}};picomatch.matchBase=(t,e,u)=>{const n=e instanceof RegExp?e:picomatch.makeRe(e,u);return n.test(s.basename(t))};picomatch.isMatch=(t,e,u)=>picomatch(e,u)(t);picomatch.parse=(t,e)=>{if(Array.isArray(t))return t.map((t=>picomatch.parse(t,e)));return o(t,{...e,fastpaths:false})};picomatch.scan=(t,e)=>n(t,e);picomatch.compileRe=(t,e,u=false,n=false)=>{if(u===true){return t.output}const o=e||{};const s=o.contains?\"\":\"^\";const r=o.contains?\"\":\"$\";let a=`${s}(?:${t.output})${r}`;if(t&&t.negated===true){a=`^(?!${a}).*$`}const i=picomatch.toRegex(a,e);if(n===true){i.state=t}return i};picomatch.makeRe=(t,e={},u=false,n=false)=>{if(!t||typeof t!==\"string\"){throw new TypeError(\"Expected a non-empty string\")}let s={negated:false,fastpaths:true};if(e.fastpaths!==false&&(t[0]===\".\"||t[0]===\"*\")){s.output=o.fastpaths(t,e)}if(!s.output){s=o(t,e)}return picomatch.compileRe(s,e,u,n)};picomatch.toRegex=(t,e)=>{try{const u=e||{};return new RegExp(t,u.flags||(u.nocase?\"i\":\"\"))}catch(t){if(e&&e.debug===true)throw t;return/$^/}};picomatch.constants=r;t.exports=picomatch},716:(t,e,u)=>{const n=u(96);const{CHAR_ASTERISK:o,CHAR_AT:s,CHAR_BACKWARD_SLASH:r,CHAR_COMMA:a,CHAR_DOT:i,CHAR_EXCLAMATION_MARK:c,CHAR_FORWARD_SLASH:p,CHAR_LEFT_CURLY_BRACE:l,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:A,CHAR_PLUS:_,CHAR_QUESTION_MARK:R,CHAR_RIGHT_CURLY_BRACE:E,CHAR_RIGHT_PARENTHESES:h,CHAR_RIGHT_SQUARE_BRACKET:g}=u(154);const isPathSeparator=t=>t===p||t===r;const depth=t=>{if(t.isPrefix!==true){t.depth=t.isGlobstar?Infinity:1}};const scan=(t,e)=>{const u=e||{};const b=t.length-1;const C=u.parts===true||u.scanToEnd===true;const y=[];const $=[];const x=[];let S=t;let H=-1;let v=0;let d=0;let L=false;let T=false;let O=false;let k=false;let m=false;let w=false;let N=false;let I=false;let B=false;let G=false;let D=0;let M;let P;let K={value:\"\",depth:0,isGlob:false};const eos=()=>H>=b;const peek=()=>S.charCodeAt(H+1);const advance=()=>{M=P;return S.charCodeAt(++H)};while(H<b){P=advance();let t;if(P===r){N=K.backslashes=true;P=advance();if(P===l){w=true}continue}if(w===true||P===l){D++;while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;advance();continue}if(P===l){D++;continue}if(w!==true&&P===i&&(P=advance())===i){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(w!==true&&P===a){L=K.isBrace=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===E){D--;if(D===0){w=false;L=K.isBrace=true;G=true;break}}}if(C===true){continue}break}if(P===p){y.push(H);$.push(K);K={value:\"\",depth:0,isGlob:false};if(G===true)continue;if(M===i&&H===v+1){v+=2;continue}d=H+1;continue}if(u.noext!==true){const t=P===_||P===s||P===o||P===R||P===c;if(t===true&&peek()===f){O=K.isGlob=true;k=K.isExtglob=true;G=true;if(P===c&&H===v){B=true}if(C===true){while(eos()!==true&&(P=advance())){if(P===r){N=K.backslashes=true;P=advance();continue}if(P===h){O=K.isGlob=true;G=true;break}}continue}break}}if(P===o){if(M===o)m=K.isGlobstar=true;O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===R){O=K.isGlob=true;G=true;if(C===true){continue}break}if(P===A){while(eos()!==true&&(t=advance())){if(t===r){N=K.backslashes=true;advance();continue}if(t===g){T=K.isBracket=true;O=K.isGlob=true;G=true;break}}if(C===true){continue}break}if(u.nonegate!==true&&P===c&&H===v){I=K.negated=true;v++;continue}if(u.noparen!==true&&P===f){O=K.isGlob=true;if(C===true){while(eos()!==true&&(P=advance())){if(P===f){N=K.backslashes=true;P=advance();continue}if(P===h){G=true;break}}continue}break}if(O===true){G=true;if(C===true){continue}break}}if(u.noext===true){k=false;O=false}let U=S;let X=\"\";let F=\"\";if(v>0){X=S.slice(0,v);S=S.slice(v);d-=v}if(U&&O===true&&d>0){U=S.slice(0,d);F=S.slice(d)}else if(O===true){U=\"\";F=S}else{U=S}if(U&&U!==\"\"&&U!==\"/\"&&U!==S){if(isPathSeparator(U.charCodeAt(U.length-1))){U=U.slice(0,-1)}}if(u.unescape===true){if(F)F=n.removeBackslashes(F);if(U&&N===true){U=n.removeBackslashes(U)}}const Q={prefix:X,input:t,start:v,base:U,glob:F,isBrace:L,isBracket:T,isGlob:O,isExtglob:k,isGlobstar:m,negated:I,negatedExtglob:B};if(u.tokens===true){Q.maxDepth=0;if(!isPathSeparator(P)){$.push(K)}Q.tokens=$}if(u.parts===true||u.tokens===true){let e;for(let n=0;n<y.length;n++){const o=e?e+1:v;const s=y[n];const r=t.slice(o,s);if(u.tokens){if(n===0&&v!==0){$[n].isPrefix=true;$[n].value=X}else{$[n].value=r}depth($[n]);Q.maxDepth+=$[n].depth}if(n!==0||r!==\"\"){x.push(r)}e=s}if(e&&e+1<t.length){const n=t.slice(e+1);x.push(n);if(u.tokens){$[$.length-1].value=n;depth($[$.length-1]);Q.maxDepth+=$[$.length-1].depth}}Q.slashes=y;Q.parts=x}return Q};t.exports=scan},96:(t,e,u)=>{const{REGEX_BACKSLASH:n,REGEX_REMOVE_BACKSLASH:o,REGEX_SPECIAL_CHARS:s,REGEX_SPECIAL_CHARS_GLOBAL:r}=u(154);e.isObject=t=>t!==null&&typeof t===\"object\"&&!Array.isArray(t);e.hasRegexChars=t=>s.test(t);e.isRegexChar=t=>t.length===1&&e.hasRegexChars(t);e.escapeRegex=t=>t.replace(r,\"\\\\$1\");e.toPosixSlashes=t=>t.replace(n,\"/\");e.removeBackslashes=t=>t.replace(o,(t=>t===\"\\\\\"?\"\":t));e.escapeLast=(t,u,n)=>{const o=t.lastIndexOf(u,n);if(o===-1)return t;if(t[o-1]===\"\\\\\")return e.escapeLast(t,u,o-1);return`${t.slice(0,o)}\\\\${t.slice(o)}`};e.removePrefix=(t,e={})=>{let u=t;if(u.startsWith(\"./\")){u=u.slice(2);e.prefix=\"./\"}return u};e.wrapOutput=(t,e={},u={})=>{const n=u.contains?\"\":\"^\";const o=u.contains?\"\":\"$\";let s=`${n}(?:${t})${o}`;if(e.negated===true){s=`(?:^(?!${s}).*$)`}return s};e.basename=(t,{windows:e}={})=>{const u=t.split(e?/[\\\\/]/:\"/\");const n=u[u.length-1];if(n===\"\"){return u[u.length-2]}return n}}};var e={};function __nccwpck_require__(u){var n=e[u];if(n!==undefined){return n.exports}var o=e[u]={exports:{}};var s=true;try{t[u](o,o.exports,__nccwpck_require__);s=false}finally{if(s)delete e[u]}return o.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var u=__nccwpck_require__(170);module.exports=u})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3BpY29tYXRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBLE1BQU0sYUFBYSxPQUFPLGNBQWMsZUFBZSxxQkFBcUIsdURBQXVELHlDQUF5QyxrQ0FBa0MsVUFBVSxPQUFPLGdCQUFnQixPQUFPLFdBQVcsT0FBTyxPQUFPLG9CQUFvQixjQUFjLGdDQUFnQyxpREFBaUQsR0FBRywwQkFBMEIsZ0JBQWdCLDJCQUEyQixvQkFBb0IsU0FBUyxnQkFBZ0IsYUFBYSxFQUFFLEdBQUcsY0FBYyxjQUFjLGNBQWMsY0FBYyxnQkFBZ0IsZUFBZSxjQUFjLEVBQUUsS0FBSyxnQkFBZ0IsRUFBRSxHQUFHLFdBQVcsR0FBRyxJQUFJLEVBQUUsRUFBRSxFQUFFLGNBQWMsRUFBRSxHQUFHLGNBQWMsRUFBRSxFQUFFLEVBQUUsR0FBRyxjQUFjLEdBQUcsSUFBSSxFQUFFLEVBQUUsR0FBRyxjQUFjLEVBQUUsR0FBRyxjQUFjLEVBQUUsR0FBRyxXQUFXLEVBQUUsSUFBSSxZQUFZLFNBQVMsd01BQXdNLFNBQVMsdUJBQXVCLEVBQUUsbUJBQW1CLEVBQUUsa0JBQWtCLEdBQUcsSUFBSSxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsdUJBQXVCLEVBQUUsSUFBSSxHQUFHLElBQUksTUFBTSxFQUFFLDBCQUEwQixHQUFHLElBQUksTUFBTSxFQUFFLDJCQUEyQixHQUFHLElBQUksTUFBTSxFQUFFLDBCQUEwQixFQUFFLHlCQUF5QixFQUFFLHNCQUFzQixFQUFFLGdCQUFnQixTQUFTLHlMQUF5TCxhQUFhLEVBQUUsOEVBQThFLFdBQVcsc0VBQXNFLHFEQUFxRCx5Q0FBeUMsZ0dBQWdHLDRFQUE0RSx1Q0FBdUMsbTNCQUFtM0IsT0FBTyxLQUFLLDBDQUEwQyxPQUFPLEdBQUcsTUFBTSxtQ0FBbUMsTUFBTSxrQ0FBa0MsTUFBTSxrQ0FBa0MsTUFBTSxpQ0FBaUMsY0FBYyxzQkFBc0IsZUFBZSxlQUFlLGNBQWMsTUFBTSx5R0FBeUcsR0FB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QkFBbUIsUUFBUSxRQUFRLFFBQVEsU0FBUyxTQUFTLFFBQVEsZUFBZSxhQUFhLEtBQUsscUJBQXFCLGVBQWUsYUFBYSxrQkFBa0IsS0FBSyxJQUFJLEtBQUssSUFBSSw4QkFBOEIsOENBQThDLGlCQUFpQixzQkFBc0IsOEJBQThCLGdCQUFnQiwwQkFBMEIsU0FBUywySEFBMkgsb0JBQW9CLGFBQWEsd0JBQXdCLFVBQVUsV0FBVyxvQ0FBb0MsTUFBTSxZQUFZLFdBQVcsS0FBSyxnQkFBZ0IsYUFBYSxxQkFBcUIsYUFBYSxpQkFBaUIsbUJBQW1CLGFBQWEsS0FBSyxhQUFhLFlBQVksdUJBQXVCLGtCQUFrQixVQUFVLElBQUksb0JBQW9CLHFCQUFxQixVQUFVLGFBQWEsc0JBQXNCLHFCQUFxQixpQ0FBaUMsWUFBWSxVQUFVLFVBQVUsZUFBZSxjQUFjLE1BQU0sOEZBQThGLFFBQVEsK0RBQStELDZCQUE2QixrREFBa0QscUNBQXFDLHFDQUFxQyx1REFBdUQsdUJBQXVCLDJCQUEyQixtQkFBbUIsOENBQThDLFNBQVMsYUFBYSxJQUFJLFdBQVcsR0FBRyxzQkFBc0IsSUFBSSxRQUFRLHVCQUF1QixhQUFhLGNBQWMsVUFBVSxvQkFBb0IsS0FBSyxJQUFJLDBCQUEwQiwwQkFBMEIsU0FBUyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsRUFBRSxxQkFBcUIsWUFBWSxFQUFFLE9BQU8sVUFBVSxlQUFlLFVBQVUsR0FBRyxJQUFJLCtCQUErQixzQkFBc0IsV0FBVyxxQkFBcUIsWUFBWSxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSywrQkFBK0IsaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9waWNvbWF0Y2gvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9ezE3MDoodCxlLHUpPT57Y29uc3Qgbj11KDUxMCk7Y29uc3QgaXNXaW5kb3dzPSgpPT57aWYodHlwZW9mIG5hdmlnYXRvciE9PVwidW5kZWZpbmVkXCImJm5hdmlnYXRvci5wbGF0Zm9ybSl7Y29uc3QgdD1uYXZpZ2F0b3IucGxhdGZvcm0udG9Mb3dlckNhc2UoKTtyZXR1cm4gdD09PVwid2luMzJcInx8dD09PVwid2luZG93c1wifWlmKHR5cGVvZiBwcm9jZXNzIT09XCJ1bmRlZmluZWRcIiYmcHJvY2Vzcy5wbGF0Zm9ybSl7cmV0dXJuIHByb2Nlc3MucGxhdGZvcm09PT1cIndpbjMyXCJ9cmV0dXJuIGZhbHNlfTtmdW5jdGlvbiBwaWNvbWF0Y2godCxlLHU9ZmFsc2Upe2lmKGUmJihlLndpbmRvd3M9PT1udWxsfHxlLndpbmRvd3M9PT11bmRlZmluZWQpKXtlPXsuLi5lLHdpbmRvd3M6aXNXaW5kb3dzKCl9fXJldHVybiBuKHQsZSx1KX1PYmplY3QuYXNzaWduKHBpY29tYXRjaCxuKTt0LmV4cG9ydHM9cGljb21hdGNofSwxNTQ6dD0+e2NvbnN0IGU9XCJcXFxcXFxcXC9cIjtjb25zdCB1PWBbXiR7ZX1dYDtjb25zdCBuPVwiXFxcXC5cIjtjb25zdCBvPVwiXFxcXCtcIjtjb25zdCBzPVwiXFxcXD9cIjtjb25zdCByPVwiXFxcXC9cIjtjb25zdCBhPVwiKD89LilcIjtjb25zdCBpPVwiW14vXVwiO2NvbnN0IGM9YCg/OiR7cn18JClgO2NvbnN0IHA9YCg/Ol58JHtyfSlgO2NvbnN0IGw9YCR7bn17MSwyfSR7Y31gO2NvbnN0IGY9YCg/ISR7bn0pYDtjb25zdCBBPWAoPyEke3B9JHtsfSlgO2NvbnN0IF89YCg/ISR7bn17MCwxfSR7Y30pYDtjb25zdCBSPWAoPyEke2x9KWA7Y29uc3QgRT1gW14uJHtyfV1gO2NvbnN0IGg9YCR7aX0qP2A7Y29uc3QgZz1cIi9cIjtjb25zdCBiPXtET1RfTElURVJBTDpuLFBMVVNfTElURVJBTDpvLFFNQVJLX0xJVEVSQUw6cyxTTEFTSF9MSVRFUkFMOnIsT05FX0NIQVI6YSxRTUFSSzppLEVORF9BTkNIT1I6YyxET1RTX1NMQVNIOmwsTk9fRE9UOmYsTk9fRE9UUzpBLE5PX0RPVF9TTEFTSDpfLE5PX0RPVFNfU0xBU0g6UixRTUFSS19OT19ET1Q6RSxTVEFSOmgsU1RBUlRfQU5DSE9SOnAsU0VQOmd9O2NvbnN0IEM9ey4uLmIsU0xBU0hfTElURVJBTDpgWyR7ZX1dYCxRTUFSSzp1LFNUQVI6YCR7dX0qP2AsRE9UU19TTEFTSDpgJHtufXsxLDJ9KD86WyR7ZX1dfCQpYCxOT19ET1Q6YCg/ISR7bn0pYCxOT19ET1RTOmAoPyEoPzpefFske2V9XSkke259ezEsMn0oPzpbJHtlfV18JCkpYCxOT19ET1RfU0xBU0g6YCg/ISR7bn17MCwxfSg/Olske2V9XXwkKSlgLE5PX0RPVFNfU0xBU0g6YCg/ISR7bn17MSwyfSg/Olske2V9XXwkKSlgLFFNQVJLX05PX0RPVDpgW14uJHtlfV1gLFNUQVJUX0FOQ0hPUjpgKD86XnxbJHtlfV0pYCxFTkRfQU5DSE9SOmAoPzpbJHtlfV18JClgLFNFUDpcIlxcXFxcIn07Y29uc3QgeT17YWxudW06XCJhLXpBLVowLTlcIixhbHBoYTpcImEtekEtWlwiLGFzY2lpOlwiXFxcXHgwMC1cXFxceDdGXCIsYmxhbms6XCIgXFxcXHRcIixjbnRybDpcIlxcXFx4MDAtXFxcXHgxRlxcXFx4N0ZcIixkaWdpdDpcIjAtOVwiLGdyYXBoOlwiXFxcXHgyMS1cXFxceDdFXCIsbG93ZXI6XCJhLXpcIixwcmludDpcIlxcXFx4MjAtXFxcXHg3RSBcIixwdW5jdDpcIlxcXFwtIVxcXCIjJCUmJygpXFxcXCorLC4vOjs8PT4/QFtcXFxcXV5fYHt8fX5cIixzcGFjZTpcIiBcXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmXCIsdXBwZXI6XCJBLVpcIix3b3JkOlwiQS1aYS16MC05X1wiLHhkaWdpdDpcIkEtRmEtZjAtOVwifTt0LmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxQT1NJWF9SRUdFWF9TT1VSQ0U6eSxSRUdFWF9CQUNLU0xBU0g6L1xcXFwoPyFbKis/XiR7fSh8KVtcXF1dKS9nLFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOi9eW15AIVtcXF0uLCQqKz9ee30oKXxcXFxcL10rLyxSRUdFWF9TUEVDSUFMX0NIQVJTOi9bLSorPy5eJHt9KHwpW1xcXV0vLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjovKFxcXFw/KSgoXFxXKShcXDMqKSkvZyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDovKFstKis/Ll4ke30ofClbXFxdXSkvZyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOi8oPzpcXFsuKj9bXlxcXFxdXFxdfFxcXFwoPz0uKSkvZyxSRVBMQUNFTUVOVFM6e1wiKioqXCI6XCIqXCIsXCIqKi8qKlwiOlwiKipcIixcIioqLyoqLyoqXCI6XCIqKlwifSxDSEFSXzA6NDgsQ0hBUl85OjU3LENIQVJfVVBQRVJDQVNFX0E6NjUsQ0hBUl9MT1dFUkNBU0VfQTo5NyxDSEFSX1VQUEVSQ0FTRV9aOjkwLENIQVJfTE9XRVJDQVNFX1o6MTIyLENIQVJfTEVGVF9QQVJFTlRIRVNFUzo0MCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOjQxLENIQVJfQVNURVJJU0s6NDIsQ0hBUl9BTVBFUlNBTkQ6MzgsQ0hBUl9BVDo2NCxDSEFSX0JBQ0tXQVJEX1NMQVNIOjkyLENIQVJfQ0FSUklBR0VfUkVUVVJOOjEzLENIQVJfQ0lSQ1VNRkxFWF9BQ0NFTlQ6OTQsQ0hBUl9DT0xPTjo1OCxDSEFSX0NPTU1BOjQ0LENIQVJfRE9UOjQ2LENIQVJfRE9VQkxFX1FVT1RFOjM0LENIQVJfRVFVQUw6NjEsQ0hBUl9FWENMQU1BVElPTl9NQVJLOjMzLENIQVJfRk9STV9GRUVEOjEyLENIQVJfRk9SV0FSRF9TTEFTSDo0NyxDSEFSX0dSQVZFX0FDQ0VOVDo5NixDSEFSX0hBU0g6MzUsQ0hBUl9IWVBIRU5fTUlOVVM6NDUsQ0hBUl9MRUZUX0FOR0xFX0JSQUNLRVQ6NjAsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOjEyMyxDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQ6OTEsQ0hBUl9MSU5FX0ZFRUQ6MTAsQ0hBUl9OT19CUkVBS19TUEFDRToxNjAsQ0hBUl9QRVJDRU5UOjM3LENIQVJfUExVUzo0MyxDSEFSX1FVRVNUSU9OX01BUks6NjMsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOjYyLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6MTI1LENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6OTMsQ0hBUl9TRU1JQ09MT046NTksQ0hBUl9TSU5HTEVfUVVPVEU6MzksQ0hBUl9TUEFDRTozMixDSEFSX1RBQjo5LENIQVJfVU5ERVJTQ09SRTo5NSxDSEFSX1ZFUlRJQ0FMX0xJTkU6MTI0LENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOjY1Mjc5LGV4dGdsb2JDaGFycyh0KXtyZXR1cm57XCIhXCI6e3R5cGU6XCJuZWdhdGVcIixvcGVuOlwiKD86KD8hKD86XCIsY2xvc2U6YCkpJHt0LlNUQVJ9KWB9LFwiP1wiOnt0eXBlOlwicW1hcmtcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpP1wifSxcIitcIjp7dHlwZTpcInBsdXNcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpK1wifSxcIipcIjp7dHlwZTpcInN0YXJcIixvcGVuOlwiKD86XCIsY2xvc2U6XCIpKlwifSxcIkBcIjp7dHlwZTpcImF0XCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKVwifX19LGdsb2JDaGFycyh0KXtyZXR1cm4gdD09PXRydWU/QzpifX19LDY5NzoodCxlLHUpPT57Y29uc3Qgbj11KDE1NCk7Y29uc3Qgbz11KDk2KTtjb25zdHtNQVhfTEVOR1RIOnMsUE9TSVhfUkVHRVhfU09VUkNFOnIsUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlM6YSxSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUY6aSxSRVBMQUNFTUVOVFM6Y309bjtjb25zdCBleHBhbmRSYW5nZT0odCxlKT0+e2lmKHR5cGVvZiBlLmV4cGFuZFJhbmdlPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZS5leHBhbmRSYW5nZSguLi50LGUpfXQuc29ydCgpO2NvbnN0IHU9YFske3Quam9pbihcIi1cIil9XWA7dHJ5e25ldyBSZWdFeHAodSl9Y2F0Y2goZSl7cmV0dXJuIHQubWFwKCh0PT5vLmVzY2FwZVJlZ2V4KHQpKSkuam9pbihcIi4uXCIpfXJldHVybiB1fTtjb25zdCBzeW50YXhFcnJvcj0odCxlKT0+YE1pc3NpbmcgJHt0fTogXCIke2V9XCIgLSB1c2UgXCJcXFxcXFxcXCR7ZX1cIiB0byBtYXRjaCBsaXRlcmFsIGNoYXJhY3RlcnNgO2NvbnN0IHBhcnNlPSh0LGUpPT57aWYodHlwZW9mIHQhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBzdHJpbmdcIil9dD1jW3RdfHx0O2NvbnN0IHU9ey4uLmV9O2NvbnN0IHA9dHlwZW9mIHUubWF4TGVuZ3RoPT09XCJudW1iZXJcIj9NYXRoLm1pbihzLHUubWF4TGVuZ3RoKTpzO2xldCBsPXQubGVuZ3RoO2lmKGw+cCl7dGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7bH0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHtwfWApfWNvbnN0IGY9e3R5cGU6XCJib3NcIix2YWx1ZTpcIlwiLG91dHB1dDp1LnByZXBlbmR8fFwiXCJ9O2NvbnN0IEE9W2ZdO2NvbnN0IF89dS5jYXB0dXJlP1wiXCI6XCI/OlwiO2NvbnN0IFI9bi5nbG9iQ2hhcnModS53aW5kb3dzKTtjb25zdCBFPW4uZXh0Z2xvYkNoYXJzKFIpO2NvbnN0e0RPVF9MSVRFUkFMOmgsUExVU19MSVRFUkFMOmcsU0xBU0hfTElURVJBTDpiLE9ORV9DSEFSOkMsRE9UU19TTEFTSDp5LE5PX0RPVDokLE5PX0RPVF9TTEFTSDp4LE5PX0RPVFNfU0xBU0g6UyxRTUFSSzpILFFNQVJLX05PX0RPVDp2LFNUQVI6ZCxTVEFSVF9BTkNIT1I6TH09Ujtjb25zdCBnbG9ic3Rhcj10PT5gKCR7X30oPzooPyEke0x9JHt0LmRvdD95Omh9KS4pKj8pYDtjb25zdCBUPXUuZG90P1wiXCI6JDtjb25zdCBPPXUuZG90P0g6djtsZXQgaz11LmJhc2g9PT10cnVlP2dsb2JzdGFyKHUpOmQ7aWYodS5jYXB0dXJlKXtrPWAoJHtrfSlgfWlmKHR5cGVvZiB1Lm5vZXh0PT09XCJib29sZWFuXCIpe3Uubm9leHRnbG9iPXUubm9leHR9Y29uc3QgbT17aW5wdXQ6dCxpbmRleDotMSxzdGFydDowLGRvdDp1LmRvdD09PXRydWUsY29uc3VtZWQ6XCJcIixvdXRwdXQ6XCJcIixwcmVmaXg6XCJcIixiYWNrdHJhY2s6ZmFsc2UsbmVnYXRlZDpmYWxzZSxicmFja2V0czowLGJyYWNlczowLHBhcmVuczowLHF1b3RlczowLGdsb2JzdGFyOmZhbHNlLHRva2VuczpBfTt0PW8ucmVtb3ZlUHJlZml4KHQsbSk7bD10Lmxlbmd0aDtjb25zdCB3PVtdO2NvbnN0IE49W107Y29uc3QgST1bXTtsZXQgQj1mO2xldCBHO2NvbnN0IGVvcz0oKT0+bS5pbmRleD09PWwtMTtjb25zdCBEPW0ucGVlaz0oZT0xKT0+dFttLmluZGV4K2VdO2NvbnN0IE09bS5hZHZhbmNlPSgpPT50WysrbS5pbmRleF18fFwiXCI7Y29uc3QgcmVtYWluaW5nPSgpPT50LnNsaWNlKG0uaW5kZXgrMSk7Y29uc3QgY29uc3VtZT0odD1cIlwiLGU9MCk9PnttLmNvbnN1bWVkKz10O20uaW5kZXgrPWV9O2NvbnN0IGFwcGVuZD10PT57bS5vdXRwdXQrPXQub3V0cHV0IT1udWxsP3Qub3V0cHV0OnQudmFsdWU7Y29uc3VtZSh0LnZhbHVlKX07Y29uc3QgbmVnYXRlPSgpPT57bGV0IHQ9MTt3aGlsZShEKCk9PT1cIiFcIiYmKEQoMikhPT1cIihcInx8RCgzKT09PVwiP1wiKSl7TSgpO20uc3RhcnQrKzt0Kyt9aWYodCUyPT09MCl7cmV0dXJuIGZhbHNlfW0ubmVnYXRlZD10cnVlO20uc3RhcnQrKztyZXR1cm4gdHJ1ZX07Y29uc3QgaW5jcmVtZW50PXQ9PnttW3RdKys7SS5wdXNoKHQpfTtjb25zdCBkZWNyZW1lbnQ9dD0+e21bdF0tLTtJLnBvcCgpfTtjb25zdCBwdXNoPXQ9PntpZihCLnR5cGU9PT1cImdsb2JzdGFyXCIpe2NvbnN0IGU9bS5icmFjZXM+MCYmKHQudHlwZT09PVwiY29tbWFcInx8dC50eXBlPT09XCJicmFjZVwiKTtjb25zdCB1PXQuZXh0Z2xvYj09PXRydWV8fHcubGVuZ3RoJiYodC50eXBlPT09XCJwaXBlXCJ8fHQudHlwZT09PVwicGFyZW5cIik7aWYodC50eXBlIT09XCJzbGFzaFwiJiZ0LnR5cGUhPT1cInBhcmVuXCImJiFlJiYhdSl7bS5vdXRwdXQ9bS5vdXRwdXQuc2xpY2UoMCwtQi5vdXRwdXQubGVuZ3RoKTtCLnR5cGU9XCJzdGFyXCI7Qi52YWx1ZT1cIipcIjtCLm91dHB1dD1rO20ub3V0cHV0Kz1CLm91dHB1dH19aWYody5sZW5ndGgmJnQudHlwZSE9PVwicGFyZW5cIil7d1t3Lmxlbmd0aC0xXS5pbm5lcis9dC52YWx1ZX1pZih0LnZhbHVlfHx0Lm91dHB1dClhcHBlbmQodCk7aWYoQiYmQi50eXBlPT09XCJ0ZXh0XCImJnQudHlwZT09PVwidGV4dFwiKXtCLm91dHB1dD0oQi5vdXRwdXR8fEIudmFsdWUpK3QudmFsdWU7Qi52YWx1ZSs9dC52YWx1ZTtyZXR1cm59dC5wcmV2PUI7QS5wdXNoKHQpO0I9dH07Y29uc3QgZXh0Z2xvYk9wZW49KHQsZSk9Pntjb25zdCBuPXsuLi5FW2VdLGNvbmRpdGlvbnM6MSxpbm5lcjpcIlwifTtuLnByZXY9QjtuLnBhcmVucz1tLnBhcmVucztuLm91dHB1dD1tLm91dHB1dDtjb25zdCBvPSh1LmNhcHR1cmU/XCIoXCI6XCJcIikrbi5vcGVuO2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOnQsdmFsdWU6ZSxvdXRwdXQ6bS5vdXRwdXQ/XCJcIjpDfSk7cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOk0oKSxvdXRwdXQ6b30pO3cucHVzaChuKX07Y29uc3QgZXh0Z2xvYkNsb3NlPXQ9PntsZXQgbj10LmNsb3NlKyh1LmNhcHR1cmU/XCIpXCI6XCJcIik7bGV0IG87aWYodC50eXBlPT09XCJuZWdhdGVcIil7bGV0IHM9aztpZih0LmlubmVyJiZ0LmlubmVyLmxlbmd0aD4xJiZ0LmlubmVyLmluY2x1ZGVzKFwiL1wiKSl7cz1nbG9ic3Rhcih1KX1pZihzIT09a3x8ZW9zKCl8fC9eXFwpKyQvLnRlc3QocmVtYWluaW5nKCkpKXtuPXQuY2xvc2U9YCkkKSkke3N9YH1pZih0LmlubmVyLmluY2x1ZGVzKFwiKlwiKSYmKG89cmVtYWluaW5nKCkpJiYvXlxcLlteXFxcXC8uXSskLy50ZXN0KG8pKXtjb25zdCB1PXBhcnNlKG8sey4uLmUsZmFzdHBhdGhzOmZhbHNlfSkub3V0cHV0O249dC5jbG9zZT1gKSR7dX0pJHtzfSlgfWlmKHQucHJldi50eXBlPT09XCJib3NcIil7bS5uZWdhdGVkRXh0Z2xvYj10cnVlfX1wdXNoKHt0eXBlOlwicGFyZW5cIixleHRnbG9iOnRydWUsdmFsdWU6RyxvdXRwdXQ6bn0pO2RlY3JlbWVudChcInBhcmVuc1wiKX07aWYodS5mYXN0cGF0aHMhPT1mYWxzZSYmIS8oXlsqIV18Wy8oKVtcXF17fVwiXSkvLnRlc3QodCkpe2xldCBuPWZhbHNlO2xldCBzPXQucmVwbGFjZShpLCgodCxlLHUsbyxzLHIpPT57aWYobz09PVwiXFxcXFwiKXtuPXRydWU7cmV0dXJuIHR9aWYobz09PVwiP1wiKXtpZihlKXtyZXR1cm4gZStvKyhzP0gucmVwZWF0KHMubGVuZ3RoKTpcIlwiKX1pZihyPT09MCl7cmV0dXJuIE8rKHM/SC5yZXBlYXQocy5sZW5ndGgpOlwiXCIpfXJldHVybiBILnJlcGVhdCh1Lmxlbmd0aCl9aWYobz09PVwiLlwiKXtyZXR1cm4gaC5yZXBlYXQodS5sZW5ndGgpfWlmKG89PT1cIipcIil7aWYoZSl7cmV0dXJuIGUrbysocz9rOlwiXCIpfXJldHVybiBrfXJldHVybiBlP3Q6YFxcXFwke3R9YH0pKTtpZihuPT09dHJ1ZSl7aWYodS51bmVzY2FwZT09PXRydWUpe3M9cy5yZXBsYWNlKC9cXFxcL2csXCJcIil9ZWxzZXtzPXMucmVwbGFjZSgvXFxcXCsvZywodD0+dC5sZW5ndGglMj09PTA/XCJcXFxcXFxcXFwiOnQ/XCJcXFxcXCI6XCJcIikpfX1pZihzPT09dCYmdS5jb250YWlucz09PXRydWUpe20ub3V0cHV0PXQ7cmV0dXJuIG19bS5vdXRwdXQ9by53cmFwT3V0cHV0KHMsbSxlKTtyZXR1cm4gbX13aGlsZSghZW9zKCkpe0c9TSgpO2lmKEc9PT1cIlxcMFwiKXtjb250aW51ZX1pZihHPT09XCJcXFxcXCIpe2NvbnN0IHQ9RCgpO2lmKHQ9PT1cIi9cIiYmdS5iYXNoIT09dHJ1ZSl7Y29udGludWV9aWYodD09PVwiLlwifHx0PT09XCI7XCIpe2NvbnRpbnVlfWlmKCF0KXtHKz1cIlxcXFxcIjtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkd9KTtjb250aW51ZX1jb25zdCBlPS9eXFxcXCsvLmV4ZWMocmVtYWluaW5nKCkpO2xldCBuPTA7aWYoZSYmZVswXS5sZW5ndGg+Mil7bj1lWzBdLmxlbmd0aDttLmluZGV4Kz1uO2lmKG4lMiE9PTApe0crPVwiXFxcXFwifX1pZih1LnVuZXNjYXBlPT09dHJ1ZSl7Rz1NKCl9ZWxzZXtHKz1NKCl9aWYobS5icmFja2V0cz09PTApe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfX1pZihtLmJyYWNrZXRzPjAmJihHIT09XCJdXCJ8fEIudmFsdWU9PT1cIltcInx8Qi52YWx1ZT09PVwiW15cIikpe2lmKHUucG9zaXghPT1mYWxzZSYmRz09PVwiOlwiKXtjb25zdCB0PUIudmFsdWUuc2xpY2UoMSk7aWYodC5pbmNsdWRlcyhcIltcIikpe0IucG9zaXg9dHJ1ZTtpZih0LmluY2x1ZGVzKFwiOlwiKSl7Y29uc3QgdD1CLnZhbHVlLmxhc3RJbmRleE9mKFwiW1wiKTtjb25zdCBlPUIudmFsdWUuc2xpY2UoMCx0KTtjb25zdCB1PUIudmFsdWUuc2xpY2UodCsyKTtjb25zdCBuPXJbdV07aWYobil7Qi52YWx1ZT1lK247bS5iYWNrdHJhY2s9dHJ1ZTtNKCk7aWYoIWYub3V0cHV0JiZBLmluZGV4T2YoQik9PT0xKXtmLm91dHB1dD1DfWNvbnRpbnVlfX19fWlmKEc9PT1cIltcIiYmRCgpIT09XCI6XCJ8fEc9PT1cIi1cIiYmRCgpPT09XCJdXCIpe0c9YFxcXFwke0d9YH1pZihHPT09XCJdXCImJihCLnZhbHVlPT09XCJbXCJ8fEIudmFsdWU9PT1cIlteXCIpKXtHPWBcXFxcJHtHfWB9aWYodS5wb3NpeD09PXRydWUmJkc9PT1cIiFcIiYmQi52YWx1ZT09PVwiW1wiKXtHPVwiXlwifUIudmFsdWUrPUc7YXBwZW5kKHt2YWx1ZTpHfSk7Y29udGludWV9aWYobS5xdW90ZXM9PT0xJiZHIT09J1wiJyl7Rz1vLmVzY2FwZVJlZ2V4KEcpO0IudmFsdWUrPUc7YXBwZW5kKHt2YWx1ZTpHfSk7Y29udGludWV9aWYoRz09PSdcIicpe20ucXVvdGVzPW0ucXVvdGVzPT09MT8wOjE7aWYodS5rZWVwUXVvdGVzPT09dHJ1ZSl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSl9Y29udGludWV9aWYoRz09PVwiKFwiKXtpbmNyZW1lbnQoXCJwYXJlbnNcIik7cHVzaCh7dHlwZTpcInBhcmVuXCIsdmFsdWU6R30pO2NvbnRpbnVlfWlmKEc9PT1cIilcIil7aWYobS5wYXJlbnM9PT0wJiZ1LnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl7dGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwib3BlbmluZ1wiLFwiKFwiKSl9Y29uc3QgdD13W3cubGVuZ3RoLTFdO2lmKHQmJm0ucGFyZW5zPT09dC5wYXJlbnMrMSl7ZXh0Z2xvYkNsb3NlKHcucG9wKCkpO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJwYXJlblwiLHZhbHVlOkcsb3V0cHV0Om0ucGFyZW5zP1wiKVwiOlwiXFxcXClcIn0pO2RlY3JlbWVudChcInBhcmVuc1wiKTtjb250aW51ZX1pZihHPT09XCJbXCIpe2lmKHUubm9icmFja2V0PT09dHJ1ZXx8IXJlbWFpbmluZygpLmluY2x1ZGVzKFwiXVwiKSl7aWYodS5ub2JyYWNrZXQhPT10cnVlJiZ1LnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl7dGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiXVwiKSl9Rz1gXFxcXCR7R31gfWVsc2V7aW5jcmVtZW50KFwiYnJhY2tldHNcIil9cHVzaCh7dHlwZTpcImJyYWNrZXRcIix2YWx1ZTpHfSk7Y29udGludWV9aWYoRz09PVwiXVwiKXtpZih1Lm5vYnJhY2tldD09PXRydWV8fEImJkIudHlwZT09PVwiYnJhY2tldFwiJiZCLnZhbHVlLmxlbmd0aD09PTEpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6YFxcXFwke0d9YH0pO2NvbnRpbnVlfWlmKG0uYnJhY2tldHM9PT0wKXtpZih1LnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl7dGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwib3BlbmluZ1wiLFwiW1wiKSl9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHLG91dHB1dDpgXFxcXCR7R31gfSk7Y29udGludWV9ZGVjcmVtZW50KFwiYnJhY2tldHNcIik7Y29uc3QgdD1CLnZhbHVlLnNsaWNlKDEpO2lmKEIucG9zaXghPT10cnVlJiZ0WzBdPT09XCJeXCImJiF0LmluY2x1ZGVzKFwiL1wiKSl7Rz1gLyR7R31gfUIudmFsdWUrPUc7YXBwZW5kKHt2YWx1ZTpHfSk7aWYodS5saXRlcmFsQnJhY2tldHM9PT1mYWxzZXx8by5oYXNSZWdleENoYXJzKHQpKXtjb250aW51ZX1jb25zdCBlPW8uZXNjYXBlUmVnZXgoQi52YWx1ZSk7bS5vdXRwdXQ9bS5vdXRwdXQuc2xpY2UoMCwtQi52YWx1ZS5sZW5ndGgpO2lmKHUubGl0ZXJhbEJyYWNrZXRzPT09dHJ1ZSl7bS5vdXRwdXQrPWU7Qi52YWx1ZT1lO2NvbnRpbnVlfUIudmFsdWU9YCgke199JHtlfXwke0IudmFsdWV9KWA7bS5vdXRwdXQrPUIudmFsdWU7Y29udGludWV9aWYoRz09PVwie1wiJiZ1Lm5vYnJhY2UhPT10cnVlKXtpbmNyZW1lbnQoXCJicmFjZXNcIik7Y29uc3QgdD17dHlwZTpcImJyYWNlXCIsdmFsdWU6RyxvdXRwdXQ6XCIoXCIsb3V0cHV0SW5kZXg6bS5vdXRwdXQubGVuZ3RoLHRva2Vuc0luZGV4Om0udG9rZW5zLmxlbmd0aH07Ti5wdXNoKHQpO3B1c2godCk7Y29udGludWV9aWYoRz09PVwifVwiKXtjb25zdCB0PU5bTi5sZW5ndGgtMV07aWYodS5ub2JyYWNlPT09dHJ1ZXx8IXQpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6RyxvdXRwdXQ6R30pO2NvbnRpbnVlfWxldCBlPVwiKVwiO2lmKHQuZG90cz09PXRydWUpe2NvbnN0IHQ9QS5zbGljZSgpO2NvbnN0IG49W107Zm9yKGxldCBlPXQubGVuZ3RoLTE7ZT49MDtlLS0pe0EucG9wKCk7aWYodFtlXS50eXBlPT09XCJicmFjZVwiKXticmVha31pZih0W2VdLnR5cGUhPT1cImRvdHNcIil7bi51bnNoaWZ0KHRbZV0udmFsdWUpfX1lPWV4cGFuZFJhbmdlKG4sdSk7bS5iYWNrdHJhY2s9dHJ1ZX1pZih0LmNvbW1hIT09dHJ1ZSYmdC5kb3RzIT09dHJ1ZSl7Y29uc3QgdT1tLm91dHB1dC5zbGljZSgwLHQub3V0cHV0SW5kZXgpO2NvbnN0IG49bS50b2tlbnMuc2xpY2UodC50b2tlbnNJbmRleCk7dC52YWx1ZT10Lm91dHB1dD1cIlxcXFx7XCI7Rz1lPVwiXFxcXH1cIjttLm91dHB1dD11O2Zvcihjb25zdCB0IG9mIG4pe20ub3V0cHV0Kz10Lm91dHB1dHx8dC52YWx1ZX19cHVzaCh7dHlwZTpcImJyYWNlXCIsdmFsdWU6RyxvdXRwdXQ6ZX0pO2RlY3JlbWVudChcImJyYWNlc1wiKTtOLnBvcCgpO2NvbnRpbnVlfWlmKEc9PT1cInxcIil7aWYody5sZW5ndGg+MCl7d1t3Lmxlbmd0aC0xXS5jb25kaXRpb25zKyt9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9aWYoRz09PVwiLFwiKXtsZXQgdD1HO2NvbnN0IGU9TltOLmxlbmd0aC0xXTtpZihlJiZJW0kubGVuZ3RoLTFdPT09XCJicmFjZXNcIil7ZS5jb21tYT10cnVlO3Q9XCJ8XCJ9cHVzaCh7dHlwZTpcImNvbW1hXCIsdmFsdWU6RyxvdXRwdXQ6dH0pO2NvbnRpbnVlfWlmKEc9PT1cIi9cIil7aWYoQi50eXBlPT09XCJkb3RcIiYmbS5pbmRleD09PW0uc3RhcnQrMSl7bS5zdGFydD1tLmluZGV4KzE7bS5jb25zdW1lZD1cIlwiO20ub3V0cHV0PVwiXCI7QS5wb3AoKTtCPWY7Y29udGludWV9cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6RyxvdXRwdXQ6Yn0pO2NvbnRpbnVlfWlmKEc9PT1cIi5cIil7aWYobS5icmFjZXM+MCYmQi50eXBlPT09XCJkb3RcIil7aWYoQi52YWx1ZT09PVwiLlwiKUIub3V0cHV0PWg7Y29uc3QgdD1OW04ubGVuZ3RoLTFdO0IudHlwZT1cImRvdHNcIjtCLm91dHB1dCs9RztCLnZhbHVlKz1HO3QuZG90cz10cnVlO2NvbnRpbnVlfWlmKG0uYnJhY2VzK20ucGFyZW5zPT09MCYmQi50eXBlIT09XCJib3NcIiYmQi50eXBlIT09XCJzbGFzaFwiKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0Omh9KTtjb250aW51ZX1wdXNoKHt0eXBlOlwiZG90XCIsdmFsdWU6RyxvdXRwdXQ6aH0pO2NvbnRpbnVlfWlmKEc9PT1cIj9cIil7Y29uc3QgdD1CJiZCLnZhbHVlPT09XCIoXCI7aWYoIXQmJnUubm9leHRnbG9iIT09dHJ1ZSYmRCgpPT09XCIoXCImJkQoMikhPT1cIj9cIil7ZXh0Z2xvYk9wZW4oXCJxbWFya1wiLEcpO2NvbnRpbnVlfWlmKEImJkIudHlwZT09PVwicGFyZW5cIil7Y29uc3QgdD1EKCk7bGV0IGU9RztpZihCLnZhbHVlPT09XCIoXCImJiEvWyE9PDpdLy50ZXN0KHQpfHx0PT09XCI8XCImJiEvPChbIT1dfFxcdys+KS8udGVzdChyZW1haW5pbmcoKSkpe2U9YFxcXFwke0d9YH1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkcsb3V0cHV0OmV9KTtjb250aW51ZX1pZih1LmRvdCE9PXRydWUmJihCLnR5cGU9PT1cInNsYXNoXCJ8fEIudHlwZT09PVwiYm9zXCIpKXtwdXNoKHt0eXBlOlwicW1hcmtcIix2YWx1ZTpHLG91dHB1dDp2fSk7Y29udGludWV9cHVzaCh7dHlwZTpcInFtYXJrXCIsdmFsdWU6RyxvdXRwdXQ6SH0pO2NvbnRpbnVlfWlmKEc9PT1cIiFcIil7aWYodS5ub2V4dGdsb2IhPT10cnVlJiZEKCk9PT1cIihcIil7aWYoRCgyKSE9PVwiP1wifHwhL1shPTw6XS8udGVzdChEKDMpKSl7ZXh0Z2xvYk9wZW4oXCJuZWdhdGVcIixHKTtjb250aW51ZX19aWYodS5ub25lZ2F0ZSE9PXRydWUmJm0uaW5kZXg9PT0wKXtuZWdhdGUoKTtjb250aW51ZX19aWYoRz09PVwiK1wiKXtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJkQoKT09PVwiKFwiJiZEKDIpIT09XCI/XCIpe2V4dGdsb2JPcGVuKFwicGx1c1wiLEcpO2NvbnRpbnVlfWlmKEImJkIudmFsdWU9PT1cIihcInx8dS5yZWdleD09PWZhbHNlKXtwdXNoKHt0eXBlOlwicGx1c1wiLHZhbHVlOkcsb3V0cHV0Omd9KTtjb250aW51ZX1pZihCJiYoQi50eXBlPT09XCJicmFja2V0XCJ8fEIudHlwZT09PVwicGFyZW5cInx8Qi50eXBlPT09XCJicmFjZVwiKXx8bS5wYXJlbnM+MCl7cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpHfSk7Y29udGludWV9cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpnfSk7Y29udGludWV9aWYoRz09PVwiQFwiKXtpZih1Lm5vZXh0Z2xvYiE9PXRydWUmJkQoKT09PVwiKFwiJiZEKDIpIT09XCI/XCIpe3B1c2goe3R5cGU6XCJhdFwiLGV4dGdsb2I6dHJ1ZSx2YWx1ZTpHLG91dHB1dDpcIlwifSk7Y29udGludWV9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpHfSk7Y29udGludWV9aWYoRyE9PVwiKlwiKXtpZihHPT09XCIkXCJ8fEc9PT1cIl5cIil7Rz1gXFxcXCR7R31gfWNvbnN0IHQ9YS5leGVjKHJlbWFpbmluZygpKTtpZih0KXtHKz10WzBdO20uaW5kZXgrPXRbMF0ubGVuZ3RofXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6R30pO2NvbnRpbnVlfWlmKEImJihCLnR5cGU9PT1cImdsb2JzdGFyXCJ8fEIuc3Rhcj09PXRydWUpKXtCLnR5cGU9XCJzdGFyXCI7Qi5zdGFyPXRydWU7Qi52YWx1ZSs9RztCLm91dHB1dD1rO20uYmFja3RyYWNrPXRydWU7bS5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoRyk7Y29udGludWV9bGV0IGU9cmVtYWluaW5nKCk7aWYodS5ub2V4dGdsb2IhPT10cnVlJiYvXlxcKFteP10vLnRlc3QoZSkpe2V4dGdsb2JPcGVuKFwic3RhclwiLEcpO2NvbnRpbnVlfWlmKEIudHlwZT09PVwic3RhclwiKXtpZih1Lm5vZ2xvYnN0YXI9PT10cnVlKXtjb25zdW1lKEcpO2NvbnRpbnVlfWNvbnN0IG49Qi5wcmV2O2NvbnN0IG89bi5wcmV2O2NvbnN0IHM9bi50eXBlPT09XCJzbGFzaFwifHxuLnR5cGU9PT1cImJvc1wiO2NvbnN0IHI9byYmKG8udHlwZT09PVwic3RhclwifHxvLnR5cGU9PT1cImdsb2JzdGFyXCIpO2lmKHUuYmFzaD09PXRydWUmJighc3x8ZVswXSYmZVswXSE9PVwiL1wiKSl7cHVzaCh7dHlwZTpcInN0YXJcIix2YWx1ZTpHLG91dHB1dDpcIlwifSk7Y29udGludWV9Y29uc3QgYT1tLmJyYWNlcz4wJiYobi50eXBlPT09XCJjb21tYVwifHxuLnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IGk9dy5sZW5ndGgmJihuLnR5cGU9PT1cInBpcGVcInx8bi50eXBlPT09XCJwYXJlblwiKTtpZighcyYmbi50eXBlIT09XCJwYXJlblwiJiYhYSYmIWkpe3B1c2goe3R5cGU6XCJzdGFyXCIsdmFsdWU6RyxvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfXdoaWxlKGUuc2xpY2UoMCwzKT09PVwiLyoqXCIpe2NvbnN0IHU9dFttLmluZGV4KzRdO2lmKHUmJnUhPT1cIi9cIil7YnJlYWt9ZT1lLnNsaWNlKDMpO2NvbnN1bWUoXCIvKipcIiwzKX1pZihuLnR5cGU9PT1cImJvc1wiJiZlb3MoKSl7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLnZhbHVlKz1HO0Iub3V0cHV0PWdsb2JzdGFyKHUpO20ub3V0cHV0PUIub3V0cHV0O20uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEcpO2NvbnRpbnVlfWlmKG4udHlwZT09PVwic2xhc2hcIiYmbi5wcmV2LnR5cGUhPT1cImJvc1wiJiYhciYmZW9zKCkpe20ub3V0cHV0PW0ub3V0cHV0LnNsaWNlKDAsLShuLm91dHB1dCtCLm91dHB1dCkubGVuZ3RoKTtuLm91dHB1dD1gKD86JHtuLm91dHB1dH1gO0IudHlwZT1cImdsb2JzdGFyXCI7Qi5vdXRwdXQ9Z2xvYnN0YXIodSkrKHUuc3RyaWN0U2xhc2hlcz9cIilcIjpcInwkKVwiKTtCLnZhbHVlKz1HO20uZ2xvYnN0YXI9dHJ1ZTttLm91dHB1dCs9bi5vdXRwdXQrQi5vdXRwdXQ7Y29uc3VtZShHKTtjb250aW51ZX1pZihuLnR5cGU9PT1cInNsYXNoXCImJm4ucHJldi50eXBlIT09XCJib3NcIiYmZVswXT09PVwiL1wiKXtjb25zdCB0PWVbMV0hPT12b2lkIDA/XCJ8JFwiOlwiXCI7bS5vdXRwdXQ9bS5vdXRwdXQuc2xpY2UoMCwtKG4ub3V0cHV0K0Iub3V0cHV0KS5sZW5ndGgpO24ub3V0cHV0PWAoPzoke24ub3V0cHV0fWA7Qi50eXBlPVwiZ2xvYnN0YXJcIjtCLm91dHB1dD1gJHtnbG9ic3Rhcih1KX0ke2J9fCR7Yn0ke3R9KWA7Qi52YWx1ZSs9RzttLm91dHB1dCs9bi5vdXRwdXQrQi5vdXRwdXQ7bS5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoRytNKCkpO3B1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOlwiL1wiLG91dHB1dDpcIlwifSk7Y29udGludWV9aWYobi50eXBlPT09XCJib3NcIiYmZVswXT09PVwiL1wiKXtCLnR5cGU9XCJnbG9ic3RhclwiO0IudmFsdWUrPUc7Qi5vdXRwdXQ9YCg/Ol58JHtifXwke2dsb2JzdGFyKHUpfSR7Yn0pYDttLm91dHB1dD1CLm91dHB1dDttLmdsb2JzdGFyPXRydWU7Y29uc3VtZShHK00oKSk7cHVzaCh7dHlwZTpcInNsYXNoXCIsdmFsdWU6XCIvXCIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX1tLm91dHB1dD1tLm91dHB1dC5zbGljZSgwLC1CLm91dHB1dC5sZW5ndGgpO0IudHlwZT1cImdsb2JzdGFyXCI7Qi5vdXRwdXQ9Z2xvYnN0YXIodSk7Qi52YWx1ZSs9RzttLm91dHB1dCs9Qi5vdXRwdXQ7bS5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoRyk7Y29udGludWV9Y29uc3Qgbj17dHlwZTpcInN0YXJcIix2YWx1ZTpHLG91dHB1dDprfTtpZih1LmJhc2g9PT10cnVlKXtuLm91dHB1dD1cIi4qP1wiO2lmKEIudHlwZT09PVwiYm9zXCJ8fEIudHlwZT09PVwic2xhc2hcIil7bi5vdXRwdXQ9VCtuLm91dHB1dH1wdXNoKG4pO2NvbnRpbnVlfWlmKEImJihCLnR5cGU9PT1cImJyYWNrZXRcInx8Qi50eXBlPT09XCJwYXJlblwiKSYmdS5yZWdleD09PXRydWUpe24ub3V0cHV0PUc7cHVzaChuKTtjb250aW51ZX1pZihtLmluZGV4PT09bS5zdGFydHx8Qi50eXBlPT09XCJzbGFzaFwifHxCLnR5cGU9PT1cImRvdFwiKXtpZihCLnR5cGU9PT1cImRvdFwiKXttLm91dHB1dCs9eDtCLm91dHB1dCs9eH1lbHNlIGlmKHUuZG90PT09dHJ1ZSl7bS5vdXRwdXQrPVM7Qi5vdXRwdXQrPVN9ZWxzZXttLm91dHB1dCs9VDtCLm91dHB1dCs9VH1pZihEKCkhPT1cIipcIil7bS5vdXRwdXQrPUM7Qi5vdXRwdXQrPUN9fXB1c2gobil9d2hpbGUobS5icmFja2V0cz4wKXtpZih1LnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJdXCIpKTttLm91dHB1dD1vLmVzY2FwZUxhc3QobS5vdXRwdXQsXCJbXCIpO2RlY3JlbWVudChcImJyYWNrZXRzXCIpfXdoaWxlKG0ucGFyZW5zPjApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIilcIikpO20ub3V0cHV0PW8uZXNjYXBlTGFzdChtLm91dHB1dCxcIihcIik7ZGVjcmVtZW50KFwicGFyZW5zXCIpfXdoaWxlKG0uYnJhY2VzPjApe2lmKHUuc3RyaWN0QnJhY2tldHM9PT10cnVlKXRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIn1cIikpO20ub3V0cHV0PW8uZXNjYXBlTGFzdChtLm91dHB1dCxcIntcIik7ZGVjcmVtZW50KFwiYnJhY2VzXCIpfWlmKHUuc3RyaWN0U2xhc2hlcyE9PXRydWUmJihCLnR5cGU9PT1cInN0YXJcInx8Qi50eXBlPT09XCJicmFja2V0XCIpKXtwdXNoKHt0eXBlOlwibWF5YmVfc2xhc2hcIix2YWx1ZTpcIlwiLG91dHB1dDpgJHtifT9gfSl9aWYobS5iYWNrdHJhY2s9PT10cnVlKXttLm91dHB1dD1cIlwiO2Zvcihjb25zdCB0IG9mIG0udG9rZW5zKXttLm91dHB1dCs9dC5vdXRwdXQhPW51bGw/dC5vdXRwdXQ6dC52YWx1ZTtpZih0LnN1ZmZpeCl7bS5vdXRwdXQrPXQuc3VmZml4fX19cmV0dXJuIG19O3BhcnNlLmZhc3RwYXRocz0odCxlKT0+e2NvbnN0IHU9ey4uLmV9O2NvbnN0IHI9dHlwZW9mIHUubWF4TGVuZ3RoPT09XCJudW1iZXJcIj9NYXRoLm1pbihzLHUubWF4TGVuZ3RoKTpzO2NvbnN0IGE9dC5sZW5ndGg7aWYoYT5yKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHthfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke3J9YCl9dD1jW3RdfHx0O2NvbnN0e0RPVF9MSVRFUkFMOmksU0xBU0hfTElURVJBTDpwLE9ORV9DSEFSOmwsRE9UU19TTEFTSDpmLE5PX0RPVDpBLE5PX0RPVFM6XyxOT19ET1RTX1NMQVNIOlIsU1RBUjpFLFNUQVJUX0FOQ0hPUjpofT1uLmdsb2JDaGFycyh1LndpbmRvd3MpO2NvbnN0IGc9dS5kb3Q/XzpBO2NvbnN0IGI9dS5kb3Q/UjpBO2NvbnN0IEM9dS5jYXB0dXJlP1wiXCI6XCI/OlwiO2NvbnN0IHk9e25lZ2F0ZWQ6ZmFsc2UscHJlZml4OlwiXCJ9O2xldCAkPXUuYmFzaD09PXRydWU/XCIuKj9cIjpFO2lmKHUuY2FwdHVyZSl7JD1gKCR7JH0pYH1jb25zdCBnbG9ic3Rhcj10PT57aWYodC5ub2dsb2JzdGFyPT09dHJ1ZSlyZXR1cm4gJDtyZXR1cm5gKCR7Q30oPzooPyEke2h9JHt0LmRvdD9mOml9KS4pKj8pYH07Y29uc3QgY3JlYXRlPXQ9Pntzd2l0Y2godCl7Y2FzZVwiKlwiOnJldHVybmAke2d9JHtsfSR7JH1gO2Nhc2VcIi4qXCI6cmV0dXJuYCR7aX0ke2x9JHskfWA7Y2FzZVwiKi4qXCI6cmV0dXJuYCR7Z30keyR9JHtpfSR7bH0keyR9YDtjYXNlXCIqLypcIjpyZXR1cm5gJHtnfSR7JH0ke3B9JHtsfSR7Yn0keyR9YDtjYXNlXCIqKlwiOnJldHVybiBnK2dsb2JzdGFyKHUpO2Nhc2VcIioqLypcIjpyZXR1cm5gKD86JHtnfSR7Z2xvYnN0YXIodSl9JHtwfSk/JHtifSR7bH0keyR9YDtjYXNlXCIqKi8qLipcIjpyZXR1cm5gKD86JHtnfSR7Z2xvYnN0YXIodSl9JHtwfSk/JHtifSR7JH0ke2l9JHtsfSR7JH1gO2Nhc2VcIioqLy4qXCI6cmV0dXJuYCg/OiR7Z30ke2dsb2JzdGFyKHUpfSR7cH0pPyR7aX0ke2x9JHskfWA7ZGVmYXVsdDp7Y29uc3QgZT0vXiguKj8pXFwuKFxcdyspJC8uZXhlYyh0KTtpZighZSlyZXR1cm47Y29uc3QgdT1jcmVhdGUoZVsxXSk7aWYoIXUpcmV0dXJuO3JldHVybiB1K2krZVsyXX19fTtjb25zdCB4PW8ucmVtb3ZlUHJlZml4KHQseSk7bGV0IFM9Y3JlYXRlKHgpO2lmKFMmJnUuc3RyaWN0U2xhc2hlcyE9PXRydWUpe1MrPWAke3B9P2B9cmV0dXJuIFN9O3QuZXhwb3J0cz1wYXJzZX0sNTEwOih0LGUsdSk9Pntjb25zdCBuPXUoNzE2KTtjb25zdCBvPXUoNjk3KTtjb25zdCBzPXUoOTYpO2NvbnN0IHI9dSgxNTQpO2NvbnN0IGlzT2JqZWN0PXQ9PnQmJnR5cGVvZiB0PT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkodCk7Y29uc3QgcGljb21hdGNoPSh0LGUsdT1mYWxzZSk9PntpZihBcnJheS5pc0FycmF5KHQpKXtjb25zdCBuPXQubWFwKCh0PT5waWNvbWF0Y2godCxlLHUpKSk7Y29uc3QgYXJyYXlNYXRjaGVyPXQ9Pntmb3IoY29uc3QgZSBvZiBuKXtjb25zdCB1PWUodCk7aWYodSlyZXR1cm4gdX1yZXR1cm4gZmFsc2V9O3JldHVybiBhcnJheU1hdGNoZXJ9Y29uc3Qgbj1pc09iamVjdCh0KSYmdC50b2tlbnMmJnQuaW5wdXQ7aWYodD09PVwiXCJ8fHR5cGVvZiB0IT09XCJzdHJpbmdcIiYmIW4pe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1jb25zdCBvPWV8fHt9O2NvbnN0IHM9by53aW5kb3dzO2NvbnN0IHI9bj9waWNvbWF0Y2guY29tcGlsZVJlKHQsZSk6cGljb21hdGNoLm1ha2VSZSh0LGUsZmFsc2UsdHJ1ZSk7Y29uc3QgYT1yLnN0YXRlO2RlbGV0ZSByLnN0YXRlO2xldCBpc0lnbm9yZWQ9KCk9PmZhbHNlO2lmKG8uaWdub3JlKXtjb25zdCB0PXsuLi5lLGlnbm9yZTpudWxsLG9uTWF0Y2g6bnVsbCxvblJlc3VsdDpudWxsfTtpc0lnbm9yZWQ9cGljb21hdGNoKG8uaWdub3JlLHQsdSl9Y29uc3QgbWF0Y2hlcj0odSxuPWZhbHNlKT0+e2NvbnN0e2lzTWF0Y2g6aSxtYXRjaDpjLG91dHB1dDpwfT1waWNvbWF0Y2gudGVzdCh1LHIsZSx7Z2xvYjp0LHBvc2l4OnN9KTtjb25zdCBsPXtnbG9iOnQsc3RhdGU6YSxyZWdleDpyLHBvc2l4OnMsaW5wdXQ6dSxvdXRwdXQ6cCxtYXRjaDpjLGlzTWF0Y2g6aX07aWYodHlwZW9mIG8ub25SZXN1bHQ9PT1cImZ1bmN0aW9uXCIpe28ub25SZXN1bHQobCl9aWYoaT09PWZhbHNlKXtsLmlzTWF0Y2g9ZmFsc2U7cmV0dXJuIG4/bDpmYWxzZX1pZihpc0lnbm9yZWQodSkpe2lmKHR5cGVvZiBvLm9uSWdub3JlPT09XCJmdW5jdGlvblwiKXtvLm9uSWdub3JlKGwpfWwuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9sOmZhbHNlfWlmKHR5cGVvZiBvLm9uTWF0Y2g9PT1cImZ1bmN0aW9uXCIpe28ub25NYXRjaChsKX1yZXR1cm4gbj9sOnRydWV9O2lmKHUpe21hdGNoZXIuc3RhdGU9YX1yZXR1cm4gbWF0Y2hlcn07cGljb21hdGNoLnRlc3Q9KHQsZSx1LHtnbG9iOm4scG9zaXg6b309e30pPT57aWYodHlwZW9mIHQhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgdG8gYmUgYSBzdHJpbmdcIil9aWYodD09PVwiXCIpe3JldHVybntpc01hdGNoOmZhbHNlLG91dHB1dDpcIlwifX1jb25zdCByPXV8fHt9O2NvbnN0IGE9ci5mb3JtYXR8fChvP3MudG9Qb3NpeFNsYXNoZXM6bnVsbCk7bGV0IGk9dD09PW47bGV0IGM9aSYmYT9hKHQpOnQ7aWYoaT09PWZhbHNlKXtjPWE/YSh0KTp0O2k9Yz09PW59aWYoaT09PWZhbHNlfHxyLmNhcHR1cmU9PT10cnVlKXtpZihyLm1hdGNoQmFzZT09PXRydWV8fHIuYmFzZW5hbWU9PT10cnVlKXtpPXBpY29tYXRjaC5tYXRjaEJhc2UodCxlLHUsbyl9ZWxzZXtpPWUuZXhlYyhjKX19cmV0dXJue2lzTWF0Y2g6Qm9vbGVhbihpKSxtYXRjaDppLG91dHB1dDpjfX07cGljb21hdGNoLm1hdGNoQmFzZT0odCxlLHUpPT57Y29uc3Qgbj1lIGluc3RhbmNlb2YgUmVnRXhwP2U6cGljb21hdGNoLm1ha2VSZShlLHUpO3JldHVybiBuLnRlc3Qocy5iYXNlbmFtZSh0KSl9O3BpY29tYXRjaC5pc01hdGNoPSh0LGUsdSk9PnBpY29tYXRjaChlLHUpKHQpO3BpY29tYXRjaC5wYXJzZT0odCxlKT0+e2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHQubWFwKCh0PT5waWNvbWF0Y2gucGFyc2UodCxlKSkpO3JldHVybiBvKHQsey4uLmUsZmFzdHBhdGhzOmZhbHNlfSl9O3BpY29tYXRjaC5zY2FuPSh0LGUpPT5uKHQsZSk7cGljb21hdGNoLmNvbXBpbGVSZT0odCxlLHU9ZmFsc2Usbj1mYWxzZSk9PntpZih1PT09dHJ1ZSl7cmV0dXJuIHQub3V0cHV0fWNvbnN0IG89ZXx8e307Y29uc3Qgcz1vLmNvbnRhaW5zP1wiXCI6XCJeXCI7Y29uc3Qgcj1vLmNvbnRhaW5zP1wiXCI6XCIkXCI7bGV0IGE9YCR7c30oPzoke3Qub3V0cHV0fSkke3J9YDtpZih0JiZ0Lm5lZ2F0ZWQ9PT10cnVlKXthPWBeKD8hJHthfSkuKiRgfWNvbnN0IGk9cGljb21hdGNoLnRvUmVnZXgoYSxlKTtpZihuPT09dHJ1ZSl7aS5zdGF0ZT10fXJldHVybiBpfTtwaWNvbWF0Y2gubWFrZVJlPSh0LGU9e30sdT1mYWxzZSxuPWZhbHNlKT0+e2lmKCF0fHx0eXBlb2YgdCE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIG5vbi1lbXB0eSBzdHJpbmdcIil9bGV0IHM9e25lZ2F0ZWQ6ZmFsc2UsZmFzdHBhdGhzOnRydWV9O2lmKGUuZmFzdHBhdGhzIT09ZmFsc2UmJih0WzBdPT09XCIuXCJ8fHRbMF09PT1cIipcIikpe3Mub3V0cHV0PW8uZmFzdHBhdGhzKHQsZSl9aWYoIXMub3V0cHV0KXtzPW8odCxlKX1yZXR1cm4gcGljb21hdGNoLmNvbXBpbGVSZShzLGUsdSxuKX07cGljb21hdGNoLnRvUmVnZXg9KHQsZSk9Pnt0cnl7Y29uc3QgdT1lfHx7fTtyZXR1cm4gbmV3IFJlZ0V4cCh0LHUuZmxhZ3N8fCh1Lm5vY2FzZT9cImlcIjpcIlwiKSl9Y2F0Y2godCl7aWYoZSYmZS5kZWJ1Zz09PXRydWUpdGhyb3cgdDtyZXR1cm4vJF4vfX07cGljb21hdGNoLmNvbnN0YW50cz1yO3QuZXhwb3J0cz1waWNvbWF0Y2h9LDcxNjoodCxlLHUpPT57Y29uc3Qgbj11KDk2KTtjb25zdHtDSEFSX0FTVEVSSVNLOm8sQ0hBUl9BVDpzLENIQVJfQkFDS1dBUkRfU0xBU0g6cixDSEFSX0NPTU1BOmEsQ0hBUl9ET1Q6aSxDSEFSX0VYQ0xBTUFUSU9OX01BUks6YyxDSEFSX0ZPUldBUkRfU0xBU0g6cCxDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6bCxDSEFSX0xFRlRfUEFSRU5USEVTRVM6ZixDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQ6QSxDSEFSX1BMVVM6XyxDSEFSX1FVRVNUSU9OX01BUks6UixDSEFSX1JJR0hUX0NVUkxZX0JSQUNFOkUsQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUzpoLENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6Z309dSgxNTQpO2NvbnN0IGlzUGF0aFNlcGFyYXRvcj10PT50PT09cHx8dD09PXI7Y29uc3QgZGVwdGg9dD0+e2lmKHQuaXNQcmVmaXghPT10cnVlKXt0LmRlcHRoPXQuaXNHbG9ic3Rhcj9JbmZpbml0eToxfX07Y29uc3Qgc2Nhbj0odCxlKT0+e2NvbnN0IHU9ZXx8e307Y29uc3QgYj10Lmxlbmd0aC0xO2NvbnN0IEM9dS5wYXJ0cz09PXRydWV8fHUuc2NhblRvRW5kPT09dHJ1ZTtjb25zdCB5PVtdO2NvbnN0ICQ9W107Y29uc3QgeD1bXTtsZXQgUz10O2xldCBIPS0xO2xldCB2PTA7bGV0IGQ9MDtsZXQgTD1mYWxzZTtsZXQgVD1mYWxzZTtsZXQgTz1mYWxzZTtsZXQgaz1mYWxzZTtsZXQgbT1mYWxzZTtsZXQgdz1mYWxzZTtsZXQgTj1mYWxzZTtsZXQgST1mYWxzZTtsZXQgQj1mYWxzZTtsZXQgRz1mYWxzZTtsZXQgRD0wO2xldCBNO2xldCBQO2xldCBLPXt2YWx1ZTpcIlwiLGRlcHRoOjAsaXNHbG9iOmZhbHNlfTtjb25zdCBlb3M9KCk9Pkg+PWI7Y29uc3QgcGVlaz0oKT0+Uy5jaGFyQ29kZUF0KEgrMSk7Y29uc3QgYWR2YW5jZT0oKT0+e009UDtyZXR1cm4gUy5jaGFyQ29kZUF0KCsrSCl9O3doaWxlKEg8Yil7UD1hZHZhbmNlKCk7bGV0IHQ7aWYoUD09PXIpe049Sy5iYWNrc2xhc2hlcz10cnVlO1A9YWR2YW5jZSgpO2lmKFA9PT1sKXt3PXRydWV9Y29udGludWV9aWYodz09PXRydWV8fFA9PT1sKXtEKys7d2hpbGUoZW9zKCkhPT10cnVlJiYoUD1hZHZhbmNlKCkpKXtpZihQPT09cil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7YWR2YW5jZSgpO2NvbnRpbnVlfWlmKFA9PT1sKXtEKys7Y29udGludWV9aWYodyE9PXRydWUmJlA9PT1pJiYoUD1hZHZhbmNlKCkpPT09aSl7TD1LLmlzQnJhY2U9dHJ1ZTtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZih3IT09dHJ1ZSYmUD09PWEpe0w9Sy5pc0JyYWNlPXRydWU7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTtpZihDPT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoUD09PUUpe0QtLTtpZihEPT09MCl7dz1mYWxzZTtMPUsuaXNCcmFjZT10cnVlO0c9dHJ1ZTticmVha319fWlmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZihQPT09cCl7eS5wdXNoKEgpOyQucHVzaChLKTtLPXt2YWx1ZTpcIlwiLGRlcHRoOjAsaXNHbG9iOmZhbHNlfTtpZihHPT09dHJ1ZSljb250aW51ZTtpZihNPT09aSYmSD09PXYrMSl7dis9Mjtjb250aW51ZX1kPUgrMTtjb250aW51ZX1pZih1Lm5vZXh0IT09dHJ1ZSl7Y29uc3QgdD1QPT09X3x8UD09PXN8fFA9PT1vfHxQPT09Unx8UD09PWM7aWYodD09PXRydWUmJnBlZWsoKT09PWYpe089Sy5pc0dsb2I9dHJ1ZTtrPUsuaXNFeHRnbG9iPXRydWU7Rz10cnVlO2lmKFA9PT1jJiZIPT09dil7Qj10cnVlfWlmKEM9PT10cnVlKXt3aGlsZShlb3MoKSE9PXRydWUmJihQPWFkdmFuY2UoKSkpe2lmKFA9PT1yKXtOPUsuYmFja3NsYXNoZXM9dHJ1ZTtQPWFkdmFuY2UoKTtjb250aW51ZX1pZihQPT09aCl7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9fWlmKFA9PT1vKXtpZihNPT09byltPUsuaXNHbG9ic3Rhcj10cnVlO089Sy5pc0dsb2I9dHJ1ZTtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKFA9PT1SKXtPPUsuaXNHbG9iPXRydWU7Rz10cnVlO2lmKEM9PT10cnVlKXtjb250aW51ZX1icmVha31pZihQPT09QSl7d2hpbGUoZW9zKCkhPT10cnVlJiYodD1hZHZhbmNlKCkpKXtpZih0PT09cil7Tj1LLmJhY2tzbGFzaGVzPXRydWU7YWR2YW5jZSgpO2NvbnRpbnVlfWlmKHQ9PT1nKXtUPUsuaXNCcmFja2V0PXRydWU7Tz1LLmlzR2xvYj10cnVlO0c9dHJ1ZTticmVha319aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKHUubm9uZWdhdGUhPT10cnVlJiZQPT09YyYmSD09PXYpe0k9Sy5uZWdhdGVkPXRydWU7disrO2NvbnRpbnVlfWlmKHUubm9wYXJlbiE9PXRydWUmJlA9PT1mKXtPPUsuaXNHbG9iPXRydWU7aWYoQz09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKFA9YWR2YW5jZSgpKSl7aWYoUD09PWYpe049Sy5iYWNrc2xhc2hlcz10cnVlO1A9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKFA9PT1oKXtHPXRydWU7YnJlYWt9fWNvbnRpbnVlfWJyZWFrfWlmKE89PT10cnVlKXtHPXRydWU7aWYoQz09PXRydWUpe2NvbnRpbnVlfWJyZWFrfX1pZih1Lm5vZXh0PT09dHJ1ZSl7az1mYWxzZTtPPWZhbHNlfWxldCBVPVM7bGV0IFg9XCJcIjtsZXQgRj1cIlwiO2lmKHY+MCl7WD1TLnNsaWNlKDAsdik7Uz1TLnNsaWNlKHYpO2QtPXZ9aWYoVSYmTz09PXRydWUmJmQ+MCl7VT1TLnNsaWNlKDAsZCk7Rj1TLnNsaWNlKGQpfWVsc2UgaWYoTz09PXRydWUpe1U9XCJcIjtGPVN9ZWxzZXtVPVN9aWYoVSYmVSE9PVwiXCImJlUhPT1cIi9cIiYmVSE9PVMpe2lmKGlzUGF0aFNlcGFyYXRvcihVLmNoYXJDb2RlQXQoVS5sZW5ndGgtMSkpKXtVPVUuc2xpY2UoMCwtMSl9fWlmKHUudW5lc2NhcGU9PT10cnVlKXtpZihGKUY9bi5yZW1vdmVCYWNrc2xhc2hlcyhGKTtpZihVJiZOPT09dHJ1ZSl7VT1uLnJlbW92ZUJhY2tzbGFzaGVzKFUpfX1jb25zdCBRPXtwcmVmaXg6WCxpbnB1dDp0LHN0YXJ0OnYsYmFzZTpVLGdsb2I6Rixpc0JyYWNlOkwsaXNCcmFja2V0OlQsaXNHbG9iOk8saXNFeHRnbG9iOmssaXNHbG9ic3RhcjptLG5lZ2F0ZWQ6SSxuZWdhdGVkRXh0Z2xvYjpCfTtpZih1LnRva2Vucz09PXRydWUpe1EubWF4RGVwdGg9MDtpZighaXNQYXRoU2VwYXJhdG9yKFApKXskLnB1c2goSyl9US50b2tlbnM9JH1pZih1LnBhcnRzPT09dHJ1ZXx8dS50b2tlbnM9PT10cnVlKXtsZXQgZTtmb3IobGV0IG49MDtuPHkubGVuZ3RoO24rKyl7Y29uc3Qgbz1lP2UrMTp2O2NvbnN0IHM9eVtuXTtjb25zdCByPXQuc2xpY2UobyxzKTtpZih1LnRva2Vucyl7aWYobj09PTAmJnYhPT0wKXskW25dLmlzUHJlZml4PXRydWU7JFtuXS52YWx1ZT1YfWVsc2V7JFtuXS52YWx1ZT1yfWRlcHRoKCRbbl0pO1EubWF4RGVwdGgrPSRbbl0uZGVwdGh9aWYobiE9PTB8fHIhPT1cIlwiKXt4LnB1c2gocil9ZT1zfWlmKGUmJmUrMTx0Lmxlbmd0aCl7Y29uc3Qgbj10LnNsaWNlKGUrMSk7eC5wdXNoKG4pO2lmKHUudG9rZW5zKXskWyQubGVuZ3RoLTFdLnZhbHVlPW47ZGVwdGgoJFskLmxlbmd0aC0xXSk7US5tYXhEZXB0aCs9JFskLmxlbmd0aC0xXS5kZXB0aH19US5zbGFzaGVzPXk7US5wYXJ0cz14fXJldHVybiBRfTt0LmV4cG9ydHM9c2Nhbn0sOTY6KHQsZSx1KT0+e2NvbnN0e1JFR0VYX0JBQ0tTTEFTSDpuLFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6byxSRUdFWF9TUEVDSUFMX0NIQVJTOnMsUkVHRVhfU1BFQ0lBTF9DSEFSU19HTE9CQUw6cn09dSgxNTQpO2UuaXNPYmplY3Q9dD0+dCE9PW51bGwmJnR5cGVvZiB0PT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkodCk7ZS5oYXNSZWdleENoYXJzPXQ9PnMudGVzdCh0KTtlLmlzUmVnZXhDaGFyPXQ9PnQubGVuZ3RoPT09MSYmZS5oYXNSZWdleENoYXJzKHQpO2UuZXNjYXBlUmVnZXg9dD0+dC5yZXBsYWNlKHIsXCJcXFxcJDFcIik7ZS50b1Bvc2l4U2xhc2hlcz10PT50LnJlcGxhY2UobixcIi9cIik7ZS5yZW1vdmVCYWNrc2xhc2hlcz10PT50LnJlcGxhY2UobywodD0+dD09PVwiXFxcXFwiP1wiXCI6dCkpO2UuZXNjYXBlTGFzdD0odCx1LG4pPT57Y29uc3Qgbz10Lmxhc3RJbmRleE9mKHUsbik7aWYobz09PS0xKXJldHVybiB0O2lmKHRbby0xXT09PVwiXFxcXFwiKXJldHVybiBlLmVzY2FwZUxhc3QodCx1LG8tMSk7cmV0dXJuYCR7dC5zbGljZSgwLG8pfVxcXFwke3Quc2xpY2Uobyl9YH07ZS5yZW1vdmVQcmVmaXg9KHQsZT17fSk9PntsZXQgdT10O2lmKHUuc3RhcnRzV2l0aChcIi4vXCIpKXt1PXUuc2xpY2UoMik7ZS5wcmVmaXg9XCIuL1wifXJldHVybiB1fTtlLndyYXBPdXRwdXQ9KHQsZT17fSx1PXt9KT0+e2NvbnN0IG49dS5jb250YWlucz9cIlwiOlwiXlwiO2NvbnN0IG89dS5jb250YWlucz9cIlwiOlwiJFwiO2xldCBzPWAke259KD86JHt0fSkke299YDtpZihlLm5lZ2F0ZWQ9PT10cnVlKXtzPWAoPzpeKD8hJHtzfSkuKiQpYH1yZXR1cm4gc307ZS5iYXNlbmFtZT0odCx7d2luZG93czplfT17fSk9Pntjb25zdCB1PXQuc3BsaXQoZT8vW1xcXFwvXS86XCIvXCIpO2NvbnN0IG49dVt1Lmxlbmd0aC0xXTtpZihuPT09XCJcIil7cmV0dXJuIHVbdS5sZW5ndGgtMl19cmV0dXJuIG59fX07dmFyIGU9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh1KXt2YXIgbj1lW3VdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIG89ZVt1XT17ZXhwb3J0czp7fX07dmFyIHM9dHJ1ZTt0cnl7dFt1XShvLG8uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtzPWZhbHNlfWZpbmFsbHl7aWYocylkZWxldGUgZVt1XX1yZXR1cm4gby5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdT1fX25jY3dwY2tfcmVxdWlyZV9fKDE3MCk7bW9kdWxlLmV4cG9ydHM9dX0pKCk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/picomatch/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsWUFBWSxPQUFPLGdCQUFnQixtQkFBbUIsTUFBTSxNQUFNLDRCQUE0QixtREFBbUQsK0JBQStCLHFEQUFxRCxZQUFZLElBQUksbUNBQW1DLGFBQWEsS0FBSyxvQkFBb0IsU0FBUyxtQkFBbUIsSUFBSSxxQ0FBcUMsZUFBZSxLQUFLLHVCQUF1QixTQUFTLHVCQUF1QixJQUFJLHVCQUF1QixtQkFBbUIsdUJBQXVCLDJDQUEyQyxhQUFhLHVCQUF1QixJQUFJLGNBQWMsU0FBUyxJQUFJLHdCQUF3QixTQUFTLDBCQUEwQiw0QkFBNEIscUJBQXFCLHVCQUF1QixnREFBZ0QsZUFBZSx1QkFBdUIsSUFBSSxZQUFZLFNBQVMsSUFBSSxzQkFBc0IsU0FBUyx3QkFBd0IsU0FBUyxZQUFZLE1BQU0sU0FBUywyQkFBMkIsV0FBVyxPQUFPLFFBQVEsYUFBYSxjQUFjLEtBQUssS0FBSyxhQUFhLGNBQWMsc0JBQXNCLE1BQU0sT0FBTyxrQ0FBa0MsT0FBTyxlQUFlLFNBQVMsSUFBSSxLQUFLLGFBQWEsTUFBTSxZQUFZLEtBQUssV0FBVyxPQUFPLFFBQVEsbUJBQW1CLHVCQUF1QixvQ0FBb0MsdUJBQXVCLFlBQVksbUJBQW1CLEtBQUsscUJBQXFCLHNCQUFzQixxQkFBcUIseUJBQXlCLG1CQUFtQixXQUFXLGFBQWEsOEJBQThCLGlDQUFpQyxrQkFBa0IsZUFBZSxTQUFTLFVBQVUsYUFBYSxjQUFjLGlCQUFpQixVQUFVLG1CQUFtQixZQUFZLFdBQVcsc0JBQXNCLDBCQUEwQixZQUFZLHVCQUF1QiwyQkFBMkIsd0JBQXdCLFVBQVUsc0JBQXNCLHFEQUFxRCxpQkFBaUIsV0FBVyxvQkFBb0IsbURBQW1ELG1CQUFtQixZQUFZLFNBQVMsZ0NBQWdDLFdBQVcsa0JBQWtCLGlCQUFpQixZQUFZLFlBQVksV0FBVyxJQUFJLHNDQUFzQyxRQUFRLFFBQVEsaUJBQWlCLGlCQUFpQixtRUFBbUUsU0FBUyxLQUFLLCtCQUErQixpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17MjI5OmZ1bmN0aW9uKGUpe3ZhciB0PWUuZXhwb3J0cz17fTt2YXIgcjt2YXIgbjtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXtpZih0eXBlb2Ygc2V0VGltZW91dD09PVwiZnVuY3Rpb25cIil7cj1zZXRUaW1lb3V0fWVsc2V7cj1kZWZhdWx0U2V0VGltb3V0fX1jYXRjaChlKXtyPWRlZmF1bHRTZXRUaW1vdXR9dHJ5e2lmKHR5cGVvZiBjbGVhclRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe249Y2xlYXJUaW1lb3V0fWVsc2V7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX1jYXRjaChlKXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fSkoKTtmdW5jdGlvbiBydW5UaW1lb3V0KGUpe2lmKHI9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChlLDApfWlmKChyPT09ZGVmYXVsdFNldFRpbW91dHx8IXIpJiZzZXRUaW1lb3V0KXtyPXNldFRpbWVvdXQ7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX10cnl7cmV0dXJuIHIoZSwwKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUsMCl9Y2F0Y2godCl7cmV0dXJuIHIuY2FsbCh0aGlzLGUsMCl9fX1mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQoZSl7aWYobj09PWNsZWFyVGltZW91dCl7cmV0dXJuIGNsZWFyVGltZW91dChlKX1pZigobj09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFuKSYmY2xlYXJUaW1lb3V0KXtuPWNsZWFyVGltZW91dDtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfXRyeXtyZXR1cm4gbihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlKX19fXZhciBpPVtdO3ZhciBvPWZhbHNlO3ZhciB1O3ZhciBhPS0xO2Z1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2lmKCFvfHwhdSl7cmV0dXJufW89ZmFsc2U7aWYodS5sZW5ndGgpe2k9dS5jb25jYXQoaSl9ZWxzZXthPS0xfWlmKGkubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihvKXtyZXR1cm59dmFyIGU9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO289dHJ1ZTt2YXIgdD1pLmxlbmd0aDt3aGlsZSh0KXt1PWk7aT1bXTt3aGlsZSgrK2E8dCl7aWYodSl7dVthXS5ydW4oKX19YT0tMTt0PWkubGVuZ3RofXU9bnVsbDtvPWZhbHNlO3J1bkNsZWFyVGltZW91dChlKX10Lm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dFtyLTFdPWFyZ3VtZW50c1tyXX19aS5wdXNoKG5ldyBJdGVtKGUsdCkpO2lmKGkubGVuZ3RoPT09MSYmIW8pe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGUsdCl7dGhpcy5mdW49ZTt0aGlzLmFycmF5PXR9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07dC50aXRsZT1cImJyb3dzZXJcIjt0LmJyb3dzZXI9dHJ1ZTt0LmVudj17fTt0LmFyZ3Y9W107dC52ZXJzaW9uPVwiXCI7dC52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXQub249bm9vcDt0LmFkZExpc3RlbmVyPW5vb3A7dC5vbmNlPW5vb3A7dC5vZmY9bm9vcDt0LnJlbW92ZUxpc3RlbmVyPW5vb3A7dC5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDt0LmVtaXQ9bm9vcDt0LnByZXBlbmRMaXN0ZW5lcj1ub29wO3QucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3QubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybltdfTt0LmJpbmRpbmc9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3QuY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDIyOSk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy9uZXh0L2hlYWQuanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n"));

/***/ }),

/***/ "./node_modules/next/image.js":
/*!************************************!*\
  !*** ./node_modules/next/image.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/image-external */ \"./node_modules/next/dist/shared/lib/image-external.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9pbWFnZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxSUFBNEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvbmV4dC9pbWFnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9zaGFyZWQvbGliL2ltYWdlLWV4dGVybmFsJylcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/image.js\n"));

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxpRUFBUTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFLGNBQWM7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBzYWZlLWJ1ZmZlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSlcblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/safe-buffer/index.js\n"));

/***/ }),

/***/ "./node_modules/satoshi-bitcoin/index.js":
/*!***********************************************!*\
  !*** ./node_modules/satoshi-bitcoin/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * @module satoshi-bitcoin\n */\n\nvar Big = __webpack_require__(/*! big.js */ \"./node_modules/big.js/big.js\");\n\n// @private\nvar conversion = 100000000;\n\n// es6 polyfill\nif (!Number.isInteger) {\n  Number.isInteger = function(num) {\n    return typeof num === 'number' && num % 1 === 0;\n  }\n}\n\n// @private\nfunction toNumber(notNum) {\n  return Number(notNum);\n}\n\nmodule.exports = {\n\n  /**\n   * Convert Satoshi to Bitcoin\n   * @param {number|string} satoshi Amount of Satoshi to convert. Must be a whole number\n   * @throws {TypeError} Thrown if input is not a number or string\n   * @throws {TypeError} Thrown if input is not a whole number or string format whole number\n   * @returns {number}\n   */\n  toBitcoin: function(satoshi) {\n    //validate arg\n    var satoshiType = typeof satoshi;\n    if (satoshiType === 'string') {\n      satoshi = toNumber(satoshi);\n      satoshiType = 'number';\n    }\n    if (satoshiType !== 'number'){\n      throw new TypeError('toBitcoin must be called on a number or string, got ' + satoshiType);\n    }\n    if (!Number.isInteger(satoshi)) {\n      throw new TypeError('toBitcoin must be called on a whole number or string format whole number');\n    }\n\n    var bigSatoshi = new Big(satoshi);\n    return Number(bigSatoshi.div(conversion));\n  },\n\n  /**\n   * Convert Bitcoin to Satoshi\n   * @param {number|string} bitcoin Amount of Bitcoin to convert\n   * @throws {TypeError} Thrown if input is not a number or string\n   * @returns {number}\n   */\n  toSatoshi: function(bitcoin) {\n    //validate arg\n    var bitcoinType = typeof bitcoin;\n    if (bitcoinType === 'string') {\n      bitcoin = toNumber(bitcoin);\n      bitcoinType = 'number';\n    }\n    if (bitcoinType !== 'number'){\n      throw new TypeError('toSatoshi must be called on a number or string, got ' + bitcoinType);\n    }\n\n    var bigBitcoin = new Big(bitcoin);\n    return Number(bigBitcoin.times(conversion));\n  }\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2F0b3NoaS1iaXRjb2luL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLG1CQUFPLENBQUMsNENBQVE7O0FBRTFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsV0FBVztBQUN6QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGNBQWMsV0FBVztBQUN6QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvc2F0b3NoaS1iaXRjb2luL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBzYXRvc2hpLWJpdGNvaW5cbiAqL1xuXG52YXIgQmlnID0gcmVxdWlyZSgnYmlnLmpzJyk7XG5cbi8vIEBwcml2YXRlXG52YXIgY29udmVyc2lvbiA9IDEwMDAwMDAwMDtcblxuLy8gZXM2IHBvbHlmaWxsXG5pZiAoIU51bWJlci5pc0ludGVnZXIpIHtcbiAgTnVtYmVyLmlzSW50ZWdlciA9IGZ1bmN0aW9uKG51bSkge1xuICAgIHJldHVybiB0eXBlb2YgbnVtID09PSAnbnVtYmVyJyAmJiBudW0gJSAxID09PSAwO1xuICB9XG59XG5cbi8vIEBwcml2YXRlXG5mdW5jdGlvbiB0b051bWJlcihub3ROdW0pIHtcbiAgcmV0dXJuIE51bWJlcihub3ROdW0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKipcbiAgICogQ29udmVydCBTYXRvc2hpIHRvIEJpdGNvaW5cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBzYXRvc2hpIEFtb3VudCBvZiBTYXRvc2hpIHRvIGNvbnZlcnQuIE11c3QgYmUgYSB3aG9sZSBudW1iZXJcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBUaHJvd24gaWYgaW5wdXQgaXMgbm90IGEgbnVtYmVyIG9yIHN0cmluZ1xuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IFRocm93biBpZiBpbnB1dCBpcyBub3QgYSB3aG9sZSBudW1iZXIgb3Igc3RyaW5nIGZvcm1hdCB3aG9sZSBudW1iZXJcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHRvQml0Y29pbjogZnVuY3Rpb24oc2F0b3NoaSkge1xuICAgIC8vdmFsaWRhdGUgYXJnXG4gICAgdmFyIHNhdG9zaGlUeXBlID0gdHlwZW9mIHNhdG9zaGk7XG4gICAgaWYgKHNhdG9zaGlUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgc2F0b3NoaSA9IHRvTnVtYmVyKHNhdG9zaGkpO1xuICAgICAgc2F0b3NoaVR5cGUgPSAnbnVtYmVyJztcbiAgICB9XG4gICAgaWYgKHNhdG9zaGlUeXBlICE9PSAnbnVtYmVyJyl7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0b0JpdGNvaW4gbXVzdCBiZSBjYWxsZWQgb24gYSBudW1iZXIgb3Igc3RyaW5nLCBnb3QgJyArIHNhdG9zaGlUeXBlKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNhdG9zaGkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0b0JpdGNvaW4gbXVzdCBiZSBjYWxsZWQgb24gYSB3aG9sZSBudW1iZXIgb3Igc3RyaW5nIGZvcm1hdCB3aG9sZSBudW1iZXInKTtcbiAgICB9XG5cbiAgICB2YXIgYmlnU2F0b3NoaSA9IG5ldyBCaWcoc2F0b3NoaSk7XG4gICAgcmV0dXJuIE51bWJlcihiaWdTYXRvc2hpLmRpdihjb252ZXJzaW9uKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgQml0Y29pbiB0byBTYXRvc2hpXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gYml0Y29pbiBBbW91bnQgb2YgQml0Y29pbiB0byBjb252ZXJ0XG4gICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gVGhyb3duIGlmIGlucHV0IGlzIG5vdCBhIG51bWJlciBvciBzdHJpbmdcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHRvU2F0b3NoaTogZnVuY3Rpb24oYml0Y29pbikge1xuICAgIC8vdmFsaWRhdGUgYXJnXG4gICAgdmFyIGJpdGNvaW5UeXBlID0gdHlwZW9mIGJpdGNvaW47XG4gICAgaWYgKGJpdGNvaW5UeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgYml0Y29pbiA9IHRvTnVtYmVyKGJpdGNvaW4pO1xuICAgICAgYml0Y29pblR5cGUgPSAnbnVtYmVyJztcbiAgICB9XG4gICAgaWYgKGJpdGNvaW5UeXBlICE9PSAnbnVtYmVyJyl7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0b1NhdG9zaGkgbXVzdCBiZSBjYWxsZWQgb24gYSBudW1iZXIgb3Igc3RyaW5nLCBnb3QgJyArIGJpdGNvaW5UeXBlKTtcbiAgICB9XG5cbiAgICB2YXIgYmlnQml0Y29pbiA9IG5ldyBCaWcoYml0Y29pbik7XG4gICAgcmV0dXJuIE51bWJlcihiaWdCaXRjb2luLnRpbWVzKGNvbnZlcnNpb24pKTtcbiAgfVxuXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/satoshi-bitcoin/index.js\n"));

/***/ }),

/***/ "./node_modules/typeforce/errors.js":
/*!******************************************!*\
  !*** ./node_modules/typeforce/errors.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var native = __webpack_require__(/*! ./native */ \"./node_modules/typeforce/native.js\")\n\nfunction getTypeName (fn) {\n  return fn.name || fn.toString().match(/function (.*?)\\s*\\(/)[1]\n}\n\nfunction getValueTypeName (value) {\n  return native.Nil(value) ? '' : getTypeName(value.constructor)\n}\n\nfunction getValue (value) {\n  if (native.Function(value)) return ''\n  if (native.String(value)) return JSON.stringify(value)\n  if (value && native.Object(value)) return ''\n  return value\n}\n\nfunction captureStackTrace (e, t) {\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(e, t)\n  }\n}\n\nfunction tfJSON (type) {\n  if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)\n  if (native.Array(type)) return 'Array'\n  if (type && native.Object(type)) return 'Object'\n\n  return type !== undefined ? type : ''\n}\n\nfunction tfErrorString (type, value, valueTypeName) {\n  var valueJson = getValue(value)\n\n  return 'Expected ' + tfJSON(type) + ', got' +\n    (valueTypeName !== '' ? ' ' + valueTypeName : '') +\n    (valueJson !== '' ? ' ' + valueJson : '')\n}\n\nfunction TfTypeError (type, value, valueTypeName) {\n  valueTypeName = valueTypeName || getValueTypeName(value)\n  this.message = tfErrorString(type, value, valueTypeName)\n\n  captureStackTrace(this, TfTypeError)\n  this.__type = type\n  this.__value = value\n  this.__valueTypeName = valueTypeName\n}\n\nTfTypeError.prototype = Object.create(Error.prototype)\nTfTypeError.prototype.constructor = TfTypeError\n\nfunction tfPropertyErrorString (type, label, name, value, valueTypeName) {\n  var description = '\" of type '\n  if (label === 'key') description = '\" with key type '\n\n  return tfErrorString('property \"' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)\n}\n\nfunction TfPropertyTypeError (type, property, label, value, valueTypeName) {\n  if (type) {\n    valueTypeName = valueTypeName || getValueTypeName(value)\n    this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)\n  } else {\n    this.message = 'Unexpected property \"' + property + '\"'\n  }\n\n  captureStackTrace(this, TfTypeError)\n  this.__label = label\n  this.__property = property\n  this.__type = type\n  this.__value = value\n  this.__valueTypeName = valueTypeName\n}\n\nTfPropertyTypeError.prototype = Object.create(Error.prototype)\nTfPropertyTypeError.prototype.constructor = TfTypeError\n\nfunction tfCustomError (expected, actual) {\n  return new TfTypeError(expected, {}, actual)\n}\n\nfunction tfSubError (e, property, label) {\n  // sub child?\n  if (e instanceof TfPropertyTypeError) {\n    property = property + '.' + e.__property\n\n    e = new TfPropertyTypeError(\n      e.__type, property, e.__label, e.__value, e.__valueTypeName\n    )\n\n  // child?\n  } else if (e instanceof TfTypeError) {\n    e = new TfPropertyTypeError(\n      e.__type, property, label, e.__value, e.__valueTypeName\n    )\n  }\n\n  captureStackTrace(e)\n  return e\n}\n\nmodule.exports = {\n  TfTypeError: TfTypeError,\n  TfPropertyTypeError: TfPropertyTypeError,\n  tfCustomError: tfCustomError,\n  tfSubError: tfSubError,\n  tfJSON: tfJSON,\n  getValueTypeName: getValueTypeName\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHlwZWZvcmNlL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsb0RBQVU7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy90eXBlZm9yY2UvZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBuYXRpdmUgPSByZXF1aXJlKCcuL25hdGl2ZScpXG5cbmZ1bmN0aW9uIGdldFR5cGVOYW1lIChmbikge1xuICByZXR1cm4gZm4ubmFtZSB8fCBmbi50b1N0cmluZygpLm1hdGNoKC9mdW5jdGlvbiAoLio/KVxccypcXCgvKVsxXVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZVR5cGVOYW1lICh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlLk5pbCh2YWx1ZSkgPyAnJyA6IGdldFR5cGVOYW1lKHZhbHVlLmNvbnN0cnVjdG9yKVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAodmFsdWUpIHtcbiAgaWYgKG5hdGl2ZS5GdW5jdGlvbih2YWx1ZSkpIHJldHVybiAnJ1xuICBpZiAobmF0aXZlLlN0cmluZyh2YWx1ZSkpIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcbiAgaWYgKHZhbHVlICYmIG5hdGl2ZS5PYmplY3QodmFsdWUpKSByZXR1cm4gJydcbiAgcmV0dXJuIHZhbHVlXG59XG5cbmZ1bmN0aW9uIGNhcHR1cmVTdGFja1RyYWNlIChlLCB0KSB7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGUsIHQpXG4gIH1cbn1cblxuZnVuY3Rpb24gdGZKU09OICh0eXBlKSB7XG4gIGlmIChuYXRpdmUuRnVuY3Rpb24odHlwZSkpIHJldHVybiB0eXBlLnRvSlNPTiA/IHR5cGUudG9KU09OKCkgOiBnZXRUeXBlTmFtZSh0eXBlKVxuICBpZiAobmF0aXZlLkFycmF5KHR5cGUpKSByZXR1cm4gJ0FycmF5J1xuICBpZiAodHlwZSAmJiBuYXRpdmUuT2JqZWN0KHR5cGUpKSByZXR1cm4gJ09iamVjdCdcblxuICByZXR1cm4gdHlwZSAhPT0gdW5kZWZpbmVkID8gdHlwZSA6ICcnXG59XG5cbmZ1bmN0aW9uIHRmRXJyb3JTdHJpbmcgKHR5cGUsIHZhbHVlLCB2YWx1ZVR5cGVOYW1lKSB7XG4gIHZhciB2YWx1ZUpzb24gPSBnZXRWYWx1ZSh2YWx1ZSlcblxuICByZXR1cm4gJ0V4cGVjdGVkICcgKyB0ZkpTT04odHlwZSkgKyAnLCBnb3QnICtcbiAgICAodmFsdWVUeXBlTmFtZSAhPT0gJycgPyAnICcgKyB2YWx1ZVR5cGVOYW1lIDogJycpICtcbiAgICAodmFsdWVKc29uICE9PSAnJyA/ICcgJyArIHZhbHVlSnNvbiA6ICcnKVxufVxuXG5mdW5jdGlvbiBUZlR5cGVFcnJvciAodHlwZSwgdmFsdWUsIHZhbHVlVHlwZU5hbWUpIHtcbiAgdmFsdWVUeXBlTmFtZSA9IHZhbHVlVHlwZU5hbWUgfHwgZ2V0VmFsdWVUeXBlTmFtZSh2YWx1ZSlcbiAgdGhpcy5tZXNzYWdlID0gdGZFcnJvclN0cmluZyh0eXBlLCB2YWx1ZSwgdmFsdWVUeXBlTmFtZSlcblxuICBjYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBUZlR5cGVFcnJvcilcbiAgdGhpcy5fX3R5cGUgPSB0eXBlXG4gIHRoaXMuX192YWx1ZSA9IHZhbHVlXG4gIHRoaXMuX192YWx1ZVR5cGVOYW1lID0gdmFsdWVUeXBlTmFtZVxufVxuXG5UZlR5cGVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSlcblRmVHlwZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRmVHlwZUVycm9yXG5cbmZ1bmN0aW9uIHRmUHJvcGVydHlFcnJvclN0cmluZyAodHlwZSwgbGFiZWwsIG5hbWUsIHZhbHVlLCB2YWx1ZVR5cGVOYW1lKSB7XG4gIHZhciBkZXNjcmlwdGlvbiA9ICdcIiBvZiB0eXBlICdcbiAgaWYgKGxhYmVsID09PSAna2V5JykgZGVzY3JpcHRpb24gPSAnXCIgd2l0aCBrZXkgdHlwZSAnXG5cbiAgcmV0dXJuIHRmRXJyb3JTdHJpbmcoJ3Byb3BlcnR5IFwiJyArIHRmSlNPTihuYW1lKSArIGRlc2NyaXB0aW9uICsgdGZKU09OKHR5cGUpLCB2YWx1ZSwgdmFsdWVUeXBlTmFtZSlcbn1cblxuZnVuY3Rpb24gVGZQcm9wZXJ0eVR5cGVFcnJvciAodHlwZSwgcHJvcGVydHksIGxhYmVsLCB2YWx1ZSwgdmFsdWVUeXBlTmFtZSkge1xuICBpZiAodHlwZSkge1xuICAgIHZhbHVlVHlwZU5hbWUgPSB2YWx1ZVR5cGVOYW1lIHx8IGdldFZhbHVlVHlwZU5hbWUodmFsdWUpXG4gICAgdGhpcy5tZXNzYWdlID0gdGZQcm9wZXJ0eUVycm9yU3RyaW5nKHR5cGUsIGxhYmVsLCBwcm9wZXJ0eSwgdmFsdWUsIHZhbHVlVHlwZU5hbWUpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5tZXNzYWdlID0gJ1VuZXhwZWN0ZWQgcHJvcGVydHkgXCInICsgcHJvcGVydHkgKyAnXCInXG4gIH1cblxuICBjYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBUZlR5cGVFcnJvcilcbiAgdGhpcy5fX2xhYmVsID0gbGFiZWxcbiAgdGhpcy5fX3Byb3BlcnR5ID0gcHJvcGVydHlcbiAgdGhpcy5fX3R5cGUgPSB0eXBlXG4gIHRoaXMuX192YWx1ZSA9IHZhbHVlXG4gIHRoaXMuX192YWx1ZVR5cGVOYW1lID0gdmFsdWVUeXBlTmFtZVxufVxuXG5UZlByb3BlcnR5VHlwZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxuVGZQcm9wZXJ0eVR5cGVFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZlR5cGVFcnJvclxuXG5mdW5jdGlvbiB0ZkN1c3RvbUVycm9yIChleHBlY3RlZCwgYWN0dWFsKSB7XG4gIHJldHVybiBuZXcgVGZUeXBlRXJyb3IoZXhwZWN0ZWQsIHt9LCBhY3R1YWwpXG59XG5cbmZ1bmN0aW9uIHRmU3ViRXJyb3IgKGUsIHByb3BlcnR5LCBsYWJlbCkge1xuICAvLyBzdWIgY2hpbGQ/XG4gIGlmIChlIGluc3RhbmNlb2YgVGZQcm9wZXJ0eVR5cGVFcnJvcikge1xuICAgIHByb3BlcnR5ID0gcHJvcGVydHkgKyAnLicgKyBlLl9fcHJvcGVydHlcblxuICAgIGUgPSBuZXcgVGZQcm9wZXJ0eVR5cGVFcnJvcihcbiAgICAgIGUuX190eXBlLCBwcm9wZXJ0eSwgZS5fX2xhYmVsLCBlLl9fdmFsdWUsIGUuX192YWx1ZVR5cGVOYW1lXG4gICAgKVxuXG4gIC8vIGNoaWxkP1xuICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBUZlR5cGVFcnJvcikge1xuICAgIGUgPSBuZXcgVGZQcm9wZXJ0eVR5cGVFcnJvcihcbiAgICAgIGUuX190eXBlLCBwcm9wZXJ0eSwgbGFiZWwsIGUuX192YWx1ZSwgZS5fX3ZhbHVlVHlwZU5hbWVcbiAgICApXG4gIH1cblxuICBjYXB0dXJlU3RhY2tUcmFjZShlKVxuICByZXR1cm4gZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVGZUeXBlRXJyb3I6IFRmVHlwZUVycm9yLFxuICBUZlByb3BlcnR5VHlwZUVycm9yOiBUZlByb3BlcnR5VHlwZUVycm9yLFxuICB0ZkN1c3RvbUVycm9yOiB0ZkN1c3RvbUVycm9yLFxuICB0ZlN1YkVycm9yOiB0ZlN1YkVycm9yLFxuICB0ZkpTT046IHRmSlNPTixcbiAgZ2V0VmFsdWVUeXBlTmFtZTogZ2V0VmFsdWVUeXBlTmFtZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/typeforce/errors.js\n"));

/***/ }),

/***/ "./node_modules/typeforce/extra.js":
/*!*****************************************!*\
  !*** ./node_modules/typeforce/extra.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\nvar NATIVE = __webpack_require__(/*! ./native */ \"./node_modules/typeforce/native.js\")\nvar ERRORS = __webpack_require__(/*! ./errors */ \"./node_modules/typeforce/errors.js\")\n\nfunction _Buffer (value) {\n  return Buffer.isBuffer(value)\n}\n\nfunction Hex (value) {\n  return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)\n}\n\nfunction _LengthN (type, length) {\n  var name = type.toJSON()\n\n  function Length (value) {\n    if (!type(value)) return false\n    if (value.length === length) return true\n\n    throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')\n  }\n  Length.toJSON = function () { return name }\n\n  return Length\n}\n\nvar _ArrayN = _LengthN.bind(null, NATIVE.Array)\nvar _BufferN = _LengthN.bind(null, _Buffer)\nvar _HexN = _LengthN.bind(null, Hex)\nvar _StringN = _LengthN.bind(null, NATIVE.String)\n\nfunction Range (a, b, f) {\n  f = f || NATIVE.Number\n  function _range (value, strict) {\n    return f(value, strict) && (value > a) && (value < b)\n  }\n  _range.toJSON = function () {\n    return `${f.toJSON()} between [${a}, ${b}]`\n  }\n  return _range\n}\n\nvar INT53_MAX = Math.pow(2, 53) - 1\n\nfunction Finite (value) {\n  return typeof value === 'number' && isFinite(value)\n}\nfunction Int8 (value) { return ((value << 24) >> 24) === value }\nfunction Int16 (value) { return ((value << 16) >> 16) === value }\nfunction Int32 (value) { return (value | 0) === value }\nfunction Int53 (value) {\n  return typeof value === 'number' &&\n    value >= -INT53_MAX &&\n    value <= INT53_MAX &&\n    Math.floor(value) === value\n}\nfunction UInt8 (value) { return (value & 0xff) === value }\nfunction UInt16 (value) { return (value & 0xffff) === value }\nfunction UInt32 (value) { return (value >>> 0) === value }\nfunction UInt53 (value) {\n  return typeof value === 'number' &&\n    value >= 0 &&\n    value <= INT53_MAX &&\n    Math.floor(value) === value\n}\n\nvar types = {\n  ArrayN: _ArrayN,\n  Buffer: _Buffer,\n  BufferN: _BufferN,\n  Finite: Finite,\n  Hex: Hex,\n  HexN: _HexN,\n  Int8: Int8,\n  Int16: Int16,\n  Int32: Int32,\n  Int53: Int53,\n  Range: Range,\n  StringN: _StringN,\n  UInt8: UInt8,\n  UInt16: UInt16,\n  UInt32: UInt32,\n  UInt53: UInt53\n}\n\nfor (var typeName in types) {\n  types[typeName].toJSON = function (t) {\n    return t\n  }.bind(null, typeName)\n}\n\nmodule.exports = types\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHlwZWZvcmNlL2V4dHJhLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxhQUFhLG1CQUFPLENBQUMsb0RBQVU7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLG9EQUFVOztBQUUvQjtBQUNBLFNBQVMsTUFBTTtBQUNmOztBQUVBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVksV0FBVyxFQUFFLElBQUksRUFBRTtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvdHlwZWZvcmNlL2V4dHJhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBOQVRJVkUgPSByZXF1aXJlKCcuL25hdGl2ZScpXG52YXIgRVJST1JTID0gcmVxdWlyZSgnLi9lcnJvcnMnKVxuXG5mdW5jdGlvbiBfQnVmZmVyICh2YWx1ZSkge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHZhbHVlKVxufVxuXG5mdW5jdGlvbiBIZXggKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIC9eKFswLTlhLWZdezJ9KSskL2kudGVzdCh2YWx1ZSlcbn1cblxuZnVuY3Rpb24gX0xlbmd0aE4gKHR5cGUsIGxlbmd0aCkge1xuICB2YXIgbmFtZSA9IHR5cGUudG9KU09OKClcblxuICBmdW5jdGlvbiBMZW5ndGggKHZhbHVlKSB7XG4gICAgaWYgKCF0eXBlKHZhbHVlKSkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gbGVuZ3RoKSByZXR1cm4gdHJ1ZVxuXG4gICAgdGhyb3cgRVJST1JTLnRmQ3VzdG9tRXJyb3IobmFtZSArICcoTGVuZ3RoOiAnICsgbGVuZ3RoICsgJyknLCBuYW1lICsgJyhMZW5ndGg6ICcgKyB2YWx1ZS5sZW5ndGggKyAnKScpXG4gIH1cbiAgTGVuZ3RoLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hbWUgfVxuXG4gIHJldHVybiBMZW5ndGhcbn1cblxudmFyIF9BcnJheU4gPSBfTGVuZ3RoTi5iaW5kKG51bGwsIE5BVElWRS5BcnJheSlcbnZhciBfQnVmZmVyTiA9IF9MZW5ndGhOLmJpbmQobnVsbCwgX0J1ZmZlcilcbnZhciBfSGV4TiA9IF9MZW5ndGhOLmJpbmQobnVsbCwgSGV4KVxudmFyIF9TdHJpbmdOID0gX0xlbmd0aE4uYmluZChudWxsLCBOQVRJVkUuU3RyaW5nKVxuXG5mdW5jdGlvbiBSYW5nZSAoYSwgYiwgZikge1xuICBmID0gZiB8fCBOQVRJVkUuTnVtYmVyXG4gIGZ1bmN0aW9uIF9yYW5nZSAodmFsdWUsIHN0cmljdCkge1xuICAgIHJldHVybiBmKHZhbHVlLCBzdHJpY3QpICYmICh2YWx1ZSA+IGEpICYmICh2YWx1ZSA8IGIpXG4gIH1cbiAgX3JhbmdlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYCR7Zi50b0pTT04oKX0gYmV0d2VlbiBbJHthfSwgJHtifV1gXG4gIH1cbiAgcmV0dXJuIF9yYW5nZVxufVxuXG52YXIgSU5UNTNfTUFYID0gTWF0aC5wb3coMiwgNTMpIC0gMVxuXG5mdW5jdGlvbiBGaW5pdGUgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbHVlKVxufVxuZnVuY3Rpb24gSW50OCAodmFsdWUpIHsgcmV0dXJuICgodmFsdWUgPDwgMjQpID4+IDI0KSA9PT0gdmFsdWUgfVxuZnVuY3Rpb24gSW50MTYgKHZhbHVlKSB7IHJldHVybiAoKHZhbHVlIDw8IDE2KSA+PiAxNikgPT09IHZhbHVlIH1cbmZ1bmN0aW9uIEludDMyICh2YWx1ZSkgeyByZXR1cm4gKHZhbHVlIHwgMCkgPT09IHZhbHVlIH1cbmZ1bmN0aW9uIEludDUzICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID49IC1JTlQ1M19NQVggJiZcbiAgICB2YWx1ZSA8PSBJTlQ1M19NQVggJiZcbiAgICBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWVcbn1cbmZ1bmN0aW9uIFVJbnQ4ICh2YWx1ZSkgeyByZXR1cm4gKHZhbHVlICYgMHhmZikgPT09IHZhbHVlIH1cbmZ1bmN0aW9uIFVJbnQxNiAodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSAmIDB4ZmZmZikgPT09IHZhbHVlIH1cbmZ1bmN0aW9uIFVJbnQzMiAodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSA+Pj4gMCkgPT09IHZhbHVlIH1cbmZ1bmN0aW9uIFVJbnQ1MyAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+PSAwICYmXG4gICAgdmFsdWUgPD0gSU5UNTNfTUFYICYmXG4gICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlXG59XG5cbnZhciB0eXBlcyA9IHtcbiAgQXJyYXlOOiBfQXJyYXlOLFxuICBCdWZmZXI6IF9CdWZmZXIsXG4gIEJ1ZmZlck46IF9CdWZmZXJOLFxuICBGaW5pdGU6IEZpbml0ZSxcbiAgSGV4OiBIZXgsXG4gIEhleE46IF9IZXhOLFxuICBJbnQ4OiBJbnQ4LFxuICBJbnQxNjogSW50MTYsXG4gIEludDMyOiBJbnQzMixcbiAgSW50NTM6IEludDUzLFxuICBSYW5nZTogUmFuZ2UsXG4gIFN0cmluZ046IF9TdHJpbmdOLFxuICBVSW50ODogVUludDgsXG4gIFVJbnQxNjogVUludDE2LFxuICBVSW50MzI6IFVJbnQzMixcbiAgVUludDUzOiBVSW50NTNcbn1cblxuZm9yICh2YXIgdHlwZU5hbWUgaW4gdHlwZXMpIHtcbiAgdHlwZXNbdHlwZU5hbWVdLnRvSlNPTiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHRcbiAgfS5iaW5kKG51bGwsIHR5cGVOYW1lKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVzXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/typeforce/extra.js\n"));

/***/ }),

/***/ "./node_modules/typeforce/index.js":
/*!*****************************************!*\
  !*** ./node_modules/typeforce/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var ERRORS = __webpack_require__(/*! ./errors */ \"./node_modules/typeforce/errors.js\")\nvar NATIVE = __webpack_require__(/*! ./native */ \"./node_modules/typeforce/native.js\")\n\n// short-hand\nvar tfJSON = ERRORS.tfJSON\nvar TfTypeError = ERRORS.TfTypeError\nvar TfPropertyTypeError = ERRORS.TfPropertyTypeError\nvar tfSubError = ERRORS.tfSubError\nvar getValueTypeName = ERRORS.getValueTypeName\n\nvar TYPES = {\n  arrayOf: function arrayOf (type, options) {\n    type = compile(type)\n    options = options || {}\n\n    function _arrayOf (array, strict) {\n      if (!NATIVE.Array(array)) return false\n      if (NATIVE.Nil(array)) return false\n      if (options.minLength !== undefined && array.length < options.minLength) return false\n      if (options.maxLength !== undefined && array.length > options.maxLength) return false\n      if (options.length !== undefined && array.length !== options.length) return false\n\n      return array.every(function (value, i) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          throw tfSubError(e, i)\n        }\n      })\n    }\n    _arrayOf.toJSON = function () {\n      var str = '[' + tfJSON(type) + ']'\n      if (options.length !== undefined) {\n        str += '{' + options.length + '}'\n      } else if (options.minLength !== undefined || options.maxLength !== undefined) {\n        str += '{' +\n          (options.minLength === undefined ? 0 : options.minLength) + ',' +\n          (options.maxLength === undefined ? Infinity : options.maxLength) + '}'\n      }\n      return str\n    }\n\n    return _arrayOf\n  },\n\n  maybe: function maybe (type) {\n    type = compile(type)\n\n    function _maybe (value, strict) {\n      return NATIVE.Nil(value) || type(value, strict, maybe)\n    }\n    _maybe.toJSON = function () { return '?' + tfJSON(type) }\n\n    return _maybe\n  },\n\n  map: function map (propertyType, propertyKeyType) {\n    propertyType = compile(propertyType)\n    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)\n\n    function _map (value, strict) {\n      if (!NATIVE.Object(value)) return false\n      if (NATIVE.Nil(value)) return false\n\n      for (var propertyName in value) {\n        try {\n          if (propertyKeyType) {\n            typeforce(propertyKeyType, propertyName, strict)\n          }\n        } catch (e) {\n          throw tfSubError(e, propertyName, 'key')\n        }\n\n        try {\n          var propertyValue = value[propertyName]\n          typeforce(propertyType, propertyValue, strict)\n        } catch (e) {\n          throw tfSubError(e, propertyName)\n        }\n      }\n\n      return true\n    }\n\n    if (propertyKeyType) {\n      _map.toJSON = function () {\n        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'\n      }\n    } else {\n      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }\n    }\n\n    return _map\n  },\n\n  object: function object (uncompiled) {\n    var type = {}\n\n    for (var typePropertyName in uncompiled) {\n      type[typePropertyName] = compile(uncompiled[typePropertyName])\n    }\n\n    function _object (value, strict) {\n      if (!NATIVE.Object(value)) return false\n      if (NATIVE.Nil(value)) return false\n\n      var propertyName\n\n      try {\n        for (propertyName in type) {\n          var propertyType = type[propertyName]\n          var propertyValue = value[propertyName]\n\n          typeforce(propertyType, propertyValue, strict)\n        }\n      } catch (e) {\n        throw tfSubError(e, propertyName)\n      }\n\n      if (strict) {\n        for (propertyName in value) {\n          if (type[propertyName]) continue\n\n          throw new TfPropertyTypeError(undefined, propertyName)\n        }\n      }\n\n      return true\n    }\n    _object.toJSON = function () { return tfJSON(type) }\n\n    return _object\n  },\n\n  anyOf: function anyOf () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _anyOf (value, strict) {\n      return types.some(function (type) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          return false\n        }\n      })\n    }\n    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }\n\n    return _anyOf\n  },\n\n  allOf: function allOf () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _allOf (value, strict) {\n      return types.every(function (type) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          return false\n        }\n      })\n    }\n    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }\n\n    return _allOf\n  },\n\n  quacksLike: function quacksLike (type) {\n    function _quacksLike (value) {\n      return type === getValueTypeName(value)\n    }\n    _quacksLike.toJSON = function () { return type }\n\n    return _quacksLike\n  },\n\n  tuple: function tuple () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _tuple (values, strict) {\n      if (NATIVE.Nil(values)) return false\n      if (NATIVE.Nil(values.length)) return false\n      if (strict && (values.length !== types.length)) return false\n\n      return types.every(function (type, i) {\n        try {\n          return typeforce(type, values[i], strict)\n        } catch (e) {\n          throw tfSubError(e, i)\n        }\n      })\n    }\n    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }\n\n    return _tuple\n  },\n\n  value: function value (expected) {\n    function _value (actual) {\n      return actual === expected\n    }\n    _value.toJSON = function () { return expected }\n\n    return _value\n  }\n}\n\n// TODO: deprecate\nTYPES.oneOf = TYPES.anyOf\n\nfunction compile (type) {\n  if (NATIVE.String(type)) {\n    if (type[0] === '?') return TYPES.maybe(type.slice(1))\n\n    return NATIVE[type] || TYPES.quacksLike(type)\n  } else if (type && NATIVE.Object(type)) {\n    if (NATIVE.Array(type)) {\n      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')\n      return TYPES.arrayOf(type[0])\n    }\n\n    return TYPES.object(type)\n  } else if (NATIVE.Function(type)) {\n    return type\n  }\n\n  return TYPES.value(type)\n}\n\nfunction typeforce (type, value, strict, surrogate) {\n  if (NATIVE.Function(type)) {\n    if (type(value, strict)) return true\n\n    throw new TfTypeError(surrogate || type, value)\n  }\n\n  // JIT\n  return typeforce(compile(type), value, strict)\n}\n\n// assign types to typeforce function\nfor (var typeName in NATIVE) {\n  typeforce[typeName] = NATIVE[typeName]\n}\n\nfor (typeName in TYPES) {\n  typeforce[typeName] = TYPES[typeName]\n}\n\nvar EXTRA = __webpack_require__(/*! ./extra */ \"./node_modules/typeforce/extra.js\")\nfor (typeName in EXTRA) {\n  typeforce[typeName] = EXTRA[typeName]\n}\n\ntypeforce.compile = compile\ntypeforce.TfTypeError = TfTypeError\ntypeforce.TfPropertyTypeError = TfPropertyTypeError\n\nmodule.exports = typeforce\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHlwZWZvcmNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxvREFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsb0RBQVU7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDLFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLDhEQUE4RDtBQUMvRTtBQUNBLE1BQU07QUFDTixrQ0FBa0MsU0FBUyw2QkFBNkI7QUFDeEU7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsa0RBQVM7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3FpYW94aWFvcnVpL2dpdGh1Yi91bmlmcmEvbXlkb2dlL215ZG9nZW1hc2stbmV4dC1leGFtcGxlL25vZGVfbW9kdWxlcy90eXBlZm9yY2UvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEVSUk9SUyA9IHJlcXVpcmUoJy4vZXJyb3JzJylcbnZhciBOQVRJVkUgPSByZXF1aXJlKCcuL25hdGl2ZScpXG5cbi8vIHNob3J0LWhhbmRcbnZhciB0ZkpTT04gPSBFUlJPUlMudGZKU09OXG52YXIgVGZUeXBlRXJyb3IgPSBFUlJPUlMuVGZUeXBlRXJyb3JcbnZhciBUZlByb3BlcnR5VHlwZUVycm9yID0gRVJST1JTLlRmUHJvcGVydHlUeXBlRXJyb3JcbnZhciB0ZlN1YkVycm9yID0gRVJST1JTLnRmU3ViRXJyb3JcbnZhciBnZXRWYWx1ZVR5cGVOYW1lID0gRVJST1JTLmdldFZhbHVlVHlwZU5hbWVcblxudmFyIFRZUEVTID0ge1xuICBhcnJheU9mOiBmdW5jdGlvbiBhcnJheU9mICh0eXBlLCBvcHRpb25zKSB7XG4gICAgdHlwZSA9IGNvbXBpbGUodHlwZSlcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgZnVuY3Rpb24gX2FycmF5T2YgKGFycmF5LCBzdHJpY3QpIHtcbiAgICAgIGlmICghTkFUSVZFLkFycmF5KGFycmF5KSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoTkFUSVZFLk5pbChhcnJheSkpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKG9wdGlvbnMubWluTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgYXJyYXkubGVuZ3RoIDwgb3B0aW9ucy5taW5MZW5ndGgpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKG9wdGlvbnMubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgYXJyYXkubGVuZ3RoID4gb3B0aW9ucy5tYXhMZW5ndGgpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgYXJyYXkubGVuZ3RoICE9PSBvcHRpb25zLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG5cbiAgICAgIHJldHVybiBhcnJheS5ldmVyeShmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdHlwZWZvcmNlKHR5cGUsIHZhbHVlLCBzdHJpY3QpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyB0ZlN1YkVycm9yKGUsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIF9hcnJheU9mLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdHIgPSAnWycgKyB0ZkpTT04odHlwZSkgKyAnXSdcbiAgICAgIGlmIChvcHRpb25zLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0ciArPSAneycgKyBvcHRpb25zLmxlbmd0aCArICd9J1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RyICs9ICd7JyArXG4gICAgICAgICAgKG9wdGlvbnMubWluTGVuZ3RoID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5taW5MZW5ndGgpICsgJywnICtcbiAgICAgICAgICAob3B0aW9ucy5tYXhMZW5ndGggPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogb3B0aW9ucy5tYXhMZW5ndGgpICsgJ30nXG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyXG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnJheU9mXG4gIH0sXG5cbiAgbWF5YmU6IGZ1bmN0aW9uIG1heWJlICh0eXBlKSB7XG4gICAgdHlwZSA9IGNvbXBpbGUodHlwZSlcblxuICAgIGZ1bmN0aW9uIF9tYXliZSAodmFsdWUsIHN0cmljdCkge1xuICAgICAgcmV0dXJuIE5BVElWRS5OaWwodmFsdWUpIHx8IHR5cGUodmFsdWUsIHN0cmljdCwgbWF5YmUpXG4gICAgfVxuICAgIF9tYXliZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPycgKyB0ZkpTT04odHlwZSkgfVxuXG4gICAgcmV0dXJuIF9tYXliZVxuICB9LFxuXG4gIG1hcDogZnVuY3Rpb24gbWFwIChwcm9wZXJ0eVR5cGUsIHByb3BlcnR5S2V5VHlwZSkge1xuICAgIHByb3BlcnR5VHlwZSA9IGNvbXBpbGUocHJvcGVydHlUeXBlKVxuICAgIGlmIChwcm9wZXJ0eUtleVR5cGUpIHByb3BlcnR5S2V5VHlwZSA9IGNvbXBpbGUocHJvcGVydHlLZXlUeXBlKVxuXG4gICAgZnVuY3Rpb24gX21hcCAodmFsdWUsIHN0cmljdCkge1xuICAgICAgaWYgKCFOQVRJVkUuT2JqZWN0KHZhbHVlKSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoTkFUSVZFLk5pbCh2YWx1ZSkpIHJldHVybiBmYWxzZVxuXG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAocHJvcGVydHlLZXlUeXBlKSB7XG4gICAgICAgICAgICB0eXBlZm9yY2UocHJvcGVydHlLZXlUeXBlLCBwcm9wZXJ0eU5hbWUsIHN0cmljdClcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyB0ZlN1YkVycm9yKGUsIHByb3BlcnR5TmFtZSwgJ2tleScpXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gdmFsdWVbcHJvcGVydHlOYW1lXVxuICAgICAgICAgIHR5cGVmb3JjZShwcm9wZXJ0eVR5cGUsIHByb3BlcnR5VmFsdWUsIHN0cmljdClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IHRmU3ViRXJyb3IoZSwgcHJvcGVydHlOYW1lKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5S2V5VHlwZSkge1xuICAgICAgX21hcC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAneycgKyB0ZkpTT04ocHJvcGVydHlLZXlUeXBlKSArICc6ICcgKyB0ZkpTT04ocHJvcGVydHlUeXBlKSArICd9J1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBfbWFwLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICd7JyArIHRmSlNPTihwcm9wZXJ0eVR5cGUpICsgJ30nIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX21hcFxuICB9LFxuXG4gIG9iamVjdDogZnVuY3Rpb24gb2JqZWN0ICh1bmNvbXBpbGVkKSB7XG4gICAgdmFyIHR5cGUgPSB7fVxuXG4gICAgZm9yICh2YXIgdHlwZVByb3BlcnR5TmFtZSBpbiB1bmNvbXBpbGVkKSB7XG4gICAgICB0eXBlW3R5cGVQcm9wZXJ0eU5hbWVdID0gY29tcGlsZSh1bmNvbXBpbGVkW3R5cGVQcm9wZXJ0eU5hbWVdKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3QgKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgIGlmICghTkFUSVZFLk9iamVjdCh2YWx1ZSkpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKE5BVElWRS5OaWwodmFsdWUpKSByZXR1cm4gZmFsc2VcblxuICAgICAgdmFyIHByb3BlcnR5TmFtZVxuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHByb3BlcnR5TmFtZSBpbiB0eXBlKSB7XG4gICAgICAgICAgdmFyIHByb3BlcnR5VHlwZSA9IHR5cGVbcHJvcGVydHlOYW1lXVxuICAgICAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gdmFsdWVbcHJvcGVydHlOYW1lXVxuXG4gICAgICAgICAgdHlwZWZvcmNlKHByb3BlcnR5VHlwZSwgcHJvcGVydHlWYWx1ZSwgc3RyaWN0KVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IHRmU3ViRXJyb3IoZSwgcHJvcGVydHlOYW1lKVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGZvciAocHJvcGVydHlOYW1lIGluIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVbcHJvcGVydHlOYW1lXSkgY29udGludWVcblxuICAgICAgICAgIHRocm93IG5ldyBUZlByb3BlcnR5VHlwZUVycm9yKHVuZGVmaW5lZCwgcHJvcGVydHlOYW1lKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIF9vYmplY3QudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGZKU09OKHR5cGUpIH1cblxuICAgIHJldHVybiBfb2JqZWN0XG4gIH0sXG5cbiAgYW55T2Y6IGZ1bmN0aW9uIGFueU9mICgpIHtcbiAgICB2YXIgdHlwZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykubWFwKGNvbXBpbGUpXG5cbiAgICBmdW5jdGlvbiBfYW55T2YgKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgIHJldHVybiB0eXBlcy5zb21lKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVmb3JjZSh0eXBlLCB2YWx1ZSwgc3RyaWN0KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIF9hbnlPZi50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlcy5tYXAodGZKU09OKS5qb2luKCd8JykgfVxuXG4gICAgcmV0dXJuIF9hbnlPZlxuICB9LFxuXG4gIGFsbE9mOiBmdW5jdGlvbiBhbGxPZiAoKSB7XG4gICAgdmFyIHR5cGVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLm1hcChjb21waWxlKVxuXG4gICAgZnVuY3Rpb24gX2FsbE9mICh2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICByZXR1cm4gdHlwZXMuZXZlcnkoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdHlwZWZvcmNlKHR5cGUsIHZhbHVlLCBzdHJpY3QpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgX2FsbE9mLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzLm1hcCh0ZkpTT04pLmpvaW4oJyAmICcpIH1cblxuICAgIHJldHVybiBfYWxsT2ZcbiAgfSxcblxuICBxdWFja3NMaWtlOiBmdW5jdGlvbiBxdWFja3NMaWtlICh0eXBlKSB7XG4gICAgZnVuY3Rpb24gX3F1YWNrc0xpa2UgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZSA9PT0gZ2V0VmFsdWVUeXBlTmFtZSh2YWx1ZSlcbiAgICB9XG4gICAgX3F1YWNrc0xpa2UudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZSB9XG5cbiAgICByZXR1cm4gX3F1YWNrc0xpa2VcbiAgfSxcblxuICB0dXBsZTogZnVuY3Rpb24gdHVwbGUgKCkge1xuICAgIHZhciB0eXBlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5tYXAoY29tcGlsZSlcblxuICAgIGZ1bmN0aW9uIF90dXBsZSAodmFsdWVzLCBzdHJpY3QpIHtcbiAgICAgIGlmIChOQVRJVkUuTmlsKHZhbHVlcykpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKE5BVElWRS5OaWwodmFsdWVzLmxlbmd0aCkpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKHN0cmljdCAmJiAodmFsdWVzLmxlbmd0aCAhPT0gdHlwZXMubGVuZ3RoKSkgcmV0dXJuIGZhbHNlXG5cbiAgICAgIHJldHVybiB0eXBlcy5ldmVyeShmdW5jdGlvbiAodHlwZSwgaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB0eXBlZm9yY2UodHlwZSwgdmFsdWVzW2ldLCBzdHJpY3QpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyB0ZlN1YkVycm9yKGUsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIF90dXBsZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnKCcgKyB0eXBlcy5tYXAodGZKU09OKS5qb2luKCcsICcpICsgJyknIH1cblxuICAgIHJldHVybiBfdHVwbGVcbiAgfSxcblxuICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUgKGV4cGVjdGVkKSB7XG4gICAgZnVuY3Rpb24gX3ZhbHVlIChhY3R1YWwpIHtcbiAgICAgIHJldHVybiBhY3R1YWwgPT09IGV4cGVjdGVkXG4gICAgfVxuICAgIF92YWx1ZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBleHBlY3RlZCB9XG5cbiAgICByZXR1cm4gX3ZhbHVlXG4gIH1cbn1cblxuLy8gVE9ETzogZGVwcmVjYXRlXG5UWVBFUy5vbmVPZiA9IFRZUEVTLmFueU9mXG5cbmZ1bmN0aW9uIGNvbXBpbGUgKHR5cGUpIHtcbiAgaWYgKE5BVElWRS5TdHJpbmcodHlwZSkpIHtcbiAgICBpZiAodHlwZVswXSA9PT0gJz8nKSByZXR1cm4gVFlQRVMubWF5YmUodHlwZS5zbGljZSgxKSlcblxuICAgIHJldHVybiBOQVRJVkVbdHlwZV0gfHwgVFlQRVMucXVhY2tzTGlrZSh0eXBlKVxuICB9IGVsc2UgaWYgKHR5cGUgJiYgTkFUSVZFLk9iamVjdCh0eXBlKSkge1xuICAgIGlmIChOQVRJVkUuQXJyYXkodHlwZSkpIHtcbiAgICAgIGlmICh0eXBlLmxlbmd0aCAhPT0gMSkgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgY29tcGlsZSgpIHBhcmFtZXRlciBvZiB0eXBlIEFycmF5IG9mIGxlbmd0aCAxJylcbiAgICAgIHJldHVybiBUWVBFUy5hcnJheU9mKHR5cGVbMF0pXG4gICAgfVxuXG4gICAgcmV0dXJuIFRZUEVTLm9iamVjdCh0eXBlKVxuICB9IGVsc2UgaWYgKE5BVElWRS5GdW5jdGlvbih0eXBlKSkge1xuICAgIHJldHVybiB0eXBlXG4gIH1cblxuICByZXR1cm4gVFlQRVMudmFsdWUodHlwZSlcbn1cblxuZnVuY3Rpb24gdHlwZWZvcmNlICh0eXBlLCB2YWx1ZSwgc3RyaWN0LCBzdXJyb2dhdGUpIHtcbiAgaWYgKE5BVElWRS5GdW5jdGlvbih0eXBlKSkge1xuICAgIGlmICh0eXBlKHZhbHVlLCBzdHJpY3QpKSByZXR1cm4gdHJ1ZVxuXG4gICAgdGhyb3cgbmV3IFRmVHlwZUVycm9yKHN1cnJvZ2F0ZSB8fCB0eXBlLCB2YWx1ZSlcbiAgfVxuXG4gIC8vIEpJVFxuICByZXR1cm4gdHlwZWZvcmNlKGNvbXBpbGUodHlwZSksIHZhbHVlLCBzdHJpY3QpXG59XG5cbi8vIGFzc2lnbiB0eXBlcyB0byB0eXBlZm9yY2UgZnVuY3Rpb25cbmZvciAodmFyIHR5cGVOYW1lIGluIE5BVElWRSkge1xuICB0eXBlZm9yY2VbdHlwZU5hbWVdID0gTkFUSVZFW3R5cGVOYW1lXVxufVxuXG5mb3IgKHR5cGVOYW1lIGluIFRZUEVTKSB7XG4gIHR5cGVmb3JjZVt0eXBlTmFtZV0gPSBUWVBFU1t0eXBlTmFtZV1cbn1cblxudmFyIEVYVFJBID0gcmVxdWlyZSgnLi9leHRyYScpXG5mb3IgKHR5cGVOYW1lIGluIEVYVFJBKSB7XG4gIHR5cGVmb3JjZVt0eXBlTmFtZV0gPSBFWFRSQVt0eXBlTmFtZV1cbn1cblxudHlwZWZvcmNlLmNvbXBpbGUgPSBjb21waWxlXG50eXBlZm9yY2UuVGZUeXBlRXJyb3IgPSBUZlR5cGVFcnJvclxudHlwZWZvcmNlLlRmUHJvcGVydHlUeXBlRXJyb3IgPSBUZlByb3BlcnR5VHlwZUVycm9yXG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZWZvcmNlXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/typeforce/index.js\n"));

/***/ }),

/***/ "./node_modules/typeforce/native.js":
/*!******************************************!*\
  !*** ./node_modules/typeforce/native.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var types = {\n  Array: function (value) { return value !== null && value !== undefined && value.constructor === Array },\n  Boolean: function (value) { return typeof value === 'boolean' },\n  Function: function (value) { return typeof value === 'function' },\n  Nil: function (value) { return value === undefined || value === null },\n  Number: function (value) { return typeof value === 'number' },\n  Object: function (value) { return typeof value === 'object' },\n  String: function (value) { return typeof value === 'string' },\n  '': function () { return true }\n}\n\n// TODO: deprecate\ntypes.Null = types.Nil\n\nfor (var typeName in types) {\n  types[typeName].toJSON = function (t) {\n    return t\n  }.bind(null, typeName)\n}\n\nmodule.exports = types\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHlwZWZvcmNlL25hdGl2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLDRCQUE0Qiw2RUFBNkU7QUFDekcsOEJBQThCLG1DQUFtQztBQUNqRSwrQkFBK0Isb0NBQW9DO0FBQ25FLDBCQUEwQiw4Q0FBOEM7QUFDeEUsNkJBQTZCLGtDQUFrQztBQUMvRCw2QkFBNkIsa0NBQWtDO0FBQy9ELDZCQUE2QixrQ0FBa0M7QUFDL0Qsb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvcWlhb3hpYW9ydWkvZ2l0aHViL3VuaWZyYS9teWRvZ2UvbXlkb2dlbWFzay1uZXh0LWV4YW1wbGUvbm9kZV9tb2R1bGVzL3R5cGVmb3JjZS9uYXRpdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHR5cGVzID0ge1xuICBBcnJheTogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBBcnJheSB9LFxuICBCb29sZWFuOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIH0sXG4gIEZ1bmN0aW9uOiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB9LFxuICBOaWw6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCB9LFxuICBOdW1iZXI6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB9LFxuICBPYmplY3Q6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB9LFxuICBTdHJpbmc6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB9LFxuICAnJzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZSB9XG59XG5cbi8vIFRPRE86IGRlcHJlY2F0ZVxudHlwZXMuTnVsbCA9IHR5cGVzLk5pbFxuXG5mb3IgKHZhciB0eXBlTmFtZSBpbiB0eXBlcykge1xuICB0eXBlc1t0eXBlTmFtZV0udG9KU09OID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdFxuICB9LmJpbmQobnVsbCwgdHlwZU5hbWUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZXNcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/typeforce/native.js\n"));

/***/ }),

/***/ "./node_modules/varuint-bitcoin/index.js":
/*!***********************************************!*\
  !*** ./node_modules/varuint-bitcoin/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\n\n// Number.MAX_SAFE_INTEGER\nvar MAX_SAFE_INTEGER = 9007199254740991\n\nfunction checkUInt53 (n) {\n  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range')\n}\n\nfunction encode (number, buffer, offset) {\n  checkUInt53(number)\n\n  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(number))\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')\n  if (!offset) offset = 0\n\n  // 8 bit\n  if (number < 0xfd) {\n    buffer.writeUInt8(number, offset)\n    encode.bytes = 1\n\n  // 16 bit\n  } else if (number <= 0xffff) {\n    buffer.writeUInt8(0xfd, offset)\n    buffer.writeUInt16LE(number, offset + 1)\n    encode.bytes = 3\n\n  // 32 bit\n  } else if (number <= 0xffffffff) {\n    buffer.writeUInt8(0xfe, offset)\n    buffer.writeUInt32LE(number, offset + 1)\n    encode.bytes = 5\n\n  // 64 bit\n  } else {\n    buffer.writeUInt8(0xff, offset)\n    buffer.writeUInt32LE(number >>> 0, offset + 1)\n    buffer.writeUInt32LE((number / 0x100000000) | 0, offset + 5)\n    encode.bytes = 9\n  }\n\n  return buffer\n}\n\nfunction decode (buffer, offset) {\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')\n  if (!offset) offset = 0\n\n  var first = buffer.readUInt8(offset)\n\n  // 8 bit\n  if (first < 0xfd) {\n    decode.bytes = 1\n    return first\n\n  // 16 bit\n  } else if (first === 0xfd) {\n    decode.bytes = 3\n    return buffer.readUInt16LE(offset + 1)\n\n  // 32 bit\n  } else if (first === 0xfe) {\n    decode.bytes = 5\n    return buffer.readUInt32LE(offset + 1)\n\n  // 64 bit\n  } else {\n    decode.bytes = 9\n    var lo = buffer.readUInt32LE(offset + 1)\n    var hi = buffer.readUInt32LE(offset + 5)\n    var number = hi * 0x0100000000 + lo\n    checkUInt53(number)\n\n    return number\n  }\n}\n\nfunction encodingLength (number) {\n  checkUInt53(number)\n\n  return (\n    number < 0xfd ? 1\n      : number <= 0xffff ? 3\n        : number <= 0xffffffff ? 5\n          : 9\n  )\n}\n\nmodule.exports = { encode: encode, decode: decode, encodingLength: encodingLength }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmFydWludC1iaXRjb2luL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osYUFBYSxzRkFBNkI7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9xaWFveGlhb3J1aS9naXRodWIvdW5pZnJhL215ZG9nZS9teWRvZ2VtYXNrLW5leHQtZXhhbXBsZS9ub2RlX21vZHVsZXMvdmFydWludC1iaXRjb2luL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbi8vIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTFcblxuZnVuY3Rpb24gY2hlY2tVSW50NTMgKG4pIHtcbiAgaWYgKG4gPCAwIHx8IG4gPiBNQVhfU0FGRV9JTlRFR0VSIHx8IG4gJSAxICE9PSAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gZW5jb2RlIChudW1iZXIsIGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIGNoZWNrVUludDUzKG51bWJlcilcblxuICBpZiAoIWJ1ZmZlcikgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoKG51bWJlcikpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcblxuICAvLyA4IGJpdFxuICBpZiAobnVtYmVyIDwgMHhmZCkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG51bWJlciwgb2Zmc2V0KVxuICAgIGVuY29kZS5ieXRlcyA9IDFcblxuICAvLyAxNiBiaXRcbiAgfSBlbHNlIGlmIChudW1iZXIgPD0gMHhmZmZmKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgoMHhmZCwgb2Zmc2V0KVxuICAgIGJ1ZmZlci53cml0ZVVJbnQxNkxFKG51bWJlciwgb2Zmc2V0ICsgMSlcbiAgICBlbmNvZGUuYnl0ZXMgPSAzXG5cbiAgLy8gMzIgYml0XG4gIH0gZWxzZSBpZiAobnVtYmVyIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZlLCBvZmZzZXQpXG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUobnVtYmVyLCBvZmZzZXQgKyAxKVxuICAgIGVuY29kZS5ieXRlcyA9IDVcblxuICAvLyA2NCBiaXRcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZmLCBvZmZzZXQpXG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUobnVtYmVyID4+PiAwLCBvZmZzZXQgKyAxKVxuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKChudW1iZXIgLyAweDEwMDAwMDAwMCkgfCAwLCBvZmZzZXQgKyA1KVxuICAgIGVuY29kZS5ieXRlcyA9IDlcbiAgfVxuXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gZGVjb2RlIChidWZmZXIsIG9mZnNldCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICghb2Zmc2V0KSBvZmZzZXQgPSAwXG5cbiAgdmFyIGZpcnN0ID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpXG5cbiAgLy8gOCBiaXRcbiAgaWYgKGZpcnN0IDwgMHhmZCkge1xuICAgIGRlY29kZS5ieXRlcyA9IDFcbiAgICByZXR1cm4gZmlyc3RcblxuICAvLyAxNiBiaXRcbiAgfSBlbHNlIGlmIChmaXJzdCA9PT0gMHhmZCkge1xuICAgIGRlY29kZS5ieXRlcyA9IDNcbiAgICByZXR1cm4gYnVmZmVyLnJlYWRVSW50MTZMRShvZmZzZXQgKyAxKVxuXG4gIC8vIDMyIGJpdFxuICB9IGVsc2UgaWYgKGZpcnN0ID09PSAweGZlKSB7XG4gICAgZGVjb2RlLmJ5dGVzID0gNVxuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDEpXG5cbiAgLy8gNjQgYml0XG4gIH0gZWxzZSB7XG4gICAgZGVjb2RlLmJ5dGVzID0gOVxuICAgIHZhciBsbyA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgMSlcbiAgICB2YXIgaGkgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDUpXG4gICAgdmFyIG51bWJlciA9IGhpICogMHgwMTAwMDAwMDAwICsgbG9cbiAgICBjaGVja1VJbnQ1MyhudW1iZXIpXG5cbiAgICByZXR1cm4gbnVtYmVyXG4gIH1cbn1cblxuZnVuY3Rpb24gZW5jb2RpbmdMZW5ndGggKG51bWJlcikge1xuICBjaGVja1VJbnQ1MyhudW1iZXIpXG5cbiAgcmV0dXJuIChcbiAgICBudW1iZXIgPCAweGZkID8gMVxuICAgICAgOiBudW1iZXIgPD0gMHhmZmZmID8gM1xuICAgICAgICA6IG51bWJlciA8PSAweGZmZmZmZmZmID8gNVxuICAgICAgICAgIDogOVxuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBlbmNvZGU6IGVuY29kZSwgZGVjb2RlOiBkZWNvZGUsIGVuY29kaW5nTGVuZ3RoOiBlbmNvZGluZ0xlbmd0aCB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/varuint-bitcoin/index.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["pages/_app","main"], () => (__webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fqiaoxiaorui%2Fgithub%2Funifra%2Fmydoge%2Fmydogemask-next-example%2Fsrc%2Fpages%2Findex.tsx&page=%2F!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);